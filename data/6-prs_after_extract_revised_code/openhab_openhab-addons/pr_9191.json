{"pr_number": 9191, "pr_title": "[Qbus] Initial contribution", "pr_createdAt": "2020-12-01T10:35:35Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9191", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_SCENE).collect(Collectors.toSet()));\n          \n          \n            \n                public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Set.of(THING_TYPE_SCENE);", "author": "fwolter", "createdAt": "2020-12-13T17:42:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBindingConstants.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link QbusBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Koen Schockaert - Initial contribution\n+ */\n+@NonNullByDefault\n+public class QbusBindingConstants {\n+\n+    private static final String BINDING_ID = \"qbus\";\n+\n+    // bridge\n+    public static final ThingTypeUID BRIDGE_THING_TYPE = new ThingTypeUID(BINDING_ID, \"bridge\");\n+    public static final Set<ThingTypeUID> BRIDGE_THING_TYPES_UIDS = Collections.singleton(BRIDGE_THING_TYPE);\n+    // Bridge config properties\n+    public static final String CONFIG_HOST_NAME = \"addr\";\n+    public static final String CONFIG_PORT = \"port\";\n+    public static final String CONFIG_REFRESH = \"refresh\";\n+    public static final String CONFIG_SN = \"sn\";\n+\n+    // generic thing types\n+    public static final ThingTypeUID THING_TYPE_CO2 = new ThingTypeUID(BINDING_ID, \"co2\");\n+    public static final ThingTypeUID THING_TYPE_SCENE = new ThingTypeUID(BINDING_ID, \"scene\");\n+    public static final ThingTypeUID THING_TYPE_TIMER_LIGHT = new ThingTypeUID(BINDING_ID, \"onOff\");\n+    public static final ThingTypeUID THING_TYPE_ON_OFF_LIGHT = new ThingTypeUID(BINDING_ID, \"onOff\");\n+    public static final ThingTypeUID THING_TYPE_DIMMABLE_LIGHT = new ThingTypeUID(BINDING_ID, \"dimmer\");\n+    public static final ThingTypeUID THING_TYPE_ROLLERSHUTTER = new ThingTypeUID(BINDING_ID, \"rollershutter\");\n+    public static final ThingTypeUID THING_TYPE_ROLLERSHUTTER_SLATS = new ThingTypeUID(BINDING_ID,\n+            \"rollershutter_slats\");\n+    public static final ThingTypeUID THING_TYPE_THERMOSTAT = new ThingTypeUID(BINDING_ID, \"thermostat\");\n+    // List of all Thing Type UIDs\n+    public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_SCENE).collect(Collectors.toSet()));", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBindingConstants.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBindingConstants.java\ndeleted file mode 100644\nindex 5cd8e6bc2b..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBindingConstants.java\n+++ /dev/null\n\n@@ -1,98 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.qbus.internal;\n-\n-import java.util.Collections;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.openhab.core.thing.ThingTypeUID;\n-\n-/**\n- * The {@link QbusBindingConstants} class defines common constants, which are\n- * used across the whole binding.\n- *\n- * @author Koen Schockaert - Initial contribution\n- */\n-@NonNullByDefault\n-public class QbusBindingConstants {\n-\n-    private static final String BINDING_ID = \"qbus\";\n-\n-    // bridge\n-    public static final ThingTypeUID BRIDGE_THING_TYPE = new ThingTypeUID(BINDING_ID, \"bridge\");\n-    public static final Set<ThingTypeUID> BRIDGE_THING_TYPES_UIDS = Collections.singleton(BRIDGE_THING_TYPE);\n-    // Bridge config properties\n-    public static final String CONFIG_HOST_NAME = \"addr\";\n-    public static final String CONFIG_PORT = \"port\";\n-    public static final String CONFIG_REFRESH = \"refresh\";\n-    public static final String CONFIG_SN = \"sn\";\n-\n-    // generic thing types\n-    public static final ThingTypeUID THING_TYPE_CO2 = new ThingTypeUID(BINDING_ID, \"co2\");\n-    public static final ThingTypeUID THING_TYPE_SCENE = new ThingTypeUID(BINDING_ID, \"scene\");\n-    public static final ThingTypeUID THING_TYPE_TIMER_LIGHT = new ThingTypeUID(BINDING_ID, \"onOff\");\n-    public static final ThingTypeUID THING_TYPE_ON_OFF_LIGHT = new ThingTypeUID(BINDING_ID, \"onOff\");\n-    public static final ThingTypeUID THING_TYPE_DIMMABLE_LIGHT = new ThingTypeUID(BINDING_ID, \"dimmer\");\n-    public static final ThingTypeUID THING_TYPE_ROLLERSHUTTER = new ThingTypeUID(BINDING_ID, \"rollershutter\");\n-    public static final ThingTypeUID THING_TYPE_ROLLERSHUTTER_SLATS = new ThingTypeUID(BINDING_ID,\n-            \"rollershutter_slats\");\n-    public static final ThingTypeUID THING_TYPE_THERMOSTAT = new ThingTypeUID(BINDING_ID, \"thermostat\");\n-    // List of all Thing Type UIDs\n-    public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_SCENE).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> CO2_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_CO2).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> ROLLERSHUTTER_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_ROLLERSHUTTER).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> ROLLERSHUTTER_SLATS_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_ROLLERSHUTTER_SLATS).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> BISTABIEL_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_ON_OFF_LIGHT, THING_TYPE_TIMER_LIGHT).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> THERMOSTAT_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_THERMOSTAT).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> DIMMER_THING_TYPES_UIDS = Collections\n-            .unmodifiableSet(Stream.of(THING_TYPE_ON_OFF_LIGHT, THING_TYPE_DIMMABLE_LIGHT).collect(Collectors.toSet()));\n-\n-    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(Stream\n-            .of(THING_TYPE_TIMER_LIGHT, THING_TYPE_ON_OFF_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_THERMOSTAT,\n-                    THING_TYPE_SCENE, THING_TYPE_CO2, THING_TYPE_ROLLERSHUTTER, THING_TYPE_ROLLERSHUTTER_SLATS)\n-            .collect(Collectors.toSet()));\n-\n-    // List of all Channel ids\n-    public static final String CHANNEL_SWITCH = \"switch\";\n-    public static final String CHANNEL_BRIGHTNESS = \"brightness\";\n-    public static final String CHANNEL_MEASURED = \"measured\";\n-    public static final String CHANNEL_SETPOINT = \"setpoint\";\n-    public static final String CHANNEL_MODE = \"mode\";\n-    public static final String CHANNEL_CO2 = \"co2\";\n-    public static final String CHANNEL_ROLLERSHUTTER = \"rollershutter\";\n-    public static final String CHANNEL_SLATS = \"slats\";\n-\n-    // Thing config properties\n-    public static final String CONFIG_BISTABIEL_ID = \"bistabielId\";\n-    public static final String CONFIG_DIMMER_ID = \"dimmerId\";\n-    public static final String CONFIG_THERMOSTAT_ID = \"thermostatId\";\n-    public static final String CONFIG_SCENE_ID = \"sceneId\";\n-    public static final String CONFIG_CO2_ID = \"co2Id\";\n-    public static final String CONFIG_ROLLERSHUTTER_ID = \"rolId\";\n-    public static final String CONFIG_STEP_VALUE = \"step\";\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970523", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-13T17:42:43Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970573", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-13T17:43:04Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970626", "bodyText": "Isn't this rather a configuration error than a communication error?\n\"Qbus: \" is redundant here as the UI will show the message in context.", "author": "fwolter", "createdAt": "2020-12-13T17:43:32Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970967", "bodyText": "Primitive types should be used where possible.", "author": "fwolter", "createdAt": "2020-12-13T17:45:16Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971098", "bodyText": "The binding's name will be included in the log messages. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n          \n          \n            \n                    logger.debug(\"Checking for Client communication every {} min\", refreshInterval);", "author": "fwolter", "createdAt": "2020-12-13T17:46:06Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTI1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971250", "bodyText": "Can you set the ThingStatusDetail and a message why this is offline? You could retrieve a message by letting communicationActive() throw an exception, instead of returning a boolean.", "author": "fwolter", "createdAt": "2020-12-13T17:47:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971422", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T17:48:12Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTQ0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971445", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging\nPlease check all.", "author": "fwolter", "createdAt": "2020-12-13T17:48:26Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Qbus: Communication still active\");", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971514", "bodyText": "What's the purpose of this?", "author": "fwolter", "createdAt": "2020-12-13T17:48:54Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Qbus: Communication still active\");\n+            }\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                \"Qbus: error starting bridge connection\");\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return true;\n+    }", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971662", "bodyText": "Is this really necessary? initialize() is called when the configuration has changed.", "author": "fwolter", "createdAt": "2020-12-13T17:49:40Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Qbus: Communication still active\");\n+            }\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                \"Qbus: error starting bridge connection\");\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+        }\n+        this.refreshTimer = null;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+\n+        scheduler.submit(() -> {\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+        });\n+    }", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MjI2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541972261", "bodyText": "You could create a dedicated class with the configuration parameters and read them here by calling getConfigAs(). That makes the casting unnecessary.", "author": "fwolter", "createdAt": "2020-12-13T17:53:14Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\ndeleted file mode 100644\nindex 4377a1fd58..0000000000\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ /dev/null\n\n@@ -1,241 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.qbus.internal;\n-\n-import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.thing.Bridge;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.ThingStatus;\n-import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.BaseBridgeHandler;\n-import org.openhab.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * {@link QbusBridgeHandler} is the handler for a Qbus controller\n- *\n- * @author Koen Schockaert - Initial Contribution\n- */\n-public class QbusBridgeHandler extends BaseBridgeHandler {\n-\n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n-    private QbusCommunication qbusComm;\n-\n-    private ScheduledFuture<?> refreshTimer;\n-\n-    public QbusBridgeHandler(Bridge Bridge) {\n-        super(Bridge);\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        // There is nothing to handle in the bridge handler\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        logger.debug(\"QBUS: initializing bridge handler\");\n-\n-        Configuration config = this.getConfig();\n-        InetAddress addr = getAddr();\n-        int port = getPort();\n-\n-        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n-\n-        if (addr != null) {\n-            createCommunicationObject(addr, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n-        }\n-    }\n-\n-    /**\n-     * Create communication object to Qbus server and start communication.\n-     *\n-     * @param addr : IP address of Qbus server\n-     * @param port : Communication port of QbusServer\n-     * @param sn : Serial number of Controller\n-     */\n-    private void createCommunicationObject(InetAddress addr, int port) {\n-        Configuration config = this.getConfig();\n-        scheduler.submit(() -> {\n-            qbusComm = new QbusCommunication();\n-\n-            // Set callback from Qbus object to this bridge to be able to take bridge\n-            // offline when non-resolvable communication error occurs.\n-            setBridgeCallBack();\n-\n-            qbusComm.startCommunication();\n-            if (!qbusComm.communicationActive()) {\n-                qbusComm = null;\n-                bridgeOffline();\n-                return;\n-            }\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-\n-        });\n-    }\n-\n-    private void setBridgeCallBack() {\n-        this.qbusComm.setBridgeCallBack(this);\n-    }\n-\n-    /**\n-     * Schedule future communication refresh.\n-     *\n-     * @param interval_config Time before refresh in minutes.\n-     */\n-    private void setupRefreshTimer(Integer refreshInterval) {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-            this.refreshTimer = null;\n-        }\n-\n-        if ((refreshInterval == null) || (refreshInterval == 0)) {\n-            return;\n-        }\n-\n-        // This timer will restart the bridge connection periodically\n-        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n-        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n-            logger.debug(\"Qbus: check communication after timerinterval\");\n-\n-            if (!qbusComm.communicationActive()) {\n-                logger.debug(\"Qbus: Restarting communication\");\n-                qbusComm.restartCommunication();\n-\n-                if (!qbusComm.communicationActive()) {\n-                    qbusComm = null;\n-                    bridgeOffline();\n-                    updateStatus(ThingStatus.OFFLINE);\n-                    return;\n-                }\n-\n-                // updateStatus(ThingStatus.ONLINE);\n-                updateStatus(ThingStatus.ONLINE);\n-            } else {\n-                logger.debug(\"Qbus: Communication still active\");\n-            }\n-\n-        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n-    }\n-\n-    /**\n-     * Take bridge offline when error in communication with Qbus server. This method can also be\n-     * called directly from {@link QbusCommunication} object.\n-     */\n-    public void bridgeOffline() {\n-        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n-                \"Qbus: error starting bridge connection\");\n-    }\n-\n-    /**\n-     * Put bridge online when error in communication resolved.\n-     */\n-    public void bridgeOnline() {\n-        updateStatus(ThingStatus.ONLINE);\n-    }\n-\n-    @Override\n-    public boolean isInitialized() {\n-        return true;\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        if (this.refreshTimer != null) {\n-            this.refreshTimer.cancel(true);\n-        }\n-        this.refreshTimer = null;\n-    }\n-\n-    @Override\n-    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n-        Configuration configuration = editConfiguration();\n-        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n-            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n-        }\n-        updateConfiguration(configuration);\n-\n-        scheduler.submit(() -> {\n-\n-            updateStatus(ThingStatus.ONLINE);\n-\n-            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n-            setupRefreshTimer(refreshInterval);\n-        });\n-    }\n-\n-    /**\n-     * Get the Qbus communication object.\n-     *\n-     * @return Qbus communication object\n-     */\n-    public QbusCommunication getCommunication() {\n-        return this.qbusComm;\n-    }\n-\n-    /**\n-     * Get the IP-address of the Qbus server.\n-     *\n-     * @return the addr\n-     */\n-    public InetAddress getAddr() {\n-        Configuration config = this.getConfig();\n-        InetAddress addr = null;\n-        try {\n-            addr = InetAddress.getByName((String) config.get(CONFIG_HOST_NAME));\n-        } catch (UnknownHostException e) {\n-            logger.debug(\"Qbus: Cannot resolve hostname {} to IP adress\", config.get(CONFIG_HOST_NAME));\n-        }\n-        return addr;\n-    }\n-\n-    /**\n-     * Get the listening port of the Qbus server.\n-     *\n-     * @return the port\n-     */\n-    public int getPort() {\n-        Configuration config = this.getConfig();\n-        return ((Number) config.get(CONFIG_PORT)).intValue();\n-    }\n-\n-    /**\n-     * Get the serial nr of the Qbus server.\n-     *\n-     * @return the sn\n-     */\n-    public String getSn() {\n-        Configuration config = this.getConfig();\n-        return ((String) config.get(CONFIG_SN));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODUwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998508", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging Please check all.\nAlso logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded.", "author": "fwolter", "createdAt": "2021-01-03T12:20:21Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODY0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998642", "bodyText": "See above. Logging to info. Please check all.", "author": "fwolter", "createdAt": "2021-01-03T12:21:57Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998722", "bodyText": "Please remove the empty lines.", "author": "fwolter", "createdAt": "2021-01-03T12:22:50Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998875", "bodyText": "Please remove these kind of log messages. I strongly encourage you to use the debugger to check where your program runs. This saves a lot of headache.", "author": "fwolter", "createdAt": "2021-01-03T12:24:06Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998950", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2021-01-03T12:24:50Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998986", "bodyText": "Is there any reason why this is synchronized?\nThe name setConfig() seems a bit misleading. Would readConfig() be better?", "author": "fwolter", "createdAt": "2021-01-03T12:25:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550999377", "bodyText": "You could throw the UnknownHostException and handle it in initialize(). That would make the null suppression unnecessary. In fact that would make the whole method unnecessary. It's better to throw an exception in case of an error instead of returning null. This way you have the error message in the calling method and can integrate it in the message the user gets presented.", "author": "fwolter", "createdAt": "2021-01-03T12:27:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {\n+        config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the IP-address of the Qbus server.\n+     *\n+     * @return the addr\n+     */\n+\n+    @SuppressWarnings(\"null\")\n+    public @Nullable InetAddress getAddr() {\n+        InetAddress addr = null;\n+        try {\n+            addr = InetAddress.getByName(config.addr);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Cannot resolve hostname {} to IP adress\", config.addr);\n+        }\n+        return addr;\n+    }", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550999483", "bodyText": "The suppression annotation should be used only if the compiler warning is wrong.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"null\")\n          \n          \n            \n                public int getPort() {\n          \n          \n            \n                    return config.port;\n          \n          \n            \n                }\n          \n          \n            \n                public @Nullable int getPort() {\n          \n          \n            \n                    return config.port;\n          \n          \n            \n                }", "author": "fwolter", "createdAt": "2021-01-03T12:28:47Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {\n+        config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the IP-address of the Qbus server.\n+     *\n+     * @return the addr\n+     */\n+\n+    @SuppressWarnings(\"null\")\n+    public @Nullable InetAddress getAddr() {\n+        InetAddress addr = null;\n+        try {\n+            addr = InetAddress.getByName(config.addr);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Cannot resolve hostname {} to IP adress\", config.addr);\n+        }\n+        return addr;\n+    }\n+\n+    /**\n+     * Get the listening port of the Qbus server.\n+     *\n+     * @return the port\n+     */\n+    @SuppressWarnings(\"null\")\n+    public int getPort() {\n+        return config.port;\n+    }", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r554426059", "bodyText": "If i follow your sollution, then i get:\nThe nullness annotation @nullable is not applicable for the primitive type int", "author": "QbusKoen", "createdAt": "2021-01-09T13:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r554426755", "bodyText": "config can be null here. You need to store config to a local variable and do a null check on that.", "author": "fwolter", "createdAt": "2021-01-09T13:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTUyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550999529", "bodyText": "Can this comment be removed?", "author": "fwolter", "createdAt": "2021-01-03T12:29:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {\n+        config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the IP-address of the Qbus server.\n+     *\n+     * @return the addr\n+     */\n+\n+    @SuppressWarnings(\"null\")\n+    public @Nullable InetAddress getAddr() {\n+        InetAddress addr = null;\n+        try {\n+            addr = InetAddress.getByName(config.addr);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Cannot resolve hostname {} to IP adress\", config.addr);\n+        }\n+        return addr;\n+    }\n+\n+    /**\n+     * Get the listening port of the Qbus server.\n+     *\n+     * @return the port\n+     */\n+    @SuppressWarnings(\"null\")\n+    public int getPort() {\n+        return config.port;\n+    }\n+\n+    /**\n+     * Get the serial nr of the Qbus server.\n+     *\n+     * @return the serial nr of the controller\n+     */\n+    @SuppressWarnings(\"null\")\n+    public String getSn() {\n+        return config.sn;\n+    }\n+\n+    /**\n+     * Get the refresh interval.\n+     *\n+     * @return the refresh interval\n+     */\n+    @SuppressWarnings(\"null\")\n+    public int getRefresh() {\n+        return config.refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // TODO Auto-generated method stub", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3970141614de42a3b250b1413315364617bc224a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 44c3d2a8d8..4377a1fd58 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,8 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.Map;\n"}}, {"oid": "3970141614de42a3b250b1413315364617bc224a", "url": "https://github.com/openhab/openhab-addons/commit/3970141614de42a3b250b1413315364617bc224a", "message": "First commit\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "url": "https://github.com/openhab/openhab-addons/commit/f41c02e56b11a6c57711d28655c9aa425a8b4615", "message": "Revert \"First commit\"\n\nThis reverts commit da86aae5e99beb06698150ded1d500529498b44f.\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "8342d4e6ac94918bd2c498246ca3ddc155b98500", "url": "https://github.com/openhab/openhab-addons/commit/8342d4e6ac94918bd2c498246ca3ddc155b98500", "message": "First Commit\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "9507c35f42ecc0a182e320ca9f4d4130462315a0", "url": "https://github.com/openhab/openhab-addons/commit/9507c35f42ecc0a182e320ca9f4d4130462315a0", "message": "Second commit\n\nHad some issues in first commit. Fixed the bugs.\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "9de4acb05e3abed6d9cfe71d11378b535bebad3a", "url": "https://github.com/openhab/openhab-addons/commit/9de4acb05e3abed6d9cfe71d11378b535bebad3a", "message": "Solved issues\n\nSolved issues reported by fwolter and changed a lot of code, based on the comments.\n\nSigned-off-by: QbusKoen <ks@qbus.be>\n\n\tmodified:   CODEOWNERS\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "ed74a2b0f8e8e17af297dd6c0baf76f329ac2746", "url": "https://github.com/openhab/openhab-addons/commit/ed74a2b0f8e8e17af297dd6c0baf76f329ac2746", "message": "Update README.md\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "3551d12972df7f17ed5deafe023227f8175477b7", "url": "https://github.com/openhab/openhab-addons/commit/3551d12972df7f17ed5deafe023227f8175477b7", "message": "Updated requested changes\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "ec2e2ac2cd4bb64719e74315439d37bfd7b4f524", "url": "https://github.com/openhab/openhab-addons/commit/ec2e2ac2cd4bb64719e74315439d37bfd7b4f524", "message": "Updated headers\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "url": "https://github.com/openhab/openhab-addons/commit/d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "message": "Code fixing\n\nUpdate code like requested by fwolter on 3/1/2021\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg0OTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573849360", "bodyText": "You could initilize this with an empty config to get rid of the null annotation.", "author": "fwolter", "createdAt": "2021-02-10T15:55:37Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @NonNullByDefault({}) QbusConfiguration config;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 2de20eb45c..16b2a6acc2 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -13,6 +13,7 @@\n \n package org.openhab.binding.qbus.internal;\n \n+import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1MTU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573851571", "bodyText": "See above. Initialize.", "author": "fwolter", "createdAt": "2021-02-10T15:57:59Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\nindex cd72eb6f75..a34fc179ec 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n\n@@ -38,23 +38,21 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusBistabielHandler extends QbusGlobalHandler {\n \n-    public QbusBistabielHandler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int bistabielId;\n \n-    int bistabielId;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    private String sn;\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n      */\n     @Override\n     public void initialize() {\n-\n         readConfig();\n         bistabielId = getId();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1MjE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573852162", "bodyText": "The constructor should be below the fields.", "author": "fwolter", "createdAt": "2021-02-10T15:58:41Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\nindex cd72eb6f75..a34fc179ec 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n\n@@ -38,23 +38,21 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusBistabielHandler extends QbusGlobalHandler {\n \n-    public QbusBistabielHandler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int bistabielId;\n \n-    int bistabielId;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    private String sn;\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n      */\n     @Override\n     public void initialize() {\n-\n         readConfig();\n         bistabielId = getId();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1MjM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573852386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private String sn;\n          \n          \n            \n                private @Nullable String sn;", "author": "fwolter", "createdAt": "2021-02-10T15:58:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int bistabielId;\n+\n+    @Nullable\n+    private String sn;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\nindex cd72eb6f75..a34fc179ec 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n\n@@ -38,23 +38,21 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusBistabielHandler extends QbusGlobalHandler {\n \n-    public QbusBistabielHandler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int bistabielId;\n \n-    int bistabielId;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    private String sn;\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n      */\n     @Override\n     public void initialize() {\n-\n         readConfig();\n         bistabielId = getId();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1ODA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573858044", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @Nullable\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n                        String snr = getSN();", "author": "fwolter", "createdAt": "2021-02-10T16:05:44Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int bistabielId;\n+\n+    @Nullable\n+    private String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        readConfig();\n+        bistabielId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = QComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel QBistabiel = bistabielComm.get(bistabielId);\n+            if (QBistabiel != null) {\n+                QBistabiel.setThingHandler(this);\n+                handleStateUpdate(QBistabiel);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        } else {\n+            this.sn = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for bistabiel \" + bistabielId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = QComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel QBistabiel = bistabielComm.get(bistabielId);\n+\n+            if (QBistabiel == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for bistabiel \"\n+                                + bistabielId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Bistabiel\", bistabielId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QBistabiel);\n+                            return;\n+                        }\n+\n+                        handleSwitchCommand(QBistabiel, channelUID, command);\n+                    }\n+\n+                });\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Executes the switch command\n+     */\n+    private void handleSwitchCommand(QbusBistabiel QBistabiel, ChannelUID channelUID, Command command) {\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            @Nullable\n+            String snr = getSN();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\nindex cd72eb6f75..a34fc179ec 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n\n@@ -38,23 +38,21 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusBistabielHandler extends QbusGlobalHandler {\n \n-    public QbusBistabielHandler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int bistabielId;\n \n-    int bistabielId;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    private String sn;\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n      */\n     @Override\n     public void initialize() {\n-\n         readConfig();\n         bistabielId = getId();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1ODgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573858808", "bodyText": "See above. Constructor below fields and null annotation. Please check all.", "author": "fwolter", "createdAt": "2021-02-10T16:06:36Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_CO2;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCO2;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusCO2Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusCO2Handler extends QbusGlobalHandler {\n+\n+    public QbusCO2Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java\nindex 5009538342..804b6b9608 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java\n\n@@ -39,16 +39,15 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusCO2Handler extends QbusGlobalHandler {\n \n-    public QbusCO2Handler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int co2Id;\n \n-    int co2Id = 0;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    String sn;\n+    public QbusCO2Handler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1OTIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573859236", "bodyText": "Can these be private?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int co2Id = 0;\n          \n          \n            \n            \n          \n          \n            \n                @Nullable\n          \n          \n            \n                String sn;\n          \n          \n            \n                private int co2Id = 0;\n          \n          \n            \n            \n          \n          \n            \n                private @Nullable String sn;", "author": "fwolter", "createdAt": "2021-02-10T16:07:06Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_CO2;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCO2;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusCO2Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusCO2Handler extends QbusGlobalHandler {\n+\n+    public QbusCO2Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int co2Id = 0;\n+\n+    @Nullable\n+    String sn;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java\nindex 5009538342..804b6b9608 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java\n\n@@ -39,16 +39,15 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusCO2Handler extends QbusGlobalHandler {\n \n-    public QbusCO2Handler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int co2Id;\n \n-    int co2Id = 0;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    String sn;\n+    public QbusCO2Handler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2MDIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573860232", "bodyText": "Do you set the Thing to online by intention?", "author": "fwolter", "createdAt": "2021-02-10T16:08:19Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int dimmerId;\n+\n+    @Nullable\n+    private String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+\n+            if (QDimmer == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+                return;\n+            } else {\n+\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Dimmer\", dimmerId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QDimmer);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SWITCH:\n+                                handleSwitchCommand(QDimmer, command);\n+                                updateStatus(ThingStatus.ONLINE);", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\nindex a5d2193320..c2d5281965 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n\n@@ -40,16 +40,15 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusDimmerHandler extends QbusGlobalHandler {\n \n-    public QbusDimmerHandler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int dimmerId;\n \n-    int dimmerId;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    private String sn;\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2MDg3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573860871", "bodyText": "It seems a bit unreasonable to set the Thing offline, when the user sent an invalid command to it. Same for the others.", "author": "fwolter", "createdAt": "2021-02-10T16:09:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int dimmerId;\n+\n+    @Nullable\n+    private String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+\n+            if (QDimmer == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+                return;\n+            } else {\n+\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Dimmer\", dimmerId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QDimmer);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SWITCH:\n+                                handleSwitchCommand(QDimmer, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            case CHANNEL_BRIGHTNESS:\n+                                handleBrightnessCommand(QDimmer, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            default:\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Channel unknown \" + channelUID.getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\nindex a5d2193320..c2d5281965 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n\n@@ -40,16 +40,15 @@ import org.openhab.core.types.Command;\n @NonNullByDefault\n public class QbusDimmerHandler extends QbusGlobalHandler {\n \n-    public QbusDimmerHandler(Thing thing) {\n-        super(thing);\n-    }\n+    protected @Nullable QbusThingsConfig config;\n \n-    protected @NonNullByDefault({}) QbusThingsConfig config;\n+    private int dimmerId;\n \n-    int dimmerId;\n+    private @Nullable String sn;\n \n-    @Nullable\n-    private String sn;\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /**\n      * Main initialization\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2MzM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573863393", "bodyText": "You could add the type to the imports. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof org.openhab.core.library.types.UpDownType) {\n          \n          \n            \n                    if (command instanceof UpDownType) {", "author": "fwolter", "createdAt": "2021-02-10T16:11:56Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int rolId;\n+\n+    @Nullable\n+    String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol != null) {\n+                QRol.setThingHandler(this);\n+                handleStateUpdate(QRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            default:\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Channel unknown \" + channelUID.getId());\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol QRol, Command command) {\n+        @Nullable\n+        String snr = getSN();\n+        if (command instanceof org.openhab.core.library.types.UpDownType) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\nindex 92baabd436..530e4dc277 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.qbus.internal.handler;\n \n import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n import static org.openhab.core.types.RefreshType.REFRESH;\n \n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2Mzc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573863751", "bodyText": "Please remove this empty line.", "author": "fwolter", "createdAt": "2021-02-10T16:12:22Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int rolId;\n+\n+    @Nullable\n+    String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol != null) {\n+                QRol.setThingHandler(this);\n+                handleStateUpdate(QRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            default:\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Channel unknown \" + channelUID.getId());\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol QRol, Command command) {\n+        @Nullable\n+        String snr = getSN();\n+        if (command instanceof org.openhab.core.library.types.UpDownType) {\n+            org.openhab.core.library.types.UpDownType s = (org.openhab.core.library.types.UpDownType) command;\n+            if (s == org.openhab.core.library.types.UpDownType.DOWN) {\n+                if (snr != null) {\n+                    QRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    QRol.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType)\n+", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\nindex 92baabd436..530e4dc277 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.qbus.internal.handler;\n \n import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n import static org.openhab.core.types.RefreshType.REFRESH;\n \n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2NTk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573865951", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private QbusCommunication QComm;\n          \n          \n            \n                private @Nullable QbusCommunication QComm;", "author": "fwolter", "createdAt": "2021-02-10T16:15:11Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusBistabiel.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusBistabielHandler;\n+\n+/**\n+ * The {@link QbusBistabiel} class represents the Qbus BISTABIEL output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusBistabiel {\n+\n+    @Nullable\n+    private QbusCommunication QComm;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusBistabiel.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusBistabiel.java\nindex 7299c1da1d..4e2b3b9ba7 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusBistabiel.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusBistabiel.java\n\n@@ -15,6 +15,8 @@ package org.openhab.binding.qbus.internal.protocol;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.handler.QbusBistabielHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link QbusBistabiel} class represents the Qbus BISTABIEL output.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2Njc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573866787", "bodyText": "Primitive types should be used where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Boolean CTDConnected = false;\n          \n          \n            \n                private boolean CTDConnected = false;", "author": "fwolter", "createdAt": "2021-02-10T16:16:12Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2NzQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573867433", "bodyText": "What's the purpose of this sleep?", "author": "fwolter", "createdAt": "2021-02-10T16:17:02Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2NzU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573867591", "bodyText": "You could add this message to the IOException. Then, you only need one logging statement for all exceptions in the catch block.", "author": "fwolter", "createdAt": "2021-02-10T16:17:12Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2OTQ5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573869492", "bodyText": "You could add a message to give the user a clue what's wrong.", "author": "fwolter", "createdAt": "2021-02-10T16:19:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2OTc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573869786", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-02-10T16:19:36Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3Mjk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573872950", "bodyText": "Threads created by bindings should be named and set to daemon mode. You can achieve this by using NamedThreadFactory. Here are some examples: https://github.com/openhab/openhab-addons/search?q=namedthreadfactory", "author": "fwolter", "createdAt": "2021-02-10T16:23:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NDg3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573874872", "bodyText": "The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.", "author": "fwolter", "createdAt": "2021-02-10T16:25:45Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573876193", "bodyText": "You could make this a private method. Then, you can use it when creating the thread by this::myMethod.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Runnable qEvents = () -> {\n          \n          \n            \n                private void myMethod() {", "author": "fwolter", "createdAt": "2021-02-10T16:27:19Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573876369", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.\nPlease check all.", "author": "fwolter", "createdAt": "2021-02-10T16:27:30Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njg4NjE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r576886178", "bodyText": "Is it ok to use logge.trace here?", "author": "QbusKoen", "createdAt": "2021-02-16T14:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njg4OTE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r576889158", "bodyText": "Yes.", "author": "fwolter", "createdAt": "2021-02-16T15:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njg5MDYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r576890616", "bodyText": ":-) THX!", "author": "QbusKoen", "createdAt": "2021-02-16T15:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327533", "bodyText": "I still see info.", "author": "fwolter", "createdAt": "2021-02-23T19:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1OTEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582159124", "bodyText": "Can you work on this?", "author": "fwolter", "createdAt": "2021-02-24T17:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573876629", "bodyText": "See above. Add a message. Please check all.", "author": "fwolter", "createdAt": "2021-02-10T16:27:48Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3ODcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573878718", "bodyText": "You could use the built-in interrupted flag. The thread is interrupted when you call thread.interrupt().\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n          \n          \n            \n                        while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {", "author": "fwolter", "createdAt": "2021-02-10T16:30:10Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3OTUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573879525", "bodyText": "Stopping a thread is a normal operation when OH is shut-down. You could make this debug or trace.", "author": "fwolter", "createdAt": "2021-02-10T16:31:08Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MDEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573880134", "bodyText": "See above. Throw InterruptedException.", "author": "fwolter", "createdAt": "2021-02-10T16:31:55Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     */\n+    synchronized void sendMessage(Object qMessage) {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1OTUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582159538", "bodyText": "Can you work on this?", "author": "fwolter", "createdAt": "2021-02-24T17:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MDEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MTE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573881148", "bodyText": "See above. Logging to error. Please check all.", "author": "fwolter", "createdAt": "2021-02-10T16:33:09Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     */\n+    synchronized void sendMessage(Object qMessage) {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                // No reaction on error is required\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdlistscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.error(\"Initialization error\");", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MjAwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573882006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void cmdlistscenes(@Nullable List<Map<String, String>> outputs) {\n          \n          \n            \n                private void cmdListScenes(@Nullable List<Map<String, String>> outputs) {", "author": "fwolter", "createdAt": "2021-02-10T16:34:04Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     */\n+    synchronized void sendMessage(Object qMessage) {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                // No reaction on error is required\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdlistscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.error(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdlistscenes(@Nullable List<Map<String, String>> outputs) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex a042f8f20f..be90cca920 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -53,22 +53,19 @@ public final class QbusCommunication {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n-    @Nullable\n-    private Socket qSocket;\n-    @Nullable\n-    private PrintWriter qOut;\n-    @Nullable\n-    private BufferedReader qIn;\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n \n     private boolean listenerStopped;\n     private boolean qEventsRunning;\n \n     private Gson gsonOut = new Gson();\n     private Gson gsonIn;\n-    @Nullable\n-    private String CTD;\n \n-    private Boolean CTDConnected = false;\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n \n     private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n     private final Map<Integer, QbusScene> scene = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4NTI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573885266", "bodyText": "It's bad practice to catch ClassCastExceptions. You could check the type beforehand with instanceof.", "author": "fwolter", "createdAt": "2021-02-10T16:37:57Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Class {@link QbusMessageDeserializer} deserializes all json messages from Qbus. Various json\n+ * message formats are supported. The format is selected based on the content of the cmd and event json objects.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ *\n+ */\n+\n+@NonNullByDefault\n+class QbusMessageDeserializer implements JsonDeserializer<QbusMessageBase> {\n+\n+    @Override\n+    public @Nullable QbusMessageBase deserialize(final JsonElement json, final Type typeOfT,\n+            final JsonDeserializationContext context) throws JsonParseException {\n+        final JsonObject jsonObject = json.getAsJsonObject();\n+\n+        try {\n+\n+            String cmd = null;\n+            String CTD = null;\n+\n+            if (jsonObject.has(\"cmd\")) {\n+                cmd = jsonObject.get(\"cmd\").getAsString();\n+            }\n+\n+            if (jsonObject.has(\"CTD\")) {\n+                CTD = jsonObject.get(\"CTD\").getAsString();\n+            }\n+\n+            JsonElement jsonOutputs = null;\n+\n+            if (jsonObject.has(\"outputs\")) {\n+                jsonOutputs = jsonObject.get(\"outputs\");\n+            }\n+\n+            QbusMessageBase message = null;\n+\n+            if (jsonOutputs != null) {\n+                if (jsonOutputs.isJsonObject()) {\n+                    message = new QbusMessageMap();\n+\n+                    Map<String, String> outputs = new HashMap<>();\n+                    for (Entry<String, JsonElement> entry : jsonOutputs.getAsJsonObject().entrySet()) {\n+                        outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                    }\n+                    ((QbusMessageMap) message).setOutputs(outputs);\n+\n+                } else if (jsonOutputs.isJsonArray()) {\n+                    JsonArray jsonOutputsArray = jsonOutputs.getAsJsonArray();\n+\n+                    message = new QbusMessageListMap();\n+\n+                    List<Map<String, String>> outputsList = new ArrayList<>();\n+                    for (int i = 0; i < jsonOutputsArray.size(); i++) {\n+                        JsonObject jsonOutputsObject = jsonOutputsArray.get(i).getAsJsonObject();\n+\n+                        Map<String, String> outputs = new HashMap<>();\n+                        for (Entry<String, JsonElement> entry : jsonOutputsObject.entrySet()) {\n+                            outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                        }\n+                        outputsList.add(outputs);\n+                    }\n+                    ((QbusMessageListMap) message).setOutputs(outputsList);\n+                }\n+            }\n+\n+            if (message != null && cmd != null && CTD != null) {\n+                message.setCmd(cmd);\n+                message.setSn(CTD);\n+            } else {\n+                throw new JsonParseException(\"Unexpected Json type\");\n+            }\n+\n+            return message;\n+\n+        } catch (IllegalStateException | ClassCastException e) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java\nindex 17a9edc669..41c3c013b7 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java\n\n@@ -46,7 +46,6 @@ class QbusMessageDeserializer implements JsonDeserializer<QbusMessageBase> {\n         final JsonObject jsonObject = json.getAsJsonObject();\n \n         try {\n-\n             String cmd = null;\n             String CTD = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4NjAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573886016", "bodyText": "Primitive types should be used where possible.", "author": "fwolter", "createdAt": "2021-02-10T16:38:33Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusThermostat.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusThermostatHandler;\n+\n+/**\n+ * The {@link QbusThermostat} class represents the thermostat Qbus communication object. It contains all\n+ * fields representing a Qbus thermostat and has methods to set the thermostat mode and setpoint in Qbus and\n+ * receive thermostat updates.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusThermostat {\n+\n+    @Nullable\n+    private QbusCommunication qComm;\n+\n+    private String id;\n+    private Double measured = 0.0;\n+    private Double setpoint = 0.0;\n+    private Integer mode = 0;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96d8d832f392965564c7f72dabb9f00f0685afca", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusThermostat.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusThermostat.java\nindex 661f0705e9..f874c2d348 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusThermostat.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusThermostat.java\n\n@@ -15,6 +15,8 @@ package org.openhab.binding.qbus.internal.protocol;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.handler.QbusThermostatHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link QbusThermostat} class represents the thermostat Qbus communication object. It contains all\n"}}, {"oid": "96d8d832f392965564c7f72dabb9f00f0685afca", "url": "https://github.com/openhab/openhab-addons/commit/96d8d832f392965564c7f72dabb9f00f0685afca", "message": "Updated requested changes\n\nUpdated requested changes by fwolter on 10/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-23T08:56:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxNzkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581317939", "bodyText": "It seems these can all be handled in the same if.", "author": "fwolter", "createdAt": "2021-02-23T19:15:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                try {\n+                    qbusComm.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication.\");\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 16b2a6acc2..bb5a0444fc 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -92,8 +92,9 @@ public class QbusBridgeHandler extends BaseBridgeHandler {\n      * Sets the Bridge call back\n      */\n     private void setBridgeCallBack() {\n-        if (qbusComm != null) {\n-            qbusComm.setBridgeCallBack(this);\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxODM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581318350", "bodyText": "It's good practice to append the exception's message to the log message. Should the Thing set to OFFLINE here?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.warn(\"Error on restaring communication.\");\n          \n          \n            \n                                logger.warn(\"Error on restaring communication: {}\", e.getMessage());", "author": "fwolter", "createdAt": "2021-02-23T19:15:56Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                try {\n+                    qbusComm.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication.\");", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 16b2a6acc2..bb5a0444fc 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -92,8 +92,9 @@ public class QbusBridgeHandler extends BaseBridgeHandler {\n      * Sets the Bridge call back\n      */\n     private void setBridgeCallBack() {\n-        if (qbusComm != null) {\n-            qbusComm.setBridgeCallBack(this);\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxOTI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581319277", "bodyText": "Please remove this empty line.", "author": "fwolter", "createdAt": "2021-02-23T19:17:24Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusHandlerFactory.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusBistabielHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusCO2Handler;\n+import org.openhab.binding.qbus.internal.handler.QbusDimmerHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusRolHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusSceneHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusThermostatHandler;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link qbusHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.qbus\")\n+", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusHandlerFactory.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusHandlerFactory.java\nindex 9a2b13cb1c..6de139b1e6 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusHandlerFactory.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusHandlerFactory.java\n\n@@ -38,7 +38,6 @@ import org.osgi.service.component.annotations.Component;\n  */\n \n @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.qbus\")\n-\n @NonNullByDefault\n public class QbusHandlerFactory extends BaseThingHandlerFactory {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMDYyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581320622", "bodyText": "Please remove this colon.", "author": "fwolter", "createdAt": "2021-02-23T19:19:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int dimmerId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\nindex c2d5281965..eb26fe7487 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n\n@@ -58,26 +58,26 @@ public class QbusDimmerHandler extends QbusGlobalHandler {\n         setConfig();\n         dimmerId = getId();\n \n-        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n-        if (QComm == null) {\n+        QbusCommunication qComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (qComm == null) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                     \"No communication with Qbus Bridge!\");\n             return;\n         }\n \n-        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n-        if (QBridgeHandler == null) {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (qBridgeHandler == null) {\n             return;\n         }\n \n         setSN();\n \n-        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        Map<Integer, QbusDimmer> dimmerComm = qComm.getDimmer();\n         if (dimmerComm != null) {\n-            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n-            if (QDimmer != null) {\n-                QDimmer.setThingHandler(this);\n-                handleStateUpdate(QDimmer);\n+            QbusDimmer qDimmer = dimmerComm.get(dimmerId);\n+            if (qDimmer != null) {\n+                qDimmer.setThingHandler(this);\n+                handleStateUpdate(qDimmer);\n             } else {\n                 updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                         \"Error while initializing the thing.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581321346", "bodyText": "You could directly check for the type. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof OnOffType) {\n          \n          \n            \n                        OnOffType s = (OnOffType) command;\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n            \n          \n          \n            \n                        if (s == OnOffType.OFF) {\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n            \n          \n          \n            \n                        if (command == OnOffType.OFF) {", "author": "fwolter", "createdAt": "2021-02-23T19:20:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int dimmerId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+\n+            if (QDimmer == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Dimmer\", dimmerId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QDimmer);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SWITCH:\n+                                handleSwitchCommand(QDimmer, command);\n+                                break;\n+\n+                            case CHANNEL_BRIGHTNESS:\n+                                handleBrightnessCommand(QDimmer, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the switch command\n+     */\n+    private void handleSwitchCommand(QbusDimmer QDimmer, Command command) {\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            String snr = getSN();\n+\n+            if (s == OnOffType.OFF) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\nindex c2d5281965..eb26fe7487 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java\n\n@@ -58,26 +58,26 @@ public class QbusDimmerHandler extends QbusGlobalHandler {\n         setConfig();\n         dimmerId = getId();\n \n-        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n-        if (QComm == null) {\n+        QbusCommunication qComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (qComm == null) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                     \"No communication with Qbus Bridge!\");\n             return;\n         }\n \n-        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n-        if (QBridgeHandler == null) {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (qBridgeHandler == null) {\n             return;\n         }\n \n         setSN();\n \n-        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        Map<Integer, QbusDimmer> dimmerComm = qComm.getDimmer();\n         if (dimmerComm != null) {\n-            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n-            if (QDimmer != null) {\n-                QDimmer.setThingHandler(this);\n-                handleStateUpdate(QDimmer);\n+            QbusDimmer qDimmer = dimmerComm.get(dimmerId);\n+            if (qDimmer != null) {\n+                qDimmer.setThingHandler(this);\n+                handleStateUpdate(qDimmer);\n             } else {\n                 updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                         \"Error while initializing the thing.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMjA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581322074", "bodyText": "Please remove.", "author": "fwolter", "createdAt": "2021-02-23T19:21:25Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int rolId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol != null) {\n+                QRol.setThingHandler(this);\n+                handleStateUpdate(QRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\nindex 530e4dc277..391487e335 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n\n@@ -57,31 +57,30 @@ public class QbusRolHandler extends QbusGlobalHandler {\n      */\n     @Override\n     public void initialize() {\n-\n         setConfig();\n         rolId = getId();\n \n-        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n-        if (QComm == null) {\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+        if (qComm == null) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                     \"No communication with Qbus Bridge!\");\n             return;\n         }\n \n-        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n-        if (QBridgeHandler == null) {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n             return;\n         }\n \n         setSN();\n \n-        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n \n         if (rolComm != null) {\n-            QbusRol QRol = rolComm.get(rolId);\n-            if (QRol != null) {\n-                QRol.setThingHandler(this);\n-                handleStateUpdate(QRol);\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol != null) {\n+                qRol.setThingHandler(this);\n+                handleStateUpdate(qRol);\n             } else {\n                 updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                         \"Error while initializing the thing.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMzIwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581323203", "bodyText": "Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:22:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusScene;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusSceneHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusSceneHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int sceneId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusSceneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        sceneId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Scene\", sceneId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusScene> sceneComm = QComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene QScene = sceneComm.get(sceneId);\n+            if (QScene != null) {\n+                QScene.setThingHandler(this);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\nindex 71d3973b70..f445ec18a6 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\n\n@@ -53,30 +53,29 @@ public class QbusSceneHandler extends QbusGlobalHandler {\n      */\n     @Override\n     public void initialize() {\n-\n         setConfig();\n         sceneId = getId();\n \n-        QbusCommunication QComm = getCommunication(\"Scene\", sceneId);\n-        if (QComm == null) {\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+        if (qComm == null) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                     \"No communication with Qbus Bridge!\");\n             return;\n         }\n \n-        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n-        if (QBridgeHandler == null) {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n             return;\n         }\n \n         setSN();\n \n-        Map<Integer, QbusScene> sceneComm = QComm.getScene();\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n \n         if (sceneComm != null) {\n-            QbusScene QScene = sceneComm.get(sceneId);\n-            if (QScene != null) {\n-                QScene.setThingHandler(this);\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene != null) {\n+                qScene.setThingHandler(this);\n                 updateStatus(ThingStatus.ONLINE);\n             } else {\n                 updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNDQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581324419", "bodyText": "You need to convert the temperature value you expect. If the user has configured Fahrenheit, s.doubleValue() would return the Fahrenheit value. You can call c.toUnit() for the conversion.", "author": "fwolter", "createdAt": "2021-02-23T19:24:47Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusThermostat;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusThermostatHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int thermostatId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusThermostatHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        thermostatId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusThermostat> thermostatComm = QComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat QThermostat = thermostatComm.get(thermostatId);\n+            if (QThermostat != null) {\n+                QThermostat.setThingHandler(this);\n+                handleStateUpdate(QThermostat);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        } else {\n+            this.sn = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Thermostat\", thermostatId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for thermostat \"\n+                            + thermostatId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusThermostat> thermostatComm = QComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+\n+            QbusThermostat QThermostat = thermostatComm.get(thermostatId);\n+\n+            if (QThermostat == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \"\n+                                + thermostatId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Thermostat\", thermostatId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QThermostat);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_MODE:\n+                                handleModeCommand(QThermostat, command);\n+                                break;\n+\n+                            case CHANNEL_SETPOINT:\n+                                handleSetpointCommand(QThermostat, command);\n+                                break;\n+\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Puts thing offline\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the Mode command\n+     */\n+    private void handleModeCommand(QbusThermostat QThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof DecimalType) {\n+            int mode = ((DecimalType) command).intValue();\n+            if (snr != null) {\n+                QThermostat.executeMode(mode, snr);\n+            } else {\n+                thingOffline(\"No serial number configured for  \" + thermostatId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the Setpoint command\n+     */\n+    private void handleSetpointCommand(QbusThermostat QThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof QuantityType<?>) {\n+            QuantityType<?> s = (QuantityType<?>) command;\n+            double sp = s.doubleValue();", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\nindex 1797f2a8c0..7ebf38c9b4 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\n\n@@ -59,27 +59,27 @@ public class QbusThermostatHandler extends QbusGlobalHandler {\n         setConfig();\n         thermostatId = getId();\n \n-        QbusCommunication QComm = getCommunication(\"Thermostat\", thermostatId);\n-        if (QComm == null) {\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (qComm == null) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                     \"No communication with Qbus Bridge!\");\n             return;\n         }\n \n-        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n-        if (QBridgeHandler == null) {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n             return;\n         }\n \n         setSN();\n \n-        Map<Integer, QbusThermostat> thermostatComm = QComm.getThermostat();\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n \n         if (thermostatComm != null) {\n-            QbusThermostat QThermostat = thermostatComm.get(thermostatId);\n-            if (QThermostat != null) {\n-                QThermostat.setThingHandler(this);\n-                handleStateUpdate(QThermostat);\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+            if (qThermostat != null) {\n+                qThermostat.setThingHandler(this);\n+                handleStateUpdate(qThermostat);\n             } else {\n                 updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n                         \"Error while initializing the thing.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNjQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581326468", "bodyText": "The Thread's name should include the Thing UID. You could use NamedThreadFactory to retrieve a correctly configured Thread. Here are some examples: https://github.com/openhab/openhab-addons/search?q=NamedThreadFactory", "author": "fwolter", "createdAt": "2021-02-23T19:27:41Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzA0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327049", "bodyText": "The readers and writers need to be closed here.", "author": "fwolter", "createdAt": "2021-02-23T19:28:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzczMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327731", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n          \n          \n            \n                        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {", "author": "fwolter", "createdAt": "2021-02-23T19:29:24Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327918", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-02-23T19:29:39Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyODQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581328465", "bodyText": "You can simply remove the try/catch clause to throw the exception.", "author": "fwolter", "createdAt": "2021-02-23T19:30:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581330145", "bodyText": "The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.", "author": "fwolter", "createdAt": "2021-02-23T19:32:40Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3Njk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582976978", "bodyText": "You need to remove the InterruptedException from the catch clause to let it be thrown.", "author": "fwolter", "createdAt": "2021-02-25T16:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMDEyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585900123", "bodyText": "Can you work on this?", "author": "fwolter", "createdAt": "2021-03-02T20:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581330556", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed.", "author": "fwolter", "createdAt": "2021-02-23T19:33:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581330978", "bodyText": "See above. Can be removed. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:33:54Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331089", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void Connect() throws InterruptedException, IOException {\n          \n          \n            \n                private void connect() throws InterruptedException, IOException {", "author": "fwolter", "createdAt": "2021-02-23T19:34:04Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331341", "bodyText": "See above. Logging to error. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:34:24Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n          \n          \n            \n                private void cmdListScenes(@Nullable List<Map<String, String>> outputs) {", "author": "fwolter", "createdAt": "2021-02-23T19:35:00Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331928", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {\n          \n          \n            \n                private void cmdListRol(@Nullable List<Map<String, String>> outputs) {", "author": "fwolter", "createdAt": "2021-02-23T19:35:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> scene : outputs) {\n+                String idStr = scene.get(\"id\");\n+                if (idStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    QbusScene Scene = new QbusScene(idStr);\n+                    Scene.setQComm(this);\n+                    this.scene.put(id, Scene);\n+                } else {\n+                    logger.error(\"Error in json for Scenes\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Dimmer outputs from the Qbus client\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListDimmers(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> dimmer : outputs) {\n+                String idStr = dimmer.get(\"id\");\n+                String stateStr = dimmer.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusDimmer qDimmer = new QbusDimmer(idStr);\n+                    if (!this.dimmer.containsKey(id)) {\n+                        qDimmer.setQComm(this);\n+                        this.dimmer.put(id, qDimmer);\n+                        qDimmer.updateState(state);\n+                    } else {\n+                        qDimmer.updateState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Dimmer\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screens with slat control outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMjM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581332377", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-02-23T19:35:53Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> scene : outputs) {\n+                String idStr = scene.get(\"id\");\n+                if (idStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    QbusScene Scene = new QbusScene(idStr);\n+                    Scene.setQComm(this);\n+                    this.scene.put(id, Scene);\n+                } else {\n+                    logger.error(\"Error in json for Scenes\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Dimmer outputs from the Qbus client\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListDimmers(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> dimmer : outputs) {\n+                String idStr = dimmer.get(\"id\");\n+                String stateStr = dimmer.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusDimmer qDimmer = new QbusDimmer(idStr);\n+                    if (!this.dimmer.containsKey(id)) {\n+                        qDimmer.setQComm(this);\n+                        this.dimmer.put(id, qDimmer);\n+                        qDimmer.updateState(state);\n+                    } else {\n+                        qDimmer.updateState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Dimmer\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screens with slat control outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String stateStr = rol.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.valueOf(stateStr);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screen outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrolslats(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String rolPos = rol.get(\"rolPos\");\n+                String slatPos = rol.get(\"slatPos\");\n+                if (idStr != null && rolPos != null && slatPos != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.parseInt(rolPos);\n+                    Integer rolposslats = Integer.parseInt(slatPos);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P_Slats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the CO2 outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistco2(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> co2 : outputs) {\n+                String idStr = co2.get(\"id\");\n+                String stateStr = co2.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    int state = Integer.parseInt(stateStr);\n+                    QbusCO2 CO2 = new QbusCO2();\n+                    if (!this.co2.containsKey(id)) {\n+                        this.co2.put(id, CO2);\n+                        CO2.setState(state);\n+                    } else {\n+                        CO2.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for CO2\");\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Thermostat outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListThermostat(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> thermostat : outputs) {\n+                String idStr = thermostat.get(\"id\");\n+                String measuredStr = thermostat.get(\"measured\");\n+                String setpointStr = thermostat.get(\"SetPoint\");\n+                String modeStr = thermostat.get(\"Mode\");\n+                if (idStr != null && measuredStr != null && setpointStr != null && modeStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Double measured = Double.valueOf(measuredStr);\n+                    Double setpoint = Double.valueOf(setpointStr);\n+                    Integer mode = Integer.valueOf(modeStr);\n+                    QbusThermostat qThermostat = new QbusThermostat(idStr);\n+                    if (!this.thermostat.containsKey(id)) {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                        qThermostat.setQComm(this);\n+                        this.thermostat.put(id, qThermostat);\n+                    } else {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Thermostats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event on incoming Bistabiel/Timer/Mono/Interval updates\n+     *\n+     * @param data\n+     */\n+    private void updateBistabiel(List<Map<String, String>> output) {\n+        for (Map<String, String> bistabiel : output) {\n+            String idStr = bistabiel.get(\"id\");\n+            String stateStr = bistabiel.get(\"state\");\n+            if (idStr != null && stateStr != null) {\n+                int id = Integer.parseInt(idStr);\n+                int value1 = Integer.parseInt(stateStr);\n+                QbusBistabiel Bistabiel = this.bistabiel.get(id);\n+                if (Bistabiel != null) {\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        logger.warn(\"Bistabiel in controller not known {}\", id);\n+                        return;\n+                    }\n+                    logger.info(\"Event execute bistabiel {} with state {}\", id, value1);", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMjUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581332513", "bodyText": "See above. Logging to info. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:36:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> scene : outputs) {\n+                String idStr = scene.get(\"id\");\n+                if (idStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    QbusScene Scene = new QbusScene(idStr);\n+                    Scene.setQComm(this);\n+                    this.scene.put(id, Scene);\n+                } else {\n+                    logger.error(\"Error in json for Scenes\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Dimmer outputs from the Qbus client\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListDimmers(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> dimmer : outputs) {\n+                String idStr = dimmer.get(\"id\");\n+                String stateStr = dimmer.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusDimmer qDimmer = new QbusDimmer(idStr);\n+                    if (!this.dimmer.containsKey(id)) {\n+                        qDimmer.setQComm(this);\n+                        this.dimmer.put(id, qDimmer);\n+                        qDimmer.updateState(state);\n+                    } else {\n+                        qDimmer.updateState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Dimmer\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screens with slat control outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String stateStr = rol.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.valueOf(stateStr);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screen outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrolslats(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String rolPos = rol.get(\"rolPos\");\n+                String slatPos = rol.get(\"slatPos\");\n+                if (idStr != null && rolPos != null && slatPos != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.parseInt(rolPos);\n+                    Integer rolposslats = Integer.parseInt(slatPos);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P_Slats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the CO2 outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistco2(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> co2 : outputs) {\n+                String idStr = co2.get(\"id\");\n+                String stateStr = co2.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    int state = Integer.parseInt(stateStr);\n+                    QbusCO2 CO2 = new QbusCO2();\n+                    if (!this.co2.containsKey(id)) {\n+                        this.co2.put(id, CO2);\n+                        CO2.setState(state);\n+                    } else {\n+                        CO2.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for CO2\");\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Thermostat outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListThermostat(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> thermostat : outputs) {\n+                String idStr = thermostat.get(\"id\");\n+                String measuredStr = thermostat.get(\"measured\");\n+                String setpointStr = thermostat.get(\"SetPoint\");\n+                String modeStr = thermostat.get(\"Mode\");\n+                if (idStr != null && measuredStr != null && setpointStr != null && modeStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Double measured = Double.valueOf(measuredStr);\n+                    Double setpoint = Double.valueOf(setpointStr);\n+                    Integer mode = Integer.valueOf(modeStr);\n+                    QbusThermostat qThermostat = new QbusThermostat(idStr);\n+                    if (!this.thermostat.containsKey(id)) {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                        qThermostat.setQComm(this);\n+                        this.thermostat.put(id, qThermostat);\n+                    } else {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Thermostats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event on incoming Bistabiel/Timer/Mono/Interval updates\n+     *\n+     * @param data\n+     */\n+    private void updateBistabiel(List<Map<String, String>> output) {\n+        for (Map<String, String> bistabiel : output) {\n+            String idStr = bistabiel.get(\"id\");\n+            String stateStr = bistabiel.get(\"state\");\n+            if (idStr != null && stateStr != null) {\n+                int id = Integer.parseInt(idStr);\n+                int value1 = Integer.parseInt(stateStr);\n+                QbusBistabiel Bistabiel = this.bistabiel.get(id);\n+                if (Bistabiel != null) {\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        logger.warn(\"Bistabiel in controller not known {}\", id);\n+                        return;\n+                    }\n+                    logger.info(\"Event execute bistabiel {} with state {}\", id, value1);\n+                    Bistabiel.setState(value1);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event on incoming Dimmer updates\n+     *\n+     * @param data\n+     */\n+    private void updateDimmers(List<Map<String, String>> data) {\n+        for (Map<String, String> dimmer : data) {\n+            String idStr = dimmer.get(\"id\");\n+            String stateStr = dimmer.get(\"state\");\n+            if (idStr != null && stateStr != null) {\n+                int id = Integer.valueOf(idStr);\n+                int value = Integer.valueOf(stateStr);\n+                QbusDimmer Qdimmer = this.dimmer.get(id);\n+                if (!this.dimmer.containsKey(id)) {\n+                    logger.warn(\"Dimmer in controller not known {}\", id);\n+                    return;\n+                }\n+                if (Qdimmer != null) {\n+                    logger.info(\"Event execute dimmer {} with state {}\", id, value);", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex be90cca920..abf59290aa 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -21,11 +21,14 @@ import java.net.Socket;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMzE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581333171", "bodyText": "See above. Handle InterruptedException correctly. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:37:00Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusDimmer.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusDimmerHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link QbusDimmer} class represents the action Qbus Dimmer output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusDimmer {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusDimmer.class);\n+\n+    private @Nullable QbusCommunication QComm;\n+\n+    private String id;\n+\n+    private @Nullable Integer state;\n+\n+    private @Nullable QbusDimmerHandler thingHandler;\n+\n+    QbusDimmer(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Update all values of the dimmer\n+     *\n+     * @param state\n+     */\n+    public void updateState(Integer state) {\n+        setState(state);\n+\n+        QbusDimmerHandler handler = thingHandler;\n+        if (handler != null) {\n+            handler.handleStateUpdate(this);\n+        }\n+    }\n+\n+    /**\n+     * This method should be called if the ThingHandler for the thing corresponding to this dimmer is initialized.\n+     * It keeps a record of the thing handler in this object so the thing can be updated when\n+     * the dimmer receives an update from the Qbus IP-interface.\n+     *\n+     * @param handler\n+     */\n+    public void setThingHandler(QbusDimmerHandler handler) {\n+        this.thingHandler = handler;\n+    }\n+\n+    /**\n+     * This method sets a pointer to the QComm Dimmer of class {@link QbusCommuncation}.\n+     * This is then used to be able to call back the sendCommand method in this class to send a command to the\n+     * Qbus IP-interface when..\n+     *\n+     * @param QComm\n+     */\n+    public void setQComm(QbusCommunication QComm) {\n+        this.QComm = QComm;\n+    }\n+\n+    /**\n+     * Get state of dimmer.\n+     *\n+     * @return dimmer state\n+     */\n+    public @Nullable Integer getState() {\n+        if (this.state != null) {\n+            return this.state;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Sets state of Dimmer.\n+     *\n+     * @param dimmer state\n+     */\n+    void setState(int state) {\n+        this.state = state;\n+        QbusDimmerHandler handler = thingHandler;\n+        if (handler != null) {\n+            handler.handleStateUpdate(this);\n+        }\n+    }\n+\n+    /**\n+     * Sends Dimmer state to Qbus.\n+     */\n+    public void execute(int percent, String sn) {\n+        QbusMessageCmd QCmd = new QbusMessageCmd(sn, \"executeDimmer\").withId(this.id).withState(percent);\n+        QbusCommunication comm = QComm;\n+        if (comm != null) {\n+            try {\n+                comm.sendMessage(QCmd);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Could not send command for dimmer {}\", this.id);", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusDimmer.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusDimmer.java\nindex 6b539aeb60..a879ec7323 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusDimmer.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusDimmer.java\n\n@@ -29,7 +29,7 @@ public final class QbusDimmer {\n \n     private final Logger logger = LoggerFactory.getLogger(QbusDimmer.class);\n \n-    private @Nullable QbusCommunication QComm;\n+    private @Nullable QbusCommunication qComm;\n \n     private String id;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzNDE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581334185", "bodyText": "It's good practice to include the cause in the exception. What throws a IllegalStateException anyway?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new JsonParseException(\"Unexpected Json type\");\n          \n          \n            \n                        throw new JsonParseException(\"Unexpected Json type\", e);", "author": "fwolter", "createdAt": "2021-02-23T19:38:35Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Class {@link QbusMessageDeserializer} deserializes all json messages from Qbus. Various json\n+ * message formats are supported. The format is selected based on the content of the cmd and event json objects.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ *\n+ */\n+\n+@NonNullByDefault\n+class QbusMessageDeserializer implements JsonDeserializer<QbusMessageBase> {\n+\n+    @Override\n+    public @Nullable QbusMessageBase deserialize(final JsonElement json, final Type typeOfT,\n+            final JsonDeserializationContext context) throws JsonParseException {\n+        final JsonObject jsonObject = json.getAsJsonObject();\n+\n+        try {\n+            String cmd = null;\n+            String CTD = null;\n+\n+            if (jsonObject.has(\"cmd\")) {\n+                cmd = jsonObject.get(\"cmd\").getAsString();\n+            }\n+\n+            if (jsonObject.has(\"CTD\")) {\n+                CTD = jsonObject.get(\"CTD\").getAsString();\n+            }\n+\n+            JsonElement jsonOutputs = null;\n+\n+            if (jsonObject.has(\"outputs\")) {\n+                jsonOutputs = jsonObject.get(\"outputs\");\n+            }\n+\n+            QbusMessageBase message = null;\n+\n+            if (jsonOutputs != null) {\n+                if (jsonOutputs.isJsonObject()) {\n+                    message = new QbusMessageMap();\n+\n+                    Map<String, String> outputs = new HashMap<>();\n+                    for (Entry<String, JsonElement> entry : jsonOutputs.getAsJsonObject().entrySet()) {\n+                        outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                    }\n+                    ((QbusMessageMap) message).setOutputs(outputs);\n+\n+                } else if (jsonOutputs.isJsonArray()) {\n+                    JsonArray jsonOutputsArray = jsonOutputs.getAsJsonArray();\n+\n+                    message = new QbusMessageListMap();\n+\n+                    List<Map<String, String>> outputsList = new ArrayList<>();\n+                    for (int i = 0; i < jsonOutputsArray.size(); i++) {\n+                        JsonObject jsonOutputsObject = jsonOutputsArray.get(i).getAsJsonObject();\n+\n+                        Map<String, String> outputs = new HashMap<>();\n+                        for (Entry<String, JsonElement> entry : jsonOutputsObject.entrySet()) {\n+                            outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                        }\n+                        outputsList.add(outputs);\n+                    }\n+                    ((QbusMessageListMap) message).setOutputs(outputsList);\n+                }\n+            }\n+\n+            if (message != null && cmd != null && CTD != null) {\n+                message.setCmd(cmd);\n+                message.setSn(CTD);\n+            } else {\n+                throw new JsonParseException(\"Unexpected Json type\");\n+            }\n+\n+            return message;\n+\n+        } catch (IllegalStateException e) {\n+            throw new JsonParseException(\"Unexpected Json type\");", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35f160764de231acf7b9f3e92e3d51df37300a8f", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java\nindex 41c3c013b7..746618be7c 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java\n\n@@ -47,14 +47,14 @@ class QbusMessageDeserializer implements JsonDeserializer<QbusMessageBase> {\n \n         try {\n             String cmd = null;\n-            String CTD = null;\n+            String ctd = null;\n \n             if (jsonObject.has(\"cmd\")) {\n                 cmd = jsonObject.get(\"cmd\").getAsString();\n             }\n \n             if (jsonObject.has(\"CTD\")) {\n-                CTD = jsonObject.get(\"CTD\").getAsString();\n+                ctd = jsonObject.get(\"CTD\").getAsString();\n             }\n \n             JsonElement jsonOutputs = null;\n"}}, {"oid": "10bbea6583b9022d0c7b65fa5d9b6b8200f54068", "url": "https://github.com/openhab/openhab-addons/commit/10bbea6583b9022d0c7b65fa5d9b6b8200f54068", "message": "Updated requested changes\n\nUpdated requested changes by fwolter on 10/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-24T15:29:58Z", "type": "commit"}, {"oid": "35f160764de231acf7b9f3e92e3d51df37300a8f", "url": "https://github.com/openhab/openhab-addons/commit/35f160764de231acf7b9f3e92e3d51df37300a8f", "message": "Updated code\n\nUpdated code as requested by FWolter on 23/02/2021", "committedDate": "2021-02-24T15:31:04Z", "type": "commit"}, {"oid": "78b7addb909b45af597f0775893d65fa2494c2e5", "url": "https://github.com/openhab/openhab-addons/commit/78b7addb909b45af597f0775893d65fa2494c2e5", "message": "Merge branch 'main' of https://github.com/QbusKoen/openhab-addons into main\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-02-24T16:28:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE0NDEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582144102", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.\nAlso, it's good practice to include the exception's message in the status detail message to display it in the UI.", "author": "fwolter", "createdAt": "2021-02-24T17:12:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication());\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication: {}\", e.getMessage());\n+                    bridgeOffline(\"Communication could not be established\");", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 823c74a708..0168b2c8b4 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -40,14 +40,16 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class QbusBridgeHandler extends BaseBridgeHandler {\n \n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n     private @Nullable QbusCommunication qbusComm;\n \n     protected @Nullable QbusConfiguration config;\n \n     private @Nullable ScheduledFuture<?> refreshTimer;\n \n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n     public QbusBridgeHandler(Bridge Bridge) {\n         super(Bridge);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE0NTYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582145600", "bodyText": "The command don't need to be cast.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        OnOffType s = (OnOffType) command;\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n                        if (snr != null) {\n          \n          \n            \n                            if (s == OnOffType.OFF) {\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n                        if (snr != null) {\n          \n          \n            \n                            if (command == OnOffType.OFF) {", "author": "fwolter", "createdAt": "2021-02-24T17:14:56Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int bistabielId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+        bistabielId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = qComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel qBistabiel = bistabielComm.get(bistabielId);\n+            if (qBistabiel != null) {\n+                qBistabiel.setThingHandler(this);\n+                handleStateUpdate(qBistabiel);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for bistabiel \" + bistabielId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = qComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel qBistabiel = bistabielComm.get(bistabielId);\n+\n+            if (qBistabiel == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"bridge communication not initialized when trying to execute command for bistabiel \"\n+                                + bistabielId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Bistabiel\", bistabielId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qBistabiel);\n+                            return;\n+                        }\n+\n+                        handleSwitchCommand(qBistabiel, channelUID, command);\n+                    }\n+                });\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Executes the switch command\n+     *\n+     * @throws InterruptedException\n+     */\n+    private void handleSwitchCommand(QbusBistabiel qBistabiel, ChannelUID channelUID, Command command) {\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            String snr = getSN();\n+            if (snr != null) {\n+                if (s == OnOffType.OFF) {", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\nindex 1ce96cf4ff..aa82f11fc3 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java\n\n@@ -16,6 +16,7 @@ import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWI\n import static org.openhab.core.types.RefreshType.REFRESH;\n \n import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE0ODE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582148147", "bodyText": "You could add the package to the imports.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof org.openhab.core.library.types.UpDownType) {\n          \n          \n            \n                    if (command instanceof UpDownType) {", "author": "fwolter", "createdAt": "2021-02-24T17:18:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int rolId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol != null) {\n+                qRol.setThingHandler(this);\n+                handleStateUpdate(qRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(qRol, command);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(qRol, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof UpDownType) {\n+            UpDownType upDown = (UpDownType) command;\n+            if (upDown == DOWN) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType) {\n+            IncreaseDecreaseType inc = (IncreaseDecreaseType) command;\n+            int stepValue = ((Number) this.getConfig().get(CONFIG_STEP_VALUE)).intValue();\n+            Integer currentValue = qRol.getState();\n+            int newValue;\n+            int sendValue;\n+            if (currentValue != null) {\n+                if (inc == IncreaseDecreaseType.INCREASE) {\n+                    newValue = currentValue + stepValue;\n+                    // round down to step multiple\n+                    newValue = newValue - newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                } else {\n+                    newValue = currentValue - stepValue;\n+                    // round up to step multiple\n+                    newValue = newValue + newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                }\n+            }\n+        } else if (command instanceof PercentType) {\n+            PercentType p = (PercentType) command;\n+            int pp = p.intValue();\n+            if (p == PercentType.ZERO) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(pp, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the command for screen slats position\n+     */\n+    private void handleSlatsposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof org.openhab.core.library.types.UpDownType) {", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\nindex 391487e335..18fe817f2f 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n\n@@ -17,6 +17,7 @@ import static org.openhab.core.library.types.UpDownType.DOWN;\n import static org.openhab.core.types.RefreshType.REFRESH;\n \n import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1MDA0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582150049", "bodyText": "You need to use the return value of toUnit() for further processing. Keep in mind that it can return null if the value can't be converted.", "author": "fwolter", "createdAt": "2021-02-24T17:20:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusThermostat;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusThermostatHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int thermostatId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusThermostatHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        thermostatId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+            if (qThermostat != null) {\n+                qThermostat.setThingHandler(this);\n+                handleStateUpdate(qThermostat);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for thermostat \"\n+                            + thermostatId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+\n+            if (qThermostat == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \"\n+                                + thermostatId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Thermostat\", thermostatId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qThermostat);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_MODE:\n+                                handleModeCommand(qThermostat, command);\n+                                break;\n+\n+                            case CHANNEL_SETPOINT:\n+                                handleSetpointCommand(qThermostat, command);\n+                                break;\n+\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Puts thing offline\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the Mode command\n+     */\n+    private void handleModeCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof DecimalType) {\n+            int mode = ((DecimalType) command).intValue();\n+            if (snr != null) {\n+                qThermostat.executeMode(mode, snr);\n+            } else {\n+                thingOffline(\"No serial number configured for  \" + thermostatId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the Setpoint command\n+     */\n+    private void handleSetpointCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof QuantityType<?>) {\n+            QuantityType<?> s = (QuantityType<?>) command;\n+            double sp = s.doubleValue();\n+            s.toUnit(CELSIUS);", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\nindex 052ef994c9..414312f349 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\n\n@@ -17,6 +17,7 @@ import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n import static org.openhab.core.types.RefreshType.REFRESH;\n \n import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1NDI0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582154241", "bodyText": "The ID should be the ThingUID. You could add it as an argument to the constructor of QbusCommunication.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ExecutorService threadExecutor = Executors\n          \n          \n            \n                        .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));\n          \n          \n            \n                private final ExecutorService threadExecutor = Executors\n          \n          \n            \n                        .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));", "author": "fwolter", "createdAt": "2021-02-24T17:25:59Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,925 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f07540a523..f625ce8e48 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -29,6 +29,10 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1ODgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582158837", "bodyText": "The InterruptedException shouldn't be cought here, but as high as possible in the program flow to exit the program as directly as possible. You can add throws InterruptedException to the method signature to do so.\nNevertheless, the IOException should be logged here.", "author": "fwolter", "createdAt": "2021-02-24T17:31:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,925 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+        if (qOut != null) {\n+            qOut.close();\n+        }\n+\n+        try {\n+            if (qIn != null) {\n+                qIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+        }", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f07540a523..f625ce8e48 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -29,6 +29,10 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1OTI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582159283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n          \n          \n            \n                        throw new IOException(\"Bufferreader for incoming messages not initialized.\");", "author": "fwolter", "createdAt": "2021-02-24T17:32:37Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,925 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+        if (qOut != null) {\n+            qOut.close();\n+        }\n+\n+        try {\n+            if (qIn != null) {\n+                qIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incomming messages not initialized.\");", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f07540a523..f625ce8e48 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -29,6 +29,10 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE2NTQwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582165406", "bodyText": "The field can be null at this point, because it isn't inittialized in the constructor. So, you need to check if it is not null before accessing it: if (config != null). But this would result in a compiler warning, as it is a field and could theoretically be modified by another thread exactly between the null check and the access in the next line. To mitigate this, you can store the field to a local variable before checking it:\nFuture<?> localPollingJob = pollingJob;\nif (localPollingJob != null) {\n    localPollingJob.cancel(true);\n}\n\nThere are some more compiler warnings, which can be seen when calling mvn clean install.", "author": "fwolter", "createdAt": "2021-02-24T17:40:37Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication());\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication: {}\", e.getMessage());\n+                    bridgeOffline(\"Communication could not be established\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.communicationActive()) {\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.clientConnected()) {\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+                } else {\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Sets the configuration parameters\n+     */\n+    protected void readConfig() {\n+        this.config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the ip address of the Qbus server.\n+     *\n+     * @return the ip address\n+     */\n+    public @Nullable String getAddress() {\n+        if (this.config != null) {\n+            return this.config.addr;", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 823c74a708..0168b2c8b4 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -40,14 +40,16 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class QbusBridgeHandler extends BaseBridgeHandler {\n \n-    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n-\n     private @Nullable QbusCommunication qbusComm;\n \n     protected @Nullable QbusConfiguration config;\n \n     private @Nullable ScheduledFuture<?> refreshTimer;\n \n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n     public QbusBridgeHandler(Bridge Bridge) {\n         super(Bridge);\n     }\n"}}, {"oid": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "url": "https://github.com/openhab/openhab-addons/commit/f67dda391c2a8bdda78f96e956ffd920a925b4eb", "message": "Updated requested changes\n\nUpdated changes as requested by Fwolter on 24/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-02-24T20:53:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2ODM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582968389", "bodyText": "The curly brackets don't work with ordinary string concatenation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n          \n          \n            \n                                bridgeOffline(\"Communication could not be established: \" + e.getMessage());", "author": "fwolter", "createdAt": "2021-02-25T16:16:19Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication(thing));\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 0168b2c8b4..badc5e9087 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -118,7 +118,7 @@ public class QbusBridgeHandler extends BaseBridgeHandler {\n                 try {\n                     qbusCommunication.startCommunication();\n                 } catch (InterruptedException | IOException e) {\n-                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    bridgeOffline(\"Communication could not be established \" + e.getMessage());\n                     return;\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2ODg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582968858", "bodyText": "There needs to be a space. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n          \n          \n            \n                                    bridgeOffline(\"No connection with Qbus Server: \" + e.toString());", "author": "fwolter", "createdAt": "2021-02-25T16:16:55Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication(thing));\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.communicationActive()) {\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.clientConnected()) {\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    try {\n+                        comm.restartCommunication();\n+                    } catch (InterruptedException e) {\n+                        bridgeOffline(\"No connection with Qbus Server\" + e.toString());", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 0168b2c8b4..badc5e9087 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -118,7 +118,7 @@ public class QbusBridgeHandler extends BaseBridgeHandler {\n                 try {\n                     qbusCommunication.startCommunication();\n                 } catch (InterruptedException | IOException e) {\n-                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    bridgeOffline(\"Communication could not be established \" + e.getMessage());\n                     return;\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2OTM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582969393", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-02-25T16:17:34Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication(thing));\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.communicationActive()) {\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.clientConnected()) {\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    try {\n+                        comm.restartCommunication();\n+                    } catch (InterruptedException e) {\n+                        bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                    } catch (IOException e) {\n+                        bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                    }\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+                } else {\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        try {\n+                            comm.restartCommunication();\n+                        } catch (InterruptedException e) {\n+                            bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                        } catch (IOException e) {\n+                            bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                        }\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+\n+        if (comm != null) {\n+            try {\n+                comm.stopCommunication();\n+            } catch (IOException e) {\n+                String message = e.toString();\n+                logger.error(\"Error on stopping communication.{} \", message);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 0168b2c8b4..badc5e9087 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -118,7 +118,7 @@ public class QbusBridgeHandler extends BaseBridgeHandler {\n                 try {\n                     qbusCommunication.startCommunication();\n                 } catch (InterruptedException | IOException e) {\n-                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    bridgeOffline(\"Communication could not be established \" + e.getMessage());\n                     return;\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3MjY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582972673", "bodyText": "You might want to call qBridgeHandler.bridgeOnline() only if no exception occurred. Otherwise, the Thing will be set to OFFLINE and then, qBridgeHandler.bridgeOnline() will be called.", "author": "fwolter", "createdAt": "2021-02-25T16:21:31Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusGlobalHandler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+\n+/**\n+ * The {@link QbusGlobalHandler} is used in other handlers, to share the functions.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public abstract class QbusGlobalHandler extends BaseThingHandler {\n+\n+    public QbusGlobalHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Get Bridge communication\n+     *\n+     * @param type\n+     * @param globalId\n+     * @return\n+     */\n+    public @Nullable QbusCommunication getCommunication(String type, @Nullable Integer globalId) {\n+        QbusBridgeHandler qBridgeHandler = null;\n+        if (globalId != null) {\n+            qBridgeHandler = getBridgeHandler(type, globalId);\n+        }\n+\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.BRIDGE_UNINITIALIZED,\n+                    \"No bridge handler initialized for \" + type + \" with id \" + globalId + \".\");\n+            return null;\n+        }\n+        QbusCommunication qComm = qBridgeHandler.getCommunication();\n+        return qComm;\n+    }\n+\n+    /**\n+     * Get the Bridge handler\n+     *\n+     * @param type\n+     * @param globalId\n+     * @return\n+     */\n+    public @Nullable QbusBridgeHandler getBridgeHandler(String type, @Nullable Integer globalId) {\n+        Bridge qBridge = getBridge();\n+        if (qBridge == null) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.BRIDGE_UNINITIALIZED,\n+                    \"No bridge initialized for \" + type + \" with ID \" + globalId);\n+            return null;\n+        }\n+        QbusBridgeHandler qBridgeHandler = (QbusBridgeHandler) qBridge.getHandler();\n+        return qBridgeHandler;\n+    }\n+\n+    /**\n+     *\n+     * @param qComm\n+     * @param type\n+     * @param globalId\n+     */\n+    public void restartCommunication(QbusCommunication qComm, String type, @Nullable Integer globalId) {\n+        try {\n+            qComm.restartCommunication();\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.toString());\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.toString());\n+        }\n+\n+        if (!qComm.communicationActive()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Communication socket error\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(type, globalId);\n+        if (qBridgeHandler != null) {\n+            qBridgeHandler.bridgeOnline();\n+        }", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusGlobalHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusGlobalHandler.java\nindex 05d67b5f12..7a9ee95bcf 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusGlobalHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusGlobalHandler.java\n\n@@ -23,6 +23,8 @@ import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingStatus;\n import org.openhab.core.thing.ThingStatusDetail;\n import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link QbusGlobalHandler} is used in other handlers, to share the functions.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3NDA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582974076", "bodyText": "The command don't need to be cast. Please check all.", "author": "fwolter", "createdAt": "2021-02-25T16:23:14Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusScene;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusSceneHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusSceneHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer sceneId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusSceneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        sceneId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene != null) {\n+                qScene.setThingHandler(this);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Scene\", sceneId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SCENE:\n+                                handleSwitchCommand(qScene, channelUID, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to update state of channel, called from Qbus Scene.\n+     */\n+    public void handleStateUpdate(QbusScene qScene) {\n+        Integer sceneState = qScene.getState();\n+        if (sceneState != null) {\n+            updateState(CHANNEL_SCENE, (sceneState == 0) ? OnOffType.OFF : OnOffType.ON);\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the scene command\n+     */\n+    void handleSwitchCommand(QbusScene qScene, ChannelUID channelUID, Command command) {\n+        String snr = getSN();\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            if (s == OnOffType.OFF) {", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\nindex 0b0a3ff155..88924a12b9 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\n\n@@ -176,8 +176,7 @@ public class QbusSceneHandler extends QbusGlobalHandler {\n     void handleSwitchCommand(QbusScene qScene, ChannelUID channelUID, Command command) {\n         String snr = getSN();\n         if (command instanceof OnOffType) {\n-            OnOffType s = (OnOffType) command;\n-            if (s == OnOffType.OFF) {\n+            if (command == OnOffType.OFF) {\n                 if (snr != null) {\n                     qScene.execute(0, snr);\n                 } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3NTQ0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582975449", "bodyText": "As this is not a permanent error, you are good to log it only.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                thingOffline(\"Could not set setpoint for thermostat (convertion failed)  \" + thermostatId);\n          \n          \n            \n                                thingOffline(\"Could not set setpoint for thermostat (conversion failed)  \" + thermostatId);", "author": "fwolter", "createdAt": "2021-02-25T16:24:55Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusThermostat;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusThermostatHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer thermostatId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusThermostatHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        thermostatId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+            if (qThermostat != null) {\n+                qThermostat.setThingHandler(this);\n+                handleStateUpdate(qThermostat);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for thermostat \"\n+                            + thermostatId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+\n+            if (qThermostat == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \"\n+                                + thermostatId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Thermostat\", thermostatId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qThermostat);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_MODE:\n+                                handleModeCommand(qThermostat, command);\n+                                break;\n+\n+                            case CHANNEL_SETPOINT:\n+                                handleSetpointCommand(qThermostat, command);\n+                                break;\n+\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Puts thing offline\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the Mode command\n+     */\n+    private void handleModeCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof DecimalType) {\n+            int mode = ((DecimalType) command).intValue();\n+            if (snr != null) {\n+                qThermostat.executeMode(mode, snr);\n+            } else {\n+                thingOffline(\"No serial number configured for  \" + thermostatId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the Setpoint command\n+     */\n+    private void handleSetpointCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof QuantityType<?>) {\n+            QuantityType<?> s = (QuantityType<?>) command;\n+            double sp = s.doubleValue();\n+            QuantityType<?> spCelcius = s.toUnit(CELSIUS);\n+\n+            if (snr != null) {\n+                if (spCelcius != null) {\n+                    qThermostat.executeSetpoint(sp, snr);\n+                } else {\n+                    thingOffline(\"Could not set setpoint for thermostat (convertion failed)  \" + thermostatId);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\nindex 414312f349..0d90eb9b34 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java\n\n@@ -31,6 +31,8 @@ import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingStatus;\n import org.openhab.core.thing.ThingStatusDetail;\n import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3NzExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582977112", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-02-25T16:26:46Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f625ce8e48..7e63b8ff6d 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -195,7 +195,7 @@ public final class QbusCommunication extends BaseThingHandler {\n             startCommunication();\n         } catch (InterruptedException | IOException e) {\n             String message = e.toString();\n-            logger.error(\"Could not start the communication with the server. {}\", message);\n+            logger.debug(\"Could not start the communication with the server. {}\", message);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3ODIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582978218", "bodyText": "As sendMessage() already throws the InterruptedException, you could simply remove this catch clause.", "author": "fwolter", "createdAt": "2021-02-25T16:28:01Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (InterruptedException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f625ce8e48..7e63b8ff6d 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -195,7 +195,7 @@ public final class QbusCommunication extends BaseThingHandler {\n             startCommunication();\n         } catch (InterruptedException | IOException e) {\n             String message = e.toString();\n-            logger.error(\"Could not start the communication with the server. {}\", message);\n+            logger.debug(\"Could not start the communication with the server. {}\", message);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3ODg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582978868", "bodyText": "See above. Logging to error. Please check all.", "author": "fwolter", "createdAt": "2021-02-25T16:28:48Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (InterruptedException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            } catch (IOException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            }\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String ctd = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            ctd = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (handler != null) {\n+            sn = handler.getSn();\n+        }\n+\n+        if (sn != null && ctd != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(ctd) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListScenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdListCo2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdListRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdListRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmer(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     */\n+    @Override\n+    public void initialize() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (bridgeCallBack != null) {\n+            if (ctdConnected) {\n+                try {\n+                    sendAndReadMessage(\"getBistabiel\");\n+                    sendAndReadMessage(\"getScene\");\n+                    sendAndReadMessage(\"getDimmer\");\n+                    sendAndReadMessage(\"getRol02p\");\n+                    sendAndReadMessage(\"getRol02pSlat\");\n+                    sendAndReadMessage(\"getThermostat\");\n+                    sendAndReadMessage(\"getCo2\");\n+                } catch (IOException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);\n+                    }\n+                } catch (InterruptedException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f625ce8e48..7e63b8ff6d 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -195,7 +195,7 @@ public final class QbusCommunication extends BaseThingHandler {\n             startCommunication();\n         } catch (InterruptedException | IOException e) {\n             String message = e.toString();\n-            logger.error(\"Could not start the communication with the server. {}\", message);\n+            logger.debug(\"Could not start the communication with the server. {}\", message);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4MDM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582980383", "bodyText": "Please remove this empty line.", "author": "fwolter", "createdAt": "2021-02-25T16:30:34Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (InterruptedException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            } catch (IOException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            }\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String ctd = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            ctd = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (handler != null) {\n+            sn = handler.getSn();\n+        }\n+\n+        if (sn != null && ctd != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(ctd) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListScenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdListCo2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdListRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdListRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmer(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     */\n+    @Override\n+    public void initialize() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (bridgeCallBack != null) {\n+            if (ctdConnected) {\n+                try {\n+                    sendAndReadMessage(\"getBistabiel\");\n+                    sendAndReadMessage(\"getScene\");\n+                    sendAndReadMessage(\"getDimmer\");\n+                    sendAndReadMessage(\"getRol02p\");\n+                    sendAndReadMessage(\"getRol02pSlat\");\n+                    sendAndReadMessage(\"getThermostat\");\n+                    sendAndReadMessage(\"getCo2\");\n+                } catch (IOException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);\n+                    }\n+                } catch (InterruptedException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);\n+                    }\n+                }\n+\n+            } else {\n+                ctdConnected = false;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else\n+\n+        {", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex f625ce8e48..7e63b8ff6d 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -195,7 +195,7 @@ public final class QbusCommunication extends BaseThingHandler {\n             startCommunication();\n         } catch (InterruptedException | IOException e) {\n             String message = e.toString();\n-            logger.error(\"Could not start the communication with the server. {}\", message);\n+            logger.debug(\"Could not start the communication with the server. {}\", message);\n         }\n     }\n \n"}}, {"oid": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "url": "https://github.com/openhab/openhab-addons/commit/34536bd3cbeeeb8e309e5e68169682f2aea3765a", "message": "Updated requested changes\n\nUpdated changes reqeusted by fwolter on 25/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-02-25T17:46:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTg5ODU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585898545", "bodyText": "Does this make any sense?", "author": "fwolter", "createdAt": "2021-03-02T20:48:52Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer rolId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol != null) {\n+                qRol.setThingHandler(this);\n+                handleStateUpdate(qRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(qRol, command);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(qRol, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof UpDownType) {\n+            UpDownType upDown = (UpDownType) command;\n+            if (upDown == DOWN) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType) {\n+            IncreaseDecreaseType inc = (IncreaseDecreaseType) command;\n+            int stepValue = ((Number) this.getConfig().get(CONFIG_STEP_VALUE)).intValue();\n+            Integer currentValue = qRol.getState();\n+            int newValue;\n+            int sendValue;\n+            if (currentValue != null) {\n+                if (inc == IncreaseDecreaseType.INCREASE) {\n+                    newValue = currentValue + stepValue;\n+                    // round down to step multiple\n+                    newValue = newValue - newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                } else {\n+                    newValue = currentValue - stepValue;\n+                    // round up to step multiple\n+                    newValue = newValue + newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                }\n+            }\n+        } else if (command instanceof PercentType) {\n+            PercentType p = (PercentType) command;\n+            int pp = p.intValue();\n+            if (p == PercentType.ZERO) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(pp, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the command for screen slats position\n+     */\n+    private void handleSlatsposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof UpDownType) {\n+            if (command == DOWN) {\n+                if (snr != null) {\n+                    qRol.executeSlats(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.executeSlats(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType) {\n+            int stepValue = ((Number) this.getConfig().get(CONFIG_STEP_VALUE)).intValue();\n+            Integer currentValue = qRol.getState();\n+            int newValue;\n+            int sendValue;\n+            if (currentValue != null) {\n+                if (command == IncreaseDecreaseType.INCREASE) {\n+                    newValue = currentValue + stepValue;\n+                    // round down to step multiple\n+                    newValue = newValue - newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.executeSlats(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                } else {\n+                    newValue = currentValue - stepValue;\n+                    // round up to step multiple\n+                    newValue = newValue + newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.executeSlats(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                }\n+            }\n+        } else if (command instanceof PercentType) {\n+            int percentToInt = ((PercentType) command).intValue();\n+            if (command == PercentType.ZERO) {\n+                if (snr != null) {\n+                    qRol.executeSlats(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.executeSlats(percentToInt, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to update state of channel, called from Qbus Screen/Store.\n+     */\n+    public void handleStateUpdate(QbusRol qRol) {\n+        Integer rolState = qRol.getState();\n+        Integer slatState = qRol.getStateSlats();\n+\n+        if (rolState != null) {\n+            updateState(CHANNEL_ROLLERSHUTTER, new PercentType(rolState));\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        if (slatState != null) {\n+            updateState(CHANNEL_SLATS, new PercentType(slatState));\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    /**\n+     * Read the configuration\n+     */\n+    protected synchronized void setConfig() {\n+        final ScheduledFuture<?> localPollingJob = this.pollingJob;\n+\n+        if (localPollingJob != null) {\n+            localPollingJob.cancel(true);\n+        }\n+\n+        if (localPollingJob == null || localPollingJob.isCancelled()) {\n+            this.config = getConfig().as(QbusThingsConfig.class);\n+        }\n+        this.config = getConfig().as(QbusThingsConfig.class);", "originalCommit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\nindex 19eeebe9e3..0a1a532f11 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java\n\n@@ -16,8 +16,8 @@ import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n import static org.openhab.core.library.types.UpDownType.DOWN;\n import static org.openhab.core.types.RefreshType.REFRESH;\n \n+import java.io.IOException;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTg5OTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585899053", "bodyText": "Same here.", "author": "fwolter", "createdAt": "2021-03-02T20:49:40Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusScene;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusSceneHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusSceneHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer sceneId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusSceneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        sceneId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene != null) {\n+                qScene.setThingHandler(this);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Scene\", sceneId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SCENE:\n+                                handleSwitchCommand(qScene, channelUID, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to update state of channel, called from Qbus Scene.\n+     */\n+    public void handleStateUpdate(QbusScene qScene) {\n+        Integer sceneState = qScene.getState();\n+        if (sceneState != null) {\n+            updateState(CHANNEL_SCENE, (sceneState == 0) ? OnOffType.OFF : OnOffType.ON);\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the scene command\n+     */\n+    void handleSwitchCommand(QbusScene qScene, ChannelUID channelUID, Command command) {\n+        String snr = getSN();\n+        if (command instanceof OnOffType) {\n+            if (command == OnOffType.OFF) {\n+                if (snr != null) {\n+                    qScene.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + sceneId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qScene.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + sceneId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the configuration\n+     */\n+    protected synchronized void setConfig() {\n+        final ScheduledFuture<?> localPollingJob = this.pollingJob;\n+\n+        if (localPollingJob != null) {\n+            localPollingJob.cancel(true);\n+        }\n+\n+        if (localPollingJob == null || localPollingJob.isCancelled()) {\n+            this.config = getConfig().as(QbusThingsConfig.class);\n+        }\n+        this.config = getConfig().as(QbusThingsConfig.class);", "originalCommit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\nindex 88924a12b9..fc0381fd4a 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java\n\n@@ -14,8 +14,8 @@ package org.openhab.binding.qbus.internal.handler;\n \n import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n \n+import java.io.IOException;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMTY3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585901670", "bodyText": "initialize() must return fast. As this will call some network code, you need to execute it asynchronously e.g. via scheduler.submit().", "author": "fwolter", "createdAt": "2021-03-02T20:54:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,943 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.debug(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (IOException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            }\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String ctd = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            ctd = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (handler != null) {\n+            sn = handler.getSn();\n+        }\n+\n+        if (sn != null && ctd != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(ctd) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListScenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdListCo2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdListRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdListRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmer(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     */\n+    @Override\n+    public void initialize() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (bridgeCallBack != null) {\n+            if (ctdConnected) {\n+                try {\n+                    sendAndReadMessage(\"getBistabiel\");", "originalCommit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex 7e63b8ff6d..6df9d47d87 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -18,6 +18,7 @@ import java.io.InputStreamReader;\n import java.io.PrintWriter;\n import java.net.InetAddress;\n import java.net.Socket;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"oid": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "url": "https://github.com/openhab/openhab-addons/commit/0c551c6032d6cdfe42d7ae84e2289b196b157159", "message": "Updated requested changes\n\nUpdated  changes as requested by fwolter on 2/3/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-03-23T09:49:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602728128", "bodyText": "initialize() must return fast. As name resolution can block, it should be executed asynchronously via the scheduler. Keep in mind that name resolution errors can be temporary. The Thing will stay OFFLINE if the name resolution recovers. You could remove the check here at all.", "author": "fwolter", "createdAt": "2021-03-27T14:48:47Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration bridgeConfig = new QbusConfiguration();\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer serverCheck = getServerCheck();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgzMTI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602831284", "bodyText": "Thanks for pointing this out. I removed port and addr as they are set in the communications object.", "author": "QbusKoen", "createdAt": "2021-03-28T04:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "9b408aeed71b6a091c62f2cf9f97192444311aea", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\nindex 30d12112ae..2f625669ae 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java\n\n@@ -14,8 +14,6 @@\n package org.openhab.binding.qbus.internal;\n \n import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602728933", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2021-03-27T14:57:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusCO2Handler;\n+\n+/**\n+ * The {@link QbusCO2} class represents the action Qbus CO2 output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCO2 {\n+\n+    private @Nullable Integer state;\n+\n+    private @Nullable QbusCO2Handler thingHandler;\n+\n+    QbusCO2() {\n+    }", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b408aeed71b6a091c62f2cf9f97192444311aea", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java\nindex 9c3276a31e..88d0f40492 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java\n\n@@ -30,9 +30,6 @@ public final class QbusCO2 {\n \n     private @Nullable QbusCO2Handler thingHandler;\n \n-    QbusCO2() {\n-    }\n-\n     /**\n      * This method should be called if the ThingHandler for the thing corresponding to this CO2 is initialized.\n      * It keeps a record of the thing handler in this object so the thing can be updated when\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODk3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602728976", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2021-03-27T14:57:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusCO2Handler;\n+\n+/**\n+ * The {@link QbusCO2} class represents the action Qbus CO2 output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCO2 {\n+\n+    private @Nullable Integer state;\n+\n+    private @Nullable QbusCO2Handler thingHandler;\n+\n+    QbusCO2() {\n+    }\n+\n+    /**\n+     * This method should be called if the ThingHandler for the thing corresponding to this CO2 is initialized.\n+     * It keeps a record of the thing handler in this object so the thing can be updated when\n+     * the CO2 output receives an update from the Qbus IP-interface.\n+     *\n+     * @param handler\n+     */\n+    public void setThingHandler(QbusCO2Handler handler) {\n+        this.thingHandler = handler;\n+    }\n+\n+    /**\n+     * This method sets a pointer to the qComm CO2 of class {@link QbusCommuncation}.\n+     * This is then used to be able to call back the sendCommand method in this class to send a command to the\n+     * Qbus client.\n+     *\n+     * @param qComm\n+     */\n+    // public void setQComm(QbusCommunication qComm) {\n+    // this.qComm = qComm;\n+    // }", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b408aeed71b6a091c62f2cf9f97192444311aea", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java\nindex 9c3276a31e..88d0f40492 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java\n\n@@ -30,9 +30,6 @@ public final class QbusCO2 {\n \n     private @Nullable QbusCO2Handler thingHandler;\n \n-    QbusCO2() {\n-    }\n-\n     /**\n      * This method should be called if the ThingHandler for the thing corresponding to this CO2 is initialized.\n      * It keeps a record of the thing handler in this object so the thing can be updated when\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyOTAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602729035", "bodyText": "Please move the constructor below the fields.", "author": "fwolter", "createdAt": "2021-03-27T14:57:44Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * CTD controllers:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9b408aeed71b6a091c62f2cf9f97192444311aea", "chunk": "diff --git a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\nindex 6df9d47d87..e07032d2eb 100644\n--- a/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n+++ b/bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java\n\n@@ -60,13 +60,6 @@ import com.google.gson.JsonParseException;\n @NonNullByDefault\n public final class QbusCommunication extends BaseThingHandler {\n \n-    public QbusCommunication(Thing thing) {\n-        super(thing);\n-        GsonBuilder gsonBuilder = new GsonBuilder();\n-        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n-        gsonIn = gsonBuilder.create();\n-    }\n-\n     private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n \n     private @Nullable Socket qSocket;\n"}}, {"oid": "9b408aeed71b6a091c62f2cf9f97192444311aea", "url": "https://github.com/openhab/openhab-addons/commit/9b408aeed71b6a091c62f2cf9f97192444311aea", "message": "Update requested changes\n\nUpdates changes as requested by FWolter on 27/03/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-03-28T05:00:24Z", "type": "commit"}, {"oid": "ce4611214a7bb812a678120f6e8f1a7f472e5d7c", "url": "https://github.com/openhab/openhab-addons/commit/ce4611214a7bb812a678120f6e8f1a7f472e5d7c", "message": "Update thing-types.xml\n\nUpdate requested  as suggested by FWolter on 28/03/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-03-28T11:47:03Z", "type": "commit"}]}