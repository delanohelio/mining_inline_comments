{"pr_number": 6814, "pr_title": "[danfossairunit] Danfoss AirUnit binding - initial commit", "pr_createdAt": "2020-01-12T02:28:00Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMTM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385911387", "bodyText": "I would cache the hrv variable locally so that you don't need to do this assertion check.", "author": "cpmeister", "createdAt": "2020-02-28T20:38:39Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex 8cb7d45e41..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMjc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385912757", "bodyText": "Please specify specific checked exceptions if possible, if not possible just catch RuntimeException", "author": "cpmeister", "createdAt": "2020-02-28T20:42:21Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            } finally {\n+                hrv.disconnect();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossHRV(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                hrv.connect();\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                hrv.disconnect();\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            hrv.connect();\n+\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(assertNonNull(hrv)));\n+                } catch (Exception e) {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex 8cb7d45e41..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxMzgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385913815", "bodyText": "I would synchronize all hrv.connect()...hrv.disconnect() logic to prevent nasty multithreaded issues.", "author": "cpmeister", "createdAt": "2020-02-28T20:45:11Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(assertNonNull(hrv), command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            } finally {\n+                hrv.disconnect();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossHRV(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                hrv.connect();\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                hrv.disconnect();", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex 8cb7d45e41..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNDMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385914303", "bodyText": "Do your TODO", "author": "cpmeister", "createdAt": "2020-02-28T20:46:27Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nsimilarity index 64%\nrename from bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\nrename to bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex 9d8c054a26..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -13,103 +13,50 @@\n package org.openhab.binding.danfossairunit.internal;\n \n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.RoundingMode;\n import java.net.InetAddress;\n-import java.net.Socket;\n-import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n import java.time.DateTimeException;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n- * The {@link DanfossHRV} class does the actual network communication with the air unit.\n- *\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n+@SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossHRV implements Commands {\n-\n-    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n-\n-    private InetAddress inetAddr;\n-    private int port;\n-    private @Nullable Socket socket;\n-    private @Nullable OutputStream oStream;\n-    private @Nullable InputStream iStream;\n+public class DanfossAirUnit {\n \n-    public DanfossHRV(InetAddress inetAddr, int port) {\n-        this.inetAddr = inetAddr;\n-        this.port = port;\n-    }\n-\n-    public void connect() throws IOException {\n-        socket = new Socket(inetAddr, port);\n-        oStream = socket.getOutputStream();\n-        iStream = socket.getInputStream();\n-    }\n+    private final DanfossAirUnitCommunicationController communicationController;\n \n-    public void disconnect() {\n-        try {\n-            if (socket != null) {\n-                socket.close();\n-                socket = null;\n-                iStream = null;\n-                oStream = null;\n-            }\n-\n-        } catch (IOException ioe) {\n-            // TODO: handle exception\n-        }\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n     }\n \n-    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register, EMPTY);\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n-        if (socket == null) {\n-            throw new DisconnectedException();\n-        }\n-        byte[] request = new byte[4 + value.length];\n-        System.arraycopy(operation, 0, request, 0, 2);\n-        System.arraycopy(register, 0, request, 2, 2);\n-        System.arraycopy(value, 0, request, 4, value.length);\n-\n-        try {\n-            return sendRequest(request);\n-        } catch (IOException exIo) {\n-            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n-            connect();\n-            return sendRequest(request);\n-        }\n-    }\n-\n-    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n-\n-        oStream.write(request);\n-        oStream.flush();\n-\n-        byte[] result = new byte[63];\n-        iStream.read(result, 0, 63);\n-\n-        return result;\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n     }\n \n     private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register)[0] != 0;\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n     }\n \n     private void setSetting(byte[] register, boolean value) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTM1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385915356", "bodyText": "ByteBuffer should not be used for something so trivial. Please write this logic without using ByteBuffer.", "author": "cpmeister", "createdAt": "2020-02-28T20:49:05Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception\n+        }\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        if (socket == null) {\n+            throw new DisconnectedException();\n+        }\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+\n+        try {\n+            return sendRequest(request);\n+        } catch (IOException exIo) {\n+            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n+            connect();\n+            return sendRequest(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n+\n+        oStream.write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        iStream.read(result, 0, 63);\n+\n+        return result;\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = sendRobustRequest(operation, register);\n+        return ByteBuffer.wrap(new byte[] { resultBytes[0], resultBytes[1] }).getShort();", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nsimilarity index 64%\nrename from bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\nrename to bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex 9d8c054a26..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -13,103 +13,50 @@\n package org.openhab.binding.danfossairunit.internal;\n \n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.RoundingMode;\n import java.net.InetAddress;\n-import java.net.Socket;\n-import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n import java.time.DateTimeException;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n- * The {@link DanfossHRV} class does the actual network communication with the air unit.\n- *\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n+@SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossHRV implements Commands {\n-\n-    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n-\n-    private InetAddress inetAddr;\n-    private int port;\n-    private @Nullable Socket socket;\n-    private @Nullable OutputStream oStream;\n-    private @Nullable InputStream iStream;\n+public class DanfossAirUnit {\n \n-    public DanfossHRV(InetAddress inetAddr, int port) {\n-        this.inetAddr = inetAddr;\n-        this.port = port;\n-    }\n-\n-    public void connect() throws IOException {\n-        socket = new Socket(inetAddr, port);\n-        oStream = socket.getOutputStream();\n-        iStream = socket.getInputStream();\n-    }\n+    private final DanfossAirUnitCommunicationController communicationController;\n \n-    public void disconnect() {\n-        try {\n-            if (socket != null) {\n-                socket.close();\n-                socket = null;\n-                iStream = null;\n-                oStream = null;\n-            }\n-\n-        } catch (IOException ioe) {\n-            // TODO: handle exception\n-        }\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n     }\n \n-    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register, EMPTY);\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n-        if (socket == null) {\n-            throw new DisconnectedException();\n-        }\n-        byte[] request = new byte[4 + value.length];\n-        System.arraycopy(operation, 0, request, 0, 2);\n-        System.arraycopy(register, 0, request, 2, 2);\n-        System.arraycopy(value, 0, request, 4, value.length);\n-\n-        try {\n-            return sendRequest(request);\n-        } catch (IOException exIo) {\n-            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n-            connect();\n-            return sendRequest(request);\n-        }\n-    }\n-\n-    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n-\n-        oStream.write(request);\n-        oStream.flush();\n-\n-        byte[] result = new byte[63];\n-        iStream.read(result, 0, 63);\n-\n-        return result;\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n     }\n \n     private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register)[0] != 0;\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n     }\n \n     private void setSetting(byte[] register, boolean value) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTQ3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385915471", "bodyText": "see comment above", "author": "cpmeister", "createdAt": "2020-02-28T20:49:25Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+                socket = null;\n+                iStream = null;\n+                oStream = null;\n+            }\n+\n+        } catch (IOException ioe) {\n+            // TODO: handle exception\n+        }\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        if (socket == null) {\n+            throw new DisconnectedException();\n+        }\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+\n+        try {\n+            return sendRequest(request);\n+        } catch (IOException exIo) {\n+            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n+            connect();\n+            return sendRequest(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n+\n+        oStream.write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        iStream.read(result, 0, 63);\n+\n+        return result;\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = sendRobustRequest(operation, register);\n+        return ByteBuffer.wrap(new byte[] { resultBytes[0], resultBytes[1] }).getShort();\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        ByteBuffer byteBuffer = ByteBuffer.allocate(2);\n+        byteBuffer.putShort(value);\n+        sendRobustRequest(operation, register, byteBuffer.array());", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nsimilarity index 64%\nrename from bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\nrename to bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex 9d8c054a26..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -13,103 +13,50 @@\n package org.openhab.binding.danfossairunit.internal;\n \n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.RoundingMode;\n import java.net.InetAddress;\n-import java.net.Socket;\n-import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n import java.time.DateTimeException;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n- * The {@link DanfossHRV} class does the actual network communication with the air unit.\n- *\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n+@SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossHRV implements Commands {\n-\n-    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n-\n-    private InetAddress inetAddr;\n-    private int port;\n-    private @Nullable Socket socket;\n-    private @Nullable OutputStream oStream;\n-    private @Nullable InputStream iStream;\n+public class DanfossAirUnit {\n \n-    public DanfossHRV(InetAddress inetAddr, int port) {\n-        this.inetAddr = inetAddr;\n-        this.port = port;\n-    }\n-\n-    public void connect() throws IOException {\n-        socket = new Socket(inetAddr, port);\n-        oStream = socket.getOutputStream();\n-        iStream = socket.getInputStream();\n-    }\n+    private final DanfossAirUnitCommunicationController communicationController;\n \n-    public void disconnect() {\n-        try {\n-            if (socket != null) {\n-                socket.close();\n-                socket = null;\n-                iStream = null;\n-                oStream = null;\n-            }\n-\n-        } catch (IOException ioe) {\n-            // TODO: handle exception\n-        }\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n     }\n \n-    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register, EMPTY);\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n-        if (socket == null) {\n-            throw new DisconnectedException();\n-        }\n-        byte[] request = new byte[4 + value.length];\n-        System.arraycopy(operation, 0, request, 0, 2);\n-        System.arraycopy(register, 0, request, 2, 2);\n-        System.arraycopy(value, 0, request, 4, value.length);\n-\n-        try {\n-            return sendRequest(request);\n-        } catch (IOException exIo) {\n-            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n-            connect();\n-            return sendRequest(request);\n-        }\n-    }\n-\n-    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n-\n-        oStream.write(request);\n-        oStream.flush();\n-\n-        byte[] result = new byte[63];\n-        iStream.read(result, 0, 63);\n-\n-        return result;\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n     }\n \n     private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register)[0] != 0;\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n     }\n \n     private void setSetting(byte[] register, boolean value) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyMjgwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385922800", "bodyText": "Rather than implementing your own cache. I would recommend using the one that already comes with the OH core.\nYou can find details here", "author": "cpmeister", "createdAt": "2020-02-28T21:08:22Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ValueCache.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.types.State;\n+\n+/**\n+ * The {@link ValueCache} is responsible for holding the last value of the channels for a\n+ * certain amount of time {@link ValueCache#durationMs} to prevent unnecessary event bus updates if the value didn't\n+ * change.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ValueCache {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYxNzM2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390617366", "bodyText": "I think you might have missed this suggestion from my first review so I'll copy it here:\nRather than implementing your own cache. I would recommend using the one that already comes with the OH core.\nYou can find details here\nThe class I think would be most relevant to you would be org.eclipse.smarthome.core.cache.ExpiringCacheMap.", "author": "cpmeister", "createdAt": "2020-03-10T21:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyMjgwMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNTAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385925010", "bodyText": "Do you mean this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(host)\n          \n          \n            \n                            DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"host\")", "author": "cpmeister", "createdAt": "2020-02-28T21:14:19Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Disover message sent\");\n+\n+        // wait for responses\n+        while (true) {\n+            byte[] receiveBuffer = new byte[7];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+            try {\n+                socket.receive(receivePacket);\n+            } catch (SocketTimeoutException e) {\n+                break; // leave the endless loop\n+            }\n+\n+            byte[] data = receivePacket.getData();\n+            if (Arrays.equals(data, DISCOVER_RECEIVE)) {\n+                logger.debug(\"Disover received correct response\");\n+\n+                String host = receivePacket.getAddress().getHostName();\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(\"host\", host);\n+\n+                logger.debug(\"Adding a new Danfoss Air Unit CCM '{}' to inbox\", host);\n+\n+                ThingUID uid = new ThingUID(THING_TYPE_AIRUNIT, String.valueOf(receivePacket.getAddress().hashCode()));\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(host)", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\nindex 32a5d7fcf1..92c70bbc15 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n\n@@ -22,7 +22,6 @@ import java.net.InterfaceAddress;\n import java.net.NetworkInterface;\n import java.net.SocketTimeoutException;\n import java.util.*;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937089", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IllegalArgumentException instead.", "author": "cpmeister", "createdAt": "2020-02-28T21:45:46Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidDateTimeException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * An Exception thrown when a value received from the air unit cannot be interpreted as DateTime value.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InvalidDateTimeException extends RuntimeException {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidDateTimeException.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidDateTimeException.java\ndeleted file mode 100644\nindex 1a65dfd8ba..0000000000\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidDateTimeException.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.danfossairunit.internal;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-\n-/**\n- * An Exception thrown when a value received from the air unit cannot be interpreted as DateTime value.\n- *\n- * @author Robert Bach - Initial contribution\n- */\n-@NonNullByDefault\n-public class InvalidDateTimeException extends RuntimeException {\n-    public InvalidDateTimeException() {\n-    }\n-\n-    public InvalidDateTimeException(String message) {\n-        super(message);\n-    }\n-\n-    public InvalidDateTimeException(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-\n-    public InvalidDateTimeException(Throwable cause) {\n-        super(cause);\n-    }\n-\n-    public InvalidDateTimeException(String message, Throwable cause, boolean enableSuppression,\n-            boolean writableStackTrace) {\n-        super(message, cause, enableSuppression, writableStackTrace);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzM5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937399", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IllegalArgumentException instead.", "author": "cpmeister", "createdAt": "2020-02-28T21:46:38Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidTemperatureException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * An Exception thrown when a value received from the air unit cannot be interpreted as temperature value.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class InvalidTemperatureException extends RuntimeException {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidTemperatureException.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidTemperatureException.java\ndeleted file mode 100644\nindex d12d603c47..0000000000\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/InvalidTemperatureException.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.danfossairunit.internal;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-\n-/**\n- * An Exception thrown when a value received from the air unit cannot be interpreted as temperature value.\n- *\n- * @author Robert Bach - Initial contribution\n- */\n-@NonNullByDefault\n-public class InvalidTemperatureException extends RuntimeException {\n-    public InvalidTemperatureException() {\n-    }\n-\n-    public InvalidTemperatureException(String message) {\n-        super(message);\n-    }\n-\n-    public InvalidTemperatureException(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-\n-    public InvalidTemperatureException(Throwable cause) {\n-        super(cause);\n-    }\n-\n-    public InvalidTemperatureException(String message, Throwable cause, boolean enableSuppression,\n-            boolean writableStackTrace) {\n-        super(message, cause, enableSuppression, writableStackTrace);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzY2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r385937661", "bodyText": "This type of Exception isn't handled in any special way in the rest of the code. I would suggest using an IOException instead.", "author": "cpmeister", "createdAt": "2020-02-28T21:47:24Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents a communication failure with the air unit when it has not been connected.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DisconnectedException extends RuntimeException {", "originalCommit": "ad93709e77a6687e32c3a9cdab3d8e74b61979c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjEyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392127", "bodyText": "This exception isn't used anywhere now, please delete this class", "author": "cpmeister", "createdAt": "2020-03-08T18:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzY2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/UnexpectedResponseValueException.java\nsimilarity index 51%\nrename from bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java\nrename to bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/UnexpectedResponseValueException.java\nindex ead737a2cf..136b6a5970 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DisconnectedException.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/UnexpectedResponseValueException.java\n\n@@ -15,29 +15,20 @@ package org.openhab.binding.danfossairunit.internal;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n \n /**\n- * Represents a communication failure with the air unit when it has not been connected.\n+ * An exception representing an unexpected value received from the air unit.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n @NonNullByDefault\n-public class DisconnectedException extends RuntimeException {\n-    public DisconnectedException() {\n-    }\n+public class UnexpectedResponseValueException extends Exception {\n+\n+    private static final long serialVersionUID = -5727747058755880978L;\n \n-    public DisconnectedException(String message) {\n+    public UnexpectedResponseValueException(String message) {\n         super(message);\n     }\n \n-    public DisconnectedException(String message, Throwable cause) {\n+    public UnexpectedResponseValueException(String message, Throwable cause) {\n         super(message, cause);\n     }\n-\n-    public DisconnectedException(Throwable cause) {\n-        super(cause);\n-    }\n-\n-    public DisconnectedException(String message, Throwable cause, boolean enableSuppression,\n-            boolean writableStackTrace) {\n-        super(message, cause, enableSuppression, writableStackTrace);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208596", "bodyText": "Please make these fields private and final", "author": "cpmeister", "createdAt": "2020-03-07T00:53:40Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\nindex 02a728be8c..6664d46ef8 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\n\n@@ -12,48 +12,55 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n /**\n  * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n  * the corresponding values on the air unit.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum Channel {\n \n     // Main Channels\n \n-    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n-    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n-    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n-            DanfossHRV::setManualFanSpeed),\n-    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n-    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossAirUnit::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossAirUnit::getMode, DanfossAirUnit::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getManualFanSpeed,\n+            DanfossAirUnit::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getSupplyFanSpeed),\n+    CHANNEL_EXTRACT_FAN_STEP(\"extract_fan_step\", ChannelGroup.MAIN, DanfossAirUnit::getExtractFanStep),\n+    CHANNEL_SUPPLY_FAN_STEP(\"supply_fan_step\", ChannelGroup.MAIN, DanfossAirUnit::getSupplyFanStep),\n \n-    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n-    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossAirUnit::getBoost, DanfossAirUnit::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossAirUnit::getNightCooling, DanfossAirUnit::setNightCooling),\n \n     // Main Temperature Channels\n-    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n-    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n-    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossAirUnit::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossAirUnit::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossAirUnit::getOutdoorTemperature),\n \n     // Humidity Channel\n-    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossAirUnit::getHumidity),\n \n     // recuperator channels\n-    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n-    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n-    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n-    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getBypass, DanfossAirUnit::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getExhaustTemperature),\n \n     // service channels\n-    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n-    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossAirUnit::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossAirUnit::getFilterLife);\n \n-    String channelName;\n-    ChannelGroup group;\n-    DanfossAirUnitReadAccessor readAccessor;\n-    DanfossAirUnitWriteAccessor writeAccessor = null;\n+    private final String channelName;\n+    private final ChannelGroup group;\n+    private final DanfossAirUnitReadAccessor readAccessor;\n+    @Nullable\n+    private final DanfossAirUnitWriteAccessor writeAccessor;\n \n     static Channel getByName(String name) {\n         for (Channel channel : values()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {\n          \n          \n            \n                private Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {", "author": "cpmeister", "createdAt": "2020-03-07T00:54:02Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;\n+\n+    static Channel getByName(String name) {\n+        for (Channel channel : values()) {\n+            if (channel.getChannelName().equals(name)) {\n+                return channel;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Unknown channel name: %s\", name));\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250010", "bodyText": "Enum constructors are always private and thus this redundant.", "author": "pravussum", "createdAt": "2020-03-07T12:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\nindex 02a728be8c..6664d46ef8 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\n\n@@ -12,48 +12,55 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n /**\n  * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n  * the corresponding values on the air unit.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum Channel {\n \n     // Main Channels\n \n-    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n-    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n-    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n-            DanfossHRV::setManualFanSpeed),\n-    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n-    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossAirUnit::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossAirUnit::getMode, DanfossAirUnit::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getManualFanSpeed,\n+            DanfossAirUnit::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getSupplyFanSpeed),\n+    CHANNEL_EXTRACT_FAN_STEP(\"extract_fan_step\", ChannelGroup.MAIN, DanfossAirUnit::getExtractFanStep),\n+    CHANNEL_SUPPLY_FAN_STEP(\"supply_fan_step\", ChannelGroup.MAIN, DanfossAirUnit::getSupplyFanStep),\n \n-    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n-    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossAirUnit::getBoost, DanfossAirUnit::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossAirUnit::getNightCooling, DanfossAirUnit::setNightCooling),\n \n     // Main Temperature Channels\n-    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n-    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n-    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossAirUnit::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossAirUnit::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossAirUnit::getOutdoorTemperature),\n \n     // Humidity Channel\n-    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossAirUnit::getHumidity),\n \n     // recuperator channels\n-    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n-    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n-    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n-    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getBypass, DanfossAirUnit::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getExhaustTemperature),\n \n     // service channels\n-    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n-    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossAirUnit::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossAirUnit::getFilterLife);\n \n-    String channelName;\n-    ChannelGroup group;\n-    DanfossAirUnitReadAccessor readAccessor;\n-    DanfossAirUnitWriteAccessor writeAccessor = null;\n+    private final String channelName;\n+    private final ChannelGroup group;\n+    private final DanfossAirUnitReadAccessor readAccessor;\n+    @Nullable\n+    private final DanfossAirUnitWriteAccessor writeAccessor;\n \n     static Channel getByName(String name) {\n         for (Channel channel : values()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208665", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,\n          \n          \n            \n                private Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,", "author": "cpmeister", "createdAt": "2020-03-07T00:54:12Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n+ * the corresponding values on the air unit.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Channel {\n+\n+    // Main Channels\n+\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n+            DanfossHRV::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+\n+    // Main Temperature Channels\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+\n+    // Humidity Channel\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+\n+    // recuperator channels\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+\n+    // service channels\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+\n+    String channelName;\n+    ChannelGroup group;\n+    DanfossAirUnitReadAccessor readAccessor;\n+    DanfossAirUnitWriteAccessor writeAccessor = null;\n+\n+    static Channel getByName(String name) {\n+        for (Channel channel : values()) {\n+            if (channel.getChannelName().equals(name)) {\n+                return channel;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.format(\"Unknown channel name: %s\", name));\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor) {\n+        this.channelName = channelName;\n+        this.group = group;\n+        this.readAccessor = readAccessor;\n+    }\n+\n+    Channel(String channelName, ChannelGroup group, DanfossAirUnitReadAccessor readAccessor,", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250089", "bodyText": "Enum constructors are always private, thus this is redundant (even a warning in IntelliJ)", "author": "pravussum", "createdAt": "2020-03-07T12:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\nindex 02a728be8c..6664d46ef8 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Channel.java\n\n@@ -12,48 +12,55 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n /**\n  * This enum holds the available channels with their properties (name, ...) and read/write accessors to access\n  * the corresponding values on the air unit.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum Channel {\n \n     // Main Channels\n \n-    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossHRV::getCurrentTime),\n-    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossHRV::getMode, DanfossHRV::setMode),\n-    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getManualFanSpeed,\n-            DanfossHRV::setManualFanSpeed),\n-    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getExtractFanSpeed),\n-    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossHRV::getSupplyFanSpeed),\n+    CHANNEL_CURRENT_TIME(\"current_time\", ChannelGroup.MAIN, DanfossAirUnit::getCurrentTime),\n+    CHANNEL_MODE(\"mode\", ChannelGroup.MAIN, DanfossAirUnit::getMode, DanfossAirUnit::setMode),\n+    CHANNEL_MANUAL_FAN_SPEED(\"manual_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getManualFanSpeed,\n+            DanfossAirUnit::setManualFanSpeed),\n+    CHANNEL_EXTRACT_FAN_SPEED(\"extract_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getExtractFanSpeed),\n+    CHANNEL_SUPPLY_FAN_SPEED(\"supply_fan_speed\", ChannelGroup.MAIN, DanfossAirUnit::getSupplyFanSpeed),\n+    CHANNEL_EXTRACT_FAN_STEP(\"extract_fan_step\", ChannelGroup.MAIN, DanfossAirUnit::getExtractFanStep),\n+    CHANNEL_SUPPLY_FAN_STEP(\"supply_fan_step\", ChannelGroup.MAIN, DanfossAirUnit::getSupplyFanStep),\n \n-    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossHRV::getBoost, DanfossHRV::setBoost),\n-    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossHRV::getNightCooling, DanfossHRV::setNightCooling),\n+    CHANNEL_BOOST(\"boost\", ChannelGroup.MAIN, DanfossAirUnit::getBoost, DanfossAirUnit::setBoost),\n+    CHANNEL_NIGHT_COOLING(\"night_cooling\", ChannelGroup.MAIN, DanfossAirUnit::getNightCooling, DanfossAirUnit::setNightCooling),\n \n     // Main Temperature Channels\n-    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperature),\n-    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossHRV::getRoomTemperatureCalculated),\n-    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossHRV::getOutdoorTemperature),\n+    CHANNEL_ROOM_TEMP(\"room_temp\", ChannelGroup.TEMPS, DanfossAirUnit::getRoomTemperature),\n+    CHANNEL_ROOM_TEMP_CALCULATED(\"room_temp_calculated\", ChannelGroup.TEMPS, DanfossAirUnit::getRoomTemperatureCalculated),\n+    CHANNEL_OUTDOOR_TEMP(\"outdoor_temp\", ChannelGroup.TEMPS, DanfossAirUnit::getOutdoorTemperature),\n \n     // Humidity Channel\n-    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossHRV::getHumidity),\n+    CHANNEL_HUMIDITY(\"humidity\", ChannelGroup.HUMIDITY, DanfossAirUnit::getHumidity),\n \n     // recuperator channels\n-    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossHRV::getBypass, DanfossHRV::setBypass),\n-    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getSupplyTemperature),\n-    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExtractTemperature),\n-    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossHRV::getExhaustTemperature),\n+    CHANNEL_BYPASS(\"bypass\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getBypass, DanfossAirUnit::setBypass),\n+    CHANNEL_SUPPLY_TEMP(\"supply_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getSupplyTemperature),\n+    CHANNEL_EXTRACT_TEMP(\"extract_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getExtractTemperature),\n+    CHANNEL_EXHAUST_TEMP(\"exhaust_temp\", ChannelGroup.RECUPERATOR, DanfossAirUnit::getExhaustTemperature),\n \n     // service channels\n-    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossHRV::getBatteryLife),\n-    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossHRV::getFilterLife);\n+    CHANNEL_BATTERY_LIFE(\"battery_life\", ChannelGroup.SERVICE, DanfossAirUnit::getBatteryLife),\n+    CHANNEL_FILTER_LIFE(\"filter_life\", ChannelGroup.SERVICE, DanfossAirUnit::getFilterLife);\n \n-    String channelName;\n-    ChannelGroup group;\n-    DanfossAirUnitReadAccessor readAccessor;\n-    DanfossAirUnitWriteAccessor writeAccessor = null;\n+    private final String channelName;\n+    private final ChannelGroup group;\n+    private final DanfossAirUnitReadAccessor readAccessor;\n+    @Nullable\n+    private final DanfossAirUnitWriteAccessor writeAccessor;\n \n     static Channel getByName(String name) {\n         for (Channel channel : values()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389208749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ChannelGroup(String groupName) {\n          \n          \n            \n                private ChannelGroup(String groupName) {", "author": "cpmeister", "createdAt": "2020-03-07T00:54:33Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    ChannelGroup(String groupName) {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\nindex 3e4c5faa7f..c31e9f1823 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n /**\n  * Represents a channel group, channels are divided into.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum ChannelGroup {\n     MAIN(\"main\"),\n     TEMPS(\"temps\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTk2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389209969", "bodyText": "IOException shouldn't be ignored, you should log it at the very least.", "author": "cpmeister", "createdAt": "2020-03-07T01:02:26Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+    }\n+\n+    public synchronized void disconnect() {\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ignore) {\n+        } finally {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nsimilarity index 65%\nrename from bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\nrename to bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex c6d40a236b..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -13,101 +13,50 @@\n package org.openhab.binding.danfossairunit.internal;\n \n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.RoundingMode;\n import java.net.InetAddress;\n-import java.net.Socket;\n import java.nio.charset.StandardCharsets;\n import java.time.DateTimeException;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n- * The {@link DanfossHRV} class does the actual network communication with the air unit.\n- *\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n+@SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossHRV implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n \n-    private InetAddress inetAddr;\n-    private int port;\n-    private @Nullable Socket socket;\n-    private @Nullable OutputStream oStream;\n-    private @Nullable InputStream iStream;\n-\n-    public DanfossHRV(InetAddress inetAddr, int port) {\n-        this.inetAddr = inetAddr;\n-        this.port = port;\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n     }\n \n-    public synchronized void connect() throws IOException {\n-        socket = new Socket(inetAddr, port);\n-        oStream = socket.getOutputStream();\n-        iStream = socket.getInputStream();\n-    }\n-\n-    public synchronized void disconnect() {\n-        try {\n-            if (socket != null) {\n-                socket.close();\n-            }\n-        } catch (IOException ignore) {\n-        } finally {\n-            socket = null;\n-            iStream = null;\n-            oStream = null;\n-        }\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register, EMPTY);\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n-        if (socket == null) {\n-            throw new IOException(\"Air unit not connected.\");\n-        }\n-        byte[] request = new byte[4 + value.length];\n-        System.arraycopy(operation, 0, request, 0, 2);\n-        System.arraycopy(register, 0, request, 2, 2);\n-        System.arraycopy(value, 0, request, 4, value.length);\n-\n-        try {\n-            return sendRequest(request);\n-        } catch (IOException exIo) {\n-            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n-            connect();\n-            return sendRequest(request);\n-        }\n-    }\n-\n-    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n-\n-        oStream.write(request);\n-        oStream.flush();\n-\n-        byte[] result = new byte[63];\n-        iStream.read(result, 0, 63);\n-\n-        return result;\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n     }\n \n     private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register)[0] != 0;\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n     }\n \n     private void setSetting(byte[] register, boolean value) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389211134", "bodyText": "What are you expecting to throw this?", "author": "cpmeister", "createdAt": "2020-03-07T01:10:49Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossHRV hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            if (hrv == null) {\n+                return;\n+            }\n+            try {\n+                DanfossHRV danfossHRV = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                hrv.connect();\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossHRV, command));\n+                }\n+            } catch (IllegalArgumentException e) {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250796", "bodyText": "I had this kind of exceptions in the past (probably due to concurrency issues as I know now), but I'd like to keep that in place to gracefully handle any communication problems in the \"right place\". The exception is originally thrown in sendRequest() method (former DanfossHRV class, now DanfossAirUnitCommunicationController).", "author": "pravussum", "createdAt": "2020-03-07T12:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex 4c2f5b76cc..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzA5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389213090", "bodyText": "\ud83e\udd26\u200d\u2642 This isn't what I meant by synchronizing connect()...disconnect() logic. I will elaborate on what I meant.\nRight now all of your communication logic happens in short bursts: connect->send/receive messages -> disconnect.\nThe issue I'm trying to point out is what happens when, lets say, a RefreshCommand and a your scheduled updateAllChannels() happen at the same time? Whichever one calls connect() first will have its socket instance overwritten by the second call to connect(), this will cause a number of problems depending on when the second call occurs. The most important problem is that if you overwrite the socket instance before closing it, it will never get closed! In the worst case this could eventually lead to crashing either openhab or the airunit you are talking to.", "author": "cpmeister", "createdAt": "2020-03-07T01:25:35Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossHRV} class does the actual network communication with the air unit.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@NonNullByDefault\n+public class DanfossHRV implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+\n+    private InetAddress inetAddr;\n+    private int port;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossHRV(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {", "originalCommit": "80f84c03c034dcb4c1f7a3571d06df1b43a2e71e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1MDY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389250644", "bodyText": "Ah ok, got your point. Very good one indeed. I refactored the whole connection & request handling to encapsulate it in one class (which is used by the the scheduled job and the updateChannel method in turn). The connect & disconnect & request methods are synchronized.\nA broken connection will block one of the scheduler threads until the timeout, though. I take it the scheduler threads are shared between all bindings? My assumption for now is that this won't pose a problem. If it does, is there a \"proper\" way to handle that?", "author": "pravussum", "createdAt": "2020-03-07T12:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMzA5MA=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nsimilarity index 65%\nrename from bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\nrename to bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex c6d40a236b..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossHRV.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -13,101 +13,50 @@\n package org.openhab.binding.danfossairunit.internal;\n \n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n import java.math.BigDecimal;\n import java.math.RoundingMode;\n import java.net.InetAddress;\n-import java.net.Socket;\n import java.nio.charset.StandardCharsets;\n import java.time.DateTimeException;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.library.types.*;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n- * The {@link DanfossHRV} class does the actual network communication with the air unit.\n- *\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n+@SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossHRV implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossHRV.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n \n-    private InetAddress inetAddr;\n-    private int port;\n-    private @Nullable Socket socket;\n-    private @Nullable OutputStream oStream;\n-    private @Nullable InputStream iStream;\n-\n-    public DanfossHRV(InetAddress inetAddr, int port) {\n-        this.inetAddr = inetAddr;\n-        this.port = port;\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n     }\n \n-    public synchronized void connect() throws IOException {\n-        socket = new Socket(inetAddr, port);\n-        oStream = socket.getOutputStream();\n-        iStream = socket.getInputStream();\n-    }\n-\n-    public synchronized void disconnect() {\n-        try {\n-            if (socket != null) {\n-                socket.close();\n-            }\n-        } catch (IOException ignore) {\n-        } finally {\n-            socket = null;\n-            iStream = null;\n-            oStream = null;\n-        }\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register, EMPTY);\n-    }\n-\n-    private byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n-        if (socket == null) {\n-            throw new IOException(\"Air unit not connected.\");\n-        }\n-        byte[] request = new byte[4 + value.length];\n-        System.arraycopy(operation, 0, request, 0, 2);\n-        System.arraycopy(register, 0, request, 2, 2);\n-        System.arraycopy(value, 0, request, 4, value.length);\n-\n-        try {\n-            return sendRequest(request);\n-        } catch (IOException exIo) {\n-            logger.info(\"Connection to the air unit has been lost, reconnecting ({}).\", exIo.getMessage());\n-            connect();\n-            return sendRequest(request);\n-        }\n-    }\n-\n-    private synchronized byte[] sendRequest(byte[] request) throws IOException {\n-\n-        oStream.write(request);\n-        oStream.flush();\n-\n-        byte[] result = new byte[63];\n-        iStream.read(result, 0, 63);\n-\n-        return result;\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n     }\n \n     private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n-        return sendRobustRequest(operation, register)[0] != 0;\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n     }\n \n     private void setSetting(byte[] register, boolean value) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MDQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389390489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.execute(this::discover);", "author": "cpmeister", "createdAt": "2020-03-08T17:42:50Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.schedule(this::discover, 0, TimeUnit.SECONDS);", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\nindex c06c66fc79..92c70bbc15 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n\n@@ -22,7 +22,6 @@ import java.net.InterfaceAddress;\n import java.net.NetworkInterface;\n import java.net.SocketTimeoutException;\n import java.util.*;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MjYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392610", "bodyText": "IllegalArgumentException should be reserved for invalid or incorrect arguments to a function or constructor. This case is neither of those as you are handling a response message. You should either throw an IOException or return Float.NaN then handle the NaN case elsewhere in your code.", "author": "cpmeister", "createdAt": "2020-03-08T18:12:49Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex bdf838af5d..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -26,24 +26,25 @@ import org.eclipse.smarthome.core.library.types.DateTimeType;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n  * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n  * {@link DanfossAirUnitCommunicationController}\n- *\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n @SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossAirUnit implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n     private final DanfossAirUnitCommunicationController communicationController;\n \n     public DanfossAirUnit(InetAddress inetAddr, int port) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389392867", "bodyText": "Is this supposed to be a signed byte value? This code will allow years in the range 1872-2127. Just checking if that is what you are expecting.", "author": "cpmeister", "createdAt": "2020-03-08T18:16:10Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQxMzkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389413907", "bodyText": "Right now it's working as expected. Got no real documentation of the protocol, though :-(", "author": "pravussum", "createdAt": "2020-03-08T22:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5Mjg2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex bdf838af5d..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -26,24 +26,25 @@ import org.eclipse.smarthome.core.library.types.DateTimeType;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n  * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n  * {@link DanfossAirUnitCommunicationController}\n- *\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n @SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossAirUnit implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n     private final DanfossAirUnitCommunicationController communicationController;\n \n     public DanfossAirUnit(InetAddress inetAddr, int port) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389393315", "bodyText": "I wouldn't throw an IllegalArgumentException. Similar to reasons I mentioned above. This code is used to process response messages and as such it should be a checked exception like an IOException.", "author": "cpmeister", "createdAt": "2020-03-08T18:22:25Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new IllegalArgumentException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            logger.debug(\"Ignoring invalid timestamp {}.{}.{} {}:{}:{}\", day, month, year, hour, minute, second);\n+            throw new IllegalArgumentException();", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex bdf838af5d..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -26,24 +26,25 @@ import org.eclipse.smarthome.core.library.types.DateTimeType;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n  * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n  * {@link DanfossAirUnitCommunicationController}\n- *\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n @SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossAirUnit implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n     private final DanfossAirUnitCommunicationController communicationController;\n \n     public DanfossAirUnit(InetAddress inetAddr, int port) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389393349", "bodyText": "Not UTF-8? Unusual.", "author": "cpmeister", "createdAt": "2020-03-08T18:23:04Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQxNDE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389414153", "bodyText": "Same as above. Right now working as expected  (the devices unit name is reported correctly), but no real documentation.", "author": "pravussum", "createdAt": "2020-03-08T22:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5MzM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex bdf838af5d..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -26,24 +26,25 @@ import org.eclipse.smarthome.core.library.types.DateTimeType;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n  * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n  * {@link DanfossAirUnitCommunicationController}\n- *\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n @SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossAirUnit implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n     private final DanfossAirUnitCommunicationController communicationController;\n \n     public DanfossAirUnit(InetAddress inetAddr, int port) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM5NDg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389394878", "bodyText": "You shouldn't catch RuntimeException here. If you are trying to catch exceptions that occur in your accessor then then your accessor should throw checked exceptions that you can then handle here.", "author": "cpmeister", "createdAt": "2020-03-08T18:45:34Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch (RuntimeException e) {", "originalCommit": "135ef20d83e815afa86904aabd4bbf102be92315", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex 909609863a..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3MTcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r389471716", "bodyText": "Please move this field above the constructor", "author": "cpmeister", "createdAt": "2020-03-09T05:44:27Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    ChannelGroup(String groupName) {\n+        this.groupName = groupName;\n+    }\n+\n+    private String groupName;", "originalCommit": "04f171986cfdf5462a02a68015ddca808913c996", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\nindex 3e4c5faa7f..c31e9f1823 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n /**\n  * Represents a channel group, channels are divided into.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum ChannelGroup {\n     MAIN(\"main\"),\n     TEMPS(\"temps\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3OTQwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390579402", "bodyText": "Putting constants into interfaces is no longer considered a good coding practice.\nI would suggest making this a class and then use static imports instead.", "author": "cpmeister", "createdAt": "2020-03-10T20:06:38Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link Commands} interface holds the commands which can be send to the air unit to read/write values or trigger\n+ * actions.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public interface Commands {", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java\nindex 4275692641..e536982082 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Commands.java\n\n@@ -22,45 +22,45 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n  */\n \n @NonNullByDefault\n-public interface Commands {\n+public class Commands {\n \n-    byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n-    byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n-    byte[] EMPTY = {};\n-    byte[] GET_HISTORY = { 0x00, 0x30 };\n-    byte[] REGISTER_0_READ = { 0x00, 0x04 };\n-    byte[] REGISTER_1_READ = { 0x01, 0x04 };\n-    byte[] REGISTER_1_WRITE = { 0x01, 0x06 };\n-    byte[] REGISTER_2_READ = { 0x02, 0x04 };\n-    byte[] REGISTER_4_READ = { 0x04, 0x04 };\n-    byte[] REGISTER_6_READ = { 0x06, 0x04 };\n-    byte[] MODE = { 0x14, 0x12 };\n-    byte[] MANUAL_FAN_SPEED_STEP = { 0x15, 0x61 };\n-    byte[] SUPPLY_FAN_SPEED = { 0x14, 0x50 };\n-    byte[] EXTRACT_FAN_SPEED = { 0x14, 0x51 };\n-    byte[] SUPPLY_FAN_STEP = {0x14,0x28};\n-    byte[] EXTRACT_FAN_STEP = {0x14,0x29};\n-    byte[] BASE_IN = { 0x14, 0x40 };\n-    byte[] BASE_OUT = { 0x14, 0x41 };\n-    byte[] BYPASS = { 0x14, 0x60 };\n-    byte[] BYPASS_DEACTIVATION = { 0x14, 0x63 };\n-    byte[] BOOST = { 0x15, 0x30 };\n-    byte[] NIGHT_COOLING = { 0x15, 0x71 };\n-    byte[] AUTOMATIC_BYPASS = { 0x17, 0x06 };\n-    byte[] AUTOMATIC_RUSH_AIRING = { 0x17, 0x02 };\n-    byte[] HUMIDITY = { 0x14, 0x70 };\n-    byte[] ROOM_TEMPERATURE = { 0x03, 0x00 };\n-    byte[] ROOM_TEMPERATURE_CALCULATED = { 0x14, (byte) 0x96 };\n-    byte[] OUTDOOR_TEMPERATURE = { 0x03, 0x34 };\n-    byte[] SUPPLY_TEMPERATURE = { 0x14, 0x73 };\n-    byte[] EXTRACT_TEMPERATURE = { 0x14, 0x74 };\n-    byte[] EXHAUST_TEMPERATURE = { 0x14, 0x75 };\n-    byte[] BATTERY_LIFE = { 0x03, 0x0f };\n-    byte[] FILTER_LIFE = { 0x14, 0x6a };\n-    byte[] CURRENT_TIME = { 0x15, (byte) 0xe0 };\n-    byte[] AWAY_TO = { 0x15, 0x20 };\n-    byte[] AWAY_FROM = { 0x15, 0x21 };\n-    byte[] UNIT_SERIAL = { 0x00, 0x25 }; // endpoint 4\n-    byte[] UNIT_NAME = { 0x15, (byte) 0xe5 }; // endpoint 1\n-    byte[] CCM_SERIAL = { 0x14, 0x6a }; // endpoint 0\n+    public static byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    public static byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+    public static byte[] EMPTY = {};\n+    public static byte[] GET_HISTORY = { 0x00, 0x30 };\n+    public static byte[] REGISTER_0_READ = { 0x00, 0x04 };\n+    public static byte[] REGISTER_1_READ = { 0x01, 0x04 };\n+    public static byte[] REGISTER_1_WRITE = { 0x01, 0x06 };\n+    public static byte[] REGISTER_2_READ = { 0x02, 0x04 };\n+    public static byte[] REGISTER_4_READ = { 0x04, 0x04 };\n+    public static byte[] REGISTER_6_READ = { 0x06, 0x04 };\n+    public static byte[] MODE = { 0x14, 0x12 };\n+    public static byte[] MANUAL_FAN_SPEED_STEP = { 0x15, 0x61 };\n+    public static byte[] SUPPLY_FAN_SPEED = { 0x14, 0x50 };\n+    public static byte[] EXTRACT_FAN_SPEED = { 0x14, 0x51 };\n+    public static byte[] SUPPLY_FAN_STEP = {0x14,0x28};\n+    public static byte[] EXTRACT_FAN_STEP = {0x14,0x29};\n+    public static byte[] BASE_IN = { 0x14, 0x40 };\n+    public static byte[] BASE_OUT = { 0x14, 0x41 };\n+    public static byte[] BYPASS = { 0x14, 0x60 };\n+    public static byte[] BYPASS_DEACTIVATION = { 0x14, 0x63 };\n+    public static byte[] BOOST = { 0x15, 0x30 };\n+    public static byte[] NIGHT_COOLING = { 0x15, 0x71 };\n+    public static byte[] AUTOMATIC_BYPASS = { 0x17, 0x06 };\n+    public static byte[] AUTOMATIC_RUSH_AIRING = { 0x17, 0x02 };\n+    public static byte[] HUMIDITY = { 0x14, 0x70 };\n+    public static byte[] ROOM_TEMPERATURE = { 0x03, 0x00 };\n+    public static byte[] ROOM_TEMPERATURE_CALCULATED = { 0x14, (byte) 0x96 };\n+    public static byte[] OUTDOOR_TEMPERATURE = { 0x03, 0x34 };\n+    public static byte[] SUPPLY_TEMPERATURE = { 0x14, 0x73 };\n+    public static byte[] EXTRACT_TEMPERATURE = { 0x14, 0x74 };\n+    public static byte[] EXHAUST_TEMPERATURE = { 0x14, 0x75 };\n+    public static byte[] BATTERY_LIFE = { 0x03, 0x0f };\n+    public static byte[] FILTER_LIFE = { 0x14, 0x6a };\n+    public static byte[] CURRENT_TIME = { 0x15, (byte) 0xe0 };\n+    public static byte[] AWAY_TO = { 0x15, 0x20 };\n+    public static byte[] AWAY_FROM = { 0x15, 0x21 };\n+    public static byte[] UNIT_SERIAL = { 0x00, 0x25 }; // endpoint 4\n+    public static byte[] UNIT_NAME = { 0x15, (byte) 0xe5 }; // endpoint 1\n+    public static byte[] CCM_SERIAL = { 0x14, 0x6a }; // endpoint 0\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3OTcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390579709", "bodyText": "See above", "author": "cpmeister", "createdAt": "2020-03-10T20:07:11Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link DanfossAirUnitBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public interface DanfossAirUnitBindingConstants {", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java\nindex 816a54bc2e..3fd9849e2c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitBindingConstants.java\n\n@@ -26,24 +26,24 @@ import org.eclipse.smarthome.core.thing.ThingTypeUID;\n  * @author Robert Bach - heavy refactorings\n  */\n @NonNullByDefault\n-public interface DanfossAirUnitBindingConstants {\n+public class DanfossAirUnitBindingConstants {\n \n-    String BINDING_ID = \"danfossairunit\";\n+    public static String BINDING_ID = \"danfossairunit\";\n \n     // List of all Thing Type UIDs\n-    ThingTypeUID THING_TYPE_SAMPLE = new ThingTypeUID(BINDING_ID, \"sample\");\n+    public static ThingTypeUID THING_TYPE_SAMPLE = new ThingTypeUID(BINDING_ID, \"sample\");\n \n     // List of all Channel ids\n-    String CHANNEL_1 = \"channel1\";\n+    public static String CHANNEL_1 = \"channel1\";\n \n     // The only thing type UIDs\n-    ThingTypeUID THING_TYPE_AIRUNIT = new ThingTypeUID(BINDING_ID, \"airunit\");\n+    public static ThingTypeUID THING_TYPE_AIRUNIT = new ThingTypeUID(BINDING_ID, \"airunit\");\n \n     // The thing type as a set\n-    Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AIRUNIT);\n+    public static Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AIRUNIT);\n \n     // Properties\n-    String PROPERTY_UNIT_NAME = \"Unit Name\";\n-    String PROPERTY_SERIAL = \"Serial Number\";\n+    public static String PROPERTY_UNIT_NAME = \"Unit Name\";\n+    public static String PROPERTY_SERIAL = \"Serial Number\";\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4MjQ1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390582455", "bodyText": "Since your temperature channels now have an item type of Number:Temperature. You should make sure to use QuantityType<Temperature> instead of DecimalType.", "author": "cpmeister", "createdAt": "2020-03-10T20:12:34Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit implements Commands {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);\n+            throw new UnexpectedResponseValueException(msg);\n+        }\n+    }\n+\n+    private static int asUnsignedByte(byte b) {\n+        return b & 0xFF;\n+    }\n+\n+    private static float asPercentByte(byte b) {\n+        float f = asUnsignedByte(b);\n+        return f * 100 / 255;\n+    }\n+\n+    private void setSetting(byte[] register, short value) throws IOException {\n+        byte[] valueArray = new byte[2];\n+        valueArray[0] = (byte) (value >> 8);\n+        valueArray[1] = (byte) value;\n+\n+        communicationController.sendRobustRequest(REGISTER_1_WRITE, register, valueArray);\n+    }\n+\n+    public String getUnitName() throws IOException {\n+        return getString(REGISTER_1_READ, UNIT_NAME);\n+    }\n+\n+    public String getUnitSerialNumber() throws IOException {\n+        return String.valueOf(getShort(REGISTER_4_READ, UNIT_SERIAL));\n+    }\n+\n+    public StringType getMode() throws IOException {\n+        return new StringType(Mode.values()[getByte(REGISTER_1_READ, MODE)].name());\n+    }\n+\n+    public PercentType getManualFanSpeed() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_1_READ, MANUAL_FAN_SPEED_STEP) * 10));\n+    }\n+\n+    public DecimalType getSupplyFanSpeed() throws IOException {\n+        return new DecimalType(BigDecimal.valueOf(getWord(REGISTER_4_READ, SUPPLY_FAN_SPEED)));\n+    }\n+\n+    public DecimalType getExtractFanSpeed() throws IOException {\n+        return new DecimalType(BigDecimal.valueOf(getWord(REGISTER_4_READ, EXTRACT_FAN_SPEED)));\n+    }\n+\n+    public PercentType getSupplyFanStep() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_4_READ, SUPPLY_FAN_STEP)));\n+    }\n+\n+    public PercentType getExtractFanStep() throws IOException {\n+        return new PercentType(BigDecimal.valueOf(getByte(REGISTER_4_READ, EXTRACT_FAN_STEP)));\n+    }\n+\n+    public OnOffType getBoost() throws IOException {\n+        return getBoolean(REGISTER_1_READ, BOOST) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public OnOffType getNightCooling() throws IOException {\n+        return getBoolean(REGISTER_1_READ, NIGHT_COOLING) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public OnOffType getBypass() throws IOException {\n+        return getBoolean(REGISTER_1_READ, BYPASS) ? OnOffType.ON : OnOffType.OFF;\n+    }\n+\n+    public DecimalType getHumidity() throws IOException {\n+        BigDecimal value = BigDecimal.valueOf(asPercentByte(getByte(REGISTER_1_READ, HUMIDITY)));\n+        return new DecimalType(value.setScale(1, RoundingMode.HALF_UP));\n+    }\n+\n+    public DecimalType getRoomTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_1_READ, ROOM_TEMPERATURE);\n+    }\n+\n+    public DecimalType getRoomTemperatureCalculated() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_0_READ, ROOM_TEMPERATURE_CALCULATED);\n+    }\n+\n+    public DecimalType getOutdoorTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_1_READ, OUTDOOR_TEMPERATURE);\n+    }\n+\n+    public DecimalType getSupplyTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, SUPPLY_TEMPERATURE);\n+    }\n+\n+    public DecimalType getExtractTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, EXTRACT_TEMPERATURE);\n+    }\n+\n+    public DecimalType getExhaustTemperature() throws IOException, UnexpectedResponseValueException {\n+        return getTemperatureAsDecimalType(REGISTER_4_READ, EXHAUST_TEMPERATURE);\n+    }", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex e6dc303c01..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -26,24 +26,25 @@ import org.eclipse.smarthome.core.library.types.DateTimeType;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n \n /**\n  * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n  * {@link DanfossAirUnitCommunicationController}\n- *\n  * @author Ralf Duckstein - Initial contribution\n  * @author Robert Bach - heavy refactorings\n  */\n \n @SuppressWarnings(\"SameParameterValue\")\n @NonNullByDefault\n-public class DanfossAirUnit implements Commands {\n+public class DanfossAirUnit {\n \n-    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n     private final DanfossAirUnitCommunicationController communicationController;\n \n     public DanfossAirUnit(InetAddress inetAddr, int port) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NzQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390587408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"Unknown host: \" + config.host);\n          \n          \n            \n                    }\n          \n          \n            \n                                \"Unknown host: \" + config.host);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-03-10T20:21:51Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+        }", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1NDQ5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390654495", "bodyText": "Pew, good find, thank you!", "author": "pravussum", "createdAt": "2020-03-10T22:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NzQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ce8450b80e..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4ODU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390588592", "bodyText": "Shouldn't this be considered a configuration error instead of a communication error?", "author": "cpmeister", "createdAt": "2020-03-10T20:24:02Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1NTYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390655619", "bodyText": "Not necessarily. Network might be temporarily down, configured hostname/IP might be wrong - in my opinion \"communication error\" covers both cases, while \"config error\" does not.", "author": "pravussum", "createdAt": "2020-03-10T22:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4ODU5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ce8450b80e..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MTQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390591461", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Disover message sent\");\n          \n          \n            \n                    logger.debug(\"Discover message sent\");", "author": "cpmeister", "createdAt": "2020-03-10T20:29:06Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Disover message sent\");", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\nindex 23cb8d77cf..92c70bbc15 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n\n@@ -22,7 +22,6 @@ import java.net.InterfaceAddress;\n import java.net.NetworkInterface;\n import java.net.SocketTimeoutException;\n import java.util.*;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwMDQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r390600481", "bodyText": "Assuming that you are doing broadcast discovery on a local area network. I don't see why you would expect any response to take up to 5 seconds. Wouldn't 500 milliseconds be more than sufficient?", "author": "cpmeister", "createdAt": "2020-03-10T20:46:37Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(5000);", "originalCommit": "7ae36564597a2284590a7bbc8bd8fe72bd8cd3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\nindex 23cb8d77cf..92c70bbc15 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n\n@@ -22,7 +22,6 @@ import java.net.InterfaceAddress;\n import java.net.NetworkInterface;\n import java.net.SocketTimeoutException;\n import java.util.*;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MjQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492442", "bodyText": "Could be null is there btw a reason you are not using the nullable annotations? For such classes its almost trivial to implement, see also: https://www.openhab.org/docs/developer/guidelines.html#null-annotations", "author": "martinvw", "createdAt": "2020-05-09T12:54:05Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * Represents a channel group, channels are divided into.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum ChannelGroup {\n+    MAIN(\"main\"),\n+    TEMPS(\"temps\"),\n+    HUMIDITY(\"humidity\"),\n+    RECUPERATOR(\"recuperator\"),\n+    SERVICE(\"service\");\n+\n+    private String groupName;", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\nindex c8368795ab..c31e9f1823 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/ChannelGroup.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n /**\n  * Represents a channel group, channels are divided into.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum ChannelGroup {\n     MAIN(\"main\"),\n     TEMPS(\"temps\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MjU0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492542", "bodyText": "Please remove this empty line", "author": "martinvw", "createdAt": "2020-05-09T12:55:04Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex 509617c046..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -30,10 +30,6 @@ import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.measure.Unit;\n import javax.measure.quantity.Temperature;\n \n import static org.openhab.binding.danfossairunit.internal.Commands.*;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492749", "bodyText": "It's considered bad practice to both log and (re)throw an exception", "author": "martinvw", "createdAt": "2020-05-09T12:56:52Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex 509617c046..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -30,10 +30,6 @@ import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.measure.Unit;\n import javax.measure.quantity.Temperature;\n \n import static org.openhab.binding.danfossairunit.internal.Commands.*;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjc5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492796", "bodyText": "Consider passing the cause of the exception, now you are effectively ignoring the caught exception.", "author": "martinvw", "createdAt": "2020-05-09T12:57:35Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.time.DateTimeException;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.*;\n+\n+/**\n+ * The {@link DanfossAirUnit} class represents the air unit device and build the commands to be sent by\n+ * {@link DanfossAirUnitCommunicationController}\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+\n+@SuppressWarnings(\"SameParameterValue\")\n+@NonNullByDefault\n+public class DanfossAirUnit {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnit.class);\n+    private final DanfossAirUnitCommunicationController communicationController;\n+\n+    public DanfossAirUnit(InetAddress inetAddr, int port) {\n+        this.communicationController  = new DanfossAirUnitCommunicationController(inetAddr, port);\n+    }\n+\n+    public void cleanUp() {\n+        this.communicationController.disconnect();\n+    }\n+\n+    private boolean getBoolean(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0] != 0;\n+    }\n+\n+    private void setSetting(byte[] register, boolean value) throws IOException {\n+        setSetting(register, value ? (byte) 1 : (byte) 0);\n+    }\n+\n+    private short getWord(byte[] operation, byte[] register) throws IOException {\n+        byte[] resultBytes = communicationController.sendRobustRequest(operation, register);\n+        return (short)((resultBytes[0] << 8)  | (resultBytes[1] & 0xFF));\n+    }\n+\n+    private byte getByte(byte[] operation, byte[] register) throws IOException {\n+        return communicationController.sendRobustRequest(operation, register)[0];\n+    }\n+\n+    private String getString(byte[] operation, byte[] register) throws IOException {\n+        // length of the string is stored in the first byte\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return new String(result, 1, result[0], StandardCharsets.US_ASCII);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, byte value) throws IOException {\n+        byte[] valueArray = { value };\n+        communicationController.sendRobustRequest(operation, register, valueArray);\n+    }\n+\n+    private void set(byte[] operation, byte[] register, short value) throws IOException {\n+        communicationController.sendRobustRequest(operation, register, shortToBytes(value));\n+    }\n+\n+    private byte[] shortToBytes(short s) {\n+        return new byte[]{(byte)((s & 0xFF00) >> 8),(byte)(s & 0x00FF)};\n+    }\n+\n+    private short getShort(byte[] operation, byte[] register) throws IOException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return (short) ((result[0] << 8) + (result[1] & 0xff));\n+    }\n+\n+    private float getTemperature(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        short shortTemp = getShort(operation, register);\n+        float temp = ((float) shortTemp) / 100;\n+        if (temp <= -274 || temp > 100) {\n+            throw new UnexpectedResponseValueException(String.format(\"Invalid temperature: %s\", temp));\n+        }\n+        return temp;\n+    }\n+\n+    private ZonedDateTime getTimestamp(byte[] operation, byte[] register) throws IOException, UnexpectedResponseValueException {\n+        byte[] result = communicationController.sendRobustRequest(operation, register);\n+        return asZonedDateTime(result);\n+    }\n+\n+    private ZonedDateTime asZonedDateTime(byte[] data) throws UnexpectedResponseValueException {\n+        int second = data[0];\n+        int minute = data[1];\n+        int hour = data[2] & 0x1f;\n+        int day = data[3] & 0x1f;\n+        int month = data[4];\n+        int year = data[5] + 2000;\n+        try {\n+            return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault());\n+        } catch (DateTimeException e) {\n+            String msg = String.format(\"Ignoring invalid timestamp %s.%s.%s %s:%s:%s\", day, month, year, hour, minute,\n+                    second);\n+            logger.debug(msg);\n+            throw new UnexpectedResponseValueException(msg);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\nindex 509617c046..50a20a790c 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnit.java\n\n@@ -30,10 +30,6 @@ import org.eclipse.smarthome.core.library.types.QuantityType;\n import org.eclipse.smarthome.core.library.types.StringType;\n import org.eclipse.smarthome.core.library.unit.SIUnits;\n import org.eclipse.smarthome.core.types.Command;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import javax.measure.Unit;\n import javax.measure.quantity.Temperature;\n \n import static org.openhab.binding.danfossairunit.internal.Commands.*;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mjk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422492963", "bodyText": "I don't think this has to be logged on info level?", "author": "martinvw", "createdAt": "2020-05-09T12:58:52Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\nindex 4546462a77..5d13062741 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\n\n@@ -19,8 +19,7 @@ import java.io.InputStream;\n import java.io.OutputStream;\n import java.net.InetAddress;\n import java.net.Socket;\n-import java.util.Objects;\n-\n+import java.util.Arrays;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493054", "bodyText": "This will throw an NPE when iStream is null and that is likely because it's nullable, is there any reason not to check?", "author": "martinvw", "createdAt": "2020-05-09T12:59:49Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());\n+        } finally {\n+            socket = null;\n+            iStream = null;\n+            oStream = null;\n+        }\n+        connected = false;\n+    }\n+\n+    public byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    public synchronized byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        connect();\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+        try {\n+            return sendRequestInternal(request);\n+        } catch (IOException ioe) {\n+            // retry once if there was connection problem\n+            disconnect();\n+            connect();\n+            return sendRequestInternal(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequestInternal(byte[] request) throws IOException {\n+\n+        Objects.requireNonNull(oStream).write(request);\n+        oStream.flush();\n+\n+        byte[] result = new byte[63];\n+        //noinspection ResultOfMethodCallIgnored\n+        Objects.requireNonNull(iStream).read(result, 0, 63);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\nindex 4546462a77..5d13062741 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\n\n@@ -19,8 +19,7 @@ import java.io.InputStream;\n import java.io.OutputStream;\n import java.net.InetAddress;\n import java.net.Socket;\n-import java.util.Objects;\n-\n+import java.util.Arrays;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzA2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493064", "bodyText": "See below", "author": "martinvw", "createdAt": "2020-05-09T12:59:58Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.Commands.EMPTY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.Objects;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitCommunicationController} class does the actual network communication with the air unit.\n+ *\n+ * @author Robert Bach - initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class DanfossAirUnitCommunicationController {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitCommunicationController.class);\n+\n+    private final InetAddress inetAddr;\n+    private final int port;\n+    private boolean connected = false;\n+    private @Nullable Socket socket;\n+    private @Nullable OutputStream oStream;\n+    private @Nullable InputStream iStream;\n+\n+    public DanfossAirUnitCommunicationController(InetAddress inetAddr, int port) {\n+        this.inetAddr = inetAddr;\n+        this.port = port;\n+    }\n+\n+    public synchronized void connect() throws IOException {\n+        if(connected) {\n+            return;\n+        }\n+        socket = new Socket(inetAddr, port);\n+        oStream = socket.getOutputStream();\n+        iStream = socket.getInputStream();\n+        connected = true;\n+    }\n+\n+    public synchronized void disconnect() {\n+        if(!connected) {\n+            return;\n+        }\n+        try {\n+            if (socket != null) {\n+                socket.close();\n+            }\n+        } catch (IOException ioe) {\n+            logger.info(\"Connection to air unit could not be closed gracefully. {}\", ioe.getMessage());\n+        } finally {\n+            socket = null;\n+            iStream = null;\n+            oStream = null;\n+        }\n+        connected = false;\n+    }\n+\n+    public byte[] sendRobustRequest(byte[] operation, byte[] register) throws IOException {\n+        return sendRobustRequest(operation, register, EMPTY);\n+    }\n+\n+    public synchronized byte[] sendRobustRequest(byte[] operation, byte[] register, byte[] value) throws IOException {\n+        connect();\n+        byte[] request = new byte[4 + value.length];\n+        System.arraycopy(operation, 0, request, 0, 2);\n+        System.arraycopy(register, 0, request, 2, 2);\n+        System.arraycopy(value, 0, request, 4, value.length);\n+        try {\n+            return sendRequestInternal(request);\n+        } catch (IOException ioe) {\n+            // retry once if there was connection problem\n+            disconnect();\n+            connect();\n+            return sendRequestInternal(request);\n+        }\n+    }\n+\n+    private synchronized byte[] sendRequestInternal(byte[] request) throws IOException {\n+\n+        Objects.requireNonNull(oStream).write(request);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\nindex 4546462a77..5d13062741 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitCommunicationController.java\n\n@@ -19,8 +19,7 @@ import java.io.InputStream;\n import java.io.OutputStream;\n import java.net.InetAddress;\n import java.net.Socket;\n-import java.util.Objects;\n-\n+import java.util.Arrays;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzExNA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493114", "bodyText": "Please put all fields above the constructor", "author": "martinvw", "createdAt": "2020-05-09T13:00:28Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzI2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493263", "bodyText": "I don't think this should be an info log statement especially not without and context and without stack trace. I would propose to provide some context what is the code doing while this fails and pass the exception as parameter.", "author": "martinvw", "createdAt": "2020-05-09T13:01:52Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzI4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493285", "bodyText": "Do you really need to catch the Exception-class or are there more specific exceptions you could catch like the IOException or maybe only RuntimeException's (which is not that good either). The current code and also catching RuntimeException's might 'hide' programming errors like NullPointerExceptions occurring.\nhttps://www.google.nl/search?q=java%20why%20not%20to%20catch%20exception", "author": "martinvw", "createdAt": "2020-05-09T13:02:06Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzMxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493316", "bodyText": "If you catch all Exception you are potentially also catching for example NullPointerExceptions and  they tend to miss a message, so you will be printing the message null which will make it troublesome to debug, in this case it is always better to log the complete stacktrace.", "author": "martinvw", "createdAt": "2020-05-09T13:02:16Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493490", "bodyText": "I doubt whether info is the proper log level and I suppose updating the thing status makes more sense for average users.", "author": "martinvw", "createdAt": "2020-05-09T13:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzMxNg=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493567", "bodyText": "It's an enum feel free to compare using ==", "author": "martinvw", "createdAt": "2020-05-09T13:04:33Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an error occurred retrieving the value: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                }\n+            }\n+\n+            if (getThing().getStatus().equals(ThingStatus.OFFLINE)) {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mzc2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493760", "bodyText": "At first glance, this catches exception before the outer catch can handle them. Should this catch update any status?", "author": "martinvw", "createdAt": "2020-05-09T13:06:14Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5Mzc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493771", "bodyText": "See above check all", "author": "martinvw", "createdAt": "2020-05-09T13:06:28Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(),\n+                            channel.getReadAccessor().access(danfossAirUnit));\n+                } catch(UnexpectedResponseValueException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an unexpected or invalid response has been received from the air unit: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                } catch (IOException e) {\n+                    updateState(channel.getGroup().getGroupName(), channel.getChannelName(), UnDefType.UNDEF);\n+                    logger.debug(\"Cannot update channel {}: an error occurred retrieving the value: {}\",\n+                            channel.getChannelName(), e.getMessage());\n+                }\n+            }\n+\n+            if (getThing().getStatus().equals(ThingStatus.OFFLINE)) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (IOException ioe) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+        } catch (Exception e) {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MzkyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422493920", "bodyText": "If you really need this nested try-catch I would suggest to split of the part of the code that contains the nested try-catch to a separate method. This makes your code more readable and it might also make it more clear which part of the exceptions should be handled inside the method and which in the updateAllChannels method", "author": "martinvw", "createdAt": "2020-05-09T13:07:58Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494139", "bodyText": "If you really need this nested try-catch I would suggest to split of the part of the code that contains the nested try-catch to a separate method. This makes your code more readable and it might also make it more clear which part of the exceptions should be handled inside the method and which in the updateAllChannels method", "author": "martinvw", "createdAt": "2020-05-09T13:10:18Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DanfossAirUnitHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@NonNullByDefault\n+public class DanfossAirUnitHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitHandler.class);\n+\n+    private @Nullable DanfossAirUnitConfiguration config;\n+\n+    public DanfossAirUnitHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    private @Nullable ValueCache valueCache;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable DanfossAirUnit hrv;\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateAllChannels();\n+        } else {\n+            try {\n+                DanfossAirUnit danfossAirUnit = hrv;\n+                Channel channel = Channel.getByName(channelUID.getIdWithoutGroup());\n+                if (channel.getWriteAccessor() != null) {\n+                    updateState(channelUID, channel.getWriteAccessor().access(danfossAirUnit, command));\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.info(\"{}\", e.getMessage());\n+            } catch (IOException ioe) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, ioe.getMessage());\n+            } catch (Exception e) {\n+                logger.info(\"Error updating channel {}: {}\", channelUID, e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = getConfigAs(DanfossAirUnitConfiguration.class);\n+        valueCache = new ValueCache(config.updateUnchangedValuesEveryMillis);\n+        try {\n+            hrv = new DanfossAirUnit(InetAddress.getByName(config.host), 30046);\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Unknown host: \" + config.host);\n+            return;\n+        }\n+\n+        scheduler.execute(() -> {\n+            try {\n+                thing.setProperty(PROPERTY_UNIT_NAME, hrv.getUnitName());\n+                thing.setProperty(PROPERTY_SERIAL, hrv.getUnitSerialNumber());\n+                pollingJob = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 5, config.refreshInterval,\n+                        TimeUnit.SECONDS);\n+                updateStatus(ThingStatus.ONLINE);\n+\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+            }\n+        });\n+    }\n+\n+    private void updateAllChannels() {\n+        if (hrv == null) {\n+            return;\n+        }\n+        DanfossAirUnit danfossAirUnit = hrv;\n+        logger.debug(\"Updating DanfossHRV data '{}'\", getThing().getUID());\n+\n+        try {\n+            for (Channel channel : Channel.values()) {\n+                if (Thread.interrupted()) {\n+                    logger.debug(\"Polling thread interrupted...\");\n+                    return;\n+                }\n+                try {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\nindex ac1d1447bf..a314340c43 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/DanfossAirUnitHandler.java\n\n@@ -12,11 +12,13 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n-import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_SERIAL;\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.PROPERTY_UNIT_NAME;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.UnknownHostException;\n+import java.util.Objects;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDI4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494286", "bodyText": "Please check for all classes that lack NonNullByDefault annotations whether they can be added easily", "author": "martinvw", "createdAt": "2020-05-09T13:11:39Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal;\n+\n+/**\n+ * The {@link Mode} enum represents an air unit operation mode.\n+ *\n+ * @author Robert Bach - Initial contribution\n+ */\n+public enum Mode {", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java\nindex b559946244..3f7e1c03b5 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/Mode.java\n\n@@ -12,11 +12,14 @@\n  */\n package org.openhab.binding.danfossairunit.internal;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n /**\n  * The {@link Mode} enum represents an air unit operation mode.\n  *\n  * @author Robert Bach - Initial contribution\n  */\n+@NonNullByDefault\n public enum Mode {\n     DEMAND,\n     PROGRAM,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494433", "bodyText": "You don't have to call toString it will be called automatically, but only when the logging-level actually applies.", "author": "martinvw", "createdAt": "2020-05-09T13:13:07Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\nindex 4941d98a9f..92c70bbc15 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n\n@@ -48,7 +48,7 @@ public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n     private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n     private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n \n-    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n \n     public DanfossAirUnitDiscoveryService() {\n         super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDY4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r422494680", "bodyText": "Is this missing a break, because if the device responds it will just keep running or will it always throw an SocketTimeoutException?", "author": "martinvw", "createdAt": "2020-05-09T13:15:35Z", "path": "bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.danfossairunit.internal.discovery;\n+\n+import static org.openhab.binding.danfossairunit.internal.DanfossAirUnitBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InterfaceAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The Discovery service implementation to scan for available air units in the network via broadcast.\n+ *\n+ * @author Ralf Duckstein - Initial contribution\n+ * @author Robert Bach - heavy refactorings\n+ */\n+@Component(service = DiscoveryService.class, immediate = true)\n+@NonNullByDefault\n+public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int BROADCAST_PORT = 30045;\n+    private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n+    private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n+\n+    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+\n+    public DanfossAirUnitDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Start Danfoss Air CCM background discovery\");\n+        scheduler.execute(this::discover);\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        logger.debug(\"Start Danfoss Air CCM scan\");\n+        discover();\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Try to discover all Danfoss Air CCM devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket()) {\n+\n+            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n+            while (interfaces.hasMoreElements()) {\n+                NetworkInterface networkInterface = interfaces.nextElement();\n+                if (networkInterface == null || networkInterface.isLoopback() || !networkInterface.isUp()) {\n+                    continue;\n+                }\n+                for (InterfaceAddress interfaceAddress : networkInterface.getInterfaceAddresses()) {\n+                    if (interfaceAddress == null || interfaceAddress.getBroadcast() == null) {\n+                        continue;\n+                    }\n+                    logger.debug(\"Sending broadcast on interface {} to discover Danfoss Air CCM device...\",\n+                            interfaceAddress.getAddress().toString());\n+                    sendBroadcastToDiscoverThing(socket, interfaceAddress.getBroadcast());\n+                }\n+            }\n+\n+        } catch (IOException e) {\n+            logger.debug(\"No Danfoss Air CCM device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void sendBroadcastToDiscoverThing(DatagramSocket socket, InetAddress broadcastAddress) throws IOException {\n+        socket.setBroadcast(true);\n+        socket.setSoTimeout(500);\n+        // send discover\n+        byte[] sendBuffer = DISCOVER_SEND;\n+        DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, broadcastAddress, BROADCAST_PORT);\n+        socket.send(sendPacket);\n+        logger.debug(\"Discover message sent\");\n+\n+        // wait for responses\n+        while (true) {\n+            byte[] receiveBuffer = new byte[7];\n+            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n+            try {\n+                socket.receive(receivePacket);\n+            } catch (SocketTimeoutException e) {\n+                break; // leave the endless loop\n+            }\n+\n+            byte[] data = receivePacket.getData();\n+            if (Arrays.equals(data, DISCOVER_RECEIVE)) {\n+                logger.debug(\"Discover received correct response\");\n+\n+                String host = receivePacket.getAddress().getHostName();\n+                Map<String, Object> properties = new HashMap<>();\n+                properties.put(\"host\", host);\n+\n+                logger.debug(\"Adding a new Danfoss Air Unit CCM '{}' to inbox\", host);\n+\n+                ThingUID uid = new ThingUID(THING_TYPE_AIRUNIT, String.valueOf(receivePacket.getAddress().hashCode()));\n+\n+                DiscoveryResult result = DiscoveryResultBuilder.create(uid).withRepresentationProperty(\"host\")\n+                        .withProperties(properties).withLabel(\"Danfoss HRV\").build();\n+                thingDiscovered(result);\n+\n+                logger.debug(\"Thing discovered '{}'\", result);", "originalCommit": "846ac84dd0b9064408bce34d6eb0ef80467c7b6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3OTQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6814#discussion_r423079431", "bodyText": "It will process packets as long as there is anything to read, otherwise it'll time out and break the loop.", "author": "pravussum", "createdAt": "2020-05-11T14:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "chunk": "diff --git a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\nindex 4941d98a9f..92c70bbc15 100644\n--- a/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n+++ b/bundles/org.openhab.binding.danfossairunit/src/main/java/org/openhab/binding/danfossairunit/internal/discovery/DanfossAirUnitDiscoveryService.java\n\n@@ -48,7 +48,7 @@ public class DanfossAirUnitDiscoveryService extends AbstractDiscoveryService {\n     private static final byte[] DISCOVER_SEND = { 0x0c, 0x00, 0x30, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13 };\n     private static final byte[] DISCOVER_RECEIVE = { 0x0d, 0x00, 0x07, 0x00, 0x02, 0x02, 0x00 };\n \n-    private Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n+    private final Logger logger = LoggerFactory.getLogger(DanfossAirUnitDiscoveryService.class);\n \n     public DanfossAirUnitDiscoveryService() {\n         super(SUPPORTED_THING_TYPES_UIDS, 15, true);\n"}}, {"oid": "22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "url": "https://github.com/openhab/openhab-addons/commit/22efaaafbe9fbbc631ebe18128e11b8dfffa74f8", "message": "[danfossairunit] initial contribution\n\nSigned-off-by: Robert Bach <openhab@mortalsilence.net>", "committedDate": "2020-05-11T16:09:56Z", "type": "commit"}]}