{"pr_number": 6985, "pr_title": "[shelly] Support for Duo, EM3, DW, Smoke, Addon; new CoAP-based updates; bug fixes", "pr_createdAt": "2020-02-09T13:48:20Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6985", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669026", "bodyText": "Shouldn't it already be stopped as part of the handler getting disposed?\nWhy do you need to call this here?", "author": "cpmeister", "createdAt": "2020-04-03T00:21:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -130,6 +142,7 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n     @Override\n     protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n         if (thingHandler instanceof ShellyBaseHandler) {\n+            ((ShellyBaseHandler) thingHandler).stop();", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzg4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403433886", "bodyText": "Sometimes I see \"xxx, but thing handled is already disposed\". Maybe this is a timing issue when shutting down the thing, but another event comes in at that time. Put it in just to avoid this potential scenario, but I could also remove it", "author": "markus7017", "createdAt": "2020-04-04T06:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NDUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403684520", "bodyText": "removed it", "author": "markus7017", "createdAt": "2020-04-05T10:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\nindex 187d905853..fbd599949c 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n\n@@ -142,7 +130,6 @@ public class ShellyHandlerFactory extends BaseThingHandlerFactory {\n     @Override\n     protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n         if (thingHandler instanceof ShellyBaseHandler) {\n-            ((ShellyBaseHandler) thingHandler).stop();\n             deviceListeners.remove(thingHandler);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669362", "bodyText": "Why are you suppressing warnings here?", "author": "cpmeister", "createdAt": "2020-04-03T00:22:31Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTUyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435527", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-04T07:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 7d6be0beff..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private @Nullable Exception e = null;\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-\n-    public ShellyApiException() {\n-        super();\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result) {\n-        apiResult = result;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return getString(super.getMessage());\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty()\n-                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n-                : \"\";\n-\n-        if (e != null) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n-                        getString(super.getMessage()));\n-            } else {\n-                message = getString(super.getMessage());\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return (e != null) && (e.getClass() == ShellyApiException.class);\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = e != null ? e.getClass() : null;\n-        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n-                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return (e != null) && (e.getClass() == MalformedURLException.class);\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return (e != null) && (e.getClass() == UnknownHostException.class);\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public ShellyApiResult getApiResult() {\n-        return apiResult != null ? apiResult : new ShellyApiResult();\n-    }\n-\n-    public static String getExceptionType(@Nullable ShellyApiException e) {\n-        if ((e == null) || e.getClass().toString().isEmpty()) {\n-            return \"\";\n-        }\n-\n-        String msg = StringUtils.substringAfterLast(e.getClass().toString(), \".\");\n-        if (msg != null) {\n-            return msg;\n-        }\n-        return e.getCause().toString();\n-    }\n-\n-    private static String getString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669991", "bodyText": "Why do you need to suppress warnings? Also isn't apiResult a non-null field?", "author": "cpmeister", "createdAt": "2020-04-03T00:24:40Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n+    }\n+\n+    public boolean isUnknownHost() {\n+        return (e != null) && (e.getClass() == MalformedURLException.class);\n+    }\n+\n+    public boolean isMalformedURL() {\n+        return (e != null) && (e.getClass() == UnknownHostException.class);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public ShellyApiResult getApiResult() {\n+        return apiResult != null ? apiResult : new ShellyApiResult();\n+    }", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435939", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-04T07:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 7d6be0beff..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private @Nullable Exception e = null;\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-\n-    public ShellyApiException() {\n-        super();\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result) {\n-        apiResult = result;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return getString(super.getMessage());\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty()\n-                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n-                : \"\";\n-\n-        if (e != null) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n-                        getString(super.getMessage()));\n-            } else {\n-                message = getString(super.getMessage());\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return (e != null) && (e.getClass() == ShellyApiException.class);\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = e != null ? e.getClass() : null;\n-        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n-                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return (e != null) && (e.getClass() == MalformedURLException.class);\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return (e != null) && (e.getClass() == UnknownHostException.class);\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public ShellyApiResult getApiResult() {\n-        return apiResult != null ? apiResult : new ShellyApiResult();\n-    }\n-\n-    public static String getExceptionType(@Nullable ShellyApiException e) {\n-        if ((e == null) || e.getClass().toString().isEmpty()) {\n-            return \"\";\n-        }\n-\n-        String msg = StringUtils.substringAfterLast(e.getClass().toString(), \".\");\n-        if (msg != null) {\n-            return msg;\n-        }\n-        return e.getCause().toString();\n-    }\n-\n-    private static String getString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670514", "bodyText": "Can this be made final? Making this final would make some of your null checks satisfy the null checker.", "author": "cpmeister", "createdAt": "2020-04-03T00:26:40Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435590", "bodyText": "re-factored", "author": "markus7017", "createdAt": "2020-04-04T07:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 7d6be0beff..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private @Nullable Exception e = null;\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-\n-    public ShellyApiException() {\n-        super();\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result) {\n-        apiResult = result;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return getString(super.getMessage());\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty()\n-                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n-                : \"\";\n-\n-        if (e != null) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n-                        getString(super.getMessage()));\n-            } else {\n-                message = getString(super.getMessage());\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return (e != null) && (e.getClass() == ShellyApiException.class);\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = e != null ? e.getClass() : null;\n-        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n-                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return (e != null) && (e.getClass() == MalformedURLException.class);\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return (e != null) && (e.getClass() == UnknownHostException.class);\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public ShellyApiResult getApiResult() {\n-        return apiResult != null ? apiResult : new ShellyApiResult();\n-    }\n-\n-    public static String getExceptionType(@Nullable ShellyApiException e) {\n-        if ((e == null) || e.getClass().toString().isEmpty()) {\n-            return \"\";\n-        }\n-\n-        String msg = StringUtils.substringAfterLast(e.getClass().toString(), \".\");\n-        if (msg != null) {\n-            return msg;\n-        }\n-        return e.getCause().toString();\n-    }\n-\n-    private static String getString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670631", "bodyText": "You can remove this.", "author": "cpmeister", "createdAt": "2020-04-03T00:27:06Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTYwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435604", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-04T07:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDYzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 7d6be0beff..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private @Nullable Exception e = null;\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-\n-    public ShellyApiException() {\n-        super();\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result) {\n-        apiResult = result;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return getString(super.getMessage());\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty()\n-                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n-                : \"\";\n-\n-        if (e != null) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n-                        getString(super.getMessage()));\n-            } else {\n-                message = getString(super.getMessage());\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return (e != null) && (e.getClass() == ShellyApiException.class);\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = e != null ? e.getClass() : null;\n-        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n-                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return (e != null) && (e.getClass() == MalformedURLException.class);\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return (e != null) && (e.getClass() == UnknownHostException.class);\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public ShellyApiResult getApiResult() {\n-        return apiResult != null ? apiResult : new ShellyApiResult();\n-    }\n-\n-    public static String getExceptionType(@Nullable ShellyApiException e) {\n-        if ((e == null) || e.getClass().toString().isEmpty()) {\n-            return \"\";\n-        }\n-\n-        String msg = StringUtils.substringAfterLast(e.getClass().toString(), \".\");\n-        if (msg != null) {\n-            return msg;\n-        }\n-        return e.getCause().toString();\n-    }\n-\n-    private static String getString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670724", "bodyText": "The null check isn't needed here.", "author": "cpmeister", "createdAt": "2020-04-03T00:27:24Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436005", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-04T07:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 7d6be0beff..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private @Nullable Exception e = null;\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-\n-    public ShellyApiException() {\n-        super();\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result) {\n-        apiResult = result;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return getString(super.getMessage());\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty()\n-                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n-                : \"\";\n-\n-        if (e != null) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n-                        getString(super.getMessage()));\n-            } else {\n-                message = getString(super.getMessage());\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return (e != null) && (e.getClass() == ShellyApiException.class);\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = e != null ? e.getClass() : null;\n-        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n-                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return (e != null) && (e.getClass() == MalformedURLException.class);\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return (e != null) && (e.getClass() == UnknownHostException.class);\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public ShellyApiResult getApiResult() {\n-        return apiResult != null ? apiResult : new ShellyApiResult();\n-    }\n-\n-    public static String getExceptionType(@Nullable ShellyApiException e) {\n-        if ((e == null) || e.getClass().toString().isEmpty()) {\n-            return \"\";\n-        }\n-\n-        String msg = StringUtils.substringAfterLast(e.getClass().toString(), \".\");\n-        if (msg != null) {\n-            return msg;\n-        }\n-        return e.getCause().toString();\n-    }\n-\n-    private static String getString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670826", "bodyText": "needed?", "author": "cpmeister", "createdAt": "2020-04-03T00:27:47Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -333,21 +445,34 @@\n         public ShellySettingsWiFiNetwork wifiSta1;\n         // public ShellySettingsMqtt mqtt; // not used for now\n         // public ShellySettingsSntp sntp; // not used for now\n+        public ShellySettingsCoiot coiot; // Firmware 1.6+\n         public ShellySettingsLogin login;\n         @SerializedName(\"pin_code\")\n         public String pinCode;\n         @SerializedName(\"coiot_execute_enable\")\n         public Boolean coiotExecuteEnable;\n         public String name;\n+        public Boolean discoverable; // FW 1.6+\n         public String fw;\n         @SerializedName(\"build_info\")\n         ShellySettingsBuildInfo buildInfo;\n         ShellyStatusCloud cloud;\n+        @SerializedName(\"sleep_mode\")\n+        public ShellySensorSleepMode sleepMode; // FW 1.6\n+\n         public String timezone;\n         public Double lat;\n         public Double lng;\n         public Boolean tzautodetect;\n         public String time;\n+        // @SerializedName(\"tz_utc_offset\")\n+        // public Integer tzUTCOoffset; // FW 1.6+\n+        // @SerializedName(\"tz_dst\")\n+        // public Boolean tzDdst; // FW 1.6+\n+        // @SerializedName(\"tz_dst_auto\")\n+        // public Boolean tzDstAuto; // FW 1.6+\n+        // public Long unixtime; // FW 1.6+", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442185", "bodyText": "Want to keep those, I want to make sure that the Java side matches the JSON at best as possible to see when new elements are included in a new firmware version", "author": "markus7017", "createdAt": "2020-04-04T08:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDgyNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\nindex 61015ab80e..27349e9e88 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\n\n@@ -445,34 +333,21 @@ public class ShellyApiJsonDTO {\n         public ShellySettingsWiFiNetwork wifiSta1;\n         // public ShellySettingsMqtt mqtt; // not used for now\n         // public ShellySettingsSntp sntp; // not used for now\n-        public ShellySettingsCoiot coiot; // Firmware 1.6+\n         public ShellySettingsLogin login;\n         @SerializedName(\"pin_code\")\n         public String pinCode;\n         @SerializedName(\"coiot_execute_enable\")\n         public Boolean coiotExecuteEnable;\n         public String name;\n-        public Boolean discoverable; // FW 1.6+\n         public String fw;\n         @SerializedName(\"build_info\")\n         ShellySettingsBuildInfo buildInfo;\n         ShellyStatusCloud cloud;\n-        @SerializedName(\"sleep_mode\")\n-        public ShellySensorSleepMode sleepMode; // FW 1.6\n-\n         public String timezone;\n         public Double lat;\n         public Double lng;\n         public Boolean tzautodetect;\n         public String time;\n-        // @SerializedName(\"tz_utc_offset\")\n-        // public Integer tzUTCOoffset; // FW 1.6+\n-        // @SerializedName(\"tz_dst\")\n-        // public Boolean tzDdst; // FW 1.6+\n-        // @SerializedName(\"tz_dst_auto\")\n-        // public Boolean tzDstAuto; // FW 1.6+\n-        // public Long unixtime; // FW 1.6+\n-\n         public ShellySettingsHwInfo hwinfo;\n         public String mode;\n         @SerializedName(\"max_power\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671291", "bodyText": "You mention 3 sensors fields but there is only one sensor field in this class.", "author": "cpmeister", "createdAt": "2020-04-03T00:29:13Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -612,20 +762,39 @@\n             public ShellyShortTemp sensor3;\n         }\n \n+        public static class ShellyExtHumidity {\n+            public static class ShellyShortHum {\n+                public Double hum; // Humidity reading of sensor 0, percent\n+            }\n+\n+            // Shelly 1/1PM have up to 3 sensors\n+            // for whatever reasons it's not an array, but 3 independent elements", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436154", "bodyText": "correct sensor1, sensor2, sensor3 as declared below\njust want to mention that I would expect a JSON array, but they added 3 values instead", "author": "markus7017", "createdAt": "2020-04-04T07:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MzA3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404273071", "bodyText": "I only see sensor1 declared...", "author": "cpmeister", "createdAt": "2020-04-06T17:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NDM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406164340", "bodyText": "???\n            // Shelly 1/1PM have up to 3 sensors\n            // for whatever reasons it's not an array, but 3 independent elements\n            @SerializedName(\"0\")\n            public ShellyShortTemp sensor1;\n            @SerializedName(\"1\")\n            public ShellyShortTemp sensor2;\n            @SerializedName(\"2\")\n            public ShellyShortTemp sensor3;\n\nsensor1, sensor2, sensor3", "author": "markus7017", "createdAt": "2020-04-09T12:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\nindex 61015ab80e..27349e9e88 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\n\n@@ -762,39 +612,20 @@ public class ShellyApiJsonDTO {\n             public ShellyShortTemp sensor3;\n         }\n \n-        public static class ShellyExtHumidity {\n-            public static class ShellyShortHum {\n-                public Double hum; // Humidity reading of sensor 0, percent\n-            }\n-\n-            // Shelly 1/1PM have up to 3 sensors\n-            // for whatever reasons it's not an array, but 3 independent elements\n-            @SerializedName(\"0\")\n-            public ShellyShortHum sensor1;\n-        }\n-\n         public ShellySensorTmp tmp;\n         public ShellySensorHum hum;\n         public ShellySensorLux lux;\n-        public ShellySensorAccel accel;\n         public ShellySensorBat bat;\n-        @SerializedName(\"sensor\")\n-        public ShellySensorState contact;\n-        public Boolean smoke; // SHelly Smoke\n+\n         public Boolean flood; // Shelly Flood: true = flood condition detected\n         @SerializedName(\"rain_sensor\")\n         public Boolean rainSensor; // Shelly Flood: true=in rain mode\n \n         public Boolean motion; // Shelly Sense: true=motion detected\n         public Boolean charger; // Shelly Sense: true=charger connected\n-        @SerializedName(\"external_power\")\n-        public Integer externalPower; // H&T FW 1.6, seems to be the same like charger for the Sense\n-\n-        @SerializedName(\"act_reasons\")\n-        public String[] actReasons; // HT/Smoke/Flood: list of reasons which woke up the device\n \n-        @SerializedName(\"sensor_error\")\n-        public String sensorError; // 1.5.7: Only displayed in case of error\n+        // @SerializedName(\"act_reasons\")\n+        // public String[] actReasons; // HT/Smoke/Flood: list of reasons which woke up the device\n     }\n \n     public static class ShellySettingsSmoke {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671463", "bodyText": "If this is non-null why not make it primitive?", "author": "cpmeister", "createdAt": "2020-04-03T00:29:52Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiResult.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpStatus.*;\n+import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+\n+/**\n+ * The {@link ShellyApiResult} wraps up the API result and provides some more information like url, http code, received\n+ * response etc.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiResult {\n+    public String url = \"\";\n+    public String method = \"\";\n+    public String response = \"\";\n+    public Integer httpCode = -1;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403684650", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T10:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiResult.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiResult.java\ndeleted file mode 100644\nindex 0b9a18cabe..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiResult.java\n+++ /dev/null\n\n@@ -1,103 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import static org.eclipse.jetty.http.HttpStatus.*;\n-import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.jetty.client.api.ContentResponse;\n-import org.eclipse.jetty.client.api.Request;\n-\n-/**\n- * The {@link ShellyApiResult} wraps up the API result and provides some more information like url, http code, received\n- * response etc.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiResult {\n-    public String url = \"\";\n-    public String method = \"\";\n-    public String response = \"\";\n-    public Integer httpCode = -1;\n-    public String httpReason = \"\";\n-\n-    public ShellyApiResult() {\n-    }\n-\n-    public ShellyApiResult(String method, String url) {\n-        this.method = method;\n-        this.url = url;\n-    }\n-\n-    public ShellyApiResult(String url, String method, Integer responseCode, String response) {\n-        this.method = method;\n-        this.url = url;\n-        this.httpCode = 0;\n-        this.response = response;\n-    }\n-\n-    public ShellyApiResult(ContentResponse contentResponse) {\n-        fillFromResponse(contentResponse);\n-    }\n-\n-    public ShellyApiResult(ContentResponse contentResponse, Throwable e) {\n-        fillFromResponse(contentResponse);\n-        response = response + \"(\" + e.toString() + \")\";\n-    }\n-\n-    public ShellyApiResult(@Nullable Request request, Throwable e) {\n-        response = e.toString();\n-        if (request != null) {\n-            url = request.getURI().toString();\n-            method = request.getMethod();\n-        }\n-    }\n-\n-    public String getHttpResponse() {\n-        return httpCode.toString() + \": \" + response;\n-    }\n-\n-    public boolean isHttpOk() {\n-        return httpCode == OK_200;\n-    }\n-\n-    public boolean isHttpAccessUnauthorized() {\n-        return (httpCode == UNAUTHORIZED_401 || response.contains(SHELLY_APIERR_UNAUTHORIZED));\n-    }\n-\n-    public boolean isHttpTimeout() {\n-        return httpCode == -1 || response.toUpperCase().contains(SHELLY_APIERR_TIMEOUT);\n-    }\n-\n-    public boolean isNotCalibrtated() {\n-        return getHttpResponse().contains(SHELLY_APIERR_NOT_CALIBRATED);\n-    }\n-\n-    private void fillFromResponse(@Nullable ContentResponse contentResponse) {\n-        if (contentResponse != null) {\n-            String r = contentResponse.getContentAsString();\n-            response = r != null ? r : \"\";\n-            httpCode = contentResponse.getStatus();\n-            httpReason = contentResponse.getReason();\n-\n-            Request request = contentResponse.getRequest();\n-            if (request != null) {\n-                url = request.getURI().toString();\n-                method = request.getMethod();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671594", "bodyText": "Why not a boolean?", "author": "cpmeister", "createdAt": "2020-04-03T00:30:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -38,14 +41,18 @@\n  */\n @NonNullByDefault\n public class ShellyDeviceProfile {\n+    public Boolean initialized = false; // true when initialized", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436333", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-04-04T07:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex 28589226a7..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -41,18 +38,14 @@ import com.google.gson.JsonSyntaxException;\n  */\n @NonNullByDefault\n public class ShellyDeviceProfile {\n-    public Boolean initialized = false; // true when initialized\n-\n     public String thingName = \"\";\n     public String deviceType = \"\";\n \n     public String settingsJson = \"\";\n-    public ShellySettingsGlobal settings = new ShellySettingsGlobal();\n-    public ShellySettingsStatus status = new ShellySettingsStatus();\n+    public @Nullable ShellySettingsGlobal settings;\n \n     public String hostname = \"\";\n     public String mode = \"\";\n-    public Boolean discoverable = true;\n \n     public String hwRev = \"\";\n     public String hwBatchId = \"\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjExOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402672118", "bodyText": "Any reason to not include the cause exception?", "author": "cpmeister", "createdAt": "2020-04-03T00:32:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -83,75 +97,186 @@\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(\n+                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442021", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-04-04T08:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjExOA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex 28589226a7..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -97,186 +83,75 @@ public class ShellyDeviceProfile {\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n+    public static ShellyDeviceProfile initialize(String thingType, String json) {\n         Gson gson = new Gson();\n \n-        initialized = false;\n+        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+        Validate.notNull(profile);\n \n-        try {\n-            initFromThingType(thingType);\n-            settingsJson = json;\n-            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n-        } catch (IllegalArgumentException | JsonSyntaxException e) {\n-            throw new ShellyApiException(\n-                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");\n-        }\n+        profile.settingsJson = json;\n+        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n \n         // General settings\n-        deviceType = ShellyUtils.getString(settings.device.type);\n-        mac = getString(settings.device.mac);\n-        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n-                ? settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n-        mode = getString(settings.mode) != null ? getString(settings.mode).toLowerCase() : \"\";\n-        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n-        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n-        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n-        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n-        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n-        discoverable = (settings.discoverable == null) || settings.discoverable;\n-\n-        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n-        if ((numRelays > 0) && (settings.relays == null)) {\n-            numRelays = 0;\n-        }\n-        hasRelays = (numRelays > 0) || isDimmer;\n-        numRollers = getInteger(settings.device.numRollers);\n-\n-        isEMeter = settings.emeters != null;\n-        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n-        if ((numMeters == 0) && isLight) {\n+        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n+        profile.mac = getString(profile.settings.device.mac);\n+        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n+                ? profile.settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n+        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n+        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n+        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n+                : \"\";\n+        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n+        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n+        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n+\n+        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n+        profile.hasLed = profile.isPlugS;\n+        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n+        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        profile.isLight = profile.isBulb\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n+        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n+        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.isSensor = profile.isSense || profile.isSmoke\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+\n+        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n+        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n+            profile.numRelays = 0;\n+        }\n+        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n+        profile.numRollers = getInteger(profile.settings.device.numRollers);\n+\n+        profile.isEMeter = profile.settings.emeters != null;\n+        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n+                : getInteger(profile.settings.device.numEMeters);\n+        if ((profile.numMeters == 0) && profile.isLight) {\n             // RGBW2 doesn't report, but has one\n-            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n-        }\n-        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-\n-        if (settings.sleepMode != null) {\n-            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n-                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n-                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n-        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n-            updatePeriod = settings.coiot.updatePeriod + 15; // usually 15+15s\n-        }\n-\n-        supportsButtonUrls = settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        supportsOutUrls = settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        supportsPushUrls = settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        supportsRollerUrls = settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        supportsSensorUrls = settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n-\n-        initialized = true;\n-        return this;\n-    }\n-\n-    public Boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    public void initFromThingType(String name) {\n-        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n-        if (thingType.isEmpty()) {\n-            return;\n+            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n         }\n+        profile.hasMeter = (profile.numMeters > 0);\n \n-        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n-\n-        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n-        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n-        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n-        hasLed = isPlugS;\n-        isLight = isBulb || isDuo || isRGBW2;\n-        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n-        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n-\n-        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n-        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n-        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n-        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n-        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n-        isSensor = isHT | isFlood | isDW | isSmoke | isSense;\n-        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n-    }\n-\n-    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n-        String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n-        return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n-                : getThingTypeUID(THING_TYPE_SHELLYPROTECTED_STR + \"-\" + devid, mode), devid);\n-    }\n-\n-    public static ThingTypeUID getThingTypeUID(String serviceName, String mode) {\n-        return new ThingTypeUID(BINDING_ID, getThingType(serviceName, mode));\n-    }\n-\n-    public static ThingTypeUID getUnknownTTUID() {\n-        return new ThingTypeUID(BINDING_ID, THING_TYPE_SHELLYPROTECTED_STR);\n-    }\n-\n-    public static String getThingType(String hostname, String mode) {\n-        String name = hostname.toLowerCase();\n-        String devid = StringUtils.substringAfterLast(name, \"-\");\n-        if (devid == null) {\n-            throw new IllegalArgumentException(\"Invalid device name format: \" + hostname);\n-        }\n-\n-        if (name.startsWith(THING_TYPE_SHELLY1PN_STR)) {\n-            return THING_TYPE_SHELLY1PN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM3_STR)) {\n-            return THING_TYPE_SHELLYEM3_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM_STR)) {\n-            return THING_TYPE_SHELLYEM_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY1_STR)) {\n-            return THING_TYPE_SHELLY1_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY25_PREFIX)) { // Shelly v2.5\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY25_RELAY_STR : THING_TYPE_SHELLY25_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY2_PREFIX)) { // Shelly v2\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY2_RELAY_STR : THING_TYPE_SHELLY2_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY4PRO_STR)) {\n-            return THING_TYPE_SHELLY4PRO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPLUG_STR)) {\n-            // shellyplug-s needs to be mapped to shellyplugs to follow the schema\n-            // for the thing types: <thing type>-<mode>\n-            if (name.startsWith(THING_TYPE_SHELLYPLUGS_STR) || name.contains(\"-s\")) {\n-                return THING_TYPE_SHELLYPLUGS_STR;\n-            }\n-            return THING_TYPE_SHELLYPLUG_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDIMMER_STR)) {\n-            return THING_TYPE_SHELLYDIMMER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDUO_STR)) {\n-            return THING_TYPE_SHELLYDUO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYBULB_STR)) {\n-            return THING_TYPE_SHELLYBULB_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX)) {\n-            return mode.equals(SHELLY_MODE_COLOR) ? THING_TYPE_SHELLYRGBW2_COLOR_STR : THING_TYPE_SHELLYRGBW2_WHITE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYHT_STR)) {\n-            return THING_TYPE_SHELLYHT_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSMOKE_STR)) {\n-            return THING_TYPE_SHELLYSMOKE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYFLOOD_STR)) {\n-            return THING_TYPE_SHELLYFLOOD_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDOORWIN_STR)) {\n-            return THING_TYPE_SHELLYDOORWIN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSENSE_STR)) {\n-            return THING_TYPE_SHELLYSENSE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEYE_STR)) {\n-            return THING_TYPE_SHELLYEYE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPROTECTED_STR)) {\n-            return THING_TYPE_SHELLYPROTECTED_STR;\n-        }\n+        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n \n-        return THING_TYPE_UNKNOWN_STR;\n+        return profile;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402672468", "bodyText": "Just to be consistent.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    isSensor = isHT | isFlood | isDW | isSmoke | isSense;\n          \n          \n            \n                    isSensor = isHT || isFlood || isDW || isSmoke || isSense;", "author": "cpmeister", "createdAt": "2020-04-03T00:33:20Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -83,75 +97,186 @@\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(\n+                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = getString(settings.mode) != null ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n+                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n+                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = settings.coiot.updatePeriod + 15; // usually 15+15s\n+        }\n+\n+        supportsButtonUrls = settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        supportsOutUrls = settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        supportsPushUrls = settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        supportsRollerUrls = settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        supportsSensorUrls = settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public Boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT | isFlood | isDW | isSmoke | isSense;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436444", "bodyText": "fixed, good catch :-)", "author": "markus7017", "createdAt": "2020-04-04T07:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex 28589226a7..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -97,186 +83,75 @@ public class ShellyDeviceProfile {\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n+    public static ShellyDeviceProfile initialize(String thingType, String json) {\n         Gson gson = new Gson();\n \n-        initialized = false;\n+        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+        Validate.notNull(profile);\n \n-        try {\n-            initFromThingType(thingType);\n-            settingsJson = json;\n-            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n-        } catch (IllegalArgumentException | JsonSyntaxException e) {\n-            throw new ShellyApiException(\n-                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");\n-        }\n+        profile.settingsJson = json;\n+        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n \n         // General settings\n-        deviceType = ShellyUtils.getString(settings.device.type);\n-        mac = getString(settings.device.mac);\n-        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n-                ? settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n-        mode = getString(settings.mode) != null ? getString(settings.mode).toLowerCase() : \"\";\n-        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n-        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n-        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n-        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n-        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n-        discoverable = (settings.discoverable == null) || settings.discoverable;\n-\n-        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n-        if ((numRelays > 0) && (settings.relays == null)) {\n-            numRelays = 0;\n-        }\n-        hasRelays = (numRelays > 0) || isDimmer;\n-        numRollers = getInteger(settings.device.numRollers);\n-\n-        isEMeter = settings.emeters != null;\n-        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n-        if ((numMeters == 0) && isLight) {\n+        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n+        profile.mac = getString(profile.settings.device.mac);\n+        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n+                ? profile.settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n+        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n+        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n+        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n+                : \"\";\n+        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n+        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n+        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n+\n+        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n+        profile.hasLed = profile.isPlugS;\n+        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n+        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        profile.isLight = profile.isBulb\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n+        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n+        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.isSensor = profile.isSense || profile.isSmoke\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+\n+        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n+        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n+            profile.numRelays = 0;\n+        }\n+        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n+        profile.numRollers = getInteger(profile.settings.device.numRollers);\n+\n+        profile.isEMeter = profile.settings.emeters != null;\n+        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n+                : getInteger(profile.settings.device.numEMeters);\n+        if ((profile.numMeters == 0) && profile.isLight) {\n             // RGBW2 doesn't report, but has one\n-            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n-        }\n-        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-\n-        if (settings.sleepMode != null) {\n-            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n-                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n-                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n-        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n-            updatePeriod = settings.coiot.updatePeriod + 15; // usually 15+15s\n-        }\n-\n-        supportsButtonUrls = settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        supportsOutUrls = settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        supportsPushUrls = settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        supportsRollerUrls = settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        supportsSensorUrls = settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n-\n-        initialized = true;\n-        return this;\n-    }\n-\n-    public Boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    public void initFromThingType(String name) {\n-        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n-        if (thingType.isEmpty()) {\n-            return;\n+            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n         }\n+        profile.hasMeter = (profile.numMeters > 0);\n \n-        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n-\n-        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n-        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n-        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n-        hasLed = isPlugS;\n-        isLight = isBulb || isDuo || isRGBW2;\n-        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n-        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n-\n-        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n-        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n-        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n-        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n-        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n-        isSensor = isHT | isFlood | isDW | isSmoke | isSense;\n-        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n-    }\n-\n-    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n-        String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n-        return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n-                : getThingTypeUID(THING_TYPE_SHELLYPROTECTED_STR + \"-\" + devid, mode), devid);\n-    }\n-\n-    public static ThingTypeUID getThingTypeUID(String serviceName, String mode) {\n-        return new ThingTypeUID(BINDING_ID, getThingType(serviceName, mode));\n-    }\n-\n-    public static ThingTypeUID getUnknownTTUID() {\n-        return new ThingTypeUID(BINDING_ID, THING_TYPE_SHELLYPROTECTED_STR);\n-    }\n-\n-    public static String getThingType(String hostname, String mode) {\n-        String name = hostname.toLowerCase();\n-        String devid = StringUtils.substringAfterLast(name, \"-\");\n-        if (devid == null) {\n-            throw new IllegalArgumentException(\"Invalid device name format: \" + hostname);\n-        }\n-\n-        if (name.startsWith(THING_TYPE_SHELLY1PN_STR)) {\n-            return THING_TYPE_SHELLY1PN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM3_STR)) {\n-            return THING_TYPE_SHELLYEM3_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM_STR)) {\n-            return THING_TYPE_SHELLYEM_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY1_STR)) {\n-            return THING_TYPE_SHELLY1_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY25_PREFIX)) { // Shelly v2.5\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY25_RELAY_STR : THING_TYPE_SHELLY25_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY2_PREFIX)) { // Shelly v2\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY2_RELAY_STR : THING_TYPE_SHELLY2_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY4PRO_STR)) {\n-            return THING_TYPE_SHELLY4PRO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPLUG_STR)) {\n-            // shellyplug-s needs to be mapped to shellyplugs to follow the schema\n-            // for the thing types: <thing type>-<mode>\n-            if (name.startsWith(THING_TYPE_SHELLYPLUGS_STR) || name.contains(\"-s\")) {\n-                return THING_TYPE_SHELLYPLUGS_STR;\n-            }\n-            return THING_TYPE_SHELLYPLUG_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDIMMER_STR)) {\n-            return THING_TYPE_SHELLYDIMMER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDUO_STR)) {\n-            return THING_TYPE_SHELLYDUO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYBULB_STR)) {\n-            return THING_TYPE_SHELLYBULB_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX)) {\n-            return mode.equals(SHELLY_MODE_COLOR) ? THING_TYPE_SHELLYRGBW2_COLOR_STR : THING_TYPE_SHELLYRGBW2_WHITE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYHT_STR)) {\n-            return THING_TYPE_SHELLYHT_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSMOKE_STR)) {\n-            return THING_TYPE_SHELLYSMOKE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYFLOOD_STR)) {\n-            return THING_TYPE_SHELLYFLOOD_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDOORWIN_STR)) {\n-            return THING_TYPE_SHELLYDOORWIN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSENSE_STR)) {\n-            return THING_TYPE_SHELLYSENSE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEYE_STR)) {\n-            return THING_TYPE_SHELLYEYE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPROTECTED_STR)) {\n-            return THING_TYPE_SHELLYPROTECTED_STR;\n-        }\n+        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n \n-        return THING_TYPE_UNKNOWN_STR;\n+        return profile;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NDgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402674810", "bodyText": "This seems like an inappropriate use of a Scanner. Why not use IOUtils.toString(request.getInputStream()) instead?", "author": "cpmeister", "createdAt": "2020-04-03T00:42:10Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -132,33 +130,9 @@ protected void service(@Nullable HttpServletRequest request, @Nullable HttpServl\n         }\n     }\n \n-    @SuppressWarnings(\"resource\")\n+    @SuppressWarnings({ \"resource\", \"null\" })\n     private String inputStreamToString(@Nullable HttpServletRequest request) throws IOException {\n-        @SuppressWarnings(\"null\")\n-        Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n+        final Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n         return scanner.hasNext() ? scanner.next() : \"\";", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NDgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403684801", "bodyText": "replaced by your code", "author": "markus7017", "createdAt": "2020-04-05T10:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NDgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\nindex eef1da9905..b880b411f6 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n\n@@ -130,9 +132,33 @@ public class ShellyEventServlet extends HttpServlet {\n         }\n     }\n \n-    @SuppressWarnings({ \"resource\", \"null\" })\n+    @SuppressWarnings(\"resource\")\n     private String inputStreamToString(@Nullable HttpServletRequest request) throws IOException {\n-        final Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n+        @SuppressWarnings(\"null\")\n+        Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n         return scanner.hasNext() ? scanner.next() : \"\";\n     }\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n+    public void setShellyHandlerFactory(ShellyHandlerFactory handlerFactory) {\n+        this.handlerFactory = handlerFactory;\n+        logger.debug(\"Shelly Binding: HandlerFactory bound\");\n+    }\n+\n+    public void unsetShellyHandlerFactory(ShellyHandlerFactory handlerFactory) {\n+        this.handlerFactory = null;\n+        logger.debug(\"Shelly Binding: HandlerFactory unbound\");\n+    }\n+\n+    @Reference\n+    public void setHttpService(HttpService httpService) {\n+        this.httpService = httpService;\n+        logger.debug(\"Shelly Binding: httpService bound\");\n+    }\n+\n+    public void unsetHttpService(HttpService httpService) {\n+        this.httpService = null;\n+        logger.debug(\"Shelly Binding: httpService unbound\");\n+    }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTczMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402675733", "bodyText": "why bother catching it if you are just going to throw it?", "author": "cpmeister", "createdAt": "2020-04-03T00:45:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -465,71 +443,110 @@ private void setEventUrls(Integer index) throws IOException {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(\n-                        thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        try {\n+            apiResult = innerRequest(HttpMethod.GET, uri);\n+        } catch (ShellyApiException e) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(\n-                            thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                if (e.isTimeout() && profile.isSensor) {\n+                    // Sensor in sleep mode\n+                    throw e;\n+                }\n+                if (e.isTimeout()) {\n+                    timeoutErrors++; // count the retries\n+                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++; // recoverd\n+                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n                 } else {\n-                    throw new IOException(\n-                            thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                    throw e;\n                 }\n+            } catch (ShellyApiException e2) {\n+                throw e2;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436558", "bodyText": "fixed, there was some code before", "author": "markus7017", "createdAt": "2020-04-04T07:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTczMw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex ad634fad34..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -443,110 +465,68 @@ public class ShellyHttpApi {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        try {\n-            apiResult = innerRequest(HttpMethod.GET, uri);\n-        } catch (ShellyApiException e) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                if (e.isTimeout() && profile.isSensor) {\n-                    // Sensor in sleep mode\n-                    throw e;\n-                }\n-                if (e.isTimeout()) {\n-                    timeoutErrors++; // count the retries\n-                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n-                    apiResult = innerRequest(HttpMethod.GET, uri);\n-                    timeoutsRecovered++; // recoverd\n-                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n                 } else {\n-                    throw e;\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n-            } catch (ShellyApiException e2) {\n-                throw e2;\n             }\n         }\n-        return apiResult.response;\n+        return result;\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n-\n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"HTTP Response: {}\", response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUrlPrefix(Integer id) {\n-        Validate.notNull(profile);\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n+        }\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n         }\n-        uri = uri + \"/\" + id.toString();\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n-    }\n-\n-    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String deviceType, String urlParm) throws ShellyApiException {\n-        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n-                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n-    }\n \n-    private static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String type, String parameter) throws ShellyApiException {\n-        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"\n-                + index + \"?type=\" + StringUtils.substringBefore(parameter, \"_url\");\n-        return urlEncode(url);\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402677126", "bodyText": "Can you give an option to support https for the callback or does shelly not support it?", "author": "cpmeister", "createdAt": "2020-04-03T00:50:24Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -465,71 +443,110 @@ private void setEventUrls(Integer index) throws IOException {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(\n-                        thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        try {\n+            apiResult = innerRequest(HttpMethod.GET, uri);\n+        } catch (ShellyApiException e) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(\n-                            thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                if (e.isTimeout() && profile.isSensor) {\n+                    // Sensor in sleep mode\n+                    throw e;\n+                }\n+                if (e.isTimeout()) {\n+                    timeoutErrors++; // count the retries\n+                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++; // recoverd\n+                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n                 } else {\n-                    throw new IOException(\n-                            thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                    throw e;\n                 }\n+            } catch (ShellyApiException e2) {\n+                throw e2;\n             }\n         }\n-        return result;\n+        return apiResult.response;\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    @SuppressWarnings(\"null\")\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n+\n+            // validate response, API errors are reported as Json\n+            logger.trace(\"HTTP Response: {}\", response);\n+            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n+                throw new ShellyApiException(apiResult);\n+            }\n+            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n+                throw new ShellyApiException(\"Unexpected response: \" + response);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n+            throw new ShellyApiException(apiResult, e);\n         }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        return apiResult;\n+    }\n+\n+    public String getControlUrlPrefix(Integer id) {\n+        Validate.notNull(profile);\n+        String uri = \"\";\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isDuo || profile.isDimmer) {\n+                // Duo + Dimmer\n+                uri = SHELLY_URL_CONTROL_LIGHT;\n+            } else {\n+                // Bulb + RGBW2\n+                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+            }\n+        } else {\n+            // Roller, Relay\n+            uri = SHELLY_URL_CONTROL_RELEAY;\n         }\n+        uri = uri + \"/\" + id.toString();\n+        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n+        return uri;\n+    }\n+\n+    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String deviceType, String urlParm) throws ShellyApiException {\n+        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n+                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n+    }\n \n-        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n-        return httpResponse;\n+    private static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String type, String parameter) throws ShellyApiException {\n+        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436596", "bodyText": "No, the devices don't support https for resource constraints", "author": "markus7017", "createdAt": "2020-04-04T07:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzEyNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex ad634fad34..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -443,110 +465,68 @@ public class ShellyHttpApi {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        try {\n-            apiResult = innerRequest(HttpMethod.GET, uri);\n-        } catch (ShellyApiException e) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                if (e.isTimeout() && profile.isSensor) {\n-                    // Sensor in sleep mode\n-                    throw e;\n-                }\n-                if (e.isTimeout()) {\n-                    timeoutErrors++; // count the retries\n-                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n-                    apiResult = innerRequest(HttpMethod.GET, uri);\n-                    timeoutsRecovered++; // recoverd\n-                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n                 } else {\n-                    throw e;\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n-            } catch (ShellyApiException e2) {\n-                throw e2;\n             }\n         }\n-        return apiResult.response;\n+        return result;\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n-\n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"HTTP Response: {}\", response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUrlPrefix(Integer id) {\n-        Validate.notNull(profile);\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n+        }\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n         }\n-        uri = uri + \"/\" + id.toString();\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n-    }\n-\n-    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String deviceType, String urlParm) throws ShellyApiException {\n-        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n-                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n-    }\n \n-    private static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String type, String parameter) throws ShellyApiException {\n-        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"\n-                + index + \"?type=\" + StringUtils.substringBefore(parameter, \"_url\");\n-        return urlEncode(url);\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzQyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402677423", "bodyText": "Can this NPE be prevented or do you have to catch it?", "author": "cpmeister", "createdAt": "2020-04-03T00:51:27Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -288,35 +300,32 @@ private void addSensor(CoIotDescrSen sen) {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) {\n+        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403441991", "bodyText": "The Coap descriptions are somehow buggy, esp. with old firmware releases. I did my best to catch those and transform in the correct format, but I want to make sure that a malformed format doesn't breaks the processing.", "author": "markus7017", "createdAt": "2020-04-04T08:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzQyMw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex c38aed87be..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -300,32 +288,35 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy\n+        } catch (NullPointerException e) {\n             logger.debug(\"{}:    Unable to decode sensor definition -> skip ({})\\n{}\", thingName, e.getMessage(),\n                     e.getStackTrace());\n         }\n     }\n \n     /**\n-     * Process CoIoT status update message. If a status update is received, but the device description has not been\n-     * received yet a GET is send to query device description.\n+     * Process CoIoT status update message. If a status update is received, but the\n+     * device description has not been received yet a GET is send to query device\n+     * description.\n      *\n      * @param devId device id included in the status packet\n      * @param payload Coap payload (Json format), example: {\"G\":[[0,112,0]]}\n      * @param serial Serial for this request. If this the the same as last serial\n      *            the update was already sent and processed so this one gets\n      *            ignored.\n+     * @throws IOException Exception on sending GET for device description.\n      */\n     @SuppressWarnings({ \"null\", \"unused\" })\n-    private void handleStatusUpdate(String devId, String payload, int serial) {\n+    private void handleStatusUpdate(String devId, String payload, int serial) throws IOException {\n+        // payload = StringUtils.substringBefore(payload, \"]]}\") + \"]]}\";\n         logger.debug(\"{}: CoIoT Sensor data {}\", thingName, payload);\n-        if (blockMap.size() == 0) {\n+        if (blockMap.isEmpty()) {\n             // send discovery packet\n             resetSerial();\n             reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n             // try to uses description from last initialization\n-            String savedDescr = th.getProperty(PROPERTY_COAP_DESCR);\n+            String savedDescr = thingHandler.getProperty(PROPERTY_COAP_DESCR);\n             if (savedDescr.isEmpty()) {\n                 logger.debug(\"{}: Device description not yet received, trigger auto-initialization\", thingName);\n                 return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3ODk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402678960", "bodyText": "orphan semicolon", "author": "cpmeister", "createdAt": "2020-04-03T00:57:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436628", "bodyText": "easy fix :-)", "author": "markus7017", "createdAt": "2020-04-04T07:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3ODk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 5befc7433e..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -93,36 +70,46 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n-            ;\n-\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679227", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());\n          \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.toString(), e);", "author": "cpmeister", "createdAt": "2020-04-03T00:58:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;\n+\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n             logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n-            }\n-\n             // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+                ShellySettingsDevice devInfo = api.getDevInfo();\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", getString(devInfo.hostname), profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address, e.toString()));\n+                    logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MDc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403440773", "bodyText": "ok, removed all references to e.getStackTrace(), thanks for the heads-up", "author": "markus7017", "createdAt": "2020-04-04T08:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTIyNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 5befc7433e..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -93,36 +70,46 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n-            ;\n-\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTQyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679429", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\\n{}\", name, getString(e),\n          \n          \n            \n                                    getString(e.getClass().toString()), e.getStackTrace());\n          \n          \n            \n                            logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\", name, getString(e),\n          \n          \n            \n                                    getString(e.getClass().toString()), e);", "author": "cpmeister", "createdAt": "2020-04-03T00:59:04Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;\n+\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n             logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n-            }\n-\n             // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+                ShellySettingsDevice devInfo = api.getDevInfo();\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", getString(devInfo.hostname), profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address, e.toString()));\n+                    logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\\n{}\", name, getString(e),\n+                        getString(e.getClass().toString()), e.getStackTrace());", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MTg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403441875", "bodyText": "removed all references to e.getStackTrace()", "author": "markus7017", "createdAt": "2020-04-04T08:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 5befc7433e..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -93,36 +70,46 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n-            ;\n-\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679729", "bodyText": "Don't call e.getStacktrace() as part of logging. Just use the exception as the last argument instead.\nSee other comments for examples.", "author": "cpmeister", "createdAt": "2020-04-03T01:00:11Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -162,13 +174,13 @@ public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n+                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n-                    e.getMessage(), e);\n+        } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, getString(e)));\n+            logger.debug(\"{}: Exception {}\\n{}\", name, e.getClass(), e.getStackTrace());", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403441879", "bodyText": "removed all references to e.getStackTrace()", "author": "markus7017", "createdAt": "2020-04-04T08:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 5befc7433e..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -174,13 +162,13 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n+                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, getString(e)));\n-            logger.debug(\"{}: Exception {}\\n{}\", name, e.getClass(), e.getStackTrace());\n+        } catch (NullPointerException e) {\n+            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n+                    e.getMessage(), e);\n         }\n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402680005", "bodyText": "Any reason you can't use primitives instead?", "author": "cpmeister", "createdAt": "2020-04-03T01:01:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -29,10 +28,34 @@\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n+    OnOffType power = OnOffType.OFF;\n+    String mode = \"\";\n+\n+    Integer red = 0;\n+    Integer green = 0;\n+    Integer blue = 0;\n+    Integer white = 0;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442500", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-04T08:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\nindex e113c8e4aa..354e637844 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\n\n@@ -28,34 +29,10 @@ import org.eclipse.smarthome.core.library.types.PercentType;\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n-    OnOffType power = OnOffType.OFF;\n-    String mode = \"\";\n-\n-    Integer red = 0;\n-    Integer green = 0;\n-    Integer blue = 0;\n-    Integer white = 0;\n-    PercentType percentRed = new PercentType(0);\n-    PercentType percentGreen = new PercentType(0);\n-    PercentType percentBlue = new PercentType(0);\n-    PercentType percentWhite = new PercentType(0);\n-\n-    Integer gain = 0;\n-    Integer brightness = 0;\n-    Integer temp = 0;\n-    Integer minTemp = 0;\n-    Integer maxTemp = 0;\n-    PercentType percentGain = new PercentType(0);\n-    PercentType percentBrightness = new PercentType(0);\n-    PercentType percentTemp = new PercentType(0);\n-    Integer effect = 0;\n-\n     public ShellyColorUtils() {\n     }\n \n     public ShellyColorUtils(ShellyColorUtils col) {\n-        minTemp = col.minTemp;\n-        maxTemp = col.maxTemp;\n         setRed(col.red);\n         setGreen(col.green);\n         setBlue(col.blue);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402680387", "bodyText": "Shouldn't the null checking been handled already by the static analyzer. Why do you need to check again? Or better question: why did you make the parameter non-null?", "author": "cpmeister", "createdAt": "2020-04-03T01:02:42Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -172,8 +172,9 @@ public static PercentType toPercent(Integer value) {\n         return toPercent(value, 0, SHELLY_MAX_COLOR);\n     }\n \n-    public static PercentType toPercent(@Nullable Integer _value, Integer min, Integer max) {\n+    public static PercentType toPercent(Integer _value, Integer min, Integer max) {\n         Double range = max.doubleValue() - min.doubleValue();\n+        @SuppressWarnings(\"null\")\n         Double value = _value != null ? _value.doubleValue() : 0;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442923", "bodyText": "change, see general notes below", "author": "markus7017", "createdAt": "2020-04-04T08:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\nindex e113c8e4aa..354e637844 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\n\n@@ -172,9 +172,8 @@ public class ShellyColorUtils {\n         return toPercent(value, 0, SHELLY_MAX_COLOR);\n     }\n \n-    public static PercentType toPercent(Integer _value, Integer min, Integer max) {\n+    public static PercentType toPercent(@Nullable Integer _value, Integer min, Integer max) {\n         Double range = max.doubleValue() - min.doubleValue();\n-        @SuppressWarnings(\"null\")\n         Double value = _value != null ? _value.doubleValue() : 0;\n         value = value < min ? min.doubleValue() : value;\n         value = value > max ? max.doubleValue() : value;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402681167", "bodyText": "Was this removed intentionally?", "author": "cpmeister", "createdAt": "2020-04-03T01:05:50Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -400,34 +415,25 @@ public boolean updateRelays(ShellySettingsStatus status) throws IOException {\n      * @param profile ShellyDeviceProfile\n      * @param status Last ShellySettingsStatus\n      *\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws IOException {\n-        ShellyDeviceProfile profile = getProfile();\n-\n+    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws ShellyApiException {\n         boolean updated = false;\n         if (profile.isDimmer) {\n-            Validate.notNull(orgStatus, \"orgStatus must not be null!\");\n-\n             // We need to fixup the returned Json: The dimmer returns light[] element, which is ok, but it doesn't have\n-            // the same structure as lights[] from Bulb and RGBW2. The tag gets replaced by dimmers[] so that Gson maps\n-            // to a different structure (ShellyShortLight).\n+            // the same structure as lights[] from Bulb,RGBW2 and Duo. The tag gets replaced by dimmers[] so that Gson\n+            // maps to a different structure (ShellyShortLight).\n             Gson gson = new Gson();\n             ShellySettingsStatus dstatus = gson.fromJson(ShellyApiJsonDTO.fixDimmerJson(orgStatus.json),\n                     ShellySettingsStatus.class);\n             Validate.notNull(dstatus.dimmers, \"dstatus.dimmers must not be null!\");\n-            Validate.notNull(dstatus.tmp, \"dstatus.tmp must not be null!\");\n \n             logger.trace(\"{}: Updating {}\u00a0dimmers(s)\", thingName, dstatus.dimmers.size());\n-\n             int l = 0;\n-            logger.trace(\"{}: Updating dimmers {}\", thingName, dstatus.dimmers.size());\n             for (ShellyShortLightStatus dimmer : dstatus.dimmers) {\n                 Integer r = l + 1;\n                 String groupName = profile.numRelays <= 1 ? CHANNEL_GROUP_DIMMER_CONTROL\n                         : CHANNEL_GROUP_DIMMER_CONTROL + r.toString();\n-                // updated |= updateChannel(groupName, CHANNEL_OUTPUT, getOnOff(dimmer.ison));", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686330", "bodyText": "Could you please re-check, my code doesn't show this line - strange", "author": "markus7017", "createdAt": "2020-04-05T11:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NTExMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406165113", "bodyText": "ah', this was removed, because the Dimmer on/off is now moved in the general brightness handling (on/off is an integrated part of the UI control)", "author": "markus7017", "createdAt": "2020-04-09T12:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java\nindex 7e1abf6314..77bba451ff 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java\n\n@@ -415,25 +400,34 @@ public class ShellyRelayHandler extends ShellyBaseHandler {\n      * @param profile ShellyDeviceProfile\n      * @param status Last ShellySettingsStatus\n      *\n-     * @throws ShellyApiException\n+     * @throws IOException\n      */\n-    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws IOException {\n+        ShellyDeviceProfile profile = getProfile();\n+\n         boolean updated = false;\n         if (profile.isDimmer) {\n+            Validate.notNull(orgStatus, \"orgStatus must not be null!\");\n+\n             // We need to fixup the returned Json: The dimmer returns light[] element, which is ok, but it doesn't have\n-            // the same structure as lights[] from Bulb,RGBW2 and Duo. The tag gets replaced by dimmers[] so that Gson\n-            // maps to a different structure (ShellyShortLight).\n+            // the same structure as lights[] from Bulb and RGBW2. The tag gets replaced by dimmers[] so that Gson maps\n+            // to a different structure (ShellyShortLight).\n             Gson gson = new Gson();\n             ShellySettingsStatus dstatus = gson.fromJson(ShellyApiJsonDTO.fixDimmerJson(orgStatus.json),\n                     ShellySettingsStatus.class);\n             Validate.notNull(dstatus.dimmers, \"dstatus.dimmers must not be null!\");\n+            Validate.notNull(dstatus.tmp, \"dstatus.tmp must not be null!\");\n \n             logger.trace(\"{}: Updating {}\u00a0dimmers(s)\", thingName, dstatus.dimmers.size());\n+\n             int l = 0;\n+            logger.trace(\"{}: Updating dimmers {}\", thingName, dstatus.dimmers.size());\n             for (ShellyShortLightStatus dimmer : dstatus.dimmers) {\n                 Integer r = l + 1;\n                 String groupName = profile.numRelays <= 1 ? CHANNEL_GROUP_DIMMER_CONTROL\n                         : CHANNEL_GROUP_DIMMER_CONTROL + r.toString();\n+                // updated |= updateChannel(groupName, CHANNEL_OUTPUT, getOnOff(dimmer.ison));\n \n                 // On a status update we map a dimmer.ison = false to brightness 0 rather than the device's brightness\n                 // and send a OFF status to the same channel.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402681762", "bodyText": "Can these exceptions be prevented?", "author": "cpmeister", "createdAt": "2020-04-03T01:08:03Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686394", "bodyText": "catch NullPointerException removed", "author": "markus7017", "createdAt": "2020-04-05T11:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTc2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 926642cb9b..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.Validate;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private String thingName = \"\";\n-    private Map<String, Object> channelData = new HashMap<>();\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        this.thingName = thingHandler.thingName;\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n-        try {\n-            Object current = channelData.get(channelId);\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, value);\n-                synchronized (channelData) {\n-                    if (current == null) {\n-                        channelData.put(channelId, value);\n-                    } else {\n-                        channelData.replace(channelId, value);\n-                    }\n-                }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        synchronized (channelData) {\n-            return channelData.get(channelId);\n-        }\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        Validate.notNull(channelId);\n-        synchronized (channelData) {\n-            if (channelData.containsKey(channelId)) {\n-                channelData.remove(channelId);\n-            }\n-        }\n-\n-    }\n-\n-    public void clear() {\n-        channelData = new HashMap<>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjEzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682138", "bodyText": "Why not just use put every time?", "author": "cpmeister", "createdAt": "2020-04-03T01:09:24Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686476", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 926642cb9b..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.Validate;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private String thingName = \"\";\n-    private Map<String, Object> channelData = new HashMap<>();\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        this.thingName = thingHandler.thingName;\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n-        try {\n-            Object current = channelData.get(channelId);\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, value);\n-                synchronized (channelData) {\n-                    if (current == null) {\n-                        channelData.put(channelId, value);\n-                    } else {\n-                        channelData.replace(channelId, value);\n-                    }\n-                }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        synchronized (channelData) {\n-            return channelData.get(channelId);\n-        }\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        Validate.notNull(channelId);\n-        synchronized (channelData) {\n-            if (channelData.containsKey(channelId)) {\n-                channelData.remove(channelId);\n-            }\n-        }\n-\n-    }\n-\n-    public void clear() {\n-        channelData = new HashMap<>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjI4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682285", "bodyText": "Why bother checking if it contains? Just call remove to begin with.", "author": "cpmeister", "createdAt": "2020-04-03T01:09:56Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {\n+        synchronized (channelData) {\n+            return channelData.get(channelId);\n+        }\n+    }\n+\n+    public void resetChannel(String channelId) {\n+        Validate.notNull(channelId);\n+        synchronized (channelData) {\n+            if (channelData.containsKey(channelId)) {\n+                channelData.remove(channelId);\n+            }", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686594", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 926642cb9b..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.Validate;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private String thingName = \"\";\n-    private Map<String, Object> channelData = new HashMap<>();\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        this.thingName = thingHandler.thingName;\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n-        try {\n-            Object current = channelData.get(channelId);\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, value);\n-                synchronized (channelData) {\n-                    if (current == null) {\n-                        channelData.put(channelId, value);\n-                    } else {\n-                        channelData.replace(channelId, value);\n-                    }\n-                }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        synchronized (channelData) {\n-            return channelData.get(channelId);\n-        }\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        Validate.notNull(channelId);\n-        synchronized (channelData) {\n-            if (channelData.containsKey(channelId)) {\n-                channelData.remove(channelId);\n-            }\n-        }\n-\n-    }\n-\n-    public void clear() {\n-        channelData = new HashMap<>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682576", "bodyText": "All of your synchronization on this field is done only for single operations. Why not just make this a ConcurrentHashMap instead so you don't need to do synchronization around it?", "author": "cpmeister", "createdAt": "2020-04-03T01:10:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjgxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682811", "bodyText": "Also, you can make this field final.", "author": "cpmeister", "createdAt": "2020-04-03T01:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MzEzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403983133", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-06T10:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 926642cb9b..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.Validate;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private String thingName = \"\";\n-    private Map<String, Object> channelData = new HashMap<>();\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        this.thingName = thingHandler.thingName;\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n-        try {\n-            Object current = channelData.get(channelId);\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, value);\n-                synchronized (channelData) {\n-                    if (current == null) {\n-                        channelData.put(channelId, value);\n-                    } else {\n-                        channelData.replace(channelId, value);\n-                    }\n-                }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        synchronized (channelData) {\n-            return channelData.get(channelId);\n-        }\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        Validate.notNull(channelId);\n-        synchronized (channelData) {\n-            if (channelData.containsKey(channelId)) {\n-                channelData.remove(channelId);\n-            }\n-        }\n-\n-    }\n-\n-    public void clear() {\n-        channelData = new HashMap<>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjczNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682734", "bodyText": "No need to be wasteful.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    channelData = new HashMap<>();\n          \n          \n            \n                    channelData.clear();", "author": "cpmeister", "createdAt": "2020-04-03T01:11:36Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {\n+        synchronized (channelData) {\n+            return channelData.get(channelId);\n+        }\n+    }\n+\n+    public void resetChannel(String channelId) {\n+        Validate.notNull(channelId);\n+        synchronized (channelData) {\n+            if (channelData.containsKey(channelId)) {\n+                channelData.remove(channelId);\n+            }\n+        }\n+\n+    }\n+\n+    public void clear() {\n+        channelData = new HashMap<>();", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjcyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686721", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjczNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 926642cb9b..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.Validate;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private String thingName = \"\";\n-    private Map<String, Object> channelData = new HashMap<>();\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        this.thingName = thingHandler.thingName;\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n-        try {\n-            Object current = channelData.get(channelId);\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, value);\n-                synchronized (channelData) {\n-                    if (current == null) {\n-                        channelData.put(channelId, value);\n-                    } else {\n-                        channelData.replace(channelId, value);\n-                    }\n-                }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        synchronized (channelData) {\n-            return channelData.get(channelId);\n-        }\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        Validate.notNull(channelId);\n-        synchronized (channelData) {\n-            if (channelData.containsKey(channelId)) {\n-                channelData.remove(channelId);\n-            }\n-        }\n-\n-    }\n-\n-    public void clear() {\n-        channelData = new HashMap<>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402683431", "bodyText": "Static analysis should have made these validation checks redundant.\nAlso, how is channelData supposed to be null here anyhow?", "author": "cpmeister", "createdAt": "2020-04-03T01:14:20Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MzI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403983240", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-06T10:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzQzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 926642cb9b..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,142 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.Validate;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private String thingName = \"\";\n-    private Map<String, Object> channelData = new HashMap<>();\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        this.thingName = thingHandler.thingName;\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n-        try {\n-            Object current = channelData.get(channelId);\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, value);\n-                synchronized (channelData) {\n-                    if (current == null) {\n-                        channelData.put(channelId, value);\n-                    } else {\n-                        channelData.replace(channelId, value);\n-                    }\n-                }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        synchronized (channelData) {\n-            return channelData.get(channelId);\n-        }\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        Validate.notNull(channelId);\n-        synchronized (channelData) {\n-            if (channelData.containsKey(channelId)) {\n-                channelData.remove(channelId);\n-            }\n-        }\n-\n-    }\n-\n-    public void clear() {\n-        channelData = new HashMap<>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402683918", "bodyText": "Can these be made final?", "author": "cpmeister", "createdAt": "2020-04-03T01:16:20Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private @Nullable Bundle bundle;\n+    private @Nullable TranslationProvider i18nProvider;\n+    private @Nullable LocaleProvider localeProvider;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java\ndeleted file mode 100644\nindex 860add2fa8..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java\n+++ /dev/null\n\n@@ -1,67 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import java.util.Locale;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.i18n.LocaleProvider;\n-import org.eclipse.smarthome.core.i18n.TranslationProvider;\n-import org.osgi.framework.Bundle;\n-\n-/**\n- * {@link ShellyTranslationProvider} provides i18n message lookup\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyTranslationProvider {\n-\n-    private @Nullable Bundle bundle;\n-    private @Nullable TranslationProvider i18nProvider;\n-    private @Nullable LocaleProvider localeProvider;\n-\n-    public ShellyTranslationProvider() {\n-    }\n-\n-    public ShellyTranslationProvider(Bundle bundle, TranslationProvider i18nProvider, LocaleProvider localeProvider) {\n-        this.bundle = bundle;\n-        this.i18nProvider = i18nProvider;\n-        this.localeProvider = localeProvider;\n-    }\n-\n-    public ShellyTranslationProvider(final ShellyTranslationProvider other) {\n-        initFrom(other);\n-    }\n-\n-    public ShellyTranslationProvider initFrom(final ShellyTranslationProvider other) {\n-        this.bundle = other.bundle;\n-        this.i18nProvider = other.i18nProvider;\n-        this.localeProvider = other.localeProvider;\n-        return this;\n-    }\n-\n-    public @Nullable String get(String key, @Nullable Object... arguments) {\n-        return getText(key.contains(\"@text/\") || key.contains(\".shelly.\") ? key : \"message.\" + key, arguments);\n-    }\n-\n-    public @Nullable String getText(String key, @Nullable Object... arguments) {\n-        Locale locale = localeProvider != null ? localeProvider.getLocale() : Locale.ENGLISH;\n-        return i18nProvider != null ? i18nProvider.getText(bundle, key, getDefaultText(key), locale, arguments) : key;\n-    }\n-\n-    public @Nullable String getDefaultText(String key) {\n-        return i18nProvider != null ? i18nProvider.getText(bundle, key, key, Locale.ENGLISH) : key;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDExNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684116", "bodyText": "getMessage is a more appropriate name for this method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String getString(Exception e) {\n          \n          \n            \n                public static String getMessage(Exception e) {", "author": "cpmeister", "createdAt": "2020-04-03T01:17:01Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java", "diffHunk": "@@ -55,6 +55,11 @@ public static String getString(@Nullable String value) {\n         return value != null ? value : \"\";\n     }\n \n+    public static String getString(Exception e) {", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzAzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687039", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDExNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyUtils.java\nsimilarity index 83%\nrename from bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java\nrename to bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyUtils.java\nindex 8c54691e14..0f71af465d 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyUtils.java\n\n@@ -55,11 +55,6 @@ public class ShellyUtils {\n         return value != null ? value : \"\";\n     }\n \n-    public static String getString(Exception e) {\n-        String message = e.getMessage();\n-        return message != null ? message : \"\";\n-    }\n-\n     public static Integer getInteger(@Nullable Integer value) {\n         return (value != null ? (Integer) value : 0);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684481", "bodyText": "Should you also pass the cause exception?", "author": "cpmeister", "createdAt": "2020-04-03T01:18:22Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java", "diffHunk": "@@ -116,24 +121,11 @@ public static void validateRange(String name, Integer value, Integer min, Intege\n                 \"Value \" + name + \" is out of range (\" + min.toString() + \"-\" + max.toString() + \")\");\n     }\n \n-    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String deviceType, String urlParm) throws IOException {\n-        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n-                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n-    }\n-\n-    public static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String type, String parameter) throws IOException {\n-        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"\n-                + index + \"?type=\" + StringUtils.substringBefore(parameter, \"_url\");\n-        return urlEncode(url);\n-    }\n-\n-    public static String urlEncode(String input) throws IOException {\n+    public static String urlEncode(String input) throws ShellyApiException {\n         try {\n             return URLEncoder.encode(input, StandardCharsets.UTF_8.toString());\n         } catch (UnsupportedEncodingException e) {\n-            throw new IOException(\n+            throw new ShellyApiException(\n                     \"Unsupported encoding format: \" + StandardCharsets.UTF_8.toString() + \", input=\" + input);", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687283", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyUtils.java\nsimilarity index 83%\nrename from bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java\nrename to bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyUtils.java\nindex 8c54691e14..0f71af465d 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyUtils.java\n\n@@ -121,11 +116,24 @@ public class ShellyUtils {\n                 \"Value \" + name + \" is out of range (\" + min.toString() + \"-\" + max.toString() + \")\");\n     }\n \n-    public static String urlEncode(String input) throws ShellyApiException {\n+    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String deviceType, String urlParm) throws IOException {\n+        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n+                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n+    }\n+\n+    public static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String type, String parameter) throws IOException {\n+        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"\n+                + index + \"?type=\" + StringUtils.substringBefore(parameter, \"_url\");\n+        return urlEncode(url);\n+    }\n+\n+    public static String urlEncode(String input) throws IOException {\n         try {\n             return URLEncoder.encode(input, StandardCharsets.UTF_8.toString());\n         } catch (UnsupportedEncodingException e) {\n-            throw new ShellyApiException(\n+            throw new IOException(\n                     \"Unsupported encoding format: \" + StandardCharsets.UTF_8.toString() + \", input=\" + input);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684704", "bodyText": "Field and variable names should be camelcase.", "author": "cpmeister", "createdAt": "2020-04-03T01:19:11Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {\n+    private class VersionTokenizer {\n+        private final String _versionString;\n+        private final int _length;\n+\n+        private int _position;\n+        private int _number;\n+        private String _suffix = \"\";", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687592", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDcwNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\ndeleted file mode 100644\nindex 1f44853c1a..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n+++ /dev/null\n\n@@ -1,176 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import java.util.Comparator;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * {@link ShellyVersionDTO} compares 2 version strings.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyVersionDTO implements Comparator<Object> {\n-    private class VersionTokenizer {\n-        private final String _versionString;\n-        private final int _length;\n-\n-        private int _position;\n-        private int _number;\n-        private String _suffix = \"\";\n-\n-        public VersionTokenizer(@Nullable String versionString) {\n-            if (versionString == null) {\n-                throw new IllegalArgumentException(\"versionString is null\");\n-            }\n-\n-            _versionString = versionString;\n-            _length = versionString.length();\n-        }\n-\n-        public boolean MoveNext() {\n-            _number = 0;\n-            _suffix = \"\";\n-\n-            // No more characters\n-            if (_position >= _length) {\n-                return false;\n-            }\n-\n-            while (_position < _length) {\n-                char c = _versionString.charAt(_position);\n-                if (c < '0' || c > '9') {\n-                    break;\n-                }\n-                _number = _number * 10 + (c - '0');\n-                _position++;\n-            }\n-\n-            int suffixStart = _position;\n-\n-            while (_position < _length) {\n-                char c = _versionString.charAt(_position);\n-                if (c == '.') {\n-                    break;\n-                }\n-                _position++;\n-            }\n-\n-            _suffix = _versionString.substring(suffixStart, _position);\n-\n-            if (_position < _length) {\n-                _position++;\n-            }\n-\n-            return true;\n-        }\n-\n-        public int getNumber() {\n-            return _number;\n-        }\n-\n-        public String getSuffix() {\n-            return _suffix;\n-        }\n-    }\n-\n-    public boolean equals(String o1, String o2) {\n-        return compare(o1, o2) == 0;\n-    }\n-\n-    @Override\n-    public int compare(Object o1, Object o2) {\n-        String version1 = (String) o1;\n-        String version2 = (String) o2;\n-\n-        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n-        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n-\n-        int number1 = 0, number2 = 0;\n-        String suffix1 = \"\", suffix2 = \"\";\n-\n-        while (tokenizer1.MoveNext()) {\n-            if (!tokenizer2.MoveNext()) {\n-                do {\n-                    number1 = tokenizer1.getNumber();\n-                    suffix1 = tokenizer1.getSuffix();\n-                    if (number1 != 0 || suffix1.length() != 0) {\n-                        // Version one is longer than number two, and non-zero\n-                        return 1;\n-                    }\n-                } while (tokenizer1.MoveNext());\n-\n-                // Version one is longer than version two, but zero\n-                return 0;\n-            }\n-\n-            number1 = tokenizer1.getNumber();\n-            suffix1 = tokenizer1.getSuffix();\n-            number2 = tokenizer2.getNumber();\n-            suffix2 = tokenizer2.getSuffix();\n-\n-            if (number1 < number2) {\n-                // Number one is less than number two\n-                return -1;\n-            }\n-            if (number1 > number2) {\n-                // Number one is greater than number two\n-                return 1;\n-            }\n-\n-            boolean empty1 = suffix1.length() == 0;\n-            boolean empty2 = suffix2.length() == 0;\n-\n-            if (empty1 && empty2) {\n-                continue;\n-            } // No suffixes\n-            if (empty1) {\n-                return 1;\n-            } // First suffix is empty (1.2 > 1.2b)\n-            if (empty2) {\n-                return -1;\n-            } // Second suffix is empty (1.2a < 1.2)\n-\n-            // Lexical comparison of suffixes\n-            int result = suffix1.compareTo(suffix2);\n-            if (result != 0) {\n-                return result;\n-            }\n-\n-        }\n-        if (tokenizer2.MoveNext()) {\n-            do {\n-                number2 = tokenizer2.getNumber();\n-                suffix2 = tokenizer2.getSuffix();\n-                if (number2 != 0 || suffix2.length() != 0) {\n-                    // Version one is longer than version two, and non-zero\n-                    return -1;\n-                }\n-            } while (tokenizer2.MoveNext());\n-\n-            // Version two is longer than version one, but zero\n-            return 0;\n-        }\n-        return 0;\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean checkBeta(@Nullable String version) {\n-        return version != null & (version.isEmpty() || version.contains(\"???\")\n-                || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));\n-\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402685281", "bodyText": "I disagree with a DTO class implementing Comparator and instead it should be either a lambda, an anonymous class, or a named nested class in this DTO.\nThe best suggestion I can give to to make VersionTokenizer implement Comparable<VersionTokenizer>", "author": "cpmeister", "createdAt": "2020-04-03T01:21:34Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzOTA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405339056", "bodyText": "How to do that? My Java skills are limited", "author": "markus7017", "createdAt": "2020-04-08T08:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407029289", "bodyText": "@cpmeister could you help here?", "author": "markus7017", "createdAt": "2020-04-11T07:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0OTg3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407149877", "bodyText": "Where is this class used as a comparator?", "author": "cpmeister", "createdAt": "2020-04-12T05:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235107", "bodyText": "I removed the comparator, ShellyBaseHandler directly calls .compare()", "author": "markus7017", "createdAt": "2020-04-12T18:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\ndeleted file mode 100644\nindex 1f44853c1a..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n+++ /dev/null\n\n@@ -1,176 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import java.util.Comparator;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * {@link ShellyVersionDTO} compares 2 version strings.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyVersionDTO implements Comparator<Object> {\n-    private class VersionTokenizer {\n-        private final String _versionString;\n-        private final int _length;\n-\n-        private int _position;\n-        private int _number;\n-        private String _suffix = \"\";\n-\n-        public VersionTokenizer(@Nullable String versionString) {\n-            if (versionString == null) {\n-                throw new IllegalArgumentException(\"versionString is null\");\n-            }\n-\n-            _versionString = versionString;\n-            _length = versionString.length();\n-        }\n-\n-        public boolean MoveNext() {\n-            _number = 0;\n-            _suffix = \"\";\n-\n-            // No more characters\n-            if (_position >= _length) {\n-                return false;\n-            }\n-\n-            while (_position < _length) {\n-                char c = _versionString.charAt(_position);\n-                if (c < '0' || c > '9') {\n-                    break;\n-                }\n-                _number = _number * 10 + (c - '0');\n-                _position++;\n-            }\n-\n-            int suffixStart = _position;\n-\n-            while (_position < _length) {\n-                char c = _versionString.charAt(_position);\n-                if (c == '.') {\n-                    break;\n-                }\n-                _position++;\n-            }\n-\n-            _suffix = _versionString.substring(suffixStart, _position);\n-\n-            if (_position < _length) {\n-                _position++;\n-            }\n-\n-            return true;\n-        }\n-\n-        public int getNumber() {\n-            return _number;\n-        }\n-\n-        public String getSuffix() {\n-            return _suffix;\n-        }\n-    }\n-\n-    public boolean equals(String o1, String o2) {\n-        return compare(o1, o2) == 0;\n-    }\n-\n-    @Override\n-    public int compare(Object o1, Object o2) {\n-        String version1 = (String) o1;\n-        String version2 = (String) o2;\n-\n-        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n-        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n-\n-        int number1 = 0, number2 = 0;\n-        String suffix1 = \"\", suffix2 = \"\";\n-\n-        while (tokenizer1.MoveNext()) {\n-            if (!tokenizer2.MoveNext()) {\n-                do {\n-                    number1 = tokenizer1.getNumber();\n-                    suffix1 = tokenizer1.getSuffix();\n-                    if (number1 != 0 || suffix1.length() != 0) {\n-                        // Version one is longer than number two, and non-zero\n-                        return 1;\n-                    }\n-                } while (tokenizer1.MoveNext());\n-\n-                // Version one is longer than version two, but zero\n-                return 0;\n-            }\n-\n-            number1 = tokenizer1.getNumber();\n-            suffix1 = tokenizer1.getSuffix();\n-            number2 = tokenizer2.getNumber();\n-            suffix2 = tokenizer2.getSuffix();\n-\n-            if (number1 < number2) {\n-                // Number one is less than number two\n-                return -1;\n-            }\n-            if (number1 > number2) {\n-                // Number one is greater than number two\n-                return 1;\n-            }\n-\n-            boolean empty1 = suffix1.length() == 0;\n-            boolean empty2 = suffix2.length() == 0;\n-\n-            if (empty1 && empty2) {\n-                continue;\n-            } // No suffixes\n-            if (empty1) {\n-                return 1;\n-            } // First suffix is empty (1.2 > 1.2b)\n-            if (empty2) {\n-                return -1;\n-            } // Second suffix is empty (1.2a < 1.2)\n-\n-            // Lexical comparison of suffixes\n-            int result = suffix1.compareTo(suffix2);\n-            if (result != 0) {\n-                return result;\n-            }\n-\n-        }\n-        if (tokenizer2.MoveNext()) {\n-            do {\n-                number2 = tokenizer2.getNumber();\n-                suffix2 = tokenizer2.getSuffix();\n-                if (number2 != 0 || suffix2.length() != 0) {\n-                    // Version one is longer than version two, and non-zero\n-                    return -1;\n-                }\n-            } while (tokenizer2.MoveNext());\n-\n-            // Version two is longer than version one, but zero\n-            return 0;\n-        }\n-        return 0;\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean checkBeta(@Nullable String version) {\n-        return version != null & (version.isEmpty() || version.contains(\"???\")\n-                || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));\n-\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NjM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402686372", "bodyText": "This fix will allow you to remove the warning suppression for this method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return version != null & (version.isEmpty() || version.contains(\"???\")\n          \n          \n            \n                            || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));\n          \n          \n            \n                    return version != null && (version.isEmpty() || version.contains(\"???\")\n          \n          \n            \n                            || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));", "author": "cpmeister", "createdAt": "2020-04-03T01:25:40Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {\n+    private class VersionTokenizer {\n+        private final String _versionString;\n+        private final int _length;\n+\n+        private int _position;\n+        private int _number;\n+        private String _suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            _versionString = versionString;\n+            _length = versionString.length();\n+        }\n+\n+        public boolean MoveNext() {\n+            _number = 0;\n+            _suffix = \"\";\n+\n+            // No more characters\n+            if (_position >= _length) {\n+                return false;\n+            }\n+\n+            while (_position < _length) {\n+                char c = _versionString.charAt(_position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                _number = _number * 10 + (c - '0');\n+                _position++;\n+            }\n+\n+            int suffixStart = _position;\n+\n+            while (_position < _length) {\n+                char c = _versionString.charAt(_position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                _position++;\n+            }\n+\n+            _suffix = _versionString.substring(suffixStart, _position);\n+\n+            if (_position < _length) {\n+                _position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        public int getNumber() {\n+            return _number;\n+        }\n+\n+        public String getSuffix() {\n+            return _suffix;\n+        }\n+    }\n+\n+    public boolean equals(String o1, String o2) {\n+        return compare(o1, o2) == 0;\n+    }\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        String version1 = (String) o1;\n+        String version2 = (String) o2;\n+\n+        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n+        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n+\n+        int number1 = 0, number2 = 0;\n+        String suffix1 = \"\", suffix2 = \"\";\n+\n+        while (tokenizer1.MoveNext()) {\n+            if (!tokenizer2.MoveNext()) {\n+                do {\n+                    number1 = tokenizer1.getNumber();\n+                    suffix1 = tokenizer1.getSuffix();\n+                    if (number1 != 0 || suffix1.length() != 0) {\n+                        // Version one is longer than number two, and non-zero\n+                        return 1;\n+                    }\n+                } while (tokenizer1.MoveNext());\n+\n+                // Version one is longer than version two, but zero\n+                return 0;\n+            }\n+\n+            number1 = tokenizer1.getNumber();\n+            suffix1 = tokenizer1.getSuffix();\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+\n+            if (number1 < number2) {\n+                // Number one is less than number two\n+                return -1;\n+            }\n+            if (number1 > number2) {\n+                // Number one is greater than number two\n+                return 1;\n+            }\n+\n+            boolean empty1 = suffix1.length() == 0;\n+            boolean empty2 = suffix2.length() == 0;\n+\n+            if (empty1 && empty2) {\n+                continue;\n+            } // No suffixes\n+            if (empty1) {\n+                return 1;\n+            } // First suffix is empty (1.2 > 1.2b)\n+            if (empty2) {\n+                return -1;\n+            } // Second suffix is empty (1.2a < 1.2)\n+\n+            // Lexical comparison of suffixes\n+            int result = suffix1.compareTo(suffix2);\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+        }\n+        if (tokenizer2.MoveNext()) {\n+            do {\n+                number2 = tokenizer2.getNumber();\n+                suffix2 = tokenizer2.getSuffix();\n+                if (number2 != 0 || suffix2.length() != 0) {\n+                    // Version one is longer than version two, and non-zero\n+                    return -1;\n+                }\n+            } while (tokenizer2.MoveNext());\n+\n+            // Version two is longer than version one, but zero\n+            return 0;\n+        }\n+        return 0;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean checkBeta(@Nullable String version) {\n+        return version != null & (version.isEmpty() || version.contains(\"???\")\n+                || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzcxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687719", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NjM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\ndeleted file mode 100644\nindex 1f44853c1a..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n+++ /dev/null\n\n@@ -1,176 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import java.util.Comparator;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * {@link ShellyVersionDTO} compares 2 version strings.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyVersionDTO implements Comparator<Object> {\n-    private class VersionTokenizer {\n-        private final String _versionString;\n-        private final int _length;\n-\n-        private int _position;\n-        private int _number;\n-        private String _suffix = \"\";\n-\n-        public VersionTokenizer(@Nullable String versionString) {\n-            if (versionString == null) {\n-                throw new IllegalArgumentException(\"versionString is null\");\n-            }\n-\n-            _versionString = versionString;\n-            _length = versionString.length();\n-        }\n-\n-        public boolean MoveNext() {\n-            _number = 0;\n-            _suffix = \"\";\n-\n-            // No more characters\n-            if (_position >= _length) {\n-                return false;\n-            }\n-\n-            while (_position < _length) {\n-                char c = _versionString.charAt(_position);\n-                if (c < '0' || c > '9') {\n-                    break;\n-                }\n-                _number = _number * 10 + (c - '0');\n-                _position++;\n-            }\n-\n-            int suffixStart = _position;\n-\n-            while (_position < _length) {\n-                char c = _versionString.charAt(_position);\n-                if (c == '.') {\n-                    break;\n-                }\n-                _position++;\n-            }\n-\n-            _suffix = _versionString.substring(suffixStart, _position);\n-\n-            if (_position < _length) {\n-                _position++;\n-            }\n-\n-            return true;\n-        }\n-\n-        public int getNumber() {\n-            return _number;\n-        }\n-\n-        public String getSuffix() {\n-            return _suffix;\n-        }\n-    }\n-\n-    public boolean equals(String o1, String o2) {\n-        return compare(o1, o2) == 0;\n-    }\n-\n-    @Override\n-    public int compare(Object o1, Object o2) {\n-        String version1 = (String) o1;\n-        String version2 = (String) o2;\n-\n-        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n-        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n-\n-        int number1 = 0, number2 = 0;\n-        String suffix1 = \"\", suffix2 = \"\";\n-\n-        while (tokenizer1.MoveNext()) {\n-            if (!tokenizer2.MoveNext()) {\n-                do {\n-                    number1 = tokenizer1.getNumber();\n-                    suffix1 = tokenizer1.getSuffix();\n-                    if (number1 != 0 || suffix1.length() != 0) {\n-                        // Version one is longer than number two, and non-zero\n-                        return 1;\n-                    }\n-                } while (tokenizer1.MoveNext());\n-\n-                // Version one is longer than version two, but zero\n-                return 0;\n-            }\n-\n-            number1 = tokenizer1.getNumber();\n-            suffix1 = tokenizer1.getSuffix();\n-            number2 = tokenizer2.getNumber();\n-            suffix2 = tokenizer2.getSuffix();\n-\n-            if (number1 < number2) {\n-                // Number one is less than number two\n-                return -1;\n-            }\n-            if (number1 > number2) {\n-                // Number one is greater than number two\n-                return 1;\n-            }\n-\n-            boolean empty1 = suffix1.length() == 0;\n-            boolean empty2 = suffix2.length() == 0;\n-\n-            if (empty1 && empty2) {\n-                continue;\n-            } // No suffixes\n-            if (empty1) {\n-                return 1;\n-            } // First suffix is empty (1.2 > 1.2b)\n-            if (empty2) {\n-                return -1;\n-            } // Second suffix is empty (1.2a < 1.2)\n-\n-            // Lexical comparison of suffixes\n-            int result = suffix1.compareTo(suffix2);\n-            if (result != 0) {\n-                return result;\n-            }\n-\n-        }\n-        if (tokenizer2.MoveNext()) {\n-            do {\n-                number2 = tokenizer2.getNumber();\n-                suffix2 = tokenizer2.getSuffix();\n-                if (number2 != 0 || suffix2.length() != 0) {\n-                    // Version one is longer than version two, and non-zero\n-                    return -1;\n-                }\n-            } while (tokenizer2.MoveNext());\n-\n-            // Version two is longer than version one, but zero\n-            return 0;\n-        }\n-        return 0;\n-    }\n-\n-    @SuppressWarnings(\"null\")\n-    public boolean checkBeta(@Nullable String version) {\n-        return version != null & (version.isEmpty() || version.contains(\"???\")\n-                || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));\n-\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDMwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404270307", "bodyText": "What would throw these errors? Are they preventable?", "author": "cpmeister", "createdAt": "2020-04-06T17:37:36Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,24 +152,23 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n         for (ShellyDeviceListener listener : deviceListeners) {\n             try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n+                if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n                     // event processed\n                     break;\n                 }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n+            } catch (IllegalArgumentException | NullPointerException e) {", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMjg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405302858", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-08T07:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDMwNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\nindex e1005fca32..fbd599949c 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n\n@@ -152,23 +142,24 @@ public class ShellyHandlerFactory extends BaseThingHandlerFactory {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n-            Map<String, String> parameters) {\n+    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n         for (ShellyDeviceListener listener : deviceListeners) {\n             try {\n-                if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n                     // event processed\n                     break;\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) {\n-                logger.debug(\"{}: Unable to process callback: type={}, index={}, parameters={}{}\", deviceName,\n-                        eventType, componentIndex, parameters.toString(), e.toString());\n+            } catch (NullPointerException e) {\n+                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n+                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n+                        e.getStackTrace());\n                 // continue with next listener\n             }\n         }\n     }\n \n+    @Nullable\n     public ShellyBindingConfiguration getBindingConfig() {\n         return bindingConfig;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404271289", "bodyText": "Can you give this field a better name than e? Also can you make it final?", "author": "cpmeister", "createdAt": "2020-04-06T17:39:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception e = new Exception(EX_NONE);", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNDAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405334035", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T08:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTI4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 9585fab688..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,132 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-    private static String EX_NONE = \"none\";\n-    private Exception e = new Exception(EX_NONE);\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(ShellyApiResult res) {\n-        super(EX_NONE);\n-        apiResult = res;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return isEmpty() ? \"\" : nonNullString(super.getMessage());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty() ? \", result =\" + apiResult.response : \"\";\n-\n-        if (!isEmpty()) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"Device unreachable or API Timeout ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = nonNullString(super.getClass().toString()) + \" - \" + getMessage();\n-            } else {\n-                message = getMessage();\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return e.getClass() == ShellyApiException.class;\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = !isEmpty() ? e.getClass() : null;\n-        return (apiResult.httpCode == -1)\n-                || (extype != null) && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult.isHttpAccessUnauthorized();\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return e.getClass() == MalformedURLException.class;\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return e.getClass() == UnknownHostException.class;\n-    }\n-\n-    public ShellyApiResult getApiResult() {\n-        return apiResult;\n-    }\n-\n-    private boolean isEmpty() {\n-        return nonNullString(e.getMessage()).equals(EX_NONE);\n-    }\n-\n-    private static String nonNullString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTQyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404271427", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "author": "cpmeister", "createdAt": "2020-04-06T17:39:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception e = new Exception(EX_NONE);\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(ShellyApiResult res) {\n+        super(EX_NONE);\n+        apiResult = res;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return isEmpty() ? \"\" : nonNullString(super.getMessage());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty() ? \", result =\" + apiResult.response : \"\";\n+\n+        if (!isEmpty()) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"Device unreachable or API Timeout ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = nonNullString(super.getClass().toString()) + \" - \" + getMessage();\n+            } else {\n+                message = getMessage();\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return e.getClass() == ShellyApiException.class;\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = !isEmpty() ? e.getClass() : null;\n+        return (apiResult.httpCode == -1)\n+                || (extype != null) && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult.isHttpAccessUnauthorized();\n+    }\n+\n+    public boolean isUnknownHost() {\n+        return e.getClass() == MalformedURLException.class;\n+    }\n+\n+    public boolean isMalformedURL() {\n+        return e.getClass() == UnknownHostException.class;\n+    }\n+\n+    public ShellyApiResult getApiResult() {\n+        return apiResult;\n+    }\n+\n+    private boolean isEmpty() {\n+        return nonNullString(e.getMessage()).equals(EX_NONE);\n+    }\n+\n+    private static String nonNullString(@Nullable String s) {\n+        return s != null ? s : \"\";\n+    }\n+}", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNTQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405305442", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T07:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTQyNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 9585fab688..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,132 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-    private static String EX_NONE = \"none\";\n-    private Exception e = new Exception(EX_NONE);\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(ShellyApiResult res) {\n-        super(EX_NONE);\n-        apiResult = res;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        e = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        e = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return isEmpty() ? \"\" : nonNullString(super.getMessage());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String message = super.getMessage();\n-        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n-                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n-        String resultString = !apiResult.response.isEmpty() ? \", result =\" + apiResult.response : \"\";\n-\n-        if (!isEmpty()) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", url);\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"Device unreachable or API Timeout ({0})\", url);\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = nonNullString(super.getClass().toString()) + \" - \" + getMessage();\n-            } else {\n-                message = getMessage();\n-            }\n-        }\n-\n-        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n-    }\n-\n-    public boolean isApiException() {\n-        return e.getClass() == ShellyApiException.class;\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = !isEmpty() ? e.getClass() : null;\n-        return (apiResult.httpCode == -1)\n-                || (extype != null) && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult.isHttpAccessUnauthorized();\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return e.getClass() == MalformedURLException.class;\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return e.getClass() == UnknownHostException.class;\n-    }\n-\n-    public ShellyApiResult getApiResult() {\n-        return apiResult;\n-    }\n-\n-    private boolean isEmpty() {\n-        return nonNullString(e.getMessage()).equals(EX_NONE);\n-    }\n-\n-    private static String nonNullString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404276294", "bodyText": "This method used to be static, which made it a factory method, which was fine. You have made it non-static yet it still produces a ShellyDeviceProfile instance. Are you trying to make this into a builder pattern? Why not just make this a constructor then?", "author": "cpmeister", "createdAt": "2020-04-06T17:47:27Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNjkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405306916", "bodyText": "This allows me to have an initialization with the default constructor in ShellyBaseHandler to make it NonNull, any better idea?", "author": "markus7017", "createdAt": "2020-04-08T07:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1OTI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405659260", "bodyText": "Just have more than one constructor. A no-arg constructor and this one.", "author": "cpmeister", "createdAt": "2020-04-08T16:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MDg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405670898", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T16:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407706654", "bodyText": "You still didn't resolve this one...", "author": "cpmeister", "createdAt": "2020-04-13T20:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex 71b133d5d7..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -62,213 +56,102 @@ public class ShellyDeviceProfile {\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 0; // number of Rollers, usually 1\n+    public Integer numRollers = 9; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n+    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM/EM3\n+    public Boolean isEMeter = false; // true for ShellyEM\n \n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean hasLed = false; // true if battery device\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true only if it is a Bulb\n-    public Boolean isDuo = false; // true only if it is a Duo\n-    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n+    public Boolean isBulb = false; // true pnly if it is a Bulb\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public Boolean hasLed = false; // true if battery device\n-\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n-    public Boolean isDW = false; // true of Door Window sensor\n-\n-    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n-    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n-\n-    public Integer updatePeriod = -1;\n+    public Boolean isSmoke = false; // true for Smoke\n \n     public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n+    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n+    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n+    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n+    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n+    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+\n+    @SuppressWarnings(\"null\")\n+    public static ShellyDeviceProfile initialize(String thingType, String json) {\n         Gson gson = new Gson();\n \n-        initialized = false;\n+        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+        Validate.notNull(profile);\n \n-        try {\n-            initFromThingType(thingType);\n-            settingsJson = json;\n-            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        } catch (IllegalArgumentException | JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n-        }\n+        profile.settingsJson = json;\n+        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n \n         // General settings\n-        deviceType = ShellyUtils.getString(settings.device.type);\n-        mac = getString(settings.device.mac);\n-        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n-                ? settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n-        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n-        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n-        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n-        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n-        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n-        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n-        discoverable = (settings.discoverable == null) || settings.discoverable;\n-\n-        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n-        if ((numRelays > 0) && (settings.relays == null)) {\n-            numRelays = 0;\n-        }\n-        hasRelays = (numRelays > 0) || isDimmer;\n-        numRollers = getInteger(settings.device.numRollers);\n-\n-        isEMeter = settings.emeters != null;\n-        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n-        if ((numMeters == 0) && isLight) {\n+        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n+        profile.mac = getString(profile.settings.device.mac);\n+        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n+                ? profile.settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n+        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n+        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n+        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n+                : \"\";\n+        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n+        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n+        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n+\n+        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n+        profile.hasLed = profile.isPlugS;\n+        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n+        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        profile.isLight = profile.isBulb\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n+        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n+        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.isSensor = profile.isSense || profile.isSmoke\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+\n+        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n+        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n+            profile.numRelays = 0;\n+        }\n+        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n+        profile.numRollers = getInteger(profile.settings.device.numRollers);\n+\n+        profile.isEMeter = profile.settings.emeters != null;\n+        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n+                : getInteger(profile.settings.device.numEMeters);\n+        if ((profile.numMeters == 0) && profile.isLight) {\n             // RGBW2 doesn't report, but has one\n-            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n-        }\n-        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-\n-        if (settings.sleepMode != null) {\n-            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n-                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n-                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n-        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n-            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n+            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n         }\n+        profile.hasMeter = (profile.numMeters > 0);\n \n-        initialized = true;\n-        return this;\n-    }\n-\n-    public boolean containsEventUrl(String eventType) {\n-        return containsEventUrl(settingsJson, eventType);\n-    }\n-\n-    public boolean containsEventUrl(String json, String eventType) {\n-        String settings = json.toLowerCase();\n-        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n-    }\n-\n-    public Boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    public void initFromThingType(String name) {\n-        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n-        if (thingType.isEmpty()) {\n-            return;\n-        }\n-\n-        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n-\n-        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n-        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n-        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n-        hasLed = isPlugS;\n-        isLight = isBulb || isDuo || isRGBW2;\n-        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n-        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n-\n-        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n-        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n-        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n-        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n-        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n-        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n-        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n-    }\n-\n-    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n-        String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n-        return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n-                : getThingTypeUID(THING_TYPE_SHELLYPROTECTED_STR + \"-\" + devid, mode), devid);\n-    }\n-\n-    public static ThingTypeUID getThingTypeUID(String serviceName, String mode) {\n-        return new ThingTypeUID(BINDING_ID, getThingType(serviceName, mode));\n-    }\n-\n-    public static ThingTypeUID getUnknownTTUID() {\n-        return new ThingTypeUID(BINDING_ID, THING_TYPE_SHELLYPROTECTED_STR);\n-    }\n-\n-    public static String getThingType(String hostname, String mode) {\n-        String name = hostname.toLowerCase();\n-        String devid = StringUtils.substringAfterLast(name, \"-\");\n-        if (devid == null) {\n-            throw new IllegalArgumentException(\"Invalid device name format: \" + hostname);\n-        }\n-\n-        if (name.startsWith(THING_TYPE_SHELLY1PN_STR)) {\n-            return THING_TYPE_SHELLY1PN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM3_STR)) {\n-            return THING_TYPE_SHELLYEM3_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM_STR)) {\n-            return THING_TYPE_SHELLYEM_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY1_STR)) {\n-            return THING_TYPE_SHELLY1_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY25_PREFIX)) { // Shelly v2.5\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY25_RELAY_STR : THING_TYPE_SHELLY25_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY2_PREFIX)) { // Shelly v2\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY2_RELAY_STR : THING_TYPE_SHELLY2_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY4PRO_STR)) {\n-            return THING_TYPE_SHELLY4PRO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPLUG_STR)) {\n-            // shellyplug-s needs to be mapped to shellyplugs to follow the schema\n-            // for the thing types: <thing type>-<mode>\n-            if (name.startsWith(THING_TYPE_SHELLYPLUGS_STR) || name.contains(\"-s\")) {\n-                return THING_TYPE_SHELLYPLUGS_STR;\n-            }\n-            return THING_TYPE_SHELLYPLUG_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDIMMER_STR)) {\n-            return THING_TYPE_SHELLYDIMMER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDUO_STR)) {\n-            return THING_TYPE_SHELLYDUO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYBULB_STR)) {\n-            return THING_TYPE_SHELLYBULB_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX)) {\n-            return mode.equals(SHELLY_MODE_COLOR) ? THING_TYPE_SHELLYRGBW2_COLOR_STR : THING_TYPE_SHELLYRGBW2_WHITE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYHT_STR)) {\n-            return THING_TYPE_SHELLYHT_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSMOKE_STR)) {\n-            return THING_TYPE_SHELLYSMOKE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYFLOOD_STR)) {\n-            return THING_TYPE_SHELLYFLOOD_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDOORWIN_STR)) {\n-            return THING_TYPE_SHELLYDOORWIN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSENSE_STR)) {\n-            return THING_TYPE_SHELLYSENSE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEYE_STR)) {\n-            return THING_TYPE_SHELLYEYE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPROTECTED_STR)) {\n-            return THING_TYPE_SHELLYPROTECTED_STR;\n-        }\n+        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n \n-        return THING_TYPE_UNKNOWN_STR;\n+        return profile;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404277016", "bodyText": "If all these fields are non-null, why not make the fields primitive? Boolean -> boolean, Integer -> int", "author": "cpmeister", "createdAt": "2020-04-06T17:48:38Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNzY0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405307647", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T07:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzAxNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex 71b133d5d7..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -62,213 +56,102 @@ public class ShellyDeviceProfile {\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 0; // number of Rollers, usually 1\n+    public Integer numRollers = 9; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n+    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM/EM3\n+    public Boolean isEMeter = false; // true for ShellyEM\n \n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean hasLed = false; // true if battery device\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true only if it is a Bulb\n-    public Boolean isDuo = false; // true only if it is a Duo\n-    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n+    public Boolean isBulb = false; // true pnly if it is a Bulb\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public Boolean hasLed = false; // true if battery device\n-\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n-    public Boolean isDW = false; // true of Door Window sensor\n-\n-    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n-    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n-\n-    public Integer updatePeriod = -1;\n+    public Boolean isSmoke = false; // true for Smoke\n \n     public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n+    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n+    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n+    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n+    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n+    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+\n+    @SuppressWarnings(\"null\")\n+    public static ShellyDeviceProfile initialize(String thingType, String json) {\n         Gson gson = new Gson();\n \n-        initialized = false;\n+        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+        Validate.notNull(profile);\n \n-        try {\n-            initFromThingType(thingType);\n-            settingsJson = json;\n-            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        } catch (IllegalArgumentException | JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n-        }\n+        profile.settingsJson = json;\n+        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n \n         // General settings\n-        deviceType = ShellyUtils.getString(settings.device.type);\n-        mac = getString(settings.device.mac);\n-        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n-                ? settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n-        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n-        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n-        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n-        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n-        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n-        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n-        discoverable = (settings.discoverable == null) || settings.discoverable;\n-\n-        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n-        if ((numRelays > 0) && (settings.relays == null)) {\n-            numRelays = 0;\n-        }\n-        hasRelays = (numRelays > 0) || isDimmer;\n-        numRollers = getInteger(settings.device.numRollers);\n-\n-        isEMeter = settings.emeters != null;\n-        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n-        if ((numMeters == 0) && isLight) {\n+        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n+        profile.mac = getString(profile.settings.device.mac);\n+        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n+                ? profile.settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n+        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n+        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n+        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n+                : \"\";\n+        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n+        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n+        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n+\n+        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n+        profile.hasLed = profile.isPlugS;\n+        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n+        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        profile.isLight = profile.isBulb\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n+        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n+        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.isSensor = profile.isSense || profile.isSmoke\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+\n+        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n+        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n+            profile.numRelays = 0;\n+        }\n+        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n+        profile.numRollers = getInteger(profile.settings.device.numRollers);\n+\n+        profile.isEMeter = profile.settings.emeters != null;\n+        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n+                : getInteger(profile.settings.device.numEMeters);\n+        if ((profile.numMeters == 0) && profile.isLight) {\n             // RGBW2 doesn't report, but has one\n-            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n-        }\n-        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-\n-        if (settings.sleepMode != null) {\n-            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n-                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n-                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n-        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n-            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n+            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n         }\n+        profile.hasMeter = (profile.numMeters > 0);\n \n-        initialized = true;\n-        return this;\n-    }\n-\n-    public boolean containsEventUrl(String eventType) {\n-        return containsEventUrl(settingsJson, eventType);\n-    }\n-\n-    public boolean containsEventUrl(String json, String eventType) {\n-        String settings = json.toLowerCase();\n-        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n-    }\n-\n-    public Boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    public void initFromThingType(String name) {\n-        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n-        if (thingType.isEmpty()) {\n-            return;\n-        }\n-\n-        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n-\n-        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n-        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n-        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n-        hasLed = isPlugS;\n-        isLight = isBulb || isDuo || isRGBW2;\n-        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n-        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n-\n-        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n-        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n-        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n-        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n-        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n-        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n-        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n-    }\n-\n-    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n-        String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n-        return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n-                : getThingTypeUID(THING_TYPE_SHELLYPROTECTED_STR + \"-\" + devid, mode), devid);\n-    }\n-\n-    public static ThingTypeUID getThingTypeUID(String serviceName, String mode) {\n-        return new ThingTypeUID(BINDING_ID, getThingType(serviceName, mode));\n-    }\n-\n-    public static ThingTypeUID getUnknownTTUID() {\n-        return new ThingTypeUID(BINDING_ID, THING_TYPE_SHELLYPROTECTED_STR);\n-    }\n-\n-    public static String getThingType(String hostname, String mode) {\n-        String name = hostname.toLowerCase();\n-        String devid = StringUtils.substringAfterLast(name, \"-\");\n-        if (devid == null) {\n-            throw new IllegalArgumentException(\"Invalid device name format: \" + hostname);\n-        }\n-\n-        if (name.startsWith(THING_TYPE_SHELLY1PN_STR)) {\n-            return THING_TYPE_SHELLY1PN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM3_STR)) {\n-            return THING_TYPE_SHELLYEM3_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM_STR)) {\n-            return THING_TYPE_SHELLYEM_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY1_STR)) {\n-            return THING_TYPE_SHELLY1_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY25_PREFIX)) { // Shelly v2.5\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY25_RELAY_STR : THING_TYPE_SHELLY25_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY2_PREFIX)) { // Shelly v2\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY2_RELAY_STR : THING_TYPE_SHELLY2_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY4PRO_STR)) {\n-            return THING_TYPE_SHELLY4PRO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPLUG_STR)) {\n-            // shellyplug-s needs to be mapped to shellyplugs to follow the schema\n-            // for the thing types: <thing type>-<mode>\n-            if (name.startsWith(THING_TYPE_SHELLYPLUGS_STR) || name.contains(\"-s\")) {\n-                return THING_TYPE_SHELLYPLUGS_STR;\n-            }\n-            return THING_TYPE_SHELLYPLUG_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDIMMER_STR)) {\n-            return THING_TYPE_SHELLYDIMMER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDUO_STR)) {\n-            return THING_TYPE_SHELLYDUO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYBULB_STR)) {\n-            return THING_TYPE_SHELLYBULB_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX)) {\n-            return mode.equals(SHELLY_MODE_COLOR) ? THING_TYPE_SHELLYRGBW2_COLOR_STR : THING_TYPE_SHELLYRGBW2_WHITE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYHT_STR)) {\n-            return THING_TYPE_SHELLYHT_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSMOKE_STR)) {\n-            return THING_TYPE_SHELLYSMOKE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYFLOOD_STR)) {\n-            return THING_TYPE_SHELLYFLOOD_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDOORWIN_STR)) {\n-            return THING_TYPE_SHELLYDOORWIN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSENSE_STR)) {\n-            return THING_TYPE_SHELLYSENSE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEYE_STR)) {\n-            return THING_TYPE_SHELLYEYE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPROTECTED_STR)) {\n-            return THING_TYPE_SHELLYPROTECTED_STR;\n-        }\n+        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n \n-        return THING_TYPE_UNKNOWN_STR;\n+        return profile;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzgwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404277802", "bodyText": "Why is this code here? This code has nothing to do with device profile, why was it moved from ShellyThingCreator?", "author": "cpmeister", "createdAt": "2020-04-06T17:49:52Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n+                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n+                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public boolean containsEventUrl(String eventType) {\n+        return containsEventUrl(settingsJson, eventType);\n+    }\n+\n+    public boolean containsEventUrl(String json, String eventType) {\n+        String settings = json.toLowerCase();\n+        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n+    }\n+\n+    public Boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n+        }\n+\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n+        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n+    }\n+\n+    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczNzE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405737174", "bodyText": "moved to ShellyThingCreator", "author": "markus7017", "createdAt": "2020-04-08T18:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex 71b133d5d7..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -62,213 +56,102 @@ public class ShellyDeviceProfile {\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 0; // number of Rollers, usually 1\n+    public Integer numRollers = 9; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n+    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM/EM3\n+    public Boolean isEMeter = false; // true for ShellyEM\n \n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean hasLed = false; // true if battery device\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true only if it is a Bulb\n-    public Boolean isDuo = false; // true only if it is a Duo\n-    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n+    public Boolean isBulb = false; // true pnly if it is a Bulb\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public Boolean hasLed = false; // true if battery device\n-\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n-    public Boolean isDW = false; // true of Door Window sensor\n-\n-    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n-    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n-\n-    public Integer updatePeriod = -1;\n+    public Boolean isSmoke = false; // true for Smoke\n \n     public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n+    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n+    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n+    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n+    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n+    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+\n+    @SuppressWarnings(\"null\")\n+    public static ShellyDeviceProfile initialize(String thingType, String json) {\n         Gson gson = new Gson();\n \n-        initialized = false;\n+        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+        Validate.notNull(profile);\n \n-        try {\n-            initFromThingType(thingType);\n-            settingsJson = json;\n-            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        } catch (IllegalArgumentException | JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n-        }\n+        profile.settingsJson = json;\n+        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n \n         // General settings\n-        deviceType = ShellyUtils.getString(settings.device.type);\n-        mac = getString(settings.device.mac);\n-        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n-                ? settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n-        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n-        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n-        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n-        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n-        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n-        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n-        discoverable = (settings.discoverable == null) || settings.discoverable;\n-\n-        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n-        if ((numRelays > 0) && (settings.relays == null)) {\n-            numRelays = 0;\n-        }\n-        hasRelays = (numRelays > 0) || isDimmer;\n-        numRollers = getInteger(settings.device.numRollers);\n-\n-        isEMeter = settings.emeters != null;\n-        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n-        if ((numMeters == 0) && isLight) {\n+        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n+        profile.mac = getString(profile.settings.device.mac);\n+        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n+                ? profile.settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n+        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n+        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n+        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n+                : \"\";\n+        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n+        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n+        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n+\n+        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n+        profile.hasLed = profile.isPlugS;\n+        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n+        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        profile.isLight = profile.isBulb\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n+        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n+        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.isSensor = profile.isSense || profile.isSmoke\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+\n+        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n+        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n+            profile.numRelays = 0;\n+        }\n+        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n+        profile.numRollers = getInteger(profile.settings.device.numRollers);\n+\n+        profile.isEMeter = profile.settings.emeters != null;\n+        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n+                : getInteger(profile.settings.device.numEMeters);\n+        if ((profile.numMeters == 0) && profile.isLight) {\n             // RGBW2 doesn't report, but has one\n-            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n-        }\n-        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-\n-        if (settings.sleepMode != null) {\n-            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n-                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n-                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n-        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n-            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n+            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n         }\n+        profile.hasMeter = (profile.numMeters > 0);\n \n-        initialized = true;\n-        return this;\n-    }\n-\n-    public boolean containsEventUrl(String eventType) {\n-        return containsEventUrl(settingsJson, eventType);\n-    }\n-\n-    public boolean containsEventUrl(String json, String eventType) {\n-        String settings = json.toLowerCase();\n-        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n-    }\n-\n-    public Boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    public void initFromThingType(String name) {\n-        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n-        if (thingType.isEmpty()) {\n-            return;\n-        }\n-\n-        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n-\n-        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n-        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n-        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n-        hasLed = isPlugS;\n-        isLight = isBulb || isDuo || isRGBW2;\n-        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n-        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n-\n-        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n-        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n-        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n-        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n-        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n-        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n-        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n-    }\n-\n-    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n-        String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n-        return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n-                : getThingTypeUID(THING_TYPE_SHELLYPROTECTED_STR + \"-\" + devid, mode), devid);\n-    }\n-\n-    public static ThingTypeUID getThingTypeUID(String serviceName, String mode) {\n-        return new ThingTypeUID(BINDING_ID, getThingType(serviceName, mode));\n-    }\n-\n-    public static ThingTypeUID getUnknownTTUID() {\n-        return new ThingTypeUID(BINDING_ID, THING_TYPE_SHELLYPROTECTED_STR);\n-    }\n-\n-    public static String getThingType(String hostname, String mode) {\n-        String name = hostname.toLowerCase();\n-        String devid = StringUtils.substringAfterLast(name, \"-\");\n-        if (devid == null) {\n-            throw new IllegalArgumentException(\"Invalid device name format: \" + hostname);\n-        }\n-\n-        if (name.startsWith(THING_TYPE_SHELLY1PN_STR)) {\n-            return THING_TYPE_SHELLY1PN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM3_STR)) {\n-            return THING_TYPE_SHELLYEM3_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM_STR)) {\n-            return THING_TYPE_SHELLYEM_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY1_STR)) {\n-            return THING_TYPE_SHELLY1_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY25_PREFIX)) { // Shelly v2.5\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY25_RELAY_STR : THING_TYPE_SHELLY25_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY2_PREFIX)) { // Shelly v2\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY2_RELAY_STR : THING_TYPE_SHELLY2_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY4PRO_STR)) {\n-            return THING_TYPE_SHELLY4PRO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPLUG_STR)) {\n-            // shellyplug-s needs to be mapped to shellyplugs to follow the schema\n-            // for the thing types: <thing type>-<mode>\n-            if (name.startsWith(THING_TYPE_SHELLYPLUGS_STR) || name.contains(\"-s\")) {\n-                return THING_TYPE_SHELLYPLUGS_STR;\n-            }\n-            return THING_TYPE_SHELLYPLUG_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDIMMER_STR)) {\n-            return THING_TYPE_SHELLYDIMMER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDUO_STR)) {\n-            return THING_TYPE_SHELLYDUO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYBULB_STR)) {\n-            return THING_TYPE_SHELLYBULB_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX)) {\n-            return mode.equals(SHELLY_MODE_COLOR) ? THING_TYPE_SHELLYRGBW2_COLOR_STR : THING_TYPE_SHELLYRGBW2_WHITE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYHT_STR)) {\n-            return THING_TYPE_SHELLYHT_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSMOKE_STR)) {\n-            return THING_TYPE_SHELLYSMOKE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYFLOOD_STR)) {\n-            return THING_TYPE_SHELLYFLOOD_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDOORWIN_STR)) {\n-            return THING_TYPE_SHELLYDOORWIN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSENSE_STR)) {\n-            return THING_TYPE_SHELLYSENSE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEYE_STR)) {\n-            return THING_TYPE_SHELLYEYE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPROTECTED_STR)) {\n-            return THING_TYPE_SHELLYPROTECTED_STR;\n-        }\n+        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n \n-        return THING_TYPE_UNKNOWN_STR;\n+        return profile;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404280789", "bodyText": "This method is called by a library, and as such you have no idea if or how they will handle this exception getting thrown here. Instead you should just log it and return immediately.", "author": "cpmeister", "createdAt": "2020-04-06T17:54:42Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNDc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405324753", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T07:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\nindex 2585350416..b880b411f6 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n\n@@ -52,44 +54,40 @@ public class ShellyEventServlet extends HttpServlet {\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private final HttpService httpService;\n-    private final ShellyHandlerFactory handlerFactory;\n+    private @Nullable HttpService httpService;\n+    private @Nullable ShellyHandlerFactory handlerFactory;\n \n+    @SuppressWarnings(\"null\")\n     @Activate\n-    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n-            Map<String, Object> config) {\n-        this.httpService = httpService;\n-        this.handlerFactory = handlerFactory;\n+    protected void activate(Map<String, Object> config) {\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n-            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n+    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        httpService.unregister(SHELLY_CALLBACK_URI);\n-        logger.debug(\"ShellyEventServlet stopped\");\n+        if (httpService != null) {\n+            httpService.unregister(SHELLY_CALLBACK_URI);\n+        }\n+        logger.debug(\"Shelly: CallbackServlet stopped\");\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException, IllegalArgumentException {\n-        String data = \"\";\n-        String path = \"\";\n+            throws ServletException, IOException {\n+        String data = inputStreamToString(request);\n+        String path = request.getRequestURI().toLowerCase();\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n-        if ((request == null) || (resp == null)) {\n-            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");\n-        }\n-\n         try {\n-            path = request.getRequestURI().toLowerCase();\n-            data = IOUtils.toString(request.getInputStream());\n             String ipAddress = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n             if (ipAddress == null) {\n                 ipAddress = request.getRemoteAddr();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404288161", "bodyText": "The formula in your comment above doesn't match the formula you used here. Which is wrong?\nAlso, I would suggest taking advantage of the units framework conversion capabilities so you don't have to handle it yourself.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                : (status.tmp.value + 32) * 0.5556;\n          \n          \n            \n                                : Units.CELSIUS.getConverterTo(Units.FAHRENHEIT).convert(status.tmp.value);", "author": "cpmeister", "createdAt": "2020-04-06T18:07:05Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -109,84 +118,77 @@ public ShellyDeviceProfile getDeviceProfile(String thingType) throws IOException\n         return profile;\n     }\n \n+    public boolean isInitialized() {\n+        return profile.initialized;\n+    }\n+\n     /**\n      * Get generic device settings/status. Json returned from API will be mapped to a Gson object\n      *\n      * @return Device settings/status as ShellySettingsStatus object\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    public ShellySettingsStatus getStatus() throws IOException {\n+    public ShellySettingsStatus getStatus() throws ShellyApiException {\n         String json = request(SHELLY_URL_STATUS);\n         ShellySettingsStatus status = gson.fromJson(json, ShellySettingsStatus.class);\n-        Validate.notNull(status);\n         status.json = json;\n         return status;\n     }\n \n-    @Nullable\n-    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws IOException {\n-        String result = request(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString());\n-        return gson.fromJson(result, ShellyStatusRelay.class);\n+    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws ShellyApiException {\n+        return callApi(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString(), ShellyStatusRelay.class);\n     }\n \n-    @SuppressWarnings(\"null\")\n-    public void setRelayTurn(Integer relayIndex, String turnMode) throws IOException {\n-        Validate.notNull(profile);\n-        request((!profile.isDimmer ? SHELLY_URL_CONTROL_RELEAY : SHELLY_URL_CONTROL_LIGHT) + \"/\" + relayIndex.toString()\n-                + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n+    public void setRelayTurn(Integer id, String turnMode) throws ShellyApiException {\n+        request(getControlUrlPrefix(id) + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n     }\n \n-    public void setDimmerBrightness(Integer relayIndex, Integer brightness, boolean autoOn) throws IOException {\n-        if (autoOn) {\n-            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + SHELLY_LIGHT_TURN + \"=\"\n-                    + SHELLY_API_ON + \"&brightness=\" + brightness.toString());\n-        } else {\n-            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + \"&brightness=\"\n-                    + brightness.toString());\n-        }\n+    public void setBrightness(Integer id, Integer brightness, boolean autoOn) throws ShellyApiException {\n+        String turn = autoOn ? SHELLY_LIGHT_TURN + \"=\" + SHELLY_API_ON + \"&\" : \"\";\n+        request(getControlUrlPrefix(id) + \"?\" + turn + \"brightness=\" + brightness.toString());\n     }\n \n-    @Nullable\n-    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws IOException {\n-        String result = request(SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\");\n-        return gson.fromJson(result, ShellyControlRoller.class);\n+    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws ShellyApiException {\n+        String uri = SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\";\n+        return callApi(uri, ShellyControlRoller.class);\n     }\n \n-    public void setRollerTurn(Integer relayIndex, String turnMode) throws IOException {\n+    public void setRollerTurn(Integer relayIndex, String turnMode) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=\" + turnMode);\n     }\n \n-    public void setRollerPos(Integer relayIndex, Integer position) throws IOException {\n+    public void setRollerPos(Integer relayIndex, Integer position) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=to_pos&roller_pos=\"\n                 + position.toString());\n     }\n \n-    public void setRollerTimer(Integer relayIndex, Integer timer) throws IOException {\n+    public void setRollerTimer(Integer relayIndex, Integer timer) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?timer=\" + timer.toString());\n     }\n \n-    @Nullable\n-    public ShellyShortLightStatus getLightStatus(Integer index) throws IOException {\n-        String result = request(SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString());\n-        return gson.fromJson(result, ShellyShortLightStatus.class);\n+    public ShellyShortLightStatus getLightStatus(Integer index) throws ShellyApiException {\n+        String uri = SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString();\n+        return callApi(uri, ShellyShortLightStatus.class);\n     }\n \n-    @SuppressWarnings(\"null\")\n-    public ShellyStatusSensor getSensorStatus() throws IOException {\n-        Validate.notNull(profile);\n-        ShellyStatusSensor status = gson.fromJson(request(SHELLY_URL_STATUS), ShellyStatusSensor.class);\n+    public ShellyStatusSensor getSensorStatus() throws ShellyApiException {\n+        ShellyStatusSensor status = callApi(SHELLY_URL_STATUS, ShellyStatusSensor.class);\n         if (profile.isSense) {\n-            // complete reported data\n-            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value : 0;\n-            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value : 0;\n+            // complete reported data, map C to F or vice versa: C=(F - 32) * 0.5556;\n+            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value\n+                    : status.tmp.value / 0.5556 + 32;\n+            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value\n+                    : (status.tmp.value + 32) * 0.5556;", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNDU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405724591", "bodyText": "Units nor SIUnits provide the unit type FAHRENHEIT\nI added 2 functions to ShellyUtils and corrected the formulas", "author": "markus7017", "createdAt": "2020-04-08T18:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1NzE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405757140", "bodyText": "My bad, they can be found in ImperialUnits", "author": "cpmeister", "createdAt": "2020-04-08T19:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2ODk3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406168977", "bodyText": "ok, changed", "author": "markus7017", "createdAt": "2020-04-09T12:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex fa4422da3d..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -118,77 +109,84 @@ public class ShellyHttpApi {\n         return profile;\n     }\n \n-    public boolean isInitialized() {\n-        return profile.initialized;\n-    }\n-\n     /**\n      * Get generic device settings/status. Json returned from API will be mapped to a Gson object\n      *\n      * @return Device settings/status as ShellySettingsStatus object\n-     * @throws ShellyApiException\n+     * @throws IOException\n      */\n-    public ShellySettingsStatus getStatus() throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    public ShellySettingsStatus getStatus() throws IOException {\n         String json = request(SHELLY_URL_STATUS);\n         ShellySettingsStatus status = gson.fromJson(json, ShellySettingsStatus.class);\n+        Validate.notNull(status);\n         status.json = json;\n         return status;\n     }\n \n-    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws ShellyApiException {\n-        return callApi(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString(), ShellyStatusRelay.class);\n+    @Nullable\n+    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws IOException {\n+        String result = request(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString());\n+        return gson.fromJson(result, ShellyStatusRelay.class);\n     }\n \n-    public void setRelayTurn(Integer id, String turnMode) throws ShellyApiException {\n-        request(getControlUrlPrefix(id) + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n+    @SuppressWarnings(\"null\")\n+    public void setRelayTurn(Integer relayIndex, String turnMode) throws IOException {\n+        Validate.notNull(profile);\n+        request((!profile.isDimmer ? SHELLY_URL_CONTROL_RELEAY : SHELLY_URL_CONTROL_LIGHT) + \"/\" + relayIndex.toString()\n+                + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n     }\n \n-    public void setBrightness(Integer id, Integer brightness, boolean autoOn) throws ShellyApiException {\n-        String turn = autoOn ? SHELLY_LIGHT_TURN + \"=\" + SHELLY_API_ON + \"&\" : \"\";\n-        request(getControlUrlPrefix(id) + \"?\" + turn + \"brightness=\" + brightness.toString());\n+    public void setDimmerBrightness(Integer relayIndex, Integer brightness, boolean autoOn) throws IOException {\n+        if (autoOn) {\n+            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + SHELLY_LIGHT_TURN + \"=\"\n+                    + SHELLY_API_ON + \"&brightness=\" + brightness.toString());\n+        } else {\n+            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + \"&brightness=\"\n+                    + brightness.toString());\n+        }\n     }\n \n-    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws ShellyApiException {\n-        String uri = SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\";\n-        return callApi(uri, ShellyControlRoller.class);\n+    @Nullable\n+    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws IOException {\n+        String result = request(SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\");\n+        return gson.fromJson(result, ShellyControlRoller.class);\n     }\n \n-    public void setRollerTurn(Integer relayIndex, String turnMode) throws ShellyApiException {\n+    public void setRollerTurn(Integer relayIndex, String turnMode) throws IOException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=\" + turnMode);\n     }\n \n-    public void setRollerPos(Integer relayIndex, Integer position) throws ShellyApiException {\n+    public void setRollerPos(Integer relayIndex, Integer position) throws IOException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=to_pos&roller_pos=\"\n                 + position.toString());\n     }\n \n-    public void setRollerTimer(Integer relayIndex, Integer timer) throws ShellyApiException {\n+    public void setRollerTimer(Integer relayIndex, Integer timer) throws IOException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?timer=\" + timer.toString());\n     }\n \n-    public ShellyShortLightStatus getLightStatus(Integer index) throws ShellyApiException {\n-        String uri = SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString();\n-        return callApi(uri, ShellyShortLightStatus.class);\n+    @Nullable\n+    public ShellyShortLightStatus getLightStatus(Integer index) throws IOException {\n+        String result = request(SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString());\n+        return gson.fromJson(result, ShellyShortLightStatus.class);\n     }\n \n-    public ShellyStatusSensor getSensorStatus() throws ShellyApiException {\n-        ShellyStatusSensor status = callApi(SHELLY_URL_STATUS, ShellyStatusSensor.class);\n+    @SuppressWarnings(\"null\")\n+    public ShellyStatusSensor getSensorStatus() throws IOException {\n+        Validate.notNull(profile);\n+        ShellyStatusSensor status = gson.fromJson(request(SHELLY_URL_STATUS), ShellyStatusSensor.class);\n         if (profile.isSense) {\n-            // complete reported data, map C to F or vice versa: C=(F - 32) * 0.5556;\n-            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value\n-                    : status.tmp.value / 0.5556 + 32;\n-            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value\n-                    : (status.tmp.value + 32) * 0.5556;\n-        }\n-        if ((status.charger == null) && (status.externalPower != null)) {\n-            // SHelly H&T uses external_power, Sense uses charger\n-            status.charger = status.externalPower != 0;\n+            // complete reported data\n+            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value : 0;\n+            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value : 0;\n         }\n-\n         return status;\n     }\n \n-    public void setTimer(Integer index, String timerName, Double value) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    public void setTimer(Integer index, String timerName, Double value) throws IOException {\n+        Validate.notNull(profile);\n         String type = SHELLY_CLASS_RELAY;\n         if (profile.isRoller) {\n             type = SHELLY_CLASS_ROLLER;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NDcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404384729", "bodyText": "You should double check that IOUtils isn't using the system default charset, if it is using the default then you should specify it yourself here instead. The default charset can vary from system to system.", "author": "cpmeister", "createdAt": "2020-04-06T20:59:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");\n+        }\n+\n         try {\n+            path = request.getRequestURI().toLowerCase();\n+            data = IOUtils.toString(request.getInputStream());", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNjYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405726613", "bodyText": "I changed it to             data = IOUtils.toString(request.getInputStream(), \"UTF-8\");", "author": "markus7017", "createdAt": "2020-04-08T18:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NDcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\nindex 4e090088fc..b880b411f6 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n\n@@ -52,44 +54,40 @@ public class ShellyEventServlet extends HttpServlet {\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private final HttpService httpService;\n-    private final ShellyHandlerFactory handlerFactory;\n+    private @Nullable HttpService httpService;\n+    private @Nullable ShellyHandlerFactory handlerFactory;\n \n+    @SuppressWarnings(\"null\")\n     @Activate\n-    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n-            Map<String, Object> config) {\n-        this.httpService = httpService;\n-        this.handlerFactory = handlerFactory;\n+    protected void activate(Map<String, Object> config) {\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n-            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n+    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        httpService.unregister(SHELLY_CALLBACK_URI);\n-        logger.debug(\"ShellyEventServlet stopped\");\n+        if (httpService != null) {\n+            httpService.unregister(SHELLY_CALLBACK_URI);\n+        }\n+        logger.debug(\"Shelly: CallbackServlet stopped\");\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException, IllegalArgumentException {\n-        String data = \"\";\n-        String path = \"\";\n+            throws ServletException, IOException {\n+        String data = inputStreamToString(request);\n+        String path = request.getRequestURI().toLowerCase();\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n-        if ((request == null) || (resp == null)) {\n-            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");\n-        }\n-\n         try {\n-            path = request.getRequestURI().toLowerCase();\n-            data = IOUtils.toString(request.getInputStream());\n             String ipAddress = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n             if (ipAddress == null) {\n                 ipAddress = request.getRemoteAddr();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404385526", "bodyText": "Why is this a field?", "author": "cpmeister", "createdAt": "2020-04-06T21:01:12Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -64,31 +70,31 @@\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler thingHandler;\n-    private final ShellyThingConfiguration config;\n-    private final GsonBuilder gsonBuilder;\n+    private final ShellyBaseHandler th;\n+    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n+    private final GsonBuilder gsonBuilder = new GsonBuilder();", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex d3b6e84ba6..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -70,31 +64,31 @@ import com.google.gson.GsonBuilder;\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler th;\n-    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    private final GsonBuilder gsonBuilder = new GsonBuilder();\n+    private final ShellyBaseHandler thingHandler;\n+    private final ShellyThingConfiguration config;\n+    private final GsonBuilder gsonBuilder;\n     private final Gson gson;\n     private String thingName;\n-    private boolean discovering = false;\n \n-    private final ShellyCoapServer coapServer;\n+    private @Nullable ShellyCoapServer coapServer;\n     private @Nullable CoapClient statusClient;\n-    private Request reqDescription = new Request(Code.GET, Type.CON);;\n-    private Request reqStatus = new Request(Code.GET, Type.CON);\n+    private @Nullable Request reqDescription;\n+    private @Nullable Request reqStatus;\n \n     private int lastSerial = -1;\n-    private Double lastBrightness = -1.0;\n     private String lastPayload = \"\";\n     private Map<String, CoIotDescrBlk> blockMap = new HashMap<>();\n     private Map<String, CoIotDescrSen> sensorMap = new HashMap<>();\n \n-    private static final byte[] EMPTY_BYTE = new byte[0];\n-\n-    public ShellyCoapHandler(ShellyBaseHandler th, ShellyCoapServer coapServer) {\n-        this.th = th;\n+    public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thingHandler,\n+            @Nullable ShellyCoapServer coapServer) {\n+        Validate.notNull(coapServer);\n+        this.thingHandler = thingHandler;\n         this.coapServer = coapServer;\n-        this.thingName = th.thingName;\n+        this.config = config;\n+        this.thingName = thingHandler.thingName;\n \n+        gsonBuilder = new GsonBuilder();\n         gsonBuilder.registerTypeAdapter(CoIotGenericSensorList.class, new CoIotSensorTypeAdapter());\n         gsonBuilder.setPrettyPrinting();\n         gson = gsonBuilder.create();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404386340", "bodyText": "It was better when this field was named thingHandler.", "author": "cpmeister", "createdAt": "2020-04-06T21:02:44Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -64,31 +70,31 @@\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler thingHandler;\n-    private final ShellyThingConfiguration config;\n-    private final GsonBuilder gsonBuilder;\n+    private final ShellyBaseHandler th;\n+    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n+    private final GsonBuilder gsonBuilder = new GsonBuilder();\n     private final Gson gson;\n     private String thingName;\n+    private boolean discovering = false;\n \n-    private @Nullable ShellyCoapServer coapServer;\n+    private final ShellyCoapServer coapServer;\n     private @Nullable CoapClient statusClient;\n-    private @Nullable Request reqDescription;\n-    private @Nullable Request reqStatus;\n+    private Request reqDescription = new Request(Code.GET, Type.CON);;\n+    private Request reqStatus = new Request(Code.GET, Type.CON);\n \n     private int lastSerial = -1;\n+    private Double lastBrightness = -1.0;\n     private String lastPayload = \"\";\n     private Map<String, CoIotDescrBlk> blockMap = new HashMap<>();\n     private Map<String, CoIotDescrSen> sensorMap = new HashMap<>();\n \n-    public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thingHandler,\n-            @Nullable ShellyCoapServer coapServer) {\n-        Validate.notNull(coapServer);\n-        this.thingHandler = thingHandler;\n+    private static final byte[] EMPTY_BYTE = new byte[0];\n+\n+    public ShellyCoapHandler(ShellyBaseHandler th, ShellyCoapServer coapServer) {\n+        this.th = th;", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NDY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405684662", "bodyText": "that causes a lot of line breaks, because statements getting longer = harder to read", "author": "markus7017", "createdAt": "2020-04-08T17:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1ODMxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405758317", "bodyText": "A poorly named variable makes code much harder to read than longer statements.", "author": "cpmeister", "createdAt": "2020-04-08T19:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3Mzg1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406173854", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-09T12:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex d3b6e84ba6..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -70,31 +64,31 @@ import com.google.gson.GsonBuilder;\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler th;\n-    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    private final GsonBuilder gsonBuilder = new GsonBuilder();\n+    private final ShellyBaseHandler thingHandler;\n+    private final ShellyThingConfiguration config;\n+    private final GsonBuilder gsonBuilder;\n     private final Gson gson;\n     private String thingName;\n-    private boolean discovering = false;\n \n-    private final ShellyCoapServer coapServer;\n+    private @Nullable ShellyCoapServer coapServer;\n     private @Nullable CoapClient statusClient;\n-    private Request reqDescription = new Request(Code.GET, Type.CON);;\n-    private Request reqStatus = new Request(Code.GET, Type.CON);\n+    private @Nullable Request reqDescription;\n+    private @Nullable Request reqStatus;\n \n     private int lastSerial = -1;\n-    private Double lastBrightness = -1.0;\n     private String lastPayload = \"\";\n     private Map<String, CoIotDescrBlk> blockMap = new HashMap<>();\n     private Map<String, CoIotDescrSen> sensorMap = new HashMap<>();\n \n-    private static final byte[] EMPTY_BYTE = new byte[0];\n-\n-    public ShellyCoapHandler(ShellyBaseHandler th, ShellyCoapServer coapServer) {\n-        this.th = th;\n+    public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thingHandler,\n+            @Nullable ShellyCoapServer coapServer) {\n+        Validate.notNull(coapServer);\n+        this.thingHandler = thingHandler;\n         this.coapServer = coapServer;\n-        this.thingName = th.thingName;\n+        this.config = config;\n+        this.thingName = thingHandler.thingName;\n \n+        gsonBuilder = new GsonBuilder();\n         gsonBuilder.registerTypeAdapter(CoIotGenericSensorList.class, new CoIotSensorTypeAdapter());\n         gsonBuilder.setPrettyPrinting();\n         gson = gsonBuilder.create();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404388456", "bodyText": "I assume that sensorMap is a LinkedHashMap or an immutable map otherwise this id generation can get very inconsistent.", "author": "cpmeister", "createdAt": "2020-04-06T21:06:55Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -698,48 +822,60 @@ private void resetSerial() {\n      * @param sensorId The id from the sensor update\n      * @return Index of found entry (+1 will be the suffix for the channel name) or null if sensorId is not found\n      */\n-    @SuppressWarnings(\"null\")\n-    @Nullable\n-    private Integer getInputId(String sensorId) {\n-        Integer idx = 0;\n+    private int getSensorNumber(String sensorName, String sensorId) {\n+        int idx = 0;\n         for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {\n-            @Nullable\n             CoIotDescrSen sen = se.getValue();\n-            if (sen.id.equalsIgnoreCase(\"Input\")) {\n+            if (sen.desc.equalsIgnoreCase(sensorName)) {\n                 idx++; // iterate from input1..2..n\n             }\n-            if (sen.id.equalsIgnoreCase(sensorId)) {\n+            if (sen.id.equalsIgnoreCase(sensorId) && blockMap.containsKey(sen.links)) {\n                 CoIotDescrBlk blk = blockMap.get(sen.links);\n-                if ((blk != null) && StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n+                if (StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n                     idx = Integer.parseInt(StringUtils.substringAfter(blk.desc, \"Relay\"));\n                 }\n-                logger.trace(\"{}:    map to input{} channel\", thingName, idx);\n+                logger.trace(\"{}:    map sensor {}{} to index {}\", thingName, sensorName, sensorId, idx);\n+                return idx;\n+            }\n+        }\n+        logger.debug(\"{}: sensorId {} not found in sensorMap!\", thingName, sensorId);\n+        return -1;\n+    }\n+\n+    private int getExtTempId(String sensorId) {\n+        int idx = 0;\n+        for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405685227", "bodyText": "changed to LinkedHashMap", "author": "markus7017", "createdAt": "2020-04-08T17:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex d3b6e84ba6..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -822,60 +698,48 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n      * @param sensorId The id from the sensor update\n      * @return Index of found entry (+1 will be the suffix for the channel name) or null if sensorId is not found\n      */\n-    private int getSensorNumber(String sensorName, String sensorId) {\n-        int idx = 0;\n+    @SuppressWarnings(\"null\")\n+    @Nullable\n+    private Integer getInputId(String sensorId) {\n+        Integer idx = 0;\n         for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {\n+            @Nullable\n             CoIotDescrSen sen = se.getValue();\n-            if (sen.desc.equalsIgnoreCase(sensorName)) {\n+            if (sen.id.equalsIgnoreCase(\"Input\")) {\n                 idx++; // iterate from input1..2..n\n             }\n-            if (sen.id.equalsIgnoreCase(sensorId) && blockMap.containsKey(sen.links)) {\n+            if (sen.id.equalsIgnoreCase(sensorId)) {\n                 CoIotDescrBlk blk = blockMap.get(sen.links);\n-                if (StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n+                if ((blk != null) && StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n                     idx = Integer.parseInt(StringUtils.substringAfter(blk.desc, \"Relay\"));\n                 }\n-                logger.trace(\"{}:    map sensor {}{} to index {}\", thingName, sensorName, sensorId, idx);\n-                return idx;\n-            }\n-        }\n-        logger.debug(\"{}: sensorId {} not found in sensorMap!\", thingName, sensorId);\n-        return -1;\n-    }\n-\n-    private int getExtTempId(String sensorId) {\n-        int idx = 0;\n-        for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {\n-            CoIotDescrSen sen = se.getValue();\n-            if (sen.desc.equalsIgnoreCase(\"External_temperature\")) {\n-                idx++; // iterate from temperature1..2..n\n-            }\n-            if (sen.id.equalsIgnoreCase(sensorId)) {\n-                logger.trace(\"{}:    map sensir id {}\u00a0to temperature{} channel\", thingName, sensorId, idx);\n+                logger.trace(\"{}:    map to input{} channel\", thingName, idx);\n                 return idx;\n             }\n         }\n         logger.debug(\"{}: sensorId {} not found in sensorMap!\", thingName, sensorId);\n-        return -1;\n+        return null;\n     }\n \n     /**\n      * Cancel pending requests and shutdown the client\n      */\n+    @SuppressWarnings(\"null\")\n     public void stop() {\n-        if (isStarted()) {\n-            logger.debug(\"{}: Stopping CoapHandler\", thingName);\n-            coapServer.removeListener(this);\n-            if (statusClient != null) {\n-                statusClient.shutdown();\n-                statusClient = null;\n-            }\n-            if (!reqDescription.isCanceled()) {\n-                reqDescription.cancel();\n-            }\n-            if (!reqStatus.isCanceled()) {\n-                reqStatus.cancel();\n-            }\n+        logger.debug(\"{}: Stop CoapHandler instance\", thingName);\n+        if ((reqDescription != null) && !reqDescription.isCanceled()) {\n+            reqDescription.cancel();\n+            reqDescription = null;\n+        }\n+        if ((reqStatus != null) && !reqStatus.isCanceled()) {\n+            reqStatus.cancel();\n+            reqStatus = null;\n+        }\n+        if (statusClient != null) {\n+            statusClient.shutdown();\n+            statusClient = null;\n         }\n+        coapServer.removeListener(this);\n     }\n \n     public void dispose() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404388918", "bodyText": "No need to create an Integer instance when you don't have to.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                sensor.id = new Integer(in.nextInt()).toString();\n          \n          \n            \n                                sensor.id = Integer.toString(in.nextInt());", "author": "cpmeister", "createdAt": "2020-04-06T21:07:51Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java", "diffHunk": "@@ -110,14 +120,13 @@ public CoIotGenericSensorList read(final JsonReader in) throws IOException {\n \n             in.beginObject();\n             String generic = in.nextName();\n-            Validate.notNull(generic, \"Invalid JSon format for CoIotSensorList\");\n             if (generic.equals(COIOT_TAG_GENERIC)) {\n                 in.beginArray();\n                 while (in.hasNext()) {\n                     in.beginArray();\n                     final CoIotSensor sensor = new CoIotSensor();\n                     in.nextInt(); // alway 0\n-                    sensor.index = new Integer(in.nextInt()).toString();\n+                    sensor.id = new Integer(in.nextInt()).toString();", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NzA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405687087", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T17:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODkxOA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java\nindex d9367418c7..78622e0c40 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java\n\n@@ -120,13 +110,14 @@ public class ShellyCoapJSonDTO {\n \n             in.beginObject();\n             String generic = in.nextName();\n+            Validate.notNull(generic, \"Invalid JSon format for CoIotSensorList\");\n             if (generic.equals(COIOT_TAG_GENERIC)) {\n                 in.beginArray();\n                 while (in.hasNext()) {\n                     in.beginArray();\n                     final CoIotSensor sensor = new CoIotSensor();\n                     in.nextInt(); // alway 0\n-                    sensor.id = new Integer(in.nextInt()).toString();\n+                    sensor.index = new Integer(in.nextInt()).toString();\n                     sensor.value = in.nextDouble();\n                     in.endArray();\n                     list.generic.add(sensor);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjIwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404396200", "bodyText": "Please make a local variable out of getThing().getStatus() so you can reuse it.", "author": "cpmeister", "createdAt": "2020-04-06T21:21:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,43 +303,38 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}:{}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n             }\n-        } finally {\n-            lockUpdates = false;\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n         }\n     }\n \n     /**\n      * Update device status and channels\n      */\n-    @SuppressWarnings(\"null\")\n-    protected void updateStatus() {\n+    protected void refreshStatus() {\n         try {\n             boolean updated = false;\n \n             skipUpdate++;\n-            if (lockUpdates) {\n-                logger.trace(\"{}: Update locked, try on next cycle\", thingName);\n-                return;\n-            }\n-\n-            if ((skipUpdate % refreshCount == 0) && (profile != null)\n+            if ((skipUpdate % refreshCount == 0) && (profile.isInitialized())\n                     && (getThing().getStatus() == ThingStatus.ONLINE)) {", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxODA3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405718072", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T18:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex 7f34532664..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -303,38 +302,43 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (ShellyApiException e) {\n-            ShellyApiResult res = e.getApiResult();\n-            if (isAuthorizationFailed(res)) {\n+        } catch (NullPointerException | IOException e) {\n+            if (authorizationFailed(e.getMessage())) {\n                 return;\n             }\n-            if (res.isNotCalibrtated()) {\n-                logger.warn(\"{}:{}\", thingName, messages.get(\"roller.calibrating\"));\n+            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n+                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n             } else {\n-                logger.info(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n+                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n+                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n             }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n+        } finally {\n+            lockUpdates = false;\n         }\n     }\n \n     /**\n      * Update device status and channels\n      */\n-    protected void refreshStatus() {\n+    @SuppressWarnings(\"null\")\n+    protected void updateStatus() {\n         try {\n             boolean updated = false;\n \n             skipUpdate++;\n-            if ((skipUpdate % refreshCount == 0) && (profile.isInitialized())\n+            if (lockUpdates) {\n+                logger.trace(\"{}: Update locked, try on next cycle\", thingName);\n+                return;\n+            }\n+\n+            if ((skipUpdate % refreshCount == 0) && (profile != null)\n                     && (getThing().getStatus() == ThingStatus.ONLINE)) {\n                 refreshSettings |= !profile.hasBattery;\n             }\n \n             if (refreshSettings || (scheduledUpdates > 0) || (skipUpdate % skipCount == 0)) {\n-                if ((!profile.isInitialized()) || ((getThing().getStatus() == ThingStatus.OFFLINE)\n-                        || (getThing().getStatus() == ThingStatus.UNKNOWN) && (getThing().getStatusInfo()\n-                                .getStatusDetail() != ThingStatusDetail.CONFIGURATION_ERROR))) {\n+                if ((profile == null) || ((getThing().getStatus() == ThingStatus.OFFLINE)\n+                        && (getThing().getStatusInfo().getStatusDetail() != ThingStatusDetail.CONFIGURATION_ERROR))) {\n                     logger.debug(\"{}: Status update triggered thing initialization\", thingName);\n                     initializeThing(); // may fire an exception if initialization failed\n                 }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5Njk5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404396997", "bodyText": "This is already handled for you by the BaseThingHandler. So you don't need this method.", "author": "cpmeister", "createdAt": "2020-04-06T21:23:32Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -357,93 +353,119 @@ protected void updateStatus() {\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                if (!profile.hasBattery) { // ignore Timeouts for Sensors\n+                    status = \"offline.status-error-timeout\";\n+                }\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            }\n-            if ((skipUpdate >= cacheCount) && !channelCache) {\n+                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            } else if ((skipUpdate >= cacheCount) && cache.isEnabled()) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                channelCache = true;\n+                cache.enable();\n             }\n         }\n+    }\n+\n+    public boolean isThingOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    public boolean isThingOffline() {\n+        ThingStatus status = getThing().getStatus();\n+        return status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN;\n+    }\n+\n+    public void setThingOnline() {\n+        if (!isThingOnline()) {\n+            setThingStatus(ThingStatus.ONLINE);\n+            requestUpdates(!profile.hasBattery ? 3 : 1, false); // request 3 updates in a row (during the first 2+3*3\n+                                                                // sec)\n+        }\n+    }\n+\n+    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n+        if (getThing().getStatus() != ThingStatus.OFFLINE) {\n+            setThingStatus(ThingStatus.OFFLINE, detail, messageKey);\n+            channelsCreated = false; // check for new channels after devices gets re-initialized (e.g. new\n+        }\n+    }\n \n+    public void setThingStatus(ThingStatus newStatus) {\n+        if (getThing().getStatus() != newStatus) {", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMzA1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405723052", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-08T18:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5Njk5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex 7f34532664..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -353,119 +357,93 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n-                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n-                // All channels must be created after the first cycle\n-                channelsCreated = true;\n-\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (ShellyApiException e) {\n+        } catch (IOException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            ShellyApiResult res = e.getApiResult();\n-            if (e.isTimeout()) {\n-                if (!profile.hasBattery) { // ignore Timeouts for Sensors\n-                    status = \"offline.status-error-timeout\";\n-                }\n-            } else if (res.isHttpAccessUnauthorized()) {\n-                status = \"offline.conf-error-access-denied\";\n+            if (e.getMessage().contains(\"Timeout\")) {\n+                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n+                        skipCount, scheduledUpdates);\n+                status = \"@text/offline.status-error-timeout\";\n+            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n+                status = \"@text/offline.conf-error-access-denied\";\n+            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n+                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n+                        thingName);\n+                status = \"@text/offline.conf-error-not-calibrated\";\n             } else {\n-                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+                status = \"@text/offline.status-error-unexpected-api-result\";\n             }\n-\n-            if (!status.isEmpty()) {\n-                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n+            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n+        } catch (NullPointerException e) {\n+            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            } else if ((skipUpdate >= cacheCount) && cache.isEnabled()) {\n+                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            }\n+            if ((skipUpdate >= cacheCount) && !channelCache) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                cache.enable();\n+                channelCache = true;\n             }\n         }\n-    }\n-\n-    public boolean isThingOnline() {\n-        return getThing().getStatus() == ThingStatus.ONLINE;\n-    }\n-\n-    public boolean isThingOffline() {\n-        ThingStatus status = getThing().getStatus();\n-        return status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN;\n-    }\n-\n-    public void setThingOnline() {\n-        if (!isThingOnline()) {\n-            setThingStatus(ThingStatus.ONLINE);\n-            requestUpdates(!profile.hasBattery ? 3 : 1, false); // request 3 updates in a row (during the first 2+3*3\n-                                                                // sec)\n-        }\n-    }\n-\n-    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n-        if (getThing().getStatus() != ThingStatus.OFFLINE) {\n-            setThingStatus(ThingStatus.OFFLINE, detail, messageKey);\n-            channelsCreated = false; // check for new channels after devices gets re-initialized (e.g. new\n-        }\n-    }\n \n-    public void setThingStatus(ThingStatus newStatus) {\n-        if (getThing().getStatus() != newStatus) {\n-            logger.debug(\"{}: Changing Thing status from {} to {}\", thingName, getThing().getStatus(), newStatus);\n-            updateStatus(newStatus);\n-        }\n-    }\n-\n-    public void setThingStatus(ThingStatus newStatus, ThingStatusDetail detail, String messageKey) {\n-        if (getThing().getStatus() != newStatus) {\n-            logger.debug(\"{}: Changing Thing status from {} to {}.{} ({})\", thingName, getThing().getStatus(),\n-                    newStatus, detail, messageKey);\n-            updateStatus(newStatus, detail, \"@text/\" + messageKey);\n-        }\n     }\n \n+    @SuppressWarnings(\"null\")\n     private void fillDeviceStatus(ShellySettingsStatus status, boolean updated) {\n         String alarm = \"\";\n         boolean force = false;\n-        Map<String, String> propertyUpdates = new TreeMap<>();\n \n-        // Update uptime and WiFi, internal temp\n-        ShellyComponents.updateDeviceStatus(this, status);\n+        Map<String, String> propertyUpdates = new HashMap<>();\n+\n+        // Update uptime and WiFi\n+        if (updated) {\n+            lastUpdateTs = now();\n+        }\n+        long uptime = getLong(status.uptime);\n+        Integer rssi = getInteger(status.wifiSta.rssi);\n+        updateChannel(CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_UPTIME,\n+                toQuantityType(new DecimalType(uptime), SmartHomeUnits.SECOND));\n+        updateChannel(CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_RSSI, mapSignalStrength(rssi));\n \n-        if (api.isInitialized() && (lastTimeoutErros != api.getTimeoutErrors())) {\n+        if ((api != null) && (lastTimeoutErros != api.getTimeoutErrors())) {\n             propertyUpdates.put(PROPERTY_STATS_TIMEOUTS, new Integer(api.getTimeoutErrors()).toString());\n             propertyUpdates.put(PROPERTY_STATS_TRECOVERED, new Integer(api.getTimeoutsRecovered()).toString());\n             lastTimeoutErros = api.getTimeoutErrors();\n         }\n \n         // Check various device indicators like overheating\n-        if ((status.uptime < lastUptime) && (profile.isInitialized()) && !profile.hasBattery) {\n+        if ((status.uptime < lastUptime) && (profile != null) && !profile.hasBattery) {\n             alarm = ALARM_TYPE_RESTARTED;\n             force = true;\n         }\n-        lastUptime = getLong(status.uptime);\n+        lastUptime = uptime;\n \n         if (getBool(status.overtemperature)) {\n             alarm = ALARM_TYPE_OVERTEMP;\n-        } else if (getBool(status.overload)) {\n+        }\n+        if (getBool(status.overload)) {\n             alarm = ALARM_TYPE_OVERLOAD;\n-        } else if (getBool(status.loaderror)) {\n+        }\n+        if (getBool(status.loaderror)) {\n             alarm = ALARM_TYPE_LOADERR;\n         }\n \n         if (!alarm.isEmpty()) {\n-            postEvent(alarm, force);\n+            postAlarm(alarm, force);\n         }\n \n         if (!propertyUpdates.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404399827", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;\n          \n          \n            \n                        int rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;", "author": "cpmeister", "createdAt": "2020-04-06T21:28:58Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -482,22 +503,30 @@ public void postAlarm(String alarm, boolean force) {\n      * @param data the HTML input data\n      * @return true if event was processed\n      */\n-    @SuppressWarnings({ \"null\" })\n     @Override\n-    public boolean onEvent(String deviceName, String deviceIndex, String type, Map<String, String> parameters) {\n-        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(deviceName)) {\n+    public boolean onEvent(String ipAddress, String deviceName, String deviceIndex, String type,\n+            Map<String, @Nullable String> parameters) {\n+        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(ipAddress)) {\n             logger.debug(\"{}: Event received: class={}, index={}, parameters={}\", deviceName, type, deviceIndex,\n                     parameters.toString());\n-            boolean hasBattery = profile != null && profile.hasBattery ? true : false;\n-            if (profile == null) {\n+            Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNDEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405724128", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T18:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTgyNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex 7f34532664..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -503,30 +482,22 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n      * @param data the HTML input data\n      * @return true if event was processed\n      */\n+    @SuppressWarnings({ \"null\" })\n     @Override\n-    public boolean onEvent(String ipAddress, String deviceName, String deviceIndex, String type,\n-            Map<String, @Nullable String> parameters) {\n-        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(ipAddress)) {\n+    public boolean onEvent(String deviceName, String deviceIndex, String type, Map<String, String> parameters) {\n+        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(deviceName)) {\n             logger.debug(\"{}: Event received: class={}, index={}, parameters={}\", deviceName, type, deviceIndex,\n                     parameters.toString());\n-            Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;\n-            if (!profile.isInitialized()) {\n+            boolean hasBattery = profile != null && profile.hasBattery ? true : false;\n+            if (profile == null) {\n                 logger.debug(\"{}: Device is not yet initialized, event triggers initialization\", deviceName);\n                 requestUpdates(1, true);\n             } else {\n                 String group = \"\";\n-                boolean isButton = false;\n+                Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;\n                 if (type.equals(EVENT_TYPE_RELAY)) {\n                     group = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                             : CHANNEL_GROUP_RELAY_CONTROL + rindex.toString();\n-                    int i = Integer.parseInt(deviceIndex);\n-                    if ((i >= 0) && (i <= profile.settings.relays.size())) {\n-                        ShellySettingsRelay relay = profile.settings.relays.get(i);\n-                        if ((relay != null) && (relay.btnType.equalsIgnoreCase(SHELLY_BTNT_MOMENTARY)\n-                                || relay.btnType.equalsIgnoreCase(SHELLY_BTNT_DETACHED))) {\n-                            isButton = true;\n-                        }\n-                    }\n                 }\n                 if (type.equals(EVENT_TYPE_ROLLER)) {\n                     group = profile.numRollers <= 1 ? CHANNEL_GROUP_ROL_CONTROL\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404402967", "bodyText": "All of these fields should be final and moved to the top of this class.", "author": "cpmeister", "createdAt": "2020-04-06T21:35:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.handler;\n+\n+import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n+import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n+import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n+\n+/**\n+ * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n+ * added on the first thing status update\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelDefinitionsDTO {\n+\n+    private static final ChannelMap channelDefinitions = new ChannelMap();\n+\n+    private static String CHGR_METER = CHANNEL_GROUP_METER;\n+    private static String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n+    private static String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n+\n+    public ShellyChannelDefinitionsDTO(ShellyTranslationProvider m) {\n+        // Device: Internal Temp\n+        channelDefinitions\n+                // Device\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP, \"deviceTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP, \"sensorWakeup\",\n+                        ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS, \"meterAccuWatts\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL, \"meterAccuTotal\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCURETURNED, \"meterAccuReturned\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER, \"charger\", ITEM_TYPE_SWITCH))\n+\n+                // Power Meter\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_CURRENTWATTS, \"meterWatts\", ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_TOTALKWH, \"meterTotal\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN1, \"lastPower1\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN2, \"lastPower2\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN3, \"lastPower3\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n+\n+                // EMeter\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_TOTALRET, \"meterReturned\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_REACTWATTS, \"meterReactive\", ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_VOLTAGE, \"meterVoltage\", ITEM_TYPE_VOLT))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_CURRENT, \"meterCurrent\", ITEM_TYPE_AMP))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_PFACTOR, \"meterPowerFactor\", ITEM_TYPE_NUMBER))\n+\n+                // Sensors\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_TEMP, \"sensorTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_HUM, \"sensorHumidity\", ITEM_TYPE_PERCENT))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_LUX, \"sensorLux\", ITEM_TYPE_LUX))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ILLUM, \"sensorIllumination\", ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_VIBRATION, \"sensorVibration\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_FLOOD, \"sensorFlood\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_SMOKE, \"sensorSmoke\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_STATE, \"sensorState\", ITEM_TYPE_CONTACT))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_MOTION, \"sensorMotion\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ERROR, \"sensorError\", ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n+\n+                // Addon with external sensors\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY, \"sensorExtHum\", ITEM_TYPE_PERCENT))\n+\n+                // Battery\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LEVEL, \"system:battery-level\",\n+                        ITEM_TYPE_PERCENT))\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LOW, \"system:low-battery\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_VOLT, \"batVoltage\", ITEM_TYPE_VOLT))\n+\n+        ;\n+    }\n+\n+    public static ShellyChannel getDefinition(String channelName) throws IllegalArgumentException {\n+        String group = StringUtils.substringBefore(channelName, \"#\");\n+        String channel = StringUtils.substringAfter(channelName, \"#\");\n+        if (group.contains(CHANNEL_GROUP_METER)) {\n+            group = CHANNEL_GROUP_METER; // map meter1..n to meter\n+        } else if (group.contains(CHANNEL_GROUP_RELAY_CONTROL)) {\n+            group = CHANNEL_GROUP_RELAY_CONTROL; // map meter1..n to meter\n+        }\n+        String channelId = group + \"#\" + channel;\n+        return channelDefinitions.get(channelId);\n+    }\n+\n+    /**\n+     * Auto-create relay channels depending on relay type/mode\n+     *\n+     * @return ArrayList<Channel> of channels to be added to the thing\n+     */\n+    public static Map<String, Channel> createDeviceChannels(final Thing thing, final ShellyDeviceProfile profile,\n+            final ShellySettingsStatus status) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+        if (!profile.isSensor) {\n+            // Only some devices report the internal device temp\n+            addChannel(thing, add, (status.tmp != null) || (status.temperature != null), CHANNEL_GROUP_DEV_STATUS,\n+                    CHANNEL_DEVST_ITEMP);\n+\n+            // If device has more than 1 meter the channel accumulatedWatts receives the accumulated value\n+            boolean accuChannel = (((status.meters != null) && (status.meters.size() > 1) && (status.rollers == null))\n+                    || ((status.emeters != null && status.emeters.size() > 1)));\n+            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS);\n+            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL);\n+            addChannel(thing, add, accuChannel && (status.emeters != null), CHANNEL_GROUP_DEV_STATUS,\n+                    CHANNEL_DEVST_ACCURETURNED);\n+        }\n+        return add;\n+    }\n+\n+    /**\n+     * Auto-create relay channels depending on relay type/mode\n+     *\n+     * @return ArrayList<Channel> of channels to be added to the thing\n+     */\n+    public static Map<String, Channel> createRelayChannels(final Thing thing, final ShellyStatusRelay relays) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+\n+        // Shelly 1/1PM Addon\n+        if (relays.extTemperature != null) {\n+            addChannel(thing, add, relays.extTemperature.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1);\n+            addChannel(thing, add, relays.extTemperature.sensor2 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2);\n+            addChannel(thing, add, relays.extTemperature.sensor3 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3);\n+        }\n+        if (relays.extHumidity != null) {\n+            addChannel(thing, add, relays.extHumidity.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY);\n+        }\n+        return add;\n+    }\n+\n+    public static Map<String, Channel> createRollerChannels(Thing thing, final ShellyControlRoller roller) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+\n+        // No dynamic channels so far, maybe added in the future\n+\n+        return add;\n+    }\n+\n+    public static Map<String, Channel> createMeterChannels(Thing thing, final ShellySettingsMeter meter, String group) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        addChannel(thing, newChannels, meter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n+        addChannel(thing, newChannels, meter.total != null, group, CHANNEL_METER_TOTALKWH);\n+        if (meter.counters != null) {\n+            addChannel(thing, newChannels, meter.counters[0] != null, group, CHANNEL_METER_LASTMIN1);\n+            addChannel(thing, newChannels, meter.counters[1] != null, group, CHANNEL_METER_LASTMIN2);\n+            addChannel(thing, newChannels, meter.counters[2] != null, group, CHANNEL_METER_LASTMIN3);\n+        }\n+        addChannel(thing, newChannels, meter.timestamp != null, group, CHANNEL_LAST_UPDATE);\n+        return newChannels;\n+    }\n+\n+    public static Map<String, Channel> createEMeterChannels(final Thing thing, final ShellySettingsEMeter emeter,\n+            String group) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        addChannel(thing, newChannels, emeter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n+        addChannel(thing, newChannels, emeter.total != null, group, CHANNEL_METER_TOTALKWH);\n+        addChannel(thing, newChannels, emeter.totalReturned != null, group, CHANNEL_EMETER_TOTALRET);\n+        addChannel(thing, newChannels, emeter.reactive != null, group, CHANNEL_EMETER_REACTWATTS);\n+        addChannel(thing, newChannels, emeter.voltage != null, group, CHANNEL_EMETER_VOLTAGE);\n+        addChannel(thing, newChannels, emeter.current != null, group, CHANNEL_EMETER_CURRENT);\n+        addChannel(thing, newChannels, emeter.pf != null, group, CHANNEL_EMETER_PFACTOR);\n+        addChannel(thing, newChannels, true, group, CHANNEL_LAST_UPDATE);\n+        return newChannels;\n+    }\n+\n+    public static Map<String, Channel> createSensorChannels(final Thing thing, final ShellyStatusSensor sdata) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        // Sensor data\n+        addChannel(thing, newChannels, sdata.tmp != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP);\n+        addChannel(thing, newChannels, sdata.hum != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_HUM);\n+        addChannel(thing, newChannels, sdata.lux != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_LUX);\n+        addChannel(thing, newChannels, sdata.accel != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_VIBRATION);\n+        addChannel(thing, newChannels, sdata.flood != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n+        addChannel(thing, newChannels, sdata.smoke != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n+        addChannel(thing, newChannels, sdata.lux != null && sdata.lux.illumination != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_ILLUM);\n+        addChannel(thing, newChannels, sdata.contact != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_STATE);\n+        addChannel(thing, newChannels, sdata.motion != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_MOTION);\n+        addChannel(thing, newChannels, sdata.charger != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER);\n+        addChannel(thing, newChannels, sdata.sensorError != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_ERROR);\n+        addChannel(thing, newChannels, true, CHANNEL_GROUP_SENSOR, CHANNEL_LAST_UPDATE);\n+        addChannel(thing, newChannels, sdata.actReasons != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP);\n+\n+        // Battery\n+        if (sdata.bat != null) {\n+            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL);\n+            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LOW);\n+            addChannel(thing, newChannels, sdata.bat.voltage != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_VOLT);\n+        }\n+        return newChannels;\n+    }\n+\n+    private static void addChannel(Thing thing, Map<String, Channel> newChannels, boolean supported, String group,\n+            String channelName) throws IllegalArgumentException {\n+        if (supported) {\n+            final String channelId = group + \"#\" + channelName;\n+            final ShellyChannel channelDef = getDefinition(channelId);\n+            final ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            final ChannelTypeUID channelTypeUID = channelDef.typeId.contains(\"system:\")\n+                    ? new ChannelTypeUID(channelDef.typeId)\n+                    : new ChannelTypeUID(BINDING_ID, channelDef.typeId);\n+\n+            // Channel channel = ChannelBuilder.create(channelUID, channelId).withType(channelTypeUID)\n+            // .withLabel(channelDef.label).withDescription(channelDef.description).build();\n+            Channel channel = ChannelBuilder.create(channelUID, channelDef.itemType).withType(channelTypeUID).build();\n+            newChannels.put(channelId, channel);\n+        }\n+    }\n+\n+    public static String ITEM_TYPE_NUMBER = \"Number\";\n+    public static String ITEM_TYPE_STRING = \"String\";\n+    public static String ITEM_TYPE_DATETIME = \"DateTime\";\n+    public static String ITEM_TYPE_TEMP = \"Number:Temperature\";\n+    public static String ITEM_TYPE_LUX = \"Number:Illuminance\";\n+    public static String ITEM_TYPE_POWER = \"Number:Power\";\n+    public static String ITEM_TYPE_ENERGY = \"Number:Energy\";\n+    public static String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n+    public static String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n+    public static String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n+    public static String ITEM_TYPE_SWITCH = \"Switch\";\n+    public static String ITEM_TYPE_CONTACT = \"Contact\";\n+\n+    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n+    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n+    public static String SUFFIX_LABEL = \".label\";\n+    public static String SUFFIX_DESCR = \".description\";", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxNDUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405714517", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T18:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjk2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java\ndeleted file mode 100644\nindex 58c7e0839f..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java\n+++ /dev/null\n\n@@ -1,326 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.handler;\n-\n-import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.smarthome.core.thing.Channel;\n-import org.eclipse.smarthome.core.thing.ChannelUID;\n-import org.eclipse.smarthome.core.thing.Thing;\n-import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n-import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n-import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n-import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n-\n-/**\n- * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n- * added on the first thing status update\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelDefinitionsDTO {\n-\n-    private static final ChannelMap channelDefinitions = new ChannelMap();\n-\n-    private static String CHGR_METER = CHANNEL_GROUP_METER;\n-    private static String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n-    private static String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n-\n-    public ShellyChannelDefinitionsDTO(ShellyTranslationProvider m) {\n-        // Device: Internal Temp\n-        channelDefinitions\n-                // Device\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP, \"deviceTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP, \"sensorWakeup\",\n-                        ITEM_TYPE_STRING))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS, \"meterAccuWatts\",\n-                        ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL, \"meterAccuTotal\",\n-                        ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCURETURNED, \"meterAccuReturned\",\n-                        ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER, \"charger\", ITEM_TYPE_SWITCH))\n-\n-                // Power Meter\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_CURRENTWATTS, \"meterWatts\", ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_TOTALKWH, \"meterTotal\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN1, \"lastPower1\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN2, \"lastPower2\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN3, \"lastPower3\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n-\n-                // EMeter\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_TOTALRET, \"meterReturned\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_REACTWATTS, \"meterReactive\", ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_VOLTAGE, \"meterVoltage\", ITEM_TYPE_VOLT))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_CURRENT, \"meterCurrent\", ITEM_TYPE_AMP))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_PFACTOR, \"meterPowerFactor\", ITEM_TYPE_NUMBER))\n-\n-                // Sensors\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_TEMP, \"sensorTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_HUM, \"sensorHumidity\", ITEM_TYPE_PERCENT))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_LUX, \"sensorLux\", ITEM_TYPE_LUX))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ILLUM, \"sensorIllumination\", ITEM_TYPE_STRING))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_VIBRATION, \"sensorVibration\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_FLOOD, \"sensorFlood\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_SMOKE, \"sensorSmoke\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_STATE, \"sensorState\", ITEM_TYPE_CONTACT))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_MOTION, \"sensorMotion\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ERROR, \"sensorError\", ITEM_TYPE_STRING))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n-\n-                // Addon with external sensors\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY, \"sensorExtHum\", ITEM_TYPE_PERCENT))\n-\n-                // Battery\n-                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LEVEL, \"system:battery-level\",\n-                        ITEM_TYPE_PERCENT))\n-                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LOW, \"system:low-battery\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_VOLT, \"batVoltage\", ITEM_TYPE_VOLT))\n-\n-        ;\n-    }\n-\n-    public static ShellyChannel getDefinition(String channelName) throws IllegalArgumentException {\n-        String group = StringUtils.substringBefore(channelName, \"#\");\n-        String channel = StringUtils.substringAfter(channelName, \"#\");\n-        if (group.contains(CHANNEL_GROUP_METER)) {\n-            group = CHANNEL_GROUP_METER; // map meter1..n to meter\n-        } else if (group.contains(CHANNEL_GROUP_RELAY_CONTROL)) {\n-            group = CHANNEL_GROUP_RELAY_CONTROL; // map meter1..n to meter\n-        }\n-        String channelId = group + \"#\" + channel;\n-        return channelDefinitions.get(channelId);\n-    }\n-\n-    /**\n-     * Auto-create relay channels depending on relay type/mode\n-     *\n-     * @return ArrayList<Channel> of channels to be added to the thing\n-     */\n-    public static Map<String, Channel> createDeviceChannels(final Thing thing, final ShellyDeviceProfile profile,\n-            final ShellySettingsStatus status) {\n-        Map<String, Channel> add = new LinkedHashMap<>();\n-        if (!profile.isSensor) {\n-            // Only some devices report the internal device temp\n-            addChannel(thing, add, (status.tmp != null) || (status.temperature != null), CHANNEL_GROUP_DEV_STATUS,\n-                    CHANNEL_DEVST_ITEMP);\n-\n-            // If device has more than 1 meter the channel accumulatedWatts receives the accumulated value\n-            boolean accuChannel = (((status.meters != null) && (status.meters.size() > 1) && (status.rollers == null))\n-                    || ((status.emeters != null && status.emeters.size() > 1)));\n-            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS);\n-            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL);\n-            addChannel(thing, add, accuChannel && (status.emeters != null), CHANNEL_GROUP_DEV_STATUS,\n-                    CHANNEL_DEVST_ACCURETURNED);\n-        }\n-        return add;\n-    }\n-\n-    /**\n-     * Auto-create relay channels depending on relay type/mode\n-     *\n-     * @return ArrayList<Channel> of channels to be added to the thing\n-     */\n-    public static Map<String, Channel> createRelayChannels(final Thing thing, final ShellyStatusRelay relays) {\n-        Map<String, Channel> add = new LinkedHashMap<>();\n-\n-        // Shelly 1/1PM Addon\n-        if (relays.extTemperature != null) {\n-            addChannel(thing, add, relays.extTemperature.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1);\n-            addChannel(thing, add, relays.extTemperature.sensor2 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2);\n-            addChannel(thing, add, relays.extTemperature.sensor3 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3);\n-        }\n-        if (relays.extHumidity != null) {\n-            addChannel(thing, add, relays.extHumidity.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY);\n-        }\n-        return add;\n-    }\n-\n-    public static Map<String, Channel> createRollerChannels(Thing thing, final ShellyControlRoller roller) {\n-        Map<String, Channel> add = new LinkedHashMap<>();\n-\n-        // No dynamic channels so far, maybe added in the future\n-\n-        return add;\n-    }\n-\n-    public static Map<String, Channel> createMeterChannels(Thing thing, final ShellySettingsMeter meter, String group) {\n-        Map<String, Channel> newChannels = new LinkedHashMap<>();\n-        addChannel(thing, newChannels, meter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n-        addChannel(thing, newChannels, meter.total != null, group, CHANNEL_METER_TOTALKWH);\n-        if (meter.counters != null) {\n-            addChannel(thing, newChannels, meter.counters[0] != null, group, CHANNEL_METER_LASTMIN1);\n-            addChannel(thing, newChannels, meter.counters[1] != null, group, CHANNEL_METER_LASTMIN2);\n-            addChannel(thing, newChannels, meter.counters[2] != null, group, CHANNEL_METER_LASTMIN3);\n-        }\n-        addChannel(thing, newChannels, meter.timestamp != null, group, CHANNEL_LAST_UPDATE);\n-        return newChannels;\n-    }\n-\n-    public static Map<String, Channel> createEMeterChannels(final Thing thing, final ShellySettingsEMeter emeter,\n-            String group) {\n-        Map<String, Channel> newChannels = new LinkedHashMap<>();\n-        addChannel(thing, newChannels, emeter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n-        addChannel(thing, newChannels, emeter.total != null, group, CHANNEL_METER_TOTALKWH);\n-        addChannel(thing, newChannels, emeter.totalReturned != null, group, CHANNEL_EMETER_TOTALRET);\n-        addChannel(thing, newChannels, emeter.reactive != null, group, CHANNEL_EMETER_REACTWATTS);\n-        addChannel(thing, newChannels, emeter.voltage != null, group, CHANNEL_EMETER_VOLTAGE);\n-        addChannel(thing, newChannels, emeter.current != null, group, CHANNEL_EMETER_CURRENT);\n-        addChannel(thing, newChannels, emeter.pf != null, group, CHANNEL_EMETER_PFACTOR);\n-        addChannel(thing, newChannels, true, group, CHANNEL_LAST_UPDATE);\n-        return newChannels;\n-    }\n-\n-    public static Map<String, Channel> createSensorChannels(final Thing thing, final ShellyStatusSensor sdata) {\n-        Map<String, Channel> newChannels = new LinkedHashMap<>();\n-        // Sensor data\n-        addChannel(thing, newChannels, sdata.tmp != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP);\n-        addChannel(thing, newChannels, sdata.hum != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_HUM);\n-        addChannel(thing, newChannels, sdata.lux != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_LUX);\n-        addChannel(thing, newChannels, sdata.accel != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_VIBRATION);\n-        addChannel(thing, newChannels, sdata.flood != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n-        addChannel(thing, newChannels, sdata.smoke != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n-        addChannel(thing, newChannels, sdata.lux != null && sdata.lux.illumination != null, CHANNEL_GROUP_SENSOR,\n-                CHANNEL_SENSOR_ILLUM);\n-        addChannel(thing, newChannels, sdata.contact != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n-                CHANNEL_SENSOR_STATE);\n-        addChannel(thing, newChannels, sdata.motion != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n-                CHANNEL_SENSOR_MOTION);\n-        addChannel(thing, newChannels, sdata.charger != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER);\n-        addChannel(thing, newChannels, sdata.sensorError != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_ERROR);\n-        addChannel(thing, newChannels, true, CHANNEL_GROUP_SENSOR, CHANNEL_LAST_UPDATE);\n-        addChannel(thing, newChannels, sdata.actReasons != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP);\n-\n-        // Battery\n-        if (sdata.bat != null) {\n-            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL);\n-            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LOW);\n-            addChannel(thing, newChannels, sdata.bat.voltage != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_VOLT);\n-        }\n-        return newChannels;\n-    }\n-\n-    private static void addChannel(Thing thing, Map<String, Channel> newChannels, boolean supported, String group,\n-            String channelName) throws IllegalArgumentException {\n-        if (supported) {\n-            final String channelId = group + \"#\" + channelName;\n-            final ShellyChannel channelDef = getDefinition(channelId);\n-            final ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n-            final ChannelTypeUID channelTypeUID = channelDef.typeId.contains(\"system:\")\n-                    ? new ChannelTypeUID(channelDef.typeId)\n-                    : new ChannelTypeUID(BINDING_ID, channelDef.typeId);\n-\n-            // Channel channel = ChannelBuilder.create(channelUID, channelId).withType(channelTypeUID)\n-            // .withLabel(channelDef.label).withDescription(channelDef.description).build();\n-            Channel channel = ChannelBuilder.create(channelUID, channelDef.itemType).withType(channelTypeUID).build();\n-            newChannels.put(channelId, channel);\n-        }\n-    }\n-\n-    public static String ITEM_TYPE_NUMBER = \"Number\";\n-    public static String ITEM_TYPE_STRING = \"String\";\n-    public static String ITEM_TYPE_DATETIME = \"DateTime\";\n-    public static String ITEM_TYPE_TEMP = \"Number:Temperature\";\n-    public static String ITEM_TYPE_LUX = \"Number:Illuminance\";\n-    public static String ITEM_TYPE_POWER = \"Number:Power\";\n-    public static String ITEM_TYPE_ENERGY = \"Number:Energy\";\n-    public static String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n-    public static String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n-    public static String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n-    public static String ITEM_TYPE_SWITCH = \"Switch\";\n-    public static String ITEM_TYPE_CONTACT = \"Contact\";\n-\n-    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n-    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n-    public static String SUFFIX_LABEL = \".label\";\n-    public static String SUFFIX_DESCR = \".description\";\n-\n-    public class ShellyChannel {\n-        private final ShellyTranslationProvider messages;\n-        public String group = \"\";\n-        public String groupLabel = \"\";\n-        public String groupDescription = \"\";\n-\n-        public String channel = \"\";\n-        public String label = \"\";\n-        public String description = \"\";\n-        public String itemType = \"\";\n-        public String typeId = \"\";\n-        public String category = \"\";\n-        public Set<String> tags = new HashSet<>();\n-\n-        public ShellyChannel(ShellyTranslationProvider messages, String group, String channel, String typeId,\n-                String itemType, String... category) {\n-            this.messages = messages;\n-            this.group = group;\n-            this.channel = channel;\n-            this.itemType = itemType;\n-            this.typeId = typeId;\n-\n-            groupLabel = getText(PREFIX_GROUP + group + SUFFIX_LABEL);\n-            groupDescription = getText(PREFIX_GROUP + group + SUFFIX_DESCR);\n-            label = getText(PREFIX_CHANNEL + channel + SUFFIX_LABEL);\n-            description = getText(PREFIX_CHANNEL + channel + SUFFIX_DESCR);\n-        }\n-\n-        public String getChanneId() {\n-            return group + \"#\" + channel;\n-        }\n-\n-        private String getText(String key) {\n-            String text = messages.get(key);\n-            return text != null ? text : \"\";\n-        }\n-    }\n-\n-    public static class ChannelMap {\n-        private final Map<String, ShellyChannel> map = new LinkedHashMap<>();\n-\n-        private ChannelMap add(ShellyChannel def) {\n-            map.put(def.getChanneId(), def);\n-            return this;\n-        }\n-\n-        public ShellyChannel get(String channelName) throws IllegalArgumentException {\n-            if (channelName.contains(\"#\")) {\n-                return map.get(channelName);\n-            }\n-            for (HashMap.Entry<String, ShellyChannel> entry : map.entrySet()) {\n-                ShellyChannel def = entry.getValue();\n-                if (def.channel.contains(\"#\" + channelName)) {\n-                    return def;\n-                }\n-            }\n-            throw new IllegalArgumentException(\"Channel definition for \" + channelName + \" not found!\");\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMzI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404403283", "bodyText": "Why are all these fields package private?", "author": "cpmeister", "createdAt": "2020-04-06T21:35:56Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -29,10 +28,34 @@\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n+    OnOffType power = OnOffType.OFF;\n+    String mode = \"\";\n+\n+    int red = 0;\n+    int green = 0;\n+    int blue = 0;\n+    int white = 0;\n+    PercentType percentRed = new PercentType(0);\n+    PercentType percentGreen = new PercentType(0);\n+    PercentType percentBlue = new PercentType(0);\n+    PercentType percentWhite = new PercentType(0);\n+\n+    int gain = 0;\n+    int brightness = 0;\n+    int temp = 0;\n+    int minTemp = 0;\n+    int maxTemp = 0;\n+    PercentType percentGain = new PercentType(0);\n+    PercentType percentBrightness = new PercentType(0);\n+    PercentType percentTemp = new PercentType(0);\n+    Integer effect = 0;", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNTMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405335336", "bodyText": "No, they are accessed in ShellyLightHandler", "author": "markus7017", "createdAt": "2020-04-08T08:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMzI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\nindex f72f3b788a..354e637844 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java\n\n@@ -28,34 +29,10 @@ import org.eclipse.smarthome.core.library.types.PercentType;\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n-    OnOffType power = OnOffType.OFF;\n-    String mode = \"\";\n-\n-    int red = 0;\n-    int green = 0;\n-    int blue = 0;\n-    int white = 0;\n-    PercentType percentRed = new PercentType(0);\n-    PercentType percentGreen = new PercentType(0);\n-    PercentType percentBlue = new PercentType(0);\n-    PercentType percentWhite = new PercentType(0);\n-\n-    int gain = 0;\n-    int brightness = 0;\n-    int temp = 0;\n-    int minTemp = 0;\n-    int maxTemp = 0;\n-    PercentType percentGain = new PercentType(0);\n-    PercentType percentBrightness = new PercentType(0);\n-    PercentType percentTemp = new PercentType(0);\n-    Integer effect = 0;\n-\n     public ShellyColorUtils() {\n     }\n \n     public ShellyColorUtils(ShellyColorUtils col) {\n-        minTemp = col.minTemp;\n-        maxTemp = col.maxTemp;\n         setRed(col.red);\n         setGreen(col.green);\n         setBlue(col.blue);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404405900", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n          \n          \n            \n                        api.setRelayTurn(index, command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "author": "cpmeister", "createdAt": "2020-04-06T21:41:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -174,7 +164,7 @@ private void handleBrightness(Command command, Integer index) throws IOException\n         if (command instanceof OnOffType) { // Switch\n             logger.debug(\"Switch output {}\", command.toString());\n             api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNjQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405336403", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T08:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266141", "bodyText": "You forgot to change this", "author": "cpmeister", "createdAt": "2020-04-12T23:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NDE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407664148", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-13T19:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java\nindex 09d558abee..77bba451ff 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java\n\n@@ -164,7 +174,7 @@ public class ShellyRelayHandler extends ShellyBaseHandler {\n         if (command instanceof OnOffType) { // Switch\n             logger.debug(\"Switch output {}\", command.toString());\n             api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-            requestUpdates(1, false);\n+            requestUpdates(2, false);\n             return;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404406960", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "author": "cpmeister", "createdAt": "2020-04-06T21:43:44Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private final Bundle bundle;\n+    private final TranslationProvider i18nProvider;\n+    private final LocaleProvider localeProvider;\n+\n+    public ShellyTranslationProvider(Bundle bundle, TranslationProvider i18nProvider, LocaleProvider localeProvider) {\n+        this.bundle = bundle;\n+        this.i18nProvider = i18nProvider;\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    public ShellyTranslationProvider(final ShellyTranslationProvider other) {\n+        this.bundle = other.bundle;\n+        this.i18nProvider = other.i18nProvider;\n+        this.localeProvider = other.localeProvider;\n+    }\n+\n+    public @Nullable String get(String key, @Nullable Object... arguments) {\n+        return getText(key.contains(\"@text/\") || key.contains(\".shelly.\") ? key : \"message.\" + key, arguments);\n+    }\n+\n+    public @Nullable String getText(String key, @Nullable Object... arguments) {\n+        Locale locale = localeProvider.getLocale();\n+        return i18nProvider.getText(bundle, key, getDefaultText(key), locale, arguments);\n+    }\n+\n+    public @Nullable String getDefaultText(String key) {\n+        return i18nProvider.getText(bundle, key, key, Locale.ENGLISH);\n+    }\n+}", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNjY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405336656", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T08:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0OTU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407149595", "bodyText": "The EOF is still here.", "author": "cpmeister", "createdAt": "2020-04-12T05:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java\ndeleted file mode 100644\nindex b2d618814e..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import java.util.Locale;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.i18n.LocaleProvider;\n-import org.eclipse.smarthome.core.i18n.TranslationProvider;\n-import org.osgi.framework.Bundle;\n-\n-/**\n- * {@link ShellyTranslationProvider} provides i18n message lookup\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyTranslationProvider {\n-\n-    private final Bundle bundle;\n-    private final TranslationProvider i18nProvider;\n-    private final LocaleProvider localeProvider;\n-\n-    public ShellyTranslationProvider(Bundle bundle, TranslationProvider i18nProvider, LocaleProvider localeProvider) {\n-        this.bundle = bundle;\n-        this.i18nProvider = i18nProvider;\n-        this.localeProvider = localeProvider;\n-    }\n-\n-    public ShellyTranslationProvider(final ShellyTranslationProvider other) {\n-        this.bundle = other.bundle;\n-        this.i18nProvider = other.i18nProvider;\n-        this.localeProvider = other.localeProvider;\n-    }\n-\n-    public @Nullable String get(String key, @Nullable Object... arguments) {\n-        return getText(key.contains(\"@text/\") || key.contains(\".shelly.\") ? key : \"message.\" + key, arguments);\n-    }\n-\n-    public @Nullable String getText(String key, @Nullable Object... arguments) {\n-        Locale locale = localeProvider.getLocale();\n-        return i18nProvider.getText(bundle, key, getDefaultText(key), locale, arguments);\n-    }\n-\n-    public @Nullable String getDefaultText(String key) {\n-        return i18nProvider.getText(bundle, key, key, Locale.ENGLISH);\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2ODY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406868678", "bodyText": "What happened to this version?", "author": "cpmeister", "createdAt": "2020-04-10T17:49:25Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java", "diffHunk": "@@ -250,9 +250,8 @@\n     public static final String CHANNEL_BUTTON_TRIGGER = \"button\";\n \n     public static final String SERVICE_TYPE = \"_http._tcp.local.\";\n-    public static final String SHELLY_API_MIN_FWVERSION = \"v1.5.7\";// v1.5.2\n-    public static final String SHELLY_API_MIN_FWCOIOT_STD = \"v1.6\";// v1.5.2\n-    public static final String SHELLY_API_MIN_FWCOIOT_SENSOR = \"v1.7\";// v1.5.2", "originalCommit": "051f5eb2df1b08fed2ca04f6a2532ed74857829c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyODk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407028989", "bodyText": "I don't know what's displayed here. This is the latest code:\n    public static final String SERVICE_TYPE = \"_http._tcp.local.\";\n    public static final String SHELLY_API_MIN_FWVERSION = \"v1.5.7\";// v1.5.7+\n    public static final String SHELLY_API_MIN_FWCOIOT = \"v1.6\";// v1.6.0+", "author": "markus7017", "createdAt": "2020-04-11T07:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2ODY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java\nindex 3af5c2d671..205ee9b786 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java\n\n@@ -236,13 +222,7 @@ public class ShellyBindingConstants {\n     public static final String CHANNEL_GROUP_DEV_STATUS = \"device\";\n     public static final String CHANNEL_DEVST_UPTIME = \"uptime\";\n     public static final String CHANNEL_DEVST_RSSI = \"wifiSignal\";\n-    public static final String CHANNEL_DEVST_ITEMP = \"internalTemp\";\n-    public static final String CHANNEL_DEVST_WAKEUP = \"wakeupReason\";\n     public static final String CHANNEL_DEVST_ALARM = \"alarm\";\n-    public static final String CHANNEL_DEVST_ACCUWATTS = \"accumulatedWatts\";\n-    public static final String CHANNEL_DEVST_ACCUTOTAL = \"accumulatedWTotal\";\n-    public static final String CHANNEL_DEVST_ACCURETURNED = \"accumulatedReturned\";\n-    public static final String CHANNEL_DEVST_CHARGER = \"charger\";\n \n     // General\n     public static final String CHANNEL_LAST_UPDATE = \"lastUpdate\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),\n          \n          \n            \n                    logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent, value,", "author": "cpmeister", "createdAt": "2020-04-12T04:26:30Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java", "diffHunk": "@@ -513,8 +513,8 @@ private Integer getColorFromHSB(PercentType colorPercent) {\n \n     private Integer getColorFromHSB(PercentType colorPercent, Double factor) {\n         Double value = new Double(Math.round(colorPercent.doubleValue() * factor));\n-        logger.trace(\"convert {}% into {}/{} (factor={})\", colorPercent.toString(), value.toString(), value.intValue(),\n-                factor.toString());\n+        logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMDQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407210478", "bodyText": "removed all toString() in logger statements in this file, will do step-by-step with the other files too", "author": "markus7017", "createdAt": "2020-04-12T15:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java\nindex c3be5b99ac..eaafd101c9 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java\n\n@@ -513,8 +503,8 @@ public class ShellyLightHandler extends ShellyBaseHandler {\n \n     private Integer getColorFromHSB(PercentType colorPercent, Double factor) {\n         Double value = new Double(Math.round(colorPercent.doubleValue() * factor));\n-        logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),\n-                value.intValue(), factor.toString());\n+        logger.trace(\"convert {}% into {}/{} (factor={})\", colorPercent.toString(), value.toString(), value.intValue(),\n+                factor.toString());\n         return value.intValue();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144998", "bodyText": "This won't actually break out early from the loop since you are using a lambda, you need to put this in a proper loop.", "author": "cpmeister", "createdAt": "2020-04-12T04:40:46Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,25 +152,21 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        for (ShellyDeviceListener listener : deviceListeners) {\n-            try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n-                    // event processed\n-                    break;\n-                }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n-                // continue with next listener\n+        deviceListeners.forEach(listener -> {\n+            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                // event processed\n+                return;", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407212754", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T15:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\nindex b5a1a3876a..fbd599949c 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n\n@@ -152,21 +142,25 @@ public class ShellyHandlerFactory extends BaseThingHandlerFactory {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n-            Map<String, String> parameters) {\n+    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        deviceListeners.forEach(listener -> {\n-            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n-                // event processed\n-                return;\n+        for (ShellyDeviceListener listener : deviceListeners) {\n+            try {\n+                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n+                    // event processed\n+                    break;\n+                }\n+            } catch (NullPointerException e) {\n+                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n+                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n+                        e.getStackTrace());\n+                // continue with next listener\n             }\n-        });\n+        }\n     }\n \n+    @Nullable\n     public ShellyBindingConfiguration getBindingConfig() {\n         return bindingConfig;\n     }\n-\n-    public void dispose() {\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145014", "bodyText": "needed?", "author": "cpmeister", "createdAt": "2020-04-12T04:40:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,25 +152,21 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        for (ShellyDeviceListener listener : deviceListeners) {\n-            try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n-                    // event processed\n-                    break;\n-                }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n-                // continue with next listener\n+        deviceListeners.forEach(listener -> {\n+            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                // event processed\n+                return;\n             }\n-        }\n+        });\n     }\n \n-    @Nullable\n     public ShellyBindingConfiguration getBindingConfig() {\n         return bindingConfig;\n     }\n+\n+    public void dispose() {\n+    }", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMDkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407210929", "bodyText": "no", "author": "markus7017", "createdAt": "2020-04-12T15:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\nindex b5a1a3876a..fbd599949c 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java\n\n@@ -152,21 +142,25 @@ public class ShellyHandlerFactory extends BaseThingHandlerFactory {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n-            Map<String, String> parameters) {\n+    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        deviceListeners.forEach(listener -> {\n-            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n-                // event processed\n-                return;\n+        for (ShellyDeviceListener listener : deviceListeners) {\n+            try {\n+                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n+                    // event processed\n+                    break;\n+                }\n+            } catch (NullPointerException e) {\n+                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n+                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n+                        e.getStackTrace());\n+                // continue with next listener\n             }\n-        });\n+        }\n     }\n \n+    @Nullable\n     public ShellyBindingConfiguration getBindingConfig() {\n         return bindingConfig;\n     }\n-\n-    public void dispose() {\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145278", "bodyText": "Actually now that I think of it, why do you need this field anyway? Can't you just call getCause instead?", "author": "cpmeister", "createdAt": "2020-04-12T04:44:27Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception exception = new Exception(EX_NONE);", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235588", "bodyText": "I don't think so.\nexception is the class causing the exception and ShellyApiException was constructed with. getClass() would return ShellyApiException, super. getClass() would return Exception, but I want to know which was the original exception type\ncorrect?", "author": "markus7017", "createdAt": "2020-04-12T18:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265222", "bodyText": "You can call getCause().getClass() to check the class. Just make sure to handle the case when getCause() returns null.", "author": "cpmeister", "createdAt": "2020-04-12T23:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3OTYwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408179601", "bodyText": "changed, needs to be tested", "author": "markus7017", "createdAt": "2020-04-14T14:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NTEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408265131", "bodyText": "@cpmeister could you please review this change", "author": "markus7017", "createdAt": "2020-04-14T16:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\ndeleted file mode 100644\nindex 4d0e1769c2..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java\n+++ /dev/null\n\n@@ -1,127 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.api;\n-\n-import java.net.MalformedURLException;\n-import java.net.UnknownHostException;\n-import java.text.MessageFormat;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeoutException;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n- * result of the last API call (e.g. including the http status code in the message).\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyApiException extends Exception {\n-    private static final long serialVersionUID = -5809459454769761821L;\n-\n-    private ShellyApiResult apiResult = new ShellyApiResult();\n-    private static String EX_NONE = \"none\";\n-    private Exception exception = new Exception(EX_NONE);\n-\n-    public ShellyApiException(Exception exception) {\n-        super(exception);\n-        this.exception = exception;\n-    }\n-\n-    public ShellyApiException(String message) {\n-        super(message);\n-    }\n-\n-    public ShellyApiException(ShellyApiResult res) {\n-        super(EX_NONE);\n-        apiResult = res;\n-    }\n-\n-    public ShellyApiException(Exception exception, String message) {\n-        super(message, exception);\n-        this.exception = exception;\n-    }\n-\n-    public ShellyApiException(ShellyApiResult result, Exception exception) {\n-        super(exception);\n-        apiResult = result;\n-        this.exception = exception;\n-    }\n-\n-    @Override\n-    public String getMessage() {\n-        return isEmpty() ? \"\" : nonNullString(super.getMessage());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String message = nonNullString(super.getMessage());\n-        if (!isEmpty()) {\n-            if (isUnknownHost()) {\n-                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n-                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n-                        string[1]);\n-            } else if (isMalformedURL()) {\n-                return MessageFormat.format(\"Invalid URL: {0}\", apiResult.getUrl());\n-            } else if (isTimeout()) {\n-                return MessageFormat.format(\"Device unreachable or API Timeout ({0})\", apiResult.getUrl());\n-            } else {\n-                return MessageFormat.format(\"{0} ({1})\", exception.toString(), message);\n-            }\n-        } else {\n-            if (isApiException()) {\n-                message = nonNullString(super.getClass().toString()) + \" - \" + getMessage();\n-            } else {\n-                message = getMessage();\n-            }\n-        }\n-        return message + \" \" + apiResult.toString();\n-    }\n-\n-    public boolean isApiException() {\n-        return exception.getClass() == ShellyApiException.class;\n-    }\n-\n-    public boolean isTimeout() {\n-        Class<?> extype = !isEmpty() ? exception.getClass() : null;\n-        return (apiResult.httpCode == -1)\n-                || (extype != null) && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n-                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n-    }\n-\n-    public boolean isHttpAccessUnauthorized() {\n-        return apiResult.isHttpAccessUnauthorized();\n-    }\n-\n-    public boolean isUnknownHost() {\n-        return exception.getClass() == MalformedURLException.class;\n-    }\n-\n-    public boolean isMalformedURL() {\n-        return exception.getClass() == UnknownHostException.class;\n-    }\n-\n-    public ShellyApiResult getApiResult() {\n-        return apiResult;\n-    }\n-\n-    private boolean isEmpty() {\n-        return nonNullString(exception.getMessage()).equals(EX_NONE);\n-    }\n-\n-    private static String nonNullString(@Nullable String s) {\n-        return s != null ? s : \"\";\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145348", "bodyText": "Just to be consistent\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n          \n          \n            \n                public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n          \n          \n            \n                public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n          \n          \n            \n                public static final String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n          \n          \n            \n                public static final String SHELLY_API_DWSTATE_OPEN = \"open\";\n          \n          \n            \n                public static final String SHELLY_API_DWSTATE_CLOSE = \"close\";", "author": "cpmeister", "createdAt": "2020-04-12T04:45:28Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -22,15 +22,166 @@\n  * @author Markus Michels - Initial contribution\n  */\n public class ShellyApiJsonDTO {\n+    public static final String SHELLY_NULL_URL = \"null\";\n+    public static final String SHELLY_URL_DEVINFO = \"/shelly\";\n+    public static final String SHELLY_URL_STATUS = \"/status\";\n+    public static final String SHELLY_URL_SETTINGS = \"/settings\";\n+    public static final String SHELLY_URL_SETTINGS_AP = \"/settings/ap\";\n+    public static final String SHELLY_URL_SETTINGS_STA = \"/settings/sta\";\n+    public static final String SHELLY_URL_SETTINGS_LOGIN = \"/settings/sta\";\n+    public static final String SHELLY_URL_SETTINGS_CLOUD = \"/settings/cloud\";\n+    public static final String SHELLY_URL_LIST_IR = \"/ir/list\";\n+    public static final String SHELLY_URL_SEND_IR = \"/ir/emit\";\n+\n+    public static final String SHELLY_URL_SETTINGS_RELAY = \"/settings/relay\";\n+    public static final String SHELLY_URL_STATUS_RELEAY = \"/status/relay\";\n+    public static final String SHELLY_URL_CONTROL_RELEAY = \"/relay\";\n+\n+    public static final String SHELLY_URL_SETTINGS_EMETER = \"/settings/emeter\";\n+    public static final String SHELLY_URL_STATUS_EMETER = \"/emeter\";\n+    public static final String SHELLY_URL_DATA_EMETER = \"/emeter/{0}/em_data.csv\";\n+\n+    public static final String SHELLY_URL_CONTROL_ROLLER = \"/roller\";\n+    public static final String SHELLY_URL_SETTINGS_ROLLER = \"/settings/roller\";\n+\n+    public static final String SHELLY_URL_SETTINGS_LIGHT = \"/settings/light\";\n+    public static final String SHELLY_URL_STATUS_LIGHT = \"/light\";\n+    public static final String SHELLY_URL_CONTROL_LIGHT = \"/light\";\n+\n+    public static final String SHELLY_URL_SETTINGS_DIMMER = \"/settings/light\";\n+\n+    //\n+    // Action URLs according to the device type\n+    //\n+    public static final String SHELLY_EVENTURL_SUFFIX = \"_url\";\n+\n+    // Relay\n+    public static final String SHELLY_EVENT_BTN_ON = \"btn_on\";\n+    public static final String SHELLY_EVENT_BTN_OFF = \"btn_off\";\n+    public static final String SHELLY_EVENT_OUT_ON = \"out_on\";\n+    public static final String SHELLY_EVENT_OUT_OFF = \"out_off\";\n+    public static final String SHELLY_EVENT_SHORTPUSH = \"shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH = \"longpush\";\n+\n+    // Dimmer\n+    public static final String SHELLY_EVENT_BTN1_ON = \"btn1_on\";\n+    public static final String SHELLY_EVENT_BTN1_OFF = \"btn1_off\";\n+    public static final String SHELLY_EVENT_BTN2_ON = \"btn2_on\";\n+    public static final String SHELLY_EVENT_BTN2_OFF = \"btn2_off\";\n+    public static final String SHELLY_EVENT_SHORTPUSH1 = \"btn1_shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH1 = \"btn1_longpush\";\n+    public static final String SHELLY_EVENT_SHORTPUSH2 = \"btn2_shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH2 = \"btn2_longpush\";\n+\n+    // Roller\n+    public static final String SHELLY_EVENT_ROLLER_OPEN = \"roller_open\";\n+    public static final String SHELLY_EVENT_ROLLER_CLOSE = \"roller_close\";\n+    public static final String SHELLY_EVENT_ROLLER_STOP = \"roller_stop\";\n+\n+    // Sensors\n+    public static final String SHELLY_EVENT_SENSORREPORT = \"report\";\n+    public static final String SHELLY_EVENT_DARK = \"dark\";\n+    public static final String SHELLY_EVENT_TWILIGHT = \"twilight\";\n+    public static final String SHELLY_EVENT_FLOOD_DETECTED = \"flood_detected\";\n+    public static final String SHELLY_EVENT_FLOOD_GONE = \"flood_gone\";\n+\n+    //\n+    // API values\n+    //\n+    public static final String SHELLY_BTNT_MOMENTARY = \"momentary\";\n+    public static final String SHELLY_BTNT_TOGGLE = \"toggle\";\n+    public static final String SHELLY_BTNT_EDGE = \"edge\";\n+    public static final String SHELLY_BTNT_DETACHED = \"detached\";\n+    public static final String SHELLY_STATE_LAST = \"last\";\n+    public static final String SHELLY_STATE_STOP = \"stop\";\n+    public static final String SHELLY_INP_MODE_OPENCLOSE = \"openclose\";\n+    public static final String SHELLY_OBSTMODE_DISABLED = \"disabled\";\n+    public static final String SHELLY_SAFETYM_WHILEOPENING = \"while_opening\";\n+    public static final String SHELLY_ALWD_TRIGGER_NONE = \"none\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_OPEN = \"open\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_CLOSE = \"close\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_STOP = \"stop\";\n+\n+    // API Error Codes\n+    public static final String SHELLY_APIERR_UNAUTHORIZED = \"Unauthorized\";\n+    public static final String SHELLY_APIERR_TIMEOUT = \"Timeout\";\n+    public static final String SHELLY_APIERR_NOT_CALIBRATED = \"Not calibrated!\";\n+\n+    // API device types / properties\n+    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n \n     public static final String SHELLY_API_ON = \"on\";\n     public static final String SHELLY_API_OFF = \"off\";\n     public static final String SHELLY_API_TRUE = \"true\";\n     public static final String SHELLY_API_FALSE = \"false\";\n \n-    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n-    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n-    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n+    public static final String SHELLY_API_MODE = \"mode\";\n+    public static final String SHELLY_MODE_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_MODE_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_MODE_COLOR = \"color\"; // Bulb/RGBW2: color mode\n+    public static final String SHELLY_MODE_WHITE = \"white\"; // Bulb/RGBW2: white mode\n+\n+    public static final String SHELLY_LED_STATUS_DISABLE = \"led_status_disable\";\n+    public static final String SHELLY_LED_POWER_DISABLE = \"led_power_disable\";\n+\n+    public static final String SHELLY_API_STOPR_NORMAL = \"normal\";\n+    public static final String SHELLY_API_STOPR_SAFETYSW = \"safety_switch\";\n+    public static final String SHELLY_API_STOPR_OBSTACLE = \"obstacle\";\n+\n+    public static final String SHELLY_TIMER_AUTOON = \"auto_on\";\n+    public static final String SHELLY_TIMER_AUTOOFF = \"auto_off\";\n+    public static final String SHELLY_TIMER_ACTIVE = \"has_timer\";\n+\n+    public static final String SHELLY_LIGHT_TURN = \"turn\";\n+    public static final String SHELLY_LIGHT_DEFSTATE = \"def_state\";\n+    public static final String SHELLY_LIGHTTIMER = \"timer\";\n+\n+    public static final String SHELLY_COLOR_RED = \"red\";\n+    public static final String SHELLY_COLOR_BLUE = \"blue\";\n+    public static final String SHELLY_COLOR_GREEN = \"green\";\n+    public static final String SHELLY_COLOR_YELLOW = \"yellow\";\n+    public static final String SHELLY_COLOR_WHITE = \"white\";\n+    public static final String SHELLY_COLOR_GAIN = \"gain\";\n+    public static final String SHELLY_COLOR_BRIGHTNESS = \"brightness\";\n+    public static final String SHELLY_COLOR_TEMP = \"temp\";\n+    public static final String SHELLY_COLOR_EFFECT = \"effect\";\n+\n+    public static final int SHELLY_MIN_ROLLER_POS = 0;\n+    public static final int SHELLY_MAX_ROLLER_POS = 100;\n+    public static final int SHELLY_MIN_BRIGHTNESS = 0;\n+    public static final int SHELLY_MAX_BRIGHTNESS = 100;\n+    public static final int SHELLY_MIN_GAIN = 0;\n+    public static final int SHELLY_MAX_GAIN = 100;\n+    public static final int SHELLY_MIN_COLOR = 0;\n+    public static final int SHELLY_MAX_COLOR = 255;\n+    public static final int SHELLY_DIM_STEPSIZE = 10;\n+\n+    // color temperature: 3000 = warm, 4750 = white, 6565 = cold; gain: 0..100\n+    public static final int MIN_COLOR_TEMP_BULB = 3000;\n+    public static final int MAX_COLOR_TEMP_BULB = 6500;\n+    public static final int MIN_COLOR_TEMP_DUO = 2700;\n+    public static final int MAX_COLOR_TEMP_DUO = 6500;\n+    public static final int COLOR_TEMP_RANGE_BULB = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n+    public static final int COLOR_TEMP_RANGE_DUO = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n+    public static final double MIN_BRIGHTNESS = 0.0;\n+    public static final double MAX_BRIGHTNESS = 100.0;\n+    public static final double SATURATION_FACTOR = 2.55;\n+    public static final double GAIN_FACTOR = SHELLY_MAX_GAIN / 100;\n+    public static final double BRIGHTNESS_FACTOR = SHELLY_MAX_BRIGHTNESS / 100;\n+\n+    // Door/Window\n+    public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n+    public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n+    public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n+    public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n+    public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyNjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407226154", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\nindex b285151b27..27349e9e88 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java\n\n@@ -22,166 +22,15 @@ import com.google.gson.annotations.SerializedName;\n  * @author Markus Michels - Initial contribution\n  */\n public class ShellyApiJsonDTO {\n-    public static final String SHELLY_NULL_URL = \"null\";\n-    public static final String SHELLY_URL_DEVINFO = \"/shelly\";\n-    public static final String SHELLY_URL_STATUS = \"/status\";\n-    public static final String SHELLY_URL_SETTINGS = \"/settings\";\n-    public static final String SHELLY_URL_SETTINGS_AP = \"/settings/ap\";\n-    public static final String SHELLY_URL_SETTINGS_STA = \"/settings/sta\";\n-    public static final String SHELLY_URL_SETTINGS_LOGIN = \"/settings/sta\";\n-    public static final String SHELLY_URL_SETTINGS_CLOUD = \"/settings/cloud\";\n-    public static final String SHELLY_URL_LIST_IR = \"/ir/list\";\n-    public static final String SHELLY_URL_SEND_IR = \"/ir/emit\";\n-\n-    public static final String SHELLY_URL_SETTINGS_RELAY = \"/settings/relay\";\n-    public static final String SHELLY_URL_STATUS_RELEAY = \"/status/relay\";\n-    public static final String SHELLY_URL_CONTROL_RELEAY = \"/relay\";\n-\n-    public static final String SHELLY_URL_SETTINGS_EMETER = \"/settings/emeter\";\n-    public static final String SHELLY_URL_STATUS_EMETER = \"/emeter\";\n-    public static final String SHELLY_URL_DATA_EMETER = \"/emeter/{0}/em_data.csv\";\n-\n-    public static final String SHELLY_URL_CONTROL_ROLLER = \"/roller\";\n-    public static final String SHELLY_URL_SETTINGS_ROLLER = \"/settings/roller\";\n-\n-    public static final String SHELLY_URL_SETTINGS_LIGHT = \"/settings/light\";\n-    public static final String SHELLY_URL_STATUS_LIGHT = \"/light\";\n-    public static final String SHELLY_URL_CONTROL_LIGHT = \"/light\";\n-\n-    public static final String SHELLY_URL_SETTINGS_DIMMER = \"/settings/light\";\n-\n-    //\n-    // Action URLs according to the device type\n-    //\n-    public static final String SHELLY_EVENTURL_SUFFIX = \"_url\";\n-\n-    // Relay\n-    public static final String SHELLY_EVENT_BTN_ON = \"btn_on\";\n-    public static final String SHELLY_EVENT_BTN_OFF = \"btn_off\";\n-    public static final String SHELLY_EVENT_OUT_ON = \"out_on\";\n-    public static final String SHELLY_EVENT_OUT_OFF = \"out_off\";\n-    public static final String SHELLY_EVENT_SHORTPUSH = \"shortpush\";\n-    public static final String SHELLY_EVENT_LONGPUSH = \"longpush\";\n-\n-    // Dimmer\n-    public static final String SHELLY_EVENT_BTN1_ON = \"btn1_on\";\n-    public static final String SHELLY_EVENT_BTN1_OFF = \"btn1_off\";\n-    public static final String SHELLY_EVENT_BTN2_ON = \"btn2_on\";\n-    public static final String SHELLY_EVENT_BTN2_OFF = \"btn2_off\";\n-    public static final String SHELLY_EVENT_SHORTPUSH1 = \"btn1_shortpush\";\n-    public static final String SHELLY_EVENT_LONGPUSH1 = \"btn1_longpush\";\n-    public static final String SHELLY_EVENT_SHORTPUSH2 = \"btn2_shortpush\";\n-    public static final String SHELLY_EVENT_LONGPUSH2 = \"btn2_longpush\";\n-\n-    // Roller\n-    public static final String SHELLY_EVENT_ROLLER_OPEN = \"roller_open\";\n-    public static final String SHELLY_EVENT_ROLLER_CLOSE = \"roller_close\";\n-    public static final String SHELLY_EVENT_ROLLER_STOP = \"roller_stop\";\n-\n-    // Sensors\n-    public static final String SHELLY_EVENT_SENSORREPORT = \"report\";\n-    public static final String SHELLY_EVENT_DARK = \"dark\";\n-    public static final String SHELLY_EVENT_TWILIGHT = \"twilight\";\n-    public static final String SHELLY_EVENT_FLOOD_DETECTED = \"flood_detected\";\n-    public static final String SHELLY_EVENT_FLOOD_GONE = \"flood_gone\";\n-\n-    //\n-    // API values\n-    //\n-    public static final String SHELLY_BTNT_MOMENTARY = \"momentary\";\n-    public static final String SHELLY_BTNT_TOGGLE = \"toggle\";\n-    public static final String SHELLY_BTNT_EDGE = \"edge\";\n-    public static final String SHELLY_BTNT_DETACHED = \"detached\";\n-    public static final String SHELLY_STATE_LAST = \"last\";\n-    public static final String SHELLY_STATE_STOP = \"stop\";\n-    public static final String SHELLY_INP_MODE_OPENCLOSE = \"openclose\";\n-    public static final String SHELLY_OBSTMODE_DISABLED = \"disabled\";\n-    public static final String SHELLY_SAFETYM_WHILEOPENING = \"while_opening\";\n-    public static final String SHELLY_ALWD_TRIGGER_NONE = \"none\";\n-    public static final String SHELLY_ALWD_ROLLER_TURN_OPEN = \"open\";\n-    public static final String SHELLY_ALWD_ROLLER_TURN_CLOSE = \"close\";\n-    public static final String SHELLY_ALWD_ROLLER_TURN_STOP = \"stop\";\n-\n-    // API Error Codes\n-    public static final String SHELLY_APIERR_UNAUTHORIZED = \"Unauthorized\";\n-    public static final String SHELLY_APIERR_TIMEOUT = \"Timeout\";\n-    public static final String SHELLY_APIERR_NOT_CALIBRATED = \"Not calibrated!\";\n-\n-    // API device types / properties\n-    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n-    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n-    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n \n     public static final String SHELLY_API_ON = \"on\";\n     public static final String SHELLY_API_OFF = \"off\";\n     public static final String SHELLY_API_TRUE = \"true\";\n     public static final String SHELLY_API_FALSE = \"false\";\n \n-    public static final String SHELLY_API_MODE = \"mode\";\n-    public static final String SHELLY_MODE_RELAY = \"relay\"; // Relay: relay mode\n-    public static final String SHELLY_MODE_ROLLER = \"roller\"; // Relay: roller mode\n-    public static final String SHELLY_MODE_COLOR = \"color\"; // Bulb/RGBW2: color mode\n-    public static final String SHELLY_MODE_WHITE = \"white\"; // Bulb/RGBW2: white mode\n-\n-    public static final String SHELLY_LED_STATUS_DISABLE = \"led_status_disable\";\n-    public static final String SHELLY_LED_POWER_DISABLE = \"led_power_disable\";\n-\n-    public static final String SHELLY_API_STOPR_NORMAL = \"normal\";\n-    public static final String SHELLY_API_STOPR_SAFETYSW = \"safety_switch\";\n-    public static final String SHELLY_API_STOPR_OBSTACLE = \"obstacle\";\n-\n-    public static final String SHELLY_TIMER_AUTOON = \"auto_on\";\n-    public static final String SHELLY_TIMER_AUTOOFF = \"auto_off\";\n-    public static final String SHELLY_TIMER_ACTIVE = \"has_timer\";\n-\n-    public static final String SHELLY_LIGHT_TURN = \"turn\";\n-    public static final String SHELLY_LIGHT_DEFSTATE = \"def_state\";\n-    public static final String SHELLY_LIGHTTIMER = \"timer\";\n-\n-    public static final String SHELLY_COLOR_RED = \"red\";\n-    public static final String SHELLY_COLOR_BLUE = \"blue\";\n-    public static final String SHELLY_COLOR_GREEN = \"green\";\n-    public static final String SHELLY_COLOR_YELLOW = \"yellow\";\n-    public static final String SHELLY_COLOR_WHITE = \"white\";\n-    public static final String SHELLY_COLOR_GAIN = \"gain\";\n-    public static final String SHELLY_COLOR_BRIGHTNESS = \"brightness\";\n-    public static final String SHELLY_COLOR_TEMP = \"temp\";\n-    public static final String SHELLY_COLOR_EFFECT = \"effect\";\n-\n-    public static final int SHELLY_MIN_ROLLER_POS = 0;\n-    public static final int SHELLY_MAX_ROLLER_POS = 100;\n-    public static final int SHELLY_MIN_BRIGHTNESS = 0;\n-    public static final int SHELLY_MAX_BRIGHTNESS = 100;\n-    public static final int SHELLY_MIN_GAIN = 0;\n-    public static final int SHELLY_MAX_GAIN = 100;\n-    public static final int SHELLY_MIN_COLOR = 0;\n-    public static final int SHELLY_MAX_COLOR = 255;\n-    public static final int SHELLY_DIM_STEPSIZE = 10;\n-\n-    // color temperature: 3000 = warm, 4750 = white, 6565 = cold; gain: 0..100\n-    public static final int MIN_COLOR_TEMP_BULB = 3000;\n-    public static final int MAX_COLOR_TEMP_BULB = 6500;\n-    public static final int MIN_COLOR_TEMP_DUO = 2700;\n-    public static final int MAX_COLOR_TEMP_DUO = 6500;\n-    public static final int COLOR_TEMP_RANGE_BULB = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n-    public static final int COLOR_TEMP_RANGE_DUO = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n-    public static final double MIN_BRIGHTNESS = 0.0;\n-    public static final double MAX_BRIGHTNESS = 100.0;\n-    public static final double SATURATION_FACTOR = 2.55;\n-    public static final double GAIN_FACTOR = SHELLY_MAX_GAIN / 100;\n-    public static final double BRIGHTNESS_FACTOR = SHELLY_MAX_BRIGHTNESS / 100;\n-\n-    // Door/Window\n-    public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n-    public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n-    public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n-    public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n-    public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";\n-\n-    // Shelly Sense\n-    public static final String SHELLY_IR_CODET_STORED = \"stored\";\n-    public static final String SHELLY_IR_CODET_PRONTO = \"pronto\";\n-    public static final String SHELLY_IR_CODET_PRONTO_HEX = \"pronto_hex\";\n+    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n \n     public static class ShellySettingsDevice {\n         public String type;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145825", "bodyText": "You said you moved it to ShellyThingCreator but the code is still here...", "author": "cpmeister", "createdAt": "2020-04-12T04:50:58Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -54,104 +60,216 @@\n     public String fwVersion = \"\";\n     public String fwDate = \"\";\n \n-    public Boolean hasRelays = false; // true if it has at least 1 power meter\n-    public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n-    public Boolean isRoller = false; // true for Shelly2 in roller mode\n-    public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-\n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n-    public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n-\n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n-    public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n-    public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public boolean hasRelays = false; // true if it has at least 1 power meter\n+    public int numRelays = 0; // number of relays/outputs\n+    public int numRollers = 0; // number of Rollers, usually 1\n+    public boolean isRoller = false; // true for Shelly2 in roller mode\n+    public boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+    public int numMeters = 0;\n+    public boolean isEMeter = false; // true for ShellyEM/EM3\n+\n+    public boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n+    public boolean isBulb = false; // true only if it is a Bulb\n+    public boolean isDuo = false; // true only if it is a Duo\n+    public boolean isRGBW2 = false; // true only if it a a RGBW2\n+    public boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public boolean hasLed = false; // true if battery device\n+\n+    public boolean isSensor = false; // true for HT & Smoke\n+    public boolean hasBattery = false; // true if battery device\n+    public boolean isSense = false; // true if thing is a Shelly Sense\n+    public boolean isDW = false; // true of Door Window sensor\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public int minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public int maxTemp = 0; // Bulb/Duo: Max Light Temp\n+\n+    public int updatePeriod = -1;\n+\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\") ? settings.sleepMode.period * 60 // minutes\n+                    : settings.sleepMode.period * 3600; // hours\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n+        } else {\n+            updatePeriod = 2 * 15 + 5; // Default acc. CoIoT Spec\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public boolean containsEventUrl(String eventType) {\n+        return containsEventUrl(settingsJson, eventType);\n+    }\n+\n+    public boolean containsEventUrl(String json, String eventType) {\n+        String settings = json.toLowerCase();\n+        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n+        }\n+\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n+        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n+    }\n+\n+    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyODI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407228259", "bodyText": "hmm, was pretty sure,\u00b4, but it was still there\nnow removed", "author": "markus7017", "createdAt": "2020-04-12T17:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\nindex ca2b6db801..502df73a9a 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java\n\n@@ -60,216 +54,104 @@ public class ShellyDeviceProfile {\n     public String fwVersion = \"\";\n     public String fwDate = \"\";\n \n-    public boolean hasRelays = false; // true if it has at least 1 power meter\n-    public int numRelays = 0; // number of relays/outputs\n-    public int numRollers = 0; // number of Rollers, usually 1\n-    public boolean isRoller = false; // true for Shelly2 in roller mode\n-    public boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-    public boolean isPlugS = false; // true if it is a Shelly Plug S\n-\n-    public int numMeters = 0;\n-    public boolean isEMeter = false; // true for ShellyEM/EM3\n-\n-    public boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public boolean isBulb = false; // true only if it is a Bulb\n-    public boolean isDuo = false; // true only if it is a Duo\n-    public boolean isRGBW2 = false; // true only if it a a RGBW2\n-    public boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public boolean hasLed = false; // true if battery device\n-\n-    public boolean isSensor = false; // true for HT & Smoke\n-    public boolean hasBattery = false; // true if battery device\n-    public boolean isSense = false; // true if thing is a Shelly Sense\n-    public boolean isDW = false; // true of Door Window sensor\n-\n-    public int minTemp = 0; // Bulb/Duo: Min Light Temp\n-    public int maxTemp = 0; // Bulb/Duo: Max Light Temp\n-\n-    public int updatePeriod = -1;\n+    public Boolean hasRelays = false; // true if it has at least 1 power meter\n+    public Integer numRelays = 0; // number of relays/outputs\n+    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Boolean isRoller = false; // true for Shelly2 in roller mode\n+    public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+\n+    public Boolean hasMeter = false; // true if it has at least 1 power meter\n+    public Integer numMeters = 0;\n+    public Boolean isEMeter = false; // true for ShellyEM\n+\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean hasLed = false; // true if battery device\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n+    public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n+    public Boolean isBulb = false; // true pnly if it is a Bulb\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean isSensor = false; // true for HT & Smoke\n+    public Boolean isSmoke = false; // true for Smoke\n \n     public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n+    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n+    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n+    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n+    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n+    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+\n+    @SuppressWarnings(\"null\")\n+    public static ShellyDeviceProfile initialize(String thingType, String json) {\n         Gson gson = new Gson();\n \n-        initialized = false;\n+        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+        Validate.notNull(profile);\n \n-        try {\n-            initFromThingType(thingType);\n-            settingsJson = json;\n-            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        } catch (IllegalArgumentException | JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n-        }\n+        profile.settingsJson = json;\n+        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n \n         // General settings\n-        deviceType = ShellyUtils.getString(settings.device.type);\n-        mac = getString(settings.device.mac);\n-        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n-                ? settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n-        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n-        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n-        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n-        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n-        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n-        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n-        discoverable = (settings.discoverable == null) || settings.discoverable;\n-\n-        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n-        if ((numRelays > 0) && (settings.relays == null)) {\n-            numRelays = 0;\n-        }\n-        hasRelays = (numRelays > 0) || isDimmer;\n-        numRollers = getInteger(settings.device.numRollers);\n-\n-        isEMeter = settings.emeters != null;\n-        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n-        if ((numMeters == 0) && isLight) {\n+        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n+        profile.mac = getString(profile.settings.device.mac);\n+        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n+                ? profile.settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n+        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n+        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n+        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n+                : \"\";\n+        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n+        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n+        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n+\n+        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n+        profile.hasLed = profile.isPlugS;\n+        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n+        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        profile.isLight = profile.isBulb\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n+        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n+        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.isSensor = profile.isSense || profile.isSmoke\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n+                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n+\n+        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n+        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n+            profile.numRelays = 0;\n+        }\n+        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n+        profile.numRollers = getInteger(profile.settings.device.numRollers);\n+\n+        profile.isEMeter = profile.settings.emeters != null;\n+        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n+                : getInteger(profile.settings.device.numEMeters);\n+        if ((profile.numMeters == 0) && profile.isLight) {\n             // RGBW2 doesn't report, but has one\n-            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n-        }\n-        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-\n-        if (settings.sleepMode != null) {\n-            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\") ? settings.sleepMode.period * 60 // minutes\n-                    : settings.sleepMode.period * 3600; // hours\n-        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n-            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n-        } else {\n-            updatePeriod = 2 * 15 + 5; // Default acc. CoIoT Spec\n+            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n         }\n+        profile.hasMeter = (profile.numMeters > 0);\n \n-        initialized = true;\n-        return this;\n-    }\n-\n-    public boolean containsEventUrl(String eventType) {\n-        return containsEventUrl(settingsJson, eventType);\n-    }\n-\n-    public boolean containsEventUrl(String json, String eventType) {\n-        String settings = json.toLowerCase();\n-        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n-    }\n-\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    public void initFromThingType(String name) {\n-        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n-        if (thingType.isEmpty()) {\n-            return;\n-        }\n-\n-        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n-\n-        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n-        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n-        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n-        hasLed = isPlugS;\n-        isLight = isBulb || isDuo || isRGBW2;\n-        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n-        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n-\n-        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n-        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n-        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n-        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n-        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n-        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n-        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n-    }\n-\n-    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n-        String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n-        return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n-                : getThingTypeUID(THING_TYPE_SHELLYPROTECTED_STR + \"-\" + devid, mode), devid);\n-    }\n-\n-    public static ThingTypeUID getThingTypeUID(String serviceName, String mode) {\n-        return new ThingTypeUID(BINDING_ID, getThingType(serviceName, mode));\n-    }\n-\n-    public static ThingTypeUID getUnknownTTUID() {\n-        return new ThingTypeUID(BINDING_ID, THING_TYPE_SHELLYPROTECTED_STR);\n-    }\n-\n-    public static String getThingType(String hostname, String mode) {\n-        String name = hostname.toLowerCase();\n-        String devid = StringUtils.substringAfterLast(name, \"-\");\n-        if (devid == null) {\n-            throw new IllegalArgumentException(\"Invalid device name format: \" + hostname);\n-        }\n-\n-        if (name.startsWith(THING_TYPE_SHELLY1PN_STR)) {\n-            return THING_TYPE_SHELLY1PN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM3_STR)) {\n-            return THING_TYPE_SHELLYEM3_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEM_STR)) {\n-            return THING_TYPE_SHELLYEM_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY1_STR)) {\n-            return THING_TYPE_SHELLY1_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY25_PREFIX)) { // Shelly v2.5\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY25_RELAY_STR : THING_TYPE_SHELLY25_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY2_PREFIX)) { // Shelly v2\n-            return mode.equals(SHELLY_MODE_RELAY) ? THING_TYPE_SHELLY2_RELAY_STR : THING_TYPE_SHELLY2_ROLLER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLY4PRO_STR)) {\n-            return THING_TYPE_SHELLY4PRO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPLUG_STR)) {\n-            // shellyplug-s needs to be mapped to shellyplugs to follow the schema\n-            // for the thing types: <thing type>-<mode>\n-            if (name.startsWith(THING_TYPE_SHELLYPLUGS_STR) || name.contains(\"-s\")) {\n-                return THING_TYPE_SHELLYPLUGS_STR;\n-            }\n-            return THING_TYPE_SHELLYPLUG_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDIMMER_STR)) {\n-            return THING_TYPE_SHELLYDIMMER_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDUO_STR)) {\n-            return THING_TYPE_SHELLYDUO_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYBULB_STR)) {\n-            return THING_TYPE_SHELLYBULB_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX)) {\n-            return mode.equals(SHELLY_MODE_COLOR) ? THING_TYPE_SHELLYRGBW2_COLOR_STR : THING_TYPE_SHELLYRGBW2_WHITE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYHT_STR)) {\n-            return THING_TYPE_SHELLYHT_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSMOKE_STR)) {\n-            return THING_TYPE_SHELLYSMOKE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYFLOOD_STR)) {\n-            return THING_TYPE_SHELLYFLOOD_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYDOORWIN_STR)) {\n-            return THING_TYPE_SHELLYDOORWIN_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYSENSE_STR)) {\n-            return THING_TYPE_SHELLYSENSE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYEYE_STR)) {\n-            return THING_TYPE_SHELLYEYE_STR;\n-        }\n-        if (name.startsWith(THING_TYPE_SHELLYPROTECTED_STR)) {\n-            return THING_TYPE_SHELLYPROTECTED_STR;\n-        }\n+        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n \n-        return THING_TYPE_UNKNOWN_STR;\n+        return profile;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145928", "bodyText": "You said you removed this...", "author": "cpmeister", "createdAt": "2020-04-12T04:52:09Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNjMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407716338", "bodyText": "Are you forgetting to change this or ignoring it?", "author": "cpmeister", "createdAt": "2020-04-13T20:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408180608", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\nindex bc8faf83f7..b880b411f6 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n\n@@ -52,44 +54,40 @@ public class ShellyEventServlet extends HttpServlet {\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private final HttpService httpService;\n-    private final ShellyHandlerFactory handlerFactory;\n+    private @Nullable HttpService httpService;\n+    private @Nullable ShellyHandlerFactory handlerFactory;\n \n+    @SuppressWarnings(\"null\")\n     @Activate\n-    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n-            Map<String, Object> config) {\n-        this.httpService = httpService;\n-        this.handlerFactory = handlerFactory;\n+    protected void activate(Map<String, Object> config) {\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n-            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException e) {\n+            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n+    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        httpService.unregister(SHELLY_CALLBACK_URI);\n-        logger.debug(\"ShellyEventServlet stopped\");\n+        if (httpService != null) {\n+            httpService.unregister(SHELLY_CALLBACK_URI);\n+        }\n+        logger.debug(\"Shelly: CallbackServlet stopped\");\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException, IllegalArgumentException {\n-        String data = \"\";\n-        String path = \"\";\n+            throws ServletException, IOException {\n+        String data = inputStreamToString(request);\n+        String path = request.getRequestURI().toLowerCase();\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n-        if ((request == null) || (resp == null)) {\n-            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");\n-        }\n-\n         try {\n-            path = request.getRequestURI().toLowerCase();\n-            data = IOUtils.toString(request.getInputStream(), \"UTF-8\");\n             String ipAddress = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n             if (ipAddress == null) {\n                 ipAddress = request.getRemoteAddr();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146124", "bodyText": "Can you make this final?", "author": "cpmeister", "createdAt": "2020-04-12T04:54:14Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -53,51 +59,58 @@\n  */\n @NonNullByDefault\n public class ShellyHttpApi {\n+    public static final String HTTP_HEADER_AUTH = \"Authorization\";\n+    public static final String HTTP_AUTH_TYPE_BASIC = \"Basic\";\n+    public static final String CONTENT_TYPE_XML = \"text/xml; charset=UTF-8\";\n+    public static final String CONTENT_TYPE_JSON = \"application/json\";\n+\n     private final Logger logger = LoggerFactory.getLogger(ShellyHttpApi.class);\n-    private final ShellyThingConfiguration config;\n-    private final String thingName = \"\";\n+    private HttpClient httpClient;", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMDA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407230087", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T17:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 3f29338781..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -59,35 +53,25 @@ import tec.uom.se.unit.Units;\n  */\n @NonNullByDefault\n public class ShellyHttpApi {\n-    public static final String HTTP_HEADER_AUTH = \"Authorization\";\n-    public static final String HTTP_AUTH_TYPE_BASIC = \"Basic\";\n-    public static final String CONTENT_TYPE_XML = \"text/xml; charset=UTF-8\";\n-    public static final String CONTENT_TYPE_JSON = \"application/json\";\n-\n     private final Logger logger = LoggerFactory.getLogger(ShellyHttpApi.class);\n-    private HttpClient httpClient;\n-    private ShellyThingConfiguration config = new ShellyThingConfiguration();;\n-    private String thingName;\n-    private final Gson gson = new Gson();\n+    private final ShellyThingConfiguration config;\n+    private final String thingName = \"\";\n     private int timeoutErrors = 0;\n     private int timeoutsRecovered = 0;\n+    private Gson gson = new Gson();\n \n-    private ShellyDeviceProfile profile = new ShellyDeviceProfile();\n+    private @Nullable ShellyDeviceProfile profile;\n \n-    public ShellyHttpApi(String thingName, ShellyThingConfiguration config, HttpClient httpClient) {\n-        this.httpClient = httpClient;\n-        this.thingName = thingName;\n-        setConfig(thingName, config);\n-        profile.initFromThingType(thingName);\n-    }\n-\n-    public void setConfig(String thingName, ShellyThingConfiguration config) {\n-        this.thingName = thingName;\n+    public ShellyHttpApi(ShellyThingConfiguration config) {\n+        Validate.notNull(config, \"Shelly Http Api: Config must not be null!\");\n         this.config = config;\n     }\n \n-    public ShellySettingsDevice getDevInfo() throws ShellyApiException {\n-        return callApi(SHELLY_URL_DEVINFO, ShellySettingsDevice.class);\n+    @Nullable\n+    public ShellySettingsDevice getDevInfo() throws IOException {\n+        String json = request(SHELLY_URL_DEVINFO);\n+        logger.debug(\"Shelly device info : {}\", json);\n+        return gson.fromJson(json, ShellySettingsDevice.class);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146269", "bodyText": "So you never retry battery devices?", "author": "cpmeister", "createdAt": "2020-04-12T04:56:49Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMDI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407230269", "bodyText": "no, they go to sleep after reporting the data\nthe next release will include a watchdog to monitor that they wake at least once within the 12h rregular interval if nothing happens", "author": "markus7017", "createdAt": "2020-04-12T17:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjI2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 3f29338781..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -348,216 +379,154 @@ public class ShellyHttpApi {\n         }\n     }\n \n-    private void setDimmerEvents() throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setDimmerEvents() throws IOException {\n+        Validate.notNull(profile);\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n-        } else if (profile.isLight) {\n-            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set sensor Action URLs\n+     * Set event URL for HT (report_url)\n      *\n-     * @throws ShellyApiException\n+     * @param deviceName\n+     * @throws IOException\n      */\n-    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n-        if (profile.isSensor) {\n-            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n-            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+    @SuppressWarnings(\"null\")\n+    private void setSensorEventUrls() throws IOException {\n+        Validate.notNull(profile);\n+        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n+            logger.debug(\"Check/set Sensor Reporting URL\");\n+            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n+            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n         }\n     }\n \n-    /**\n-     * Set/delete Relay/Roller/Dimmer Action URLs\n-     *\n-     * @param index Device Index (0-based)\n-     * @throws ShellyApiException\n-     */\n-    private void setEventUrls(Integer index) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setEventUrls(Integer index) throws IOException {\n+        Validate.notNull(profile);\n+        String lip = config.localIp;\n+        String localPort = config.httpPort.toString();\n+        String deviceName = profile.thingName;\n         if (profile.isRoller) {\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n-        } else if (profile.isDimmer) {\n-            // 2 set of URLs, e.g. Dimmer\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n-\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n-\n-            // Relay output\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        } else if (profile.hasRelays) {\n-            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        }\n-    }\n-\n-    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            // Sensors add the type=xx to report_url themself, so we need to ommit here\n-            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + eventType + urlParm;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsRollerUrls) {\n+                logger.debug(\"Set Roller event urls\");\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_STOP));\n             }\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n+        } else {\n+            if (profile.supportsButtonUrls && config.eventsButton) {\n+                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n+                    // 2 set of URLs, e.g. Dimmer\n+                    logger.debug(\"Set Dimmer event urls\");\n+\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_OFF));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_OFF));\n+                } else {\n+                    // Standard relays: btn_xxx URLs\n+                    logger.debug(\"Set Relay event urls\");\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_OFF));\n+                }\n             }\n-        }\n-    }\n-\n-    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n-            throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsOutUrls && config.eventsSwitch) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n             }\n-            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n-                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n-                        + urlEncode(newUrl));\n+            if (profile.supportsPushUrls && config.eventsPush) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n             }\n         }\n     }\n \n-    private static String mkEventUrl(String eventType) {\n-        return eventType + SHELLY_EVENTURL_SUFFIX;\n-    }\n-\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        int retries = 3;\n-        while (retries > 0) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                apiResult = innerRequest(HttpMethod.GET, uri);\n-                return apiResult.response; // successful\n-            } catch (ShellyApiException e) {\n-                retries--;\n-                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n-                    // Sensor in sleep mode or\n-                    // API exception for non-battery device\n-                    throw e; // non-timeout exception\n-                }\n-\n-                timeoutErrors++; // count the retries\n-                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n-                try {\n-                    apiResult = innerRequest(HttpMethod.GET, uri);\n-                    timeoutsRecovered++;\n-                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n-                            apiResult.getUrl());\n-                } catch (ShellyApiException e2) {\n-                    if (retries <= 1) {\n-                        throw new ShellyApiException(e2);\n-                    }\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                } else {\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n             }\n         }\n-        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n+        return result;\n     }\n \n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n-\n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"HTTP Response: {}\", response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUrlPrefix(Integer id) {\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n         }\n-        uri = uri + \"/\" + id.toString();\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        }\n+\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146487", "bodyText": "Since you don't need regex here you can use replace instead of replaceAll.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n          \n          \n            \n                        String response = contentResponse.getContentAsString().replace(\"\\t\", \"\").replace(\"\\r\\n\", \"\").trim();", "author": "cpmeister", "createdAt": "2020-04-12T04:59:14Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMDQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407230431", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjQ4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 3f29338781..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -348,216 +379,154 @@ public class ShellyHttpApi {\n         }\n     }\n \n-    private void setDimmerEvents() throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setDimmerEvents() throws IOException {\n+        Validate.notNull(profile);\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n-        } else if (profile.isLight) {\n-            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set sensor Action URLs\n+     * Set event URL for HT (report_url)\n      *\n-     * @throws ShellyApiException\n+     * @param deviceName\n+     * @throws IOException\n      */\n-    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n-        if (profile.isSensor) {\n-            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n-            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+    @SuppressWarnings(\"null\")\n+    private void setSensorEventUrls() throws IOException {\n+        Validate.notNull(profile);\n+        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n+            logger.debug(\"Check/set Sensor Reporting URL\");\n+            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n+            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n         }\n     }\n \n-    /**\n-     * Set/delete Relay/Roller/Dimmer Action URLs\n-     *\n-     * @param index Device Index (0-based)\n-     * @throws ShellyApiException\n-     */\n-    private void setEventUrls(Integer index) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setEventUrls(Integer index) throws IOException {\n+        Validate.notNull(profile);\n+        String lip = config.localIp;\n+        String localPort = config.httpPort.toString();\n+        String deviceName = profile.thingName;\n         if (profile.isRoller) {\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n-        } else if (profile.isDimmer) {\n-            // 2 set of URLs, e.g. Dimmer\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n-\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n-\n-            // Relay output\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        } else if (profile.hasRelays) {\n-            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        }\n-    }\n-\n-    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            // Sensors add the type=xx to report_url themself, so we need to ommit here\n-            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + eventType + urlParm;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsRollerUrls) {\n+                logger.debug(\"Set Roller event urls\");\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_STOP));\n             }\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n+        } else {\n+            if (profile.supportsButtonUrls && config.eventsButton) {\n+                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n+                    // 2 set of URLs, e.g. Dimmer\n+                    logger.debug(\"Set Dimmer event urls\");\n+\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_OFF));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_OFF));\n+                } else {\n+                    // Standard relays: btn_xxx URLs\n+                    logger.debug(\"Set Relay event urls\");\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_OFF));\n+                }\n             }\n-        }\n-    }\n-\n-    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n-            throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsOutUrls && config.eventsSwitch) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n             }\n-            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n-                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n-                        + urlEncode(newUrl));\n+            if (profile.supportsPushUrls && config.eventsPush) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n             }\n         }\n     }\n \n-    private static String mkEventUrl(String eventType) {\n-        return eventType + SHELLY_EVENTURL_SUFFIX;\n-    }\n-\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        int retries = 3;\n-        while (retries > 0) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                apiResult = innerRequest(HttpMethod.GET, uri);\n-                return apiResult.response; // successful\n-            } catch (ShellyApiException e) {\n-                retries--;\n-                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n-                    // Sensor in sleep mode or\n-                    // API exception for non-battery device\n-                    throw e; // non-timeout exception\n-                }\n-\n-                timeoutErrors++; // count the retries\n-                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n-                try {\n-                    apiResult = innerRequest(HttpMethod.GET, uri);\n-                    timeoutsRecovered++;\n-                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n-                            apiResult.getUrl());\n-                } catch (ShellyApiException e2) {\n-                    if (retries <= 1) {\n-                        throw new ShellyApiException(e2);\n-                    }\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                } else {\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n             }\n         }\n-        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n+        return result;\n     }\n \n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n-\n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"HTTP Response: {}\", response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUrlPrefix(Integer id) {\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n         }\n-        uri = uri + \"/\" + id.toString();\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        }\n+\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146552", "bodyText": "You should specify a charset.", "author": "cpmeister", "createdAt": "2020-04-12T05:00:15Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231125", "bodyText": "changed, now using getBytes(StandardCharsets.UTF_8) and\npublic static final String CONTENT_TYPE_JSON = \"application/json; charset=UTF-8\";\nok?", "author": "markus7017", "createdAt": "2020-04-12T17:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjU1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 3f29338781..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -348,216 +379,154 @@ public class ShellyHttpApi {\n         }\n     }\n \n-    private void setDimmerEvents() throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setDimmerEvents() throws IOException {\n+        Validate.notNull(profile);\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n-        } else if (profile.isLight) {\n-            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set sensor Action URLs\n+     * Set event URL for HT (report_url)\n      *\n-     * @throws ShellyApiException\n+     * @param deviceName\n+     * @throws IOException\n      */\n-    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n-        if (profile.isSensor) {\n-            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n-            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+    @SuppressWarnings(\"null\")\n+    private void setSensorEventUrls() throws IOException {\n+        Validate.notNull(profile);\n+        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n+            logger.debug(\"Check/set Sensor Reporting URL\");\n+            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n+            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n         }\n     }\n \n-    /**\n-     * Set/delete Relay/Roller/Dimmer Action URLs\n-     *\n-     * @param index Device Index (0-based)\n-     * @throws ShellyApiException\n-     */\n-    private void setEventUrls(Integer index) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setEventUrls(Integer index) throws IOException {\n+        Validate.notNull(profile);\n+        String lip = config.localIp;\n+        String localPort = config.httpPort.toString();\n+        String deviceName = profile.thingName;\n         if (profile.isRoller) {\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n-        } else if (profile.isDimmer) {\n-            // 2 set of URLs, e.g. Dimmer\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n-\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n-\n-            // Relay output\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        } else if (profile.hasRelays) {\n-            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        }\n-    }\n-\n-    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            // Sensors add the type=xx to report_url themself, so we need to ommit here\n-            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + eventType + urlParm;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsRollerUrls) {\n+                logger.debug(\"Set Roller event urls\");\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_STOP));\n             }\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n+        } else {\n+            if (profile.supportsButtonUrls && config.eventsButton) {\n+                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n+                    // 2 set of URLs, e.g. Dimmer\n+                    logger.debug(\"Set Dimmer event urls\");\n+\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_OFF));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_OFF));\n+                } else {\n+                    // Standard relays: btn_xxx URLs\n+                    logger.debug(\"Set Relay event urls\");\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_OFF));\n+                }\n             }\n-        }\n-    }\n-\n-    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n-            throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsOutUrls && config.eventsSwitch) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n             }\n-            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n-                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n-                        + urlEncode(newUrl));\n+            if (profile.supportsPushUrls && config.eventsPush) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n             }\n         }\n     }\n \n-    private static String mkEventUrl(String eventType) {\n-        return eventType + SHELLY_EVENTURL_SUFFIX;\n-    }\n-\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        int retries = 3;\n-        while (retries > 0) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                apiResult = innerRequest(HttpMethod.GET, uri);\n-                return apiResult.response; // successful\n-            } catch (ShellyApiException e) {\n-                retries--;\n-                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n-                    // Sensor in sleep mode or\n-                    // API exception for non-battery device\n-                    throw e; // non-timeout exception\n-                }\n-\n-                timeoutErrors++; // count the retries\n-                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n-                try {\n-                    apiResult = innerRequest(HttpMethod.GET, uri);\n-                    timeoutsRecovered++;\n-                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n-                            apiResult.getUrl());\n-                } catch (ShellyApiException e2) {\n-                    if (retries <= 1) {\n-                        throw new ShellyApiException(e2);\n-                    }\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                } else {\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n             }\n         }\n-        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n+        return result;\n     }\n \n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n-\n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"HTTP Response: {}\", response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUrlPrefix(Integer id) {\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n         }\n-        uri = uri + \"/\" + id.toString();\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        }\n+\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146602", "bodyText": "toString is called automatically\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    uri = uri + \"/\" + id.toString();\n          \n          \n            \n                    uri = uri + \"/\" + id;", "author": "cpmeister", "createdAt": "2020-04-12T05:01:28Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n+\n+            // validate response, API errors are reported as Json\n+            logger.trace(\"HTTP Response: {}\", response);\n+            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n+                throw new ShellyApiException(apiResult);\n+            }\n+            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n+                throw new ShellyApiException(\"Unexpected response: \" + response);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n+            throw new ShellyApiException(apiResult, e);\n         }\n+        return apiResult;\n+    }\n \n-        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n-        return httpResponse;\n+    public String getControlUrlPrefix(Integer id) {\n+        String uri = \"\";\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isDuo || profile.isDimmer) {\n+                // Duo + Dimmer\n+                uri = SHELLY_URL_CONTROL_LIGHT;\n+            } else {\n+                // Bulb + RGBW2\n+                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+            }\n+        } else {\n+            // Roller, Relay\n+            uri = SHELLY_URL_CONTROL_RELEAY;\n+        }\n+        uri = uri + \"/\" + id.toString();", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231162", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjYwMg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 3f29338781..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -348,216 +379,154 @@ public class ShellyHttpApi {\n         }\n     }\n \n-    private void setDimmerEvents() throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setDimmerEvents() throws IOException {\n+        Validate.notNull(profile);\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n-        } else if (profile.isLight) {\n-            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set sensor Action URLs\n+     * Set event URL for HT (report_url)\n      *\n-     * @throws ShellyApiException\n+     * @param deviceName\n+     * @throws IOException\n      */\n-    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n-        if (profile.isSensor) {\n-            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n-            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+    @SuppressWarnings(\"null\")\n+    private void setSensorEventUrls() throws IOException {\n+        Validate.notNull(profile);\n+        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n+            logger.debug(\"Check/set Sensor Reporting URL\");\n+            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n+            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n         }\n     }\n \n-    /**\n-     * Set/delete Relay/Roller/Dimmer Action URLs\n-     *\n-     * @param index Device Index (0-based)\n-     * @throws ShellyApiException\n-     */\n-    private void setEventUrls(Integer index) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setEventUrls(Integer index) throws IOException {\n+        Validate.notNull(profile);\n+        String lip = config.localIp;\n+        String localPort = config.httpPort.toString();\n+        String deviceName = profile.thingName;\n         if (profile.isRoller) {\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n-        } else if (profile.isDimmer) {\n-            // 2 set of URLs, e.g. Dimmer\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n-\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n-\n-            // Relay output\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        } else if (profile.hasRelays) {\n-            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        }\n-    }\n-\n-    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            // Sensors add the type=xx to report_url themself, so we need to ommit here\n-            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + eventType + urlParm;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsRollerUrls) {\n+                logger.debug(\"Set Roller event urls\");\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_STOP));\n             }\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n+        } else {\n+            if (profile.supportsButtonUrls && config.eventsButton) {\n+                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n+                    // 2 set of URLs, e.g. Dimmer\n+                    logger.debug(\"Set Dimmer event urls\");\n+\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_OFF));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_OFF));\n+                } else {\n+                    // Standard relays: btn_xxx URLs\n+                    logger.debug(\"Set Relay event urls\");\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_OFF));\n+                }\n             }\n-        }\n-    }\n-\n-    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n-            throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsOutUrls && config.eventsSwitch) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n             }\n-            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n-                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n-                        + urlEncode(newUrl));\n+            if (profile.supportsPushUrls && config.eventsPush) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n             }\n         }\n     }\n \n-    private static String mkEventUrl(String eventType) {\n-        return eventType + SHELLY_EVENTURL_SUFFIX;\n-    }\n-\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        int retries = 3;\n-        while (retries > 0) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                apiResult = innerRequest(HttpMethod.GET, uri);\n-                return apiResult.response; // successful\n-            } catch (ShellyApiException e) {\n-                retries--;\n-                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n-                    // Sensor in sleep mode or\n-                    // API exception for non-battery device\n-                    throw e; // non-timeout exception\n-                }\n-\n-                timeoutErrors++; // count the retries\n-                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n-                try {\n-                    apiResult = innerRequest(HttpMethod.GET, uri);\n-                    timeoutsRecovered++;\n-                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n-                            apiResult.getUrl());\n-                } catch (ShellyApiException e2) {\n-                    if (retries <= 1) {\n-                        throw new ShellyApiException(e2);\n-                    }\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                } else {\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n             }\n         }\n-        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n+        return result;\n     }\n \n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n-\n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"HTTP Response: {}\", response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUrlPrefix(Integer id) {\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n         }\n-        uri = uri + \"/\" + id.toString();\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        }\n+\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzAzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147034", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-12T05:07:43Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -371,8 +363,39 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\":\n+                                if ((profile.settings.temperatureUnits != null)\n+                                        && profile.settings.temperatureUnits.equalsIgnoreCase(\"F\")) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTM4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231380", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T17:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzAzNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex bf7c24ba11..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -363,39 +371,8 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        Double value = getDouble(s.value);\n-                        switch (sen.desc.toLowerCase()) {\n-                            case \"temperature\":\n-                                if ((profile.settings.temperatureUnits != null)\n-                                        && profile.settings.temperatureUnits.equalsIgnoreCase(\"F\")) {\n-                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n-                                            .convert(getDouble(s.value)).doubleValue();\n-                                }\n-                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n-                                break;\n-\n-                            case \"external_temperature\": // Shelly 1/1PM externa\u00f6 temp sensors\n-                                logger.debug(\"{}: Update external sensor from Coap update\", thingName);\n-                                int idx = getExtTempId(sen.id);\n-                                if (idx > 0) {\n-                                    updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP + idx,\n-                                            toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n-                                }\n-                                break;\n-                            case \"temperature f\":\n-                                value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n-                                        .convert(getDouble(s.value)).doubleValue();\n-                            case \"temperature c\":\n-                                // Device temperature\n-                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n-                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n-                                break;\n-                            default:\n-                                // Regular sensor temp (H&T)\n-                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n-                        }\n+                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n                         break;\n                     case \"h\" /* Humidity */:\n                         updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_HUM,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzEwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147106", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-12T05:08:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -474,47 +538,46 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n                                 updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_GAIN,\n                                         ShellyColorUtils.toPercent((int) s.value, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n                                 break;\n-                            case \"temp\":\n-                                updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_TEMP, ShellyColorUtils\n-                                        .toPercent((int) s.value, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE));\n-\n+                            case \"temp\": // Shelly Bulb\n+                            case \"colortemperature\": // Shelly Duo\n+                                updateChannel(updates,\n+                                        profile.inColor ? CHANNEL_GROUP_COLOR_CONTROL : CHANNEL_GROUP_WHITE_CONTROL,\n+                                        CHANNEL_COLOR_TEMP,\n+                                        ShellyColorUtils.toPercent((int) s.value, profile.minTemp, profile.maxTemp));\n                                 break;\n-\n                             default:\n                                 logger.debug(\"{}: Update for unknown sensor type {}/{} received\", thingName, sen.type,\n                                         sen.desc);\n                         }\n                         break;\n-\n                     default:\n                         logger.debug(\"{}: Sensor data for type {} not processed, value={}\", thingName, sen.type,\n                                 s.value);\n-                        break;\n                 }\n-            } else {\n-                logger.debug(\"{}: Update for unknown sensor[{}]: Dev={}, Index={}, Value={}\", thingName, i, devId,\n-                        s.index, s.value);\n+            } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n+                // even the processing of one value failed we continue with the next one (sometimes this is caused by\n+                // buggy formats provided by the device\n+                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n             }\n         }\n \n         if (!updates.isEmpty()) {\n+", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMjU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407232546", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T18:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzEwNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex bf7c24ba11..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -538,46 +474,47 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n                                 updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_GAIN,\n                                         ShellyColorUtils.toPercent((int) s.value, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n                                 break;\n-                            case \"temp\": // Shelly Bulb\n-                            case \"colortemperature\": // Shelly Duo\n-                                updateChannel(updates,\n-                                        profile.inColor ? CHANNEL_GROUP_COLOR_CONTROL : CHANNEL_GROUP_WHITE_CONTROL,\n-                                        CHANNEL_COLOR_TEMP,\n-                                        ShellyColorUtils.toPercent((int) s.value, profile.minTemp, profile.maxTemp));\n+                            case \"temp\":\n+                                updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_TEMP, ShellyColorUtils\n+                                        .toPercent((int) s.value, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE));\n+\n                                 break;\n+\n                             default:\n                                 logger.debug(\"{}: Update for unknown sensor type {}/{} received\", thingName, sen.type,\n                                         sen.desc);\n                         }\n                         break;\n+\n                     default:\n                         logger.debug(\"{}: Sensor data for type {} not processed, value={}\", thingName, sen.type,\n                                 s.value);\n+                        break;\n                 }\n-            } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n-                // even the processing of one value failed we continue with the next one (sometimes this is caused by\n-                // buggy formats provided by the device\n-                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n+            } else {\n+                logger.debug(\"{}: Update for unknown sensor[{}]: Dev={}, Index={}, Value={}\", thingName, i, devId,\n+                        s.index, s.value);\n             }\n         }\n \n         if (!updates.isEmpty()) {\n-\n             logger.debug(\"{}: Process {} CoIoT channel updates\", thingName, updates.size());\n             int i = 0;\n             for (Map.Entry<String, State> u : updates.entrySet()) {\n-                if (th.updateChannel(u.getKey(), u.getValue(), false)) {\n-                    logger.debug(\"{}:  Update[{}] Channel {} updated, value={} (type {})\", thingName, i, u.getKey(),\n-                            u.getValue(), u.getValue().getClass());\n-                }\n+                logger.debug(\"{}:  Update[{}] channel {}, value={} (type {})\", thingName, i, u.getKey(), u.getValue(),\n+                        u.getValue().getClass());\n+                thingHandler.updateChannel(u.getKey(), u.getValue(), true);\n                 i++;\n             }\n \n-            // Old firmware release are lacking various status values, which are not updated using CoIoT.\n-            // In this case we keep a refresh so it gets polled using REST. Beginning with Firmware 1.6 most\n-            // of the values are available so in thise case we could skip an extra poll to reduce load.\n-            if (th.scheduledUpdates <= 1) {\n-                th.requestUpdates(1, false);\n+            if (!profile.isSensor) {\n+                // For now the Coap interface is not providing all updates, e.g. currentWatts yes, but not the average\n+                // values for the 3 mins\n+                // To prevent confusing the user we schedule a regular REST update shortly\n+                // This will be removed once Coap returns all values, which have changed since the last update\n+                if (thingHandler.scheduledUpdates == 0) {\n+                    thingHandler.requestUpdates(1, false);\n+                }\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147557", "bodyText": "This log is a bit funky", "author": "cpmeister", "createdAt": "2020-04-12T05:14:23Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: Exception {}\", name, e.toString());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTY0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235643", "bodyText": "message changed", "author": "markus7017", "createdAt": "2020-04-12T18:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 4c38a250b1..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -99,85 +70,89 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            logger.debug(\n-                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n-                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n-                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n-                    service.getNiceTextString());\n-            address = service.getHostAddress();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n-                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n-                        service.toString());\n+                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n-            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n+            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            // Get device settings\n-            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n-            if (serviceConfig.getProperties() != null) {\n-                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            if (handlerFactory != null) {\n+                bindingConfig = handlerFactory.getBindingConfig();\n             }\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            // Get device settings\n+            Validate.notNull(bindingConfig);\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n+            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n-                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n-\n                 profile = api.getDeviceProfile(thingType);\n-                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n-                model = getString(profile.settings.device.type);\n+                Validate.notNull(profile);\n+                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n+                Validate.notNull(profile, \"Unable to get device profile: \");\n+                model = profile.settings.device.type;\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n-            } catch (ShellyApiException e) {\n-                ShellyApiResult result = e.getApiResult();\n-                if (result.isHttpAccessUnauthorized()) {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n+                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n+            } catch (IOException e) {\n+                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n+                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n+                            e.getMessage(), e.getClass(), e.getStackTrace());\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());\n             }\n \n             if (thingUID != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147613", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.toString());\n          \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.getMessage());", "author": "cpmeister", "createdAt": "2020-04-12T05:15:13Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: Exception {}\", name, e.toString());", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231674", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 4c38a250b1..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -99,85 +70,89 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            logger.debug(\n-                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n-                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n-                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n-                    service.getNiceTextString());\n-            address = service.getHostAddress();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n-                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n-                        service.toString());\n+                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n-            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n+            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            // Get device settings\n-            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n-            if (serviceConfig.getProperties() != null) {\n-                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            if (handlerFactory != null) {\n+                bindingConfig = handlerFactory.getBindingConfig();\n             }\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            // Get device settings\n+            Validate.notNull(bindingConfig);\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n+            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n-                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n-\n                 profile = api.getDeviceProfile(thingType);\n-                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n-                model = getString(profile.settings.device.type);\n+                Validate.notNull(profile);\n+                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n+                Validate.notNull(profile, \"Unable to get device profile: \");\n+                model = profile.settings.device.type;\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n-            } catch (ShellyApiException e) {\n-                ShellyApiResult result = e.getApiResult();\n-                if (result.isHttpAccessUnauthorized()) {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n+                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n+            } catch (IOException e) {\n+                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n+                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n+                            e.getMessage(), e.getClass(), e.getStackTrace());\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());\n             }\n \n             if (thingUID != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147641", "bodyText": "info?", "author": "cpmeister", "createdAt": "2020-04-12T05:15:30Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235705", "bodyText": "yes, I want to inform the user. Mostly this requires the config of the credentials", "author": "markus7017", "createdAt": "2020-04-12T18:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MDI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407380277", "bodyText": "I removed the .info on an run-time exception and kept it for an API exception (e.g. unauthorized)", "author": "markus7017", "createdAt": "2020-04-13T08:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 4c38a250b1..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -99,85 +70,89 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            logger.debug(\n-                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n-                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n-                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n-                    service.getNiceTextString());\n-            address = service.getHostAddress();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n-                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n-                        service.toString());\n+                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n-            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n+            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            // Get device settings\n-            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n-            if (serviceConfig.getProperties() != null) {\n-                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            if (handlerFactory != null) {\n+                bindingConfig = handlerFactory.getBindingConfig();\n             }\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            // Get device settings\n+            Validate.notNull(bindingConfig);\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n+            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n-                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n-\n                 profile = api.getDeviceProfile(thingType);\n-                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n-                model = getString(profile.settings.device.type);\n+                Validate.notNull(profile);\n+                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n+                Validate.notNull(profile, \"Unable to get device profile: \");\n+                model = profile.settings.device.type;\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n-            } catch (ShellyApiException e) {\n-                ShellyApiResult result = e.getApiResult();\n-                if (result.isHttpAccessUnauthorized()) {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n+                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n+            } catch (IOException e) {\n+                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n+                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n+                            e.getMessage(), e.getClass(), e.getStackTrace());\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());\n             }\n \n             if (thingUID != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147706", "bodyText": "info?", "author": "cpmeister", "createdAt": "2020-04-12T05:16:29Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231728", "bodyText": "yes, show the info to the user - needs user action (config credentials)", "author": "markus7017", "createdAt": "2020-04-12T17:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzcwNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 4c38a250b1..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -99,85 +70,89 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            logger.debug(\n-                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n-                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n-                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n-                    service.getNiceTextString());\n-            address = service.getHostAddress();\n-            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n-                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n-                        service.toString());\n+                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n-            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n+            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            // Get device settings\n-            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n-            if (serviceConfig.getProperties() != null) {\n-                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            if (handlerFactory != null) {\n+                bindingConfig = handlerFactory.getBindingConfig();\n             }\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            // Get device settings\n+            Validate.notNull(bindingConfig);\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n+            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n-                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n-\n                 profile = api.getDeviceProfile(thingType);\n-                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n-                model = getString(profile.settings.device.type);\n+                Validate.notNull(profile);\n+                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n+                Validate.notNull(profile, \"Unable to get device profile: \");\n+                model = profile.settings.device.type;\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n-            } catch (ShellyApiException e) {\n-                ShellyApiResult result = e.getApiResult();\n-                if (result.isHttpAccessUnauthorized()) {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n+                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n+            } catch (IOException e) {\n+                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n+                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n+                            e.getMessage(), e.getClass(), e.getStackTrace());\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());\n             }\n \n             if (thingUID != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147748", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception {}\", name, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception {}\", name, e.getMessage());", "author": "cpmeister", "createdAt": "2020-04-12T05:16:49Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -162,13 +187,14 @@ public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n+                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n-                    e.getMessage(), e);\n+        } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n+                                                                                    // buggy\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n+            logger.debug(\"{}: Exception {}\", name, e.toString());", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTgyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231821", "bodyText": "if I use getMessage8) I don't get the stack trace, that's what I'm looking for here", "author": "markus7017", "createdAt": "2020-04-12T17:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNDQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407234497", "bodyText": "why is\nlogger.debug(\"{}: Unable to initialize, retrying later: {}\", thingName, e);\n``\nresults in \n\n[ERROR] Code Analysis Tool has found:\n4 error(s)!\n9 warning(s)\n10 info(s)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[158]\nCount of placeholder(2) is not equal to count of parameter(1)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[325]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[392]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHand\n\nwhereas it gets accepted when I use e.toString(). AFAIK log4j has support for argument type Throwable", "author": "markus7017", "createdAt": "2020-04-12T18:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408180790", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 4c38a250b1..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -187,14 +162,13 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n+                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n-                                                                                    // buggy\n-            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n-            logger.debug(\"{}: Exception {}\", name, e.toString());\n+        } catch (NullPointerException e) {\n+            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n+                    e.getMessage(), e);\n         }\n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147837", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-04-12T05:18:01Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java", "diffHunk": "@@ -16,19 +16,16 @@\n import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n \n import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.thing.ThingTypeUID;\n import org.eclipse.smarthome.core.thing.ThingUID;\n \n /**\n- * The {@link ShellyThingCreator} implements some helper functions for Thing creation (used by Discovery and Thing\n- * handler).\n+ * The {@link ShellyThingCreator} maps the device id into the thing type id\n  *\n  * @author Markus Michels - Initial contribution\n  */\n-@NonNullByDefault\n-public class ShellyThingCreator {\n \n+public class ShellyThingCreator {", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTkwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231902", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T17:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java\nindex 770f25a581..3a2fb01fbb 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java\n\n@@ -16,16 +16,19 @@ import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n \n import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.thing.ThingTypeUID;\n import org.eclipse.smarthome.core.thing.ThingUID;\n \n /**\n- * The {@link ShellyThingCreator} maps the device id into the thing type id\n+ * The {@link ShellyThingCreator} implements some helper functions for Thing creation (used by Discovery and Thing\n+ * handler).\n  *\n  * @author Markus Michels - Initial contribution\n  */\n-\n+@NonNullByDefault\n public class ShellyThingCreator {\n+\n     public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {\n         String devid = StringUtils.substringAfterLast(serviceName, \"-\");\n         return new ThingUID(!unknown ? getThingTypeUID(serviceName, mode)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Boolean autoCoIoT = false;\n          \n          \n            \n                private boolean autoCoIoT = false;", "author": "cpmeister", "createdAt": "2020-04-12T05:18:53Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -61,38 +68,39 @@\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n+    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n+    public String thingType = \"\";\n+\n+    protected final ShellyHttpApi api;\n+    protected ShellyBindingConfiguration bindingConfig;\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected @Nullable ShellyHttpApi api;\n-    private @Nullable ShellyCoapHandler coap;\n-    protected @Nullable ShellyDeviceProfile profile;\n-    private final @Nullable ShellyCoapServer coapServer;\n+    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n+    private final ShellyCoapHandler coap;\n+    private Boolean autoCoIoT = false;", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231971", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzkyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex c2c4451b4c..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -68,39 +61,38 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n-    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    public String thingType = \"\";\n-\n-    protected final ShellyHttpApi api;\n-    protected ShellyBindingConfiguration bindingConfig;\n+    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n-    private final ShellyCoapHandler coap;\n-    private Boolean autoCoIoT = false;\n+    protected @Nullable ShellyHttpApi api;\n+    private @Nullable ShellyCoapHandler coap;\n+    protected @Nullable ShellyDeviceProfile profile;\n+    private final @Nullable ShellyCoapServer coapServer;\n     protected boolean lockUpdates = false;\n \n-    private final ShellyTranslationProvider messages;\n-    private boolean channelsCreated = false;\n-\n+    @SuppressWarnings(\"unused\")\n+    private long lastUpdateTs = 0;\n     private long lastUptime = 0;\n     private long lastAlarmTs = 0;\n-    private long lastTimeoutErros = -1;\n+    private Integer lastTimeoutErros = -1;\n \n-    private Optional<ScheduledFuture<?>> statusJob = Optional.empty();\n+    private @Nullable ScheduledFuture<?> statusJob;\n+    private int skipUpdate = 0;\n     public int scheduledUpdates = 0;\n-    private int refreshCount = UPDATE_SETTINGS_INTERVAL_SECONDS / UPDATE_STATUS_INTERVAL_SECONDS;\n     private int skipCount = UPDATE_SKIP_COUNT;\n-    private int skipUpdate = 0;\n+\n+    // force settings refresh every x seconds\n+    private int refreshCount = UPDATE_SETTINGS_INTERVAL_SECONDS / UPDATE_STATUS_INTERVAL_SECONDS;\n     private boolean refreshSettings = false;\n \n     // delay before enabling channel\n     private final int cacheCount = UPDATE_SETTINGS_INTERVAL_SECONDS / UPDATE_STATUS_INTERVAL_SECONDS;\n-    protected final ShellyChannelCache cache;\n+    private boolean channelCache = false;\n+    private Map<String, Object> channelData = new HashMap<>();\n \n-    private String localIP = \"\";\n-    private String localPort = \"\";\n+    String localIP = \"\";\n+    int httpPort = -1;\n \n     /**\n      * Constructor\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148500", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-12T05:27:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -517,55 +532,65 @@ public boolean onEvent(String deviceName, String deviceIndex, String type, Map<S\n \n                 // map some of the events to system defined button triggers\n                 String channel = \"\";\n+                String onoff = \"\";\n                 String payload = \"\";\n-                String event = type.contentEquals(EVENT_TYPE_SENSORDATA) ? SHELLY_EVENT_SENSORDATA\n-                        : parameters.get(\"type\");\n+                String parmType = getString(parameters.get(\"type\"));\n+                String event = !parmType.isEmpty() ? parmType : type;\n                 switch (event) {\n                     case SHELLY_EVENT_SHORTPUSH:\n-                        channel = CHANNEL_BUTTON_TRIGGER;\n-                        payload = CommonTriggerEvents.SHORT_PRESSED;\n-                        break;\n                     case SHELLY_EVENT_LONGPUSH:\n-                        channel = CHANNEL_BUTTON_TRIGGER;\n-                        payload = CommonTriggerEvents.LONG_PRESSED;\n+                        if (isButton) {\n+                            channel = CHANNEL_BUTTON_TRIGGER;\n+                            payload = event.equals(SHELLY_EVENT_SHORTPUSH) ? CommonTriggerEvents.SHORT_PRESSED\n+                                    : CommonTriggerEvents.LONG_PRESSED;\n+                        } else {\n+                            logger.debug(\"{}: Relay button is not in memontary or detached mode, ignore SHORT/LONGPUSH\",\n+                                    thingName);\n+                        }\n                         break;\n-\n                     case SHELLY_EVENT_ROLLER_OPEN:\n                     case SHELLY_EVENT_ROLLER_CLOSE:\n                     case SHELLY_EVENT_ROLLER_STOP:\n                         channel = CHANNEL_EVENT_TRIGGER;\n                         payload = event;\n                         break;\n-\n                     case SHELLY_EVENT_BTN_ON:\n-                        updateChannel(group, CHANNEL_INPUT, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN_OFF:\n-                        updateChannel(group, CHANNEL_INPUT, OnOffType.OFF);\n+                        if (profile.isRGBW2) {\n+                            // RGBW2 has only one input, so not per channel\n+                            group = CHANNEL_GROUP_LIGHT_CONTROL;\n+                        }\n+                        onoff = CHANNEL_INPUT;\n                         break;\n                     case SHELLY_EVENT_BTN1_ON:\n-                        updateChannel(group, CHANNEL_INPUT1, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN1_OFF:\n-                        updateChannel(group, CHANNEL_INPUT1, OnOffType.OFF);\n+                        onoff = CHANNEL_INPUT1;\n                         break;\n                     case SHELLY_EVENT_BTN2_ON:\n-                        updateChannel(group, CHANNEL_INPUT2, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN2_OFF:\n-                        updateChannel(group, CHANNEL_INPUT2, OnOffType.OFF);\n+                        onoff = CHANNEL_INPUT2;\n                         break;\n                     case SHELLY_EVENT_OUT_ON:\n-                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_OUT_OFF:\n-                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.OFF);\n+                        onoff = CHANNEL_OUTPUT;\n+                        break;\n+                    case SHELLY_EVENT_SENSORREPORT:\n+                        // process sensor with next refresh\n+                        break;\n+                    case SHELLY_EVENT_FLOOD_DETECTED:\n+                    case SHELLY_EVENT_FLOOD_GONE:\n+                        updateChannel(group, CHANNEL_SENSOR_FLOOD,\n+                                event.equalsIgnoreCase(SHELLY_EVENT_FLOOD_DETECTED) ? OnOffType.ON : OnOffType.OFF);\n                         break;\n \n                     default:\n                         // trigger will be provided by input/output channel or sensor channels\n                 }\n \n+                if (!onoff.isEmpty()) {\n+                    updateChannel(group, onoff, event.toLowerCase().contains(\"_on\") ? OnOffType.ON : OnOffType.OFF);\n+", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMDg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407210868", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T15:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex c2c4451b4c..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -532,65 +517,55 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n \n                 // map some of the events to system defined button triggers\n                 String channel = \"\";\n-                String onoff = \"\";\n                 String payload = \"\";\n-                String parmType = getString(parameters.get(\"type\"));\n-                String event = !parmType.isEmpty() ? parmType : type;\n+                String event = type.contentEquals(EVENT_TYPE_SENSORDATA) ? SHELLY_EVENT_SENSORDATA\n+                        : parameters.get(\"type\");\n                 switch (event) {\n                     case SHELLY_EVENT_SHORTPUSH:\n+                        channel = CHANNEL_BUTTON_TRIGGER;\n+                        payload = CommonTriggerEvents.SHORT_PRESSED;\n+                        break;\n                     case SHELLY_EVENT_LONGPUSH:\n-                        if (isButton) {\n-                            channel = CHANNEL_BUTTON_TRIGGER;\n-                            payload = event.equals(SHELLY_EVENT_SHORTPUSH) ? CommonTriggerEvents.SHORT_PRESSED\n-                                    : CommonTriggerEvents.LONG_PRESSED;\n-                        } else {\n-                            logger.debug(\"{}: Relay button is not in memontary or detached mode, ignore SHORT/LONGPUSH\",\n-                                    thingName);\n-                        }\n+                        channel = CHANNEL_BUTTON_TRIGGER;\n+                        payload = CommonTriggerEvents.LONG_PRESSED;\n                         break;\n+\n                     case SHELLY_EVENT_ROLLER_OPEN:\n                     case SHELLY_EVENT_ROLLER_CLOSE:\n                     case SHELLY_EVENT_ROLLER_STOP:\n                         channel = CHANNEL_EVENT_TRIGGER;\n                         payload = event;\n                         break;\n+\n                     case SHELLY_EVENT_BTN_ON:\n+                        updateChannel(group, CHANNEL_INPUT, OnOffType.ON);\n+                        break;\n                     case SHELLY_EVENT_BTN_OFF:\n-                        if (profile.isRGBW2) {\n-                            // RGBW2 has only one input, so not per channel\n-                            group = CHANNEL_GROUP_LIGHT_CONTROL;\n-                        }\n-                        onoff = CHANNEL_INPUT;\n+                        updateChannel(group, CHANNEL_INPUT, OnOffType.OFF);\n                         break;\n                     case SHELLY_EVENT_BTN1_ON:\n+                        updateChannel(group, CHANNEL_INPUT1, OnOffType.ON);\n+                        break;\n                     case SHELLY_EVENT_BTN1_OFF:\n-                        onoff = CHANNEL_INPUT1;\n+                        updateChannel(group, CHANNEL_INPUT1, OnOffType.OFF);\n                         break;\n                     case SHELLY_EVENT_BTN2_ON:\n+                        updateChannel(group, CHANNEL_INPUT2, OnOffType.ON);\n+                        break;\n                     case SHELLY_EVENT_BTN2_OFF:\n-                        onoff = CHANNEL_INPUT2;\n+                        updateChannel(group, CHANNEL_INPUT2, OnOffType.OFF);\n                         break;\n                     case SHELLY_EVENT_OUT_ON:\n-                    case SHELLY_EVENT_OUT_OFF:\n-                        onoff = CHANNEL_OUTPUT;\n-                        break;\n-                    case SHELLY_EVENT_SENSORREPORT:\n-                        // process sensor with next refresh\n+                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.ON);\n                         break;\n-                    case SHELLY_EVENT_FLOOD_DETECTED:\n-                    case SHELLY_EVENT_FLOOD_GONE:\n-                        updateChannel(group, CHANNEL_SENSOR_FLOOD,\n-                                event.equalsIgnoreCase(SHELLY_EVENT_FLOOD_DETECTED) ? OnOffType.ON : OnOffType.OFF);\n+                    case SHELLY_EVENT_OUT_OFF:\n+                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.OFF);\n                         break;\n \n                     default:\n                         // trigger will be provided by input/output channel or sensor channels\n                 }\n \n-                if (!onoff.isEmpty()) {\n-                    updateChannel(group, onoff, event.toLowerCase().contains(\"_on\") ? OnOffType.ON : OnOffType.OFF);\n-\n-                }\n                 if (!payload.isEmpty()) {\n                     // Pass event to trigger channel\n                     payload = payload.toUpperCase();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148728", "bodyText": "Optional isn't really a very good choice in this case. It was better when it was a nullable field.", "author": "cpmeister", "createdAt": "2020-04-12T05:29:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -61,38 +68,39 @@\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n+    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n+    public String thingType = \"\";\n+\n+    protected final ShellyHttpApi api;\n+    protected ShellyBindingConfiguration bindingConfig;\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected @Nullable ShellyHttpApi api;\n-    private @Nullable ShellyCoapHandler coap;\n-    protected @Nullable ShellyDeviceProfile profile;\n-    private final @Nullable ShellyCoapServer coapServer;\n+    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n+    private final ShellyCoapHandler coap;\n+    private Boolean autoCoIoT = false;\n     protected boolean lockUpdates = false;\n \n-    @SuppressWarnings(\"unused\")\n-    private long lastUpdateTs = 0;\n+    private final ShellyTranslationProvider messages;\n+    private boolean channelsCreated = false;\n+\n     private long lastUptime = 0;\n     private long lastAlarmTs = 0;\n-    private Integer lastTimeoutErros = -1;\n+    private long lastTimeoutErros = -1;\n \n-    private @Nullable ScheduledFuture<?> statusJob;\n-    private int skipUpdate = 0;\n+    private Optional<ScheduledFuture<?>> statusJob = Optional.empty();", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407212195", "bodyText": "change reverted\nwhy?", "author": "markus7017", "createdAt": "2020-04-12T15:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265053", "bodyText": "Using nullables for future fields is an unofficial openhab coding standard. We are just trying to make all the bindings consistent.", "author": "cpmeister", "createdAt": "2020-04-12T23:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM3OTc4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407379782", "bodyText": "aha", "author": "markus7017", "createdAt": "2020-04-13T08:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex c2c4451b4c..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -68,39 +61,38 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n-    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    public String thingType = \"\";\n-\n-    protected final ShellyHttpApi api;\n-    protected ShellyBindingConfiguration bindingConfig;\n+    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n-    private final ShellyCoapHandler coap;\n-    private Boolean autoCoIoT = false;\n+    protected @Nullable ShellyHttpApi api;\n+    private @Nullable ShellyCoapHandler coap;\n+    protected @Nullable ShellyDeviceProfile profile;\n+    private final @Nullable ShellyCoapServer coapServer;\n     protected boolean lockUpdates = false;\n \n-    private final ShellyTranslationProvider messages;\n-    private boolean channelsCreated = false;\n-\n+    @SuppressWarnings(\"unused\")\n+    private long lastUpdateTs = 0;\n     private long lastUptime = 0;\n     private long lastAlarmTs = 0;\n-    private long lastTimeoutErros = -1;\n+    private Integer lastTimeoutErros = -1;\n \n-    private Optional<ScheduledFuture<?>> statusJob = Optional.empty();\n+    private @Nullable ScheduledFuture<?> statusJob;\n+    private int skipUpdate = 0;\n     public int scheduledUpdates = 0;\n-    private int refreshCount = UPDATE_SETTINGS_INTERVAL_SECONDS / UPDATE_STATUS_INTERVAL_SECONDS;\n     private int skipCount = UPDATE_SKIP_COUNT;\n-    private int skipUpdate = 0;\n+\n+    // force settings refresh every x seconds\n+    private int refreshCount = UPDATE_SETTINGS_INTERVAL_SECONDS / UPDATE_STATUS_INTERVAL_SECONDS;\n     private boolean refreshSettings = false;\n \n     // delay before enabling channel\n     private final int cacheCount = UPDATE_SETTINGS_INTERVAL_SECONDS / UPDATE_STATUS_INTERVAL_SECONDS;\n-    protected final ShellyChannelCache cache;\n+    private boolean channelCache = false;\n+    private Map<String, Object> channelData = new HashMap<>();\n \n-    private String localIP = \"\";\n-    private String localPort = \"\";\n+    String localIP = \"\";\n+    int httpPort = -1;\n \n     /**\n      * Constructor\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148863", "bodyText": "please make these final", "author": "cpmeister", "createdAt": "2020-04-12T05:31:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.handler;\n+\n+import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n+import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n+import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n+\n+/**\n+ * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n+ * added on the first thing status update\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelDefinitionsDTO {\n+\n+    private static final ChannelMap channelDefinitions = new ChannelMap();\n+\n+    private static final String CHGR_METER = CHANNEL_GROUP_METER;\n+    private static final String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n+    private static final String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n+\n+    public static final String ITEM_TYPE_NUMBER = \"Number\";\n+    public static final String ITEM_TYPE_STRING = \"String\";\n+    public static final String ITEM_TYPE_DATETIME = \"DateTime\";\n+    public static final String ITEM_TYPE_TEMP = \"Number:Temperature\";\n+    public static final String ITEM_TYPE_LUX = \"Number:Illuminance\";\n+    public static final String ITEM_TYPE_POWER = \"Number:Power\";\n+    public static final String ITEM_TYPE_ENERGY = \"Number:Energy\";\n+    public static final String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n+    public static final String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n+    public static final String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n+    public static final String ITEM_TYPE_SWITCH = \"Switch\";\n+    public static final String ITEM_TYPE_CONTACT = \"Contact\";\n+\n+    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n+    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n+    public static String SUFFIX_LABEL = \".label\";\n+    public static String SUFFIX_DESCR = \".description\";", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjMxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407212312", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T15:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODg2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java\ndeleted file mode 100644\nindex f3ceef40ea..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java\n+++ /dev/null\n\n@@ -1,344 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.handler;\n-\n-import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.smarthome.core.thing.Channel;\n-import org.eclipse.smarthome.core.thing.ChannelUID;\n-import org.eclipse.smarthome.core.thing.Thing;\n-import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n-import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n-import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n-import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n-import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n-\n-/**\n- * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n- * added on the first thing status update\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelDefinitionsDTO {\n-\n-    private static final ChannelMap channelDefinitions = new ChannelMap();\n-\n-    private static final String CHGR_METER = CHANNEL_GROUP_METER;\n-    private static final String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n-    private static final String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n-\n-    public static final String ITEM_TYPE_NUMBER = \"Number\";\n-    public static final String ITEM_TYPE_STRING = \"String\";\n-    public static final String ITEM_TYPE_DATETIME = \"DateTime\";\n-    public static final String ITEM_TYPE_TEMP = \"Number:Temperature\";\n-    public static final String ITEM_TYPE_LUX = \"Number:Illuminance\";\n-    public static final String ITEM_TYPE_POWER = \"Number:Power\";\n-    public static final String ITEM_TYPE_ENERGY = \"Number:Energy\";\n-    public static final String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n-    public static final String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n-    public static final String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n-    public static final String ITEM_TYPE_SWITCH = \"Switch\";\n-    public static final String ITEM_TYPE_CONTACT = \"Contact\";\n-\n-    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n-    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n-    public static String SUFFIX_LABEL = \".label\";\n-    public static String SUFFIX_DESCR = \".description\";\n-\n-    public ShellyChannelDefinitionsDTO(ShellyTranslationProvider m) {\n-        // Device: Internal Temp\n-        channelDefinitions\n-                // Device\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP, \"deviceTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP, \"sensorWakeup\",\n-                        ITEM_TYPE_STRING))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS, \"meterAccuWatts\",\n-                        ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL, \"meterAccuTotal\",\n-                        ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCURETURNED, \"meterAccuReturned\",\n-                        ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER, \"charger\", ITEM_TYPE_SWITCH))\n-\n-                // RGBW2\n-                .add(new ShellyChannel(m, CHANNEL_GROUP_LIGHT_CONTROL, CHANNEL_INPUT, \"inputState\", ITEM_TYPE_SWITCH))\n-\n-                // Power Meter\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_CURRENTWATTS, \"meterWatts\", ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_TOTALKWH, \"meterTotal\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN1, \"lastPower1\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN2, \"lastPower2\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN3, \"lastPower3\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n-\n-                // EMeter\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_TOTALRET, \"meterReturned\", ITEM_TYPE_ENERGY))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_REACTWATTS, \"meterReactive\", ITEM_TYPE_POWER))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_VOLTAGE, \"meterVoltage\", ITEM_TYPE_VOLT))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_CURRENT, \"meterCurrent\", ITEM_TYPE_AMP))\n-                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_PFACTOR, \"meterPowerFactor\", ITEM_TYPE_NUMBER))\n-\n-                // Sensors\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_TEMP, \"sensorTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_HUM, \"sensorHumidity\", ITEM_TYPE_PERCENT))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_LUX, \"sensorLux\", ITEM_TYPE_LUX))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ILLUM, \"sensorIllumination\", ITEM_TYPE_STRING))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_VIBRATION, \"sensorVibration\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_TILT, \"sensorTilt\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_FLOOD, \"sensorFlood\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_SMOKE, \"sensorSmoke\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_STATE, \"sensorState\", ITEM_TYPE_CONTACT))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_MOTION, \"sensorMotion\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ERROR, \"sensorError\", ITEM_TYPE_STRING))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n-\n-                // Addon with external sensors\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n-                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY, \"sensorExtHum\", ITEM_TYPE_PERCENT))\n-\n-                // Battery\n-                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LEVEL, \"system:battery-level\",\n-                        ITEM_TYPE_PERCENT))\n-                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LOW, \"system:low-battery\", ITEM_TYPE_SWITCH))\n-                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_VOLT, \"batVoltage\", ITEM_TYPE_VOLT));\n-    }\n-\n-    public static ShellyChannel getDefinition(String channelName) throws IllegalArgumentException {\n-        String group = StringUtils.substringBefore(channelName, \"#\");\n-        String channel = StringUtils.substringAfter(channelName, \"#\");\n-        if (group.contains(CHANNEL_GROUP_METER)) {\n-            group = CHANNEL_GROUP_METER; // map meter1..n to meter\n-        } else if (group.contains(CHANNEL_GROUP_RELAY_CONTROL)) {\n-            group = CHANNEL_GROUP_RELAY_CONTROL; // map meter1..n to meter\n-        } else if (group.contains(CHANNEL_GROUP_LIGHT_CHANNEL)) {\n-            group = CHANNEL_GROUP_LIGHT_CHANNEL;\n-        }\n-        String channelId = group + \"#\" + channel;\n-        return channelDefinitions.get(channelId);\n-    }\n-\n-    /**\n-     * Auto-create relay channels depending on relay type/mode\n-     *\n-     * @return ArrayList<Channel> of channels to be added to the thing\n-     */\n-    public static Map<String, Channel> createDeviceChannels(final Thing thing, final ShellyDeviceProfile profile,\n-            final ShellySettingsStatus status) {\n-        Map<String, Channel> add = new LinkedHashMap<>();\n-        if (!profile.isSensor) {\n-            // Only some devices report the internal device temp\n-            addChannel(thing, add, (status.tmp != null) || (status.temperature != null), CHANNEL_GROUP_DEV_STATUS,\n-                    CHANNEL_DEVST_ITEMP);\n-        }\n-\n-        // RGBW2\n-        addChannel(thing, add, status.input != null, CHANNEL_GROUP_LIGHT_CONTROL, CHANNEL_INPUT);\n-\n-        // If device has more than 1 meter the channel accumulatedWatts receives the accumulated value\n-        boolean accuChannel = (((status.meters != null) && (status.meters.size() > 1) && !profile.isRoller\n-                && !profile.isRGBW2) || ((status.emeters != null && status.emeters.size() > 1)));\n-        addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS);\n-        addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL);\n-        addChannel(thing, add, accuChannel && (status.emeters != null), CHANNEL_GROUP_DEV_STATUS,\n-                CHANNEL_DEVST_ACCURETURNED);\n-\n-        return add;\n-    }\n-\n-    /**\n-     * Auto-create relay channels depending on relay type/mode\n-     *\n-     * @return ArrayList<Channel> of channels to be added to the thing\n-     */\n-    public static Map<String, Channel> createRelayChannels(final Thing thing, final ShellyStatusRelay relays) {\n-        Map<String, Channel> add = new LinkedHashMap<>();\n-\n-        // Shelly 1/1PM Addon\n-        if (relays.extTemperature != null) {\n-            addChannel(thing, add, relays.extTemperature.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1);\n-            addChannel(thing, add, relays.extTemperature.sensor2 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2);\n-            addChannel(thing, add, relays.extTemperature.sensor3 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3);\n-        }\n-        if (relays.extHumidity != null) {\n-            addChannel(thing, add, relays.extHumidity.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY);\n-        }\n-        return add;\n-    }\n-\n-    public static Map<String, Channel> createRollerChannels(Thing thing, final ShellyControlRoller roller) {\n-        Map<String, Channel> add = new LinkedHashMap<>();\n-\n-        // No dynamic channels so far, maybe added in the future\n-\n-        return add;\n-    }\n-\n-    public static Map<String, Channel> createMeterChannels(Thing thing, final ShellySettingsMeter meter, String group) {\n-        Map<String, Channel> newChannels = new LinkedHashMap<>();\n-        addChannel(thing, newChannels, meter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n-        addChannel(thing, newChannels, meter.total != null, group, CHANNEL_METER_TOTALKWH);\n-        if (meter.counters != null) {\n-            addChannel(thing, newChannels, meter.counters[0] != null, group, CHANNEL_METER_LASTMIN1);\n-            addChannel(thing, newChannels, meter.counters[1] != null, group, CHANNEL_METER_LASTMIN2);\n-            addChannel(thing, newChannels, meter.counters[2] != null, group, CHANNEL_METER_LASTMIN3);\n-        }\n-        addChannel(thing, newChannels, meter.timestamp != null, group, CHANNEL_LAST_UPDATE);\n-        return newChannels;\n-    }\n-\n-    public static Map<String, Channel> createEMeterChannels(final Thing thing, final ShellySettingsEMeter emeter,\n-            String group) {\n-        Map<String, Channel> newChannels = new LinkedHashMap<>();\n-        addChannel(thing, newChannels, emeter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n-        addChannel(thing, newChannels, emeter.total != null, group, CHANNEL_METER_TOTALKWH);\n-        addChannel(thing, newChannels, emeter.totalReturned != null, group, CHANNEL_EMETER_TOTALRET);\n-        addChannel(thing, newChannels, emeter.reactive != null, group, CHANNEL_EMETER_REACTWATTS);\n-        addChannel(thing, newChannels, emeter.voltage != null, group, CHANNEL_EMETER_VOLTAGE);\n-        addChannel(thing, newChannels, emeter.current != null, group, CHANNEL_EMETER_CURRENT);\n-        addChannel(thing, newChannels, emeter.pf != null, group, CHANNEL_EMETER_PFACTOR);\n-        addChannel(thing, newChannels, true, group, CHANNEL_LAST_UPDATE);\n-        return newChannels;\n-    }\n-\n-    public static Map<String, Channel> createSensorChannels(final Thing thing, final ShellyStatusSensor sdata) {\n-        Map<String, Channel> newChannels = new LinkedHashMap<>();\n-        // Sensor data\n-        addChannel(thing, newChannels, sdata.tmp != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP);\n-        addChannel(thing, newChannels, sdata.hum != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_HUM);\n-        addChannel(thing, newChannels, sdata.lux != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_LUX);\n-        if (sdata.accel != null) {\n-            addChannel(thing, newChannels, sdata.accel.vibration != null, CHANNEL_GROUP_SENSOR,\n-                    CHANNEL_SENSOR_VIBRATION);\n-            addChannel(thing, newChannels, sdata.accel.tilt != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TILT);\n-        }\n-        addChannel(thing, newChannels, sdata.flood != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n-        addChannel(thing, newChannels, sdata.smoke != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n-        addChannel(thing, newChannels, sdata.lux != null && sdata.lux.illumination != null, CHANNEL_GROUP_SENSOR,\n-                CHANNEL_SENSOR_ILLUM);\n-        addChannel(thing, newChannels, sdata.contact != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n-                CHANNEL_SENSOR_STATE);\n-        addChannel(thing, newChannels, sdata.motion != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n-                CHANNEL_SENSOR_MOTION);\n-        addChannel(thing, newChannels, sdata.charger != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER);\n-        addChannel(thing, newChannels, sdata.sensorError != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_ERROR);\n-        addChannel(thing, newChannels, sdata.actReasons != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP);\n-        addChannel(thing, newChannels, true, CHANNEL_GROUP_SENSOR, CHANNEL_LAST_UPDATE);\n-\n-        // Battery\n-        if (sdata.bat != null) {\n-            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL);\n-            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LOW);\n-            addChannel(thing, newChannels, sdata.bat.voltage != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_VOLT);\n-        }\n-        return newChannels;\n-    }\n-\n-    private static void addChannel(Thing thing, Map<String, Channel> newChannels, boolean supported, String group,\n-            String channelName) throws IllegalArgumentException {\n-        if (supported) {\n-            final String channelId = group + \"#\" + channelName;\n-            final ShellyChannel channelDef = getDefinition(channelId);\n-            final ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n-            final ChannelTypeUID channelTypeUID = channelDef.typeId.contains(\"system:\")\n-                    ? new ChannelTypeUID(channelDef.typeId)\n-                    : new ChannelTypeUID(BINDING_ID, channelDef.typeId);\n-\n-            // Channel channel = ChannelBuilder.create(channelUID, channelId).withType(channelTypeUID)\n-            // .withLabel(channelDef.label).withDescription(channelDef.description).build();\n-            Channel channel = ChannelBuilder.create(channelUID, channelDef.itemType).withType(channelTypeUID).build();\n-            newChannels.put(channelId, channel);\n-        }\n-    }\n-\n-    public class ShellyChannel {\n-        private final ShellyTranslationProvider messages;\n-        public String group = \"\";\n-        public String groupLabel = \"\";\n-        public String groupDescription = \"\";\n-\n-        public String channel = \"\";\n-        public String label = \"\";\n-        public String description = \"\";\n-        public String itemType = \"\";\n-        public String typeId = \"\";\n-        public String category = \"\";\n-        public Set<String> tags = new HashSet<>();\n-\n-        public ShellyChannel(ShellyTranslationProvider messages, String group, String channel, String typeId,\n-                String itemType, String... category) {\n-            this.messages = messages;\n-            this.group = group;\n-            this.channel = channel;\n-            this.itemType = itemType;\n-            this.typeId = typeId;\n-\n-            groupLabel = getText(PREFIX_GROUP + group + SUFFIX_LABEL);\n-            groupDescription = getText(PREFIX_GROUP + group + SUFFIX_DESCR);\n-            label = getText(PREFIX_CHANNEL + channel + SUFFIX_LABEL);\n-            description = getText(PREFIX_CHANNEL + channel + SUFFIX_DESCR);\n-        }\n-\n-        public String getChanneId() {\n-            return group + \"#\" + channel;\n-        }\n-\n-        private String getText(String key) {\n-            String text = messages.get(key);\n-            return text != null ? text : \"\";\n-        }\n-    }\n-\n-    public static class ChannelMap {\n-        private final Map<String, ShellyChannel> map = new LinkedHashMap<>();\n-\n-        private ChannelMap add(ShellyChannel def) {\n-            map.put(def.getChanneId(), def);\n-            return this;\n-        }\n-\n-        public ShellyChannel get(String channelName) throws IllegalArgumentException {\n-            ShellyChannel def = null;\n-            if (channelName.contains(\"#\")) {\n-                def = map.get(channelName);\n-            }\n-            for (HashMap.Entry<String, ShellyChannel> entry : map.entrySet()) {\n-                if (entry.getValue().channel.contains(\"#\" + channelName)) {\n-                    def = entry.getValue();\n-                    break;\n-                }\n-            }\n-\n-            if (def == null) {\n-                throw new IllegalArgumentException(\"Channel definition for \" + channelName + \" not found!\");\n-            }\n-\n-            return def;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265906", "bodyText": "If you want the stack trace, the proper way to do it is like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}:\", thingName, i, devId,\n          \n          \n            \n                                    e);", "author": "cpmeister", "createdAt": "2020-04-12T23:29:49Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -557,12 +554,12 @@ private void handleStatusUpdate(String devId, String payload, int serial) {\n             } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n                 // even the processing of one value failed we continue with the next one (sometimes this is caused by\n                 // buggy formats provided by the device\n-                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n+                logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n+                        e.toString());", "originalCommit": "a3e8c7be0049a752c350a7658df11de459feda54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM3OTA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407379086", "bodyText": "that's what I tried, but doesn't work, the code checker reports in incorrect number of arguments even if the statement has the correct number of args\nexample:\nERROR] Code Analysis Tool has found:\n4 error(s)!\n9 warning(s)\n10 info(s)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[158]\nCount of placeholder(2) is not equal to count of parameter(1)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[325]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[392]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHand", "author": "markus7017", "createdAt": "2020-04-13T08:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMDU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407720554", "bodyText": "This change is correct.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}:\", thingName, i, devId,\n          \n          \n            \n                                    e);", "author": "cpmeister", "createdAt": "2020-04-13T21:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408180987", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 4236c461e7..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -535,27 +474,26 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n                                 updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_GAIN,\n                                         ShellyColorUtils.toPercent((int) s.value, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n                                 break;\n-                            case \"temp\": // Shelly Bulb\n-                            case \"colortemperature\": // Shelly Duo\n-                                updateChannel(updates,\n-                                        profile.inColor ? CHANNEL_GROUP_COLOR_CONTROL : CHANNEL_GROUP_WHITE_CONTROL,\n-                                        CHANNEL_COLOR_TEMP,\n-                                        ShellyColorUtils.toPercent((int) s.value, profile.minTemp, profile.maxTemp));\n+                            case \"temp\":\n+                                updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_TEMP, ShellyColorUtils\n+                                        .toPercent((int) s.value, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE));\n+\n                                 break;\n+\n                             default:\n                                 logger.debug(\"{}: Update for unknown sensor type {}/{} received\", thingName, sen.type,\n                                         sen.desc);\n                         }\n                         break;\n+\n                     default:\n                         logger.debug(\"{}: Sensor data for type {} not processed, value={}\", thingName, sen.type,\n                                 s.value);\n+                        break;\n                 }\n-            } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n-                // even the processing of one value failed we continue with the next one (sometimes this is caused by\n-                // buggy formats provided by the device\n-                logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n-                        e.toString());\n+            } else {\n+                logger.debug(\"{}: Update for unknown sensor[{}]: Dev={}, Index={}, Value={}\", thingName, i, devId,\n+                        s.index, s.value);\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266002", "bodyText": "same here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: {}\", name, e.toString());\n          \n          \n            \n                                logger.debug(\"{}:\", name, e);", "author": "cpmeister", "createdAt": "2020-04-12T23:31:12Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -174,7 +173,7 @@ public DiscoveryResult createResult(final ServiceInfo service) {\n                     thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n                     logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.debug(\"{}: {}\", name, e.toString());", "originalCommit": "a3e8c7be0049a752c350a7658df11de459feda54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MzExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407383111", "bodyText": "that's what I tried, but doesn't work, the code checker reports in incorrect number of arguments even if the statement has the correct number of args\nexample:\nERROR] Code Analysis Tool has found:\n4 error(s)!\n9 warning(s)\n10 info(s)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[158]\nCount of placeholder(2) is not equal to count of parameter(1)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[325]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[392]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHand", "author": "markus7017", "createdAt": "2020-04-13T08:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzNzQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407637417", "bodyText": "You should notice that when adding an exception as the last argument you don't include a {} for it in the log format string.\nNotice that the code analysis didn't complain about line 171 \ud83d\ude04", "author": "cpmeister", "createdAt": "2020-04-13T18:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NDc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408264774", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-14T16:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 70313a14c7..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -98,85 +70,89 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            logger.trace(\"{}: Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}\",\n-                    name, service.getDomain(), service.getServer(), service.getQualifiedName(),\n-                    service.getHostAddress(), service.getPort());\n-            address = service.getHostAddress();\n+            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n-                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n-                        service.toString());\n+                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n-            String thingType = service.getQualifiedName().contains(SERVICE_TYPE) && name.contains(\"-\")\n-                    ? StringUtils.substringBefore(name, \"-\")\n-                    : name;\n-            logger.debug(\"{}: Shelly device discovered: IP-Adress={}, type={}\", name, address, thingType);\n+            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            // Get device settings\n-            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n-            if (serviceConfig.getProperties() != null) {\n-                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            if (handlerFactory != null) {\n+                bindingConfig = handlerFactory.getBindingConfig();\n             }\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            // Get device settings\n+            Validate.notNull(bindingConfig);\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n+            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n-                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n-\n                 profile = api.getDeviceProfile(thingType);\n-                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n-                model = getString(profile.settings.device.type);\n+                Validate.notNull(profile);\n+                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n+                Validate.notNull(profile, \"Unable to get device profile: \");\n+                model = profile.settings.device.type;\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n-            } catch (ShellyApiException e) {\n-                ShellyApiResult result = e.getApiResult();\n-                if (result.isHttpAccessUnauthorized()) {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n+                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n+            } catch (IOException e) {\n+                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n+                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: {}\", name, e.toString());\n+                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n+                            e.getMessage(), e.getClass(), e.getStackTrace());\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());\n             }\n \n             if (thingUID != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266015", "bodyText": "and here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n          \n          \n            \n                                e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception on processing serviceInfo '{}': \", name, service.getNiceTextString(),\n          \n          \n            \n                                e);", "author": "cpmeister", "createdAt": "2020-04-12T23:31:31Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -193,8 +192,9 @@ public DiscoveryResult createResult(final ServiceInfo service) {\n             }\n         } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n                                                                                     // buggy\n-            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n-            logger.debug(\"{}: Exception {}\", name, e.toString());\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, e.getMessage()));\n+            logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n+                    e.toString());", "originalCommit": "a3e8c7be0049a752c350a7658df11de459feda54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MTE1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408181159", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 70313a14c7..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -186,15 +162,13 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n+                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n-                                                                                    // buggy\n-            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, e.getMessage()));\n-            logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n-                    e.toString());\n+        } catch (NullPointerException e) {\n+            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n+                    e.getMessage(), e);\n         }\n         return null;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407717466", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-13T20:58:58Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +347,218 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n+        String type = \"\";\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        boolean timeout = false;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                if (timeout) {\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                    timeoutsRecovered++;\n                 }\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if ((!e.isTimeout() && !apiResult.isHttpServerError()) || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or API exception for non-battery device or retry counter expired\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeout = true;\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NjkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408076914", "bodyText": "In general I don't ignore your recommendations/requirements :-)\nFSInternetRadioDiscoveryParticipant was wrong in this repo here, so I removed the file, but the comment stays somehow. Not sure how to handle that.\n.classpath\nMy code doesn't show\n<classpathentry kind=\"src\" output=\"target/test-classes\" path=\"src/test/java\">\t\t\n \t\t<attributes>\t\t\n \t\t\t<attribute name=\"test\" value=\"true\"/>\t\t\n \t\t\t<attribute name=\"optional\" value=\"true\"/>\t\t\n \t\t\t<attribute name=\"maven.pomderived\" value=\"true\"/>\t\t\n \t\t</attributes>\t\t\n \t</classpathentry>\n\nMy code shows\npublic ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n\n(initialize () is not static). Are you checking the latest version?\nI need to have several stages of the initialization\n\nthe empty constructor when ShellyBaseHandler is constructed\ninitializeFromThing(): a basic initialization, which just sets some properties based on the thing type. A full initialization needs information from the device, but a sensor is usually in sleep mode when the binding starts. A wakeup causes a CoAP message and those basic parameters are enough to handle channel updates from that message and set the thing online.\ninitialize() is called when the device has been successfully access by REST API the first time. This allows to verify the firmware, initialize number of relays, meters etc. and refresh the channels. This is the standard procedure for non-battery devices and inclusion of a sensor (when REST API is available)\nI don't want to change things here, it was hard to figure out the different scenarios and how to handle them.\n\nempty line was removed", "author": "markus7017", "createdAt": "2020-04-14T11:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 8ede783959..f93835c019 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -347,218 +379,154 @@ public class ShellyHttpApi {\n         }\n     }\n \n-    private void setDimmerEvents() throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private void setDimmerEvents() throws IOException {\n+        Validate.notNull(profile);\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n-        } else if (profile.isLight) {\n-            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set sensor Action URLs\n+     * Set event URL for HT (report_url)\n      *\n-     * @throws ShellyApiException\n+     * @param deviceName\n+     * @throws IOException\n      */\n-    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n-        if (profile.isSensor) {\n-            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n-            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+    @SuppressWarnings(\"null\")\n+    private void setSensorEventUrls() throws IOException {\n+        Validate.notNull(profile);\n+        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n+            logger.debug(\"Check/set Sensor Reporting URL\");\n+            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n+            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n         }\n     }\n \n-    /**\n-     * Set/delete Relay/Roller/Dimmer Action URLs\n-     *\n-     * @param index Device Index (0-based)\n-     * @throws ShellyApiException\n-     */\n-    private void setEventUrls(Integer index) throws ShellyApiException {\n-        String type = \"\";\n+    @SuppressWarnings(\"null\")\n+    private void setEventUrls(Integer index) throws IOException {\n+        Validate.notNull(profile);\n+        String lip = config.localIp;\n+        String localPort = config.httpPort.toString();\n+        String deviceName = profile.thingName;\n         if (profile.isRoller) {\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n-            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n-        } else if (profile.isDimmer) {\n-            // 2 set of URLs\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n-\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n-\n-            // Relay output\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        } else if (profile.hasRelays) {\n-            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        } else if (profile.isLight) {\n-            // Duo, Bulb\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n-            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n-        }\n-    }\n-\n-    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            // Sensors add the type=xx to report_url themself, so we need to ommit here\n-            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + eventType + urlParm;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsRollerUrls) {\n+                logger.debug(\"Set Roller event urls\");\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n+                        SHELLY_API_EVENTURL_ROLLER_STOP));\n             }\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n+        } else {\n+            if (profile.supportsButtonUrls && config.eventsButton) {\n+                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n+                    // 2 set of URLs, e.g. Dimmer\n+                    logger.debug(\"Set Dimmer event urls\");\n+\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN1_OFF));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n+                            SHELLY_API_EVENTURL_BTN2_OFF));\n+                } else {\n+                    // Standard relays: btn_xxx URLs\n+                    logger.debug(\"Set Relay event urls\");\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_ON));\n+                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n+                            SHELLY_API_EVENTURL_BTN_OFF));\n+                }\n             }\n-        }\n-    }\n-\n-    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n-            throws ShellyApiException {\n-        if (profile.containsEventUrl(eventType)) {\n-            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n-            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n-            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n-            if (!enabled && !profile.settingsJson.contains(test)) {\n-                // Don't set URL to null when the current one doesn't point to this OH\n-                // Don't interfer a 3rd party App\n-                return;\n+            if (profile.supportsOutUrls && config.eventsSwitch) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n             }\n-            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n-            if (!profile.settingsJson.contains(test)) {\n-                // Current Action URL is != new URL\n-                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n-                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n-                        + urlEncode(newUrl));\n+            if (profile.supportsPushUrls && config.eventsPush) {\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n+                request(buildSetEventUrl(lip, localPort, deviceName, index,\n+                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n             }\n         }\n     }\n \n-    private static String mkEventUrl(String eventType) {\n-        return eventType + SHELLY_EVENTURL_SUFFIX;\n-    }\n-\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n-        String json = \"Invalid API result\";\n+    private String request(String uri) throws IOException {\n+        String result = \"\";\n+        boolean retry = false;\n         try {\n-            json = request(uri);\n-            return gson.fromJson(json, classOfT);\n-        } catch (JsonSyntaxException e) {\n-            throw new ShellyApiException(e,\n-                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n+            result = innerRequest(uri);\n+        } catch (IOException e) {\n+            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                    || e.getMessage().contains(\"Connection reset\")) {\n+                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n+                timeoutErrors++;\n+                retry = true;\n+            } else {\n+                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n+            }\n         }\n-    }\n-\n-    private String request(String uri) throws ShellyApiException {\n-        ShellyApiResult apiResult = new ShellyApiResult();\n-        int retries = 3;\n-        boolean timeout = false;\n-        while (retries > 0) {\n+        if (retry && !profile.hasBattery) {\n             try {\n-                apiResult = innerRequest(HttpMethod.GET, uri);\n-                if (timeout) {\n-                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n-                            apiResult.getUrl());\n-                    timeoutsRecovered++;\n+                // retry to recover\n+                result = innerRequest(uri);\n+                timeoutsRecovered++;\n+                logger.debug(\"Shelly API timeout recovered\");\n+            } catch (IOException e) {\n+                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n+                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n+                        || e.getMessage().contains(\"Connection reset\")) {\n+                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                } else {\n+                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n                 }\n-                return apiResult.response; // successful\n-            } catch (ShellyApiException e) {\n-                retries--;\n-                if ((!e.isTimeout() && !apiResult.isHttpServerError()) || profile.hasBattery || (retries == 0)) {\n-                    // Sensor in sleep mode or API exception for non-battery device or retry counter expired\n-                    throw e; // non-timeout exception\n-                }\n-\n-                timeout = true;\n-                timeoutErrors++; // count the retries\n-                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n-\n             }\n         }\n-        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n+        return result;\n     }\n \n-    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n-        Request request = null;\n+    private String innerRequest(String uri) throws IOException {\n+        String httpResponse = \"ERROR\";\n         String url = \"http://\" + config.deviceIp + uri;\n-        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n+        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n \n-        try {\n-            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n-                    TimeUnit.MILLISECONDS);\n-\n-            if (!config.userId.isEmpty()) {\n-                String value = config.userId + \":\" + config.password;\n-                request.header(HTTP_HEADER_AUTH,\n-                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-            }\n-            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n-            logger.trace(\"{}: HTTP {} for {}\", thingName, method, url);\n-\n-            // Do request and get response\n-            ContentResponse contentResponse = request.send();\n-            apiResult = new ShellyApiResult(contentResponse);\n-            String response = contentResponse.getContentAsString().replace(\"\\t\", \"\").replace(\"\\r\\n\", \"\").trim();\n-\n-            // validate response, API errors are reported as Json\n-            logger.trace(\"{}: HTTP Response: {}\", thingName, response);\n-            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n-                throw new ShellyApiException(apiResult);\n-            }\n-            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n-                throw new ShellyApiException(\"Unexpected response: \" + response);\n-            }\n-        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n-            throw new ShellyApiException(apiResult, e);\n+        Properties headers = new Properties();\n+        if (!config.userId.isEmpty()) {\n+            String value = config.userId + \":\" + config.password;\n+            headers.put(HTTP_HEADER_AUTH,\n+                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n         }\n-        return apiResult;\n-    }\n \n-    public String getControlUriPrefix(Integer id) {\n-        String uri = \"\";\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isDuo || profile.isDimmer) {\n-                // Duo + Dimmer\n-                uri = SHELLY_URL_CONTROL_LIGHT;\n-            } else {\n-                // Bulb + RGBW2\n-                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-            }\n-        } else {\n-            // Roller, Relay\n-            uri = SHELLY_URL_CONTROL_RELEAY;\n+        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n+        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n+        // all api responses are returning the result in Json format. If we are getting\n+        // something else it must\n+        // be an error message, e.g. http result code\n+        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+            throw new IOException(\n+                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n         }\n-        uri = uri + \"/\" + id;\n-        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n-        return uri;\n+        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n+            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        }\n+\n+        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n+        return httpResponse;\n     }\n \n     public int getTimeoutErrors() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxODg3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407718872", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: CoAP Exception\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:01:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -97,31 +103,38 @@ public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thin\n     /*\n      * Initialize Coap access, send discovery packet and start Status server\n      */\n-    @SuppressWarnings(\"null\")\n-    public void start() {\n+    public void start(String thingName, ShellyThingConfiguration config) throws ShellyApiException {\n+        if (isStarted()) {\n+            logger.trace(\"{}: CoAP Listener was already started\", thingName);\n+            return;\n+        }\n         try {\n+            this.thingName = thingName;\n+            this.config = config;\n+\n             reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n-            if (statusClient == null) {\n-                coapServer.init(config.localIp);\n-                coapServer.addListener(this);\n+            if (!isStarted()) {\n+                logger.debug(\"{}: Starting CoAP Listener\", thingName);\n+                reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n+                coapServer.start(config.localIp, this);\n                 statusClient = new CoapClient(completeUrl(config.deviceIp, COLOIT_URI_DEVSTATUS))\n                         .setTimeout((long) SHELLY_API_TIMEOUT_MS).useNONs().setEndpoint(coapServer.getEndpoint());\n-\n-                coapServer.start();\n             }\n-        } catch (IOException e) {\n-            logger.warn(\"{}: Unable to start CoIoT: {}\", thingName, e.getMessage());\n-        } catch (NullPointerException e) {\n-            logger.debug(\"{}: Coap Exception: {} ({})\\n{}\", thingName, e.getMessage(), e.getClass(), e.getStackTrace());\n+        } catch (UnknownHostException e) {\n+            ShellyApiException ea = new ShellyApiException(e);\n+            logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzODgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408038815", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T10:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxODg3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 906e830061..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -103,38 +97,31 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n     /*\n      * Initialize Coap access, send discovery packet and start Status server\n      */\n-    public void start(String thingName, ShellyThingConfiguration config) throws ShellyApiException {\n-        if (isStarted()) {\n-            logger.trace(\"{}: CoAP Listener was already started\", thingName);\n-            return;\n-        }\n+    @SuppressWarnings(\"null\")\n+    public void start() {\n         try {\n-            this.thingName = thingName;\n-            this.config = config;\n-\n             reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n-            if (!isStarted()) {\n-                logger.debug(\"{}: Starting CoAP Listener\", thingName);\n-                reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n+            if (statusClient == null) {\n+                coapServer.init(config.localIp);\n+                coapServer.addListener(this);\n \n-                coapServer.start(config.localIp, this);\n                 statusClient = new CoapClient(completeUrl(config.deviceIp, COLOIT_URI_DEVSTATUS))\n                         .setTimeout((long) SHELLY_API_TIMEOUT_MS).useNONs().setEndpoint(coapServer.getEndpoint());\n+\n+                coapServer.start();\n             }\n-        } catch (UnknownHostException e) {\n-            ShellyApiException ea = new ShellyApiException(e);\n-            logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());\n-            throw ea;\n+        } catch (IOException e) {\n+            logger.warn(\"{}: Unable to start CoIoT: {}\", thingName, e.getMessage());\n+        } catch (NullPointerException e) {\n+            logger.debug(\"{}: Coap Exception: {} ({})\\n{}\", thingName, e.getMessage(), e.getClass(), e.getStackTrace());\n         }\n     }\n \n-    public boolean isStarted() {\n-        return statusClient != null;\n-    }\n-\n     /**\n-     * Process an inbound Response (or mapped Request): decode Coap options. handle discovery result or status updates\n+     * Process an inbound Response (or mapped Request)\n+     * - decode Coap options\n+     * - handle discery result or status updates\n      *\n      * @param response The Response packet\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407719409", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to process CoIoT Message for payload={}\", thingName, payload, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:02:38Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -211,40 +218,33 @@ public void processResponse(@Nullable Response response) {\n                         response.getPayloadString());\n             }\n \n-            if (reqStatus == null) {\n-                /*\n-                 * Observe Status Updates\n-                 */\n+            if (!discovering) {\n+                // Observe Status Updates\n                 reqStatus = sendRequest(reqStatus, config.deviceIp, COLOIT_URI_DEVSTATUS, Type.NON);\n+                discovering = true;\n             }\n-        } catch (NullPointerException | IOException e) {\n-            logger.debug(\"{}: Unable to process CoIoT Message: {} ({}); payload={}\\n{}\", thingName, e.getMessage(),\n-                    e.getClass(), payload, e.getStackTrace());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzODg4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408038887", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T10:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 906e830061..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -218,21 +211,25 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n                         response.getPayloadString());\n             }\n \n-            if (!discovering) {\n-                // Observe Status Updates\n+            if (reqStatus == null) {\n+                /*\n+                 * Observe Status Updates\n+                 */\n                 reqStatus = sendRequest(reqStatus, config.deviceIp, COLOIT_URI_DEVSTATUS, Type.NON);\n-                discovering = true;\n             }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());\n+        } catch (NullPointerException | IOException e) {\n+            logger.debug(\"{}: Unable to process CoIoT Message: {} ({}); payload={}\\n{}\", thingName, e.getMessage(),\n+                    e.getClass(), payload, e.getStackTrace());\n             resetSerial();\n         }\n     }\n \n     /**\n      * Process a CoIoT device description message. This includes definitions on device units (Relay0, Relay1, Sensors\n-     * etc.) as well as a definition of sensors and actors. This information needs to be stored allowing to map ids from\n-     * status updates to the device units and matching the correct thing channel.\n+     * etc.) as well as a definition of\n+     * sensors and actors. This information needs to be stored allowing to map ids from status updates to the device\n+     * units and matching the correct\n+     * thing channel.\n      *\n      * @param payload Device desciption in JSon format, example:\n      *            {\"blk\":[{\"I\":0,\"D\":\"Relay0\"}],\"sen\":[{\"I\":112,\"T\":\"Switch\",\"R\":\"0/1\",\"L\":0}],\"act\":[{\"I\":211,\"D\":\"Switch\",\"L\":0,\"P\":[{\"I\":2011,\"D\":\"ToState\",\"R\":\"0/1\"}]}]}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407719674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to decode sensor definition -> skip\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:03:09Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -288,35 +288,30 @@ private void addSensor(CoIotDescrSen sen) {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) {\n-            logger.debug(\"{}:    Unable to decode sensor definition -> skip ({})\\n{}\", thingName, e.getMessage(),\n-                    e.getStackTrace());\n+        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy\n+            logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1NjQ3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408056471", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 906e830061..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -288,22 +288,27 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy\n-            logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());\n+        } catch (NullPointerException e) {\n+            logger.debug(\"{}:    Unable to decode sensor definition -> skip ({})\\n{}\", thingName, e.getMessage(),\n+                    e.getStackTrace());\n         }\n     }\n \n     /**\n-     * Process CoIoT status update message. If a status update is received, but the device description has not been\n-     * received yet a GET is send to query device description.\n+     * Process CoIoT status update message. If a status update is received, but the\n+     * device description has not been received yet a GET is send to query device\n+     * description.\n      *\n      * @param devId device id included in the status packet\n      * @param payload Coap payload (Json format), example: {\"G\":[[0,112,0]]}\n      * @param serial Serial for this request. If this the the same as last serial\n      *            the update was already sent and processed so this one gets\n      *            ignored.\n+     * @throws IOException Exception on sending GET for device description.\n      */\n-    private void handleStatusUpdate(String devId, String payload, int serial) {\n+    @SuppressWarnings({ \"null\", \"unused\" })\n+    private void handleStatusUpdate(String devId, String payload, int serial) throws IOException {\n+        // payload = StringUtils.substringBefore(payload, \"]]}\") + \"]]}\";\n         logger.debug(\"{}: CoIoT Sensor data {}\", thingName, payload);\n         if (blockMap.isEmpty()) {\n             // send discovery packet\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407723594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param sen Semsor description\n          \n          \n            \n                 * @param sen Sensor description", "author": "cpmeister", "createdAt": "2020-04-13T21:10:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -523,28 +581,77 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n         lastPayload = payload;\n     }\n \n-    private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n-        State v = (State) thingHandler.getChannelValue(group, channel);\n-        if ((v != null) && v.equals(value)) {\n-            return false;\n+    private void updatePower(ShellyDeviceProfile profile, Map<String, State> updates, Integer id, CoIotDescrSen sen,\n+            CoIotSensor s, List<CoIotSensor> allUpdates) {\n+        String group = \"\";\n+        String channel = CHANNEL_BRIGHTNESS;\n+        String checkL = \"\"; // RGBW-white uses 4 different Power, Brightness, VSwitch values\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isBulb || profile.inColor) {\n+                group = CHANNEL_GROUP_LIGHT_CONTROL;\n+                channel = CHANNEL_LIGHT_POWER;\n+            } else if (profile.isDuo) {\n+                group = CHANNEL_GROUP_WHITE_CONTROL;\n+            } else if (profile.isDimmer) {\n+                group = CHANNEL_GROUP_RELAY_CONTROL;\n+            } else if (profile.isRGBW2) {\n+                group = CHANNEL_GROUP_LIGHT_CHANNEL + id;\n+                checkL = String.valueOf(id.intValue() - 1); // id is 1-based, L is 0-based\n+                logger.trace(\"{}: updatePower() for L={}\", thingName, checkL);\n+            }\n+\n+            // We need to update brigthtess and on/off state at the same time to avoid \"flipping brightness slider\" in\n+            // the UI\n+            Double brightness = -1.0;\n+            Double power = -1.0;\n+            for (CoIotSensor update : allUpdates) {\n+                CoIotDescrSen d = fixDescription(sensorMap.get(update.id));\n+                if (!checkL.isEmpty() && !d.links.equals(checkL)) {\n+                    // continue until we find the correct one\n+                    continue;\n+                }\n+                if (d.desc.equalsIgnoreCase(\"brightness\")) {\n+                    brightness = new Double(update.value);\n+                } else if (d.desc.equalsIgnoreCase(\"output\") || d.desc.equalsIgnoreCase(\"state\")) {\n+                    power = new Double(update.value);\n+                }\n+            }\n+            if (power != -1) {\n+                updateChannel(updates, group, channel + \"$Switch\", power == 1 ? OnOffType.ON : OnOffType.OFF);\n+            }\n+            if (brightness != -1) {\n+                updateChannel(updates, group, channel + \"$Value\",\n+                        toQuantityType(power == 1 ? brightness : 0, DIGITS_NONE, SmartHomeUnits.PERCENT));\n+            }\n+        } else if (profile.hasRelays) {\n+            group = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL : CHANNEL_GROUP_RELAY_CONTROL + id;\n+            updateChannel(updates, group, CHANNEL_OUTPUT, s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n+        } else if (profile.isSensor) {\n+            // Sensor state\n+            if (profile.isDW) { // Door Window has item type Contact\n+                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n+                        s.value != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+            } else {\n+                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n+                        s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n+            }\n         }\n-        logger.trace(\"{}: Updating channel {}.{} from CoIoT, new value={}\", thingName, group, channel, value);\n+    }\n+\n+    private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n         updates.put(mkChannelId(group, channel), value);\n         return true;\n \n     }\n \n     /**\n-     * Work around to fix inconsistent sensor types and description\n-     * Shelly not uses always the same coding for sen.T and sen.D - this helps to unify the format and simplifies\n-     * processing\n+     * Work around to fix inconsistent sensor types and description. Shelly not uses always the same coding for sen.T\n+     * and sen.D - this helps to unify the format and simplifies processing\n      *\n-     * @param sen\n+     * @param sen Semsor description", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 906e830061..75400fb5a7 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -581,77 +523,28 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n         lastPayload = payload;\n     }\n \n-    private void updatePower(ShellyDeviceProfile profile, Map<String, State> updates, Integer id, CoIotDescrSen sen,\n-            CoIotSensor s, List<CoIotSensor> allUpdates) {\n-        String group = \"\";\n-        String channel = CHANNEL_BRIGHTNESS;\n-        String checkL = \"\"; // RGBW-white uses 4 different Power, Brightness, VSwitch values\n-        if (profile.isLight || profile.isDimmer) {\n-            if (profile.isBulb || profile.inColor) {\n-                group = CHANNEL_GROUP_LIGHT_CONTROL;\n-                channel = CHANNEL_LIGHT_POWER;\n-            } else if (profile.isDuo) {\n-                group = CHANNEL_GROUP_WHITE_CONTROL;\n-            } else if (profile.isDimmer) {\n-                group = CHANNEL_GROUP_RELAY_CONTROL;\n-            } else if (profile.isRGBW2) {\n-                group = CHANNEL_GROUP_LIGHT_CHANNEL + id;\n-                checkL = String.valueOf(id.intValue() - 1); // id is 1-based, L is 0-based\n-                logger.trace(\"{}: updatePower() for L={}\", thingName, checkL);\n-            }\n-\n-            // We need to update brigthtess and on/off state at the same time to avoid \"flipping brightness slider\" in\n-            // the UI\n-            Double brightness = -1.0;\n-            Double power = -1.0;\n-            for (CoIotSensor update : allUpdates) {\n-                CoIotDescrSen d = fixDescription(sensorMap.get(update.id));\n-                if (!checkL.isEmpty() && !d.links.equals(checkL)) {\n-                    // continue until we find the correct one\n-                    continue;\n-                }\n-                if (d.desc.equalsIgnoreCase(\"brightness\")) {\n-                    brightness = new Double(update.value);\n-                } else if (d.desc.equalsIgnoreCase(\"output\") || d.desc.equalsIgnoreCase(\"state\")) {\n-                    power = new Double(update.value);\n-                }\n-            }\n-            if (power != -1) {\n-                updateChannel(updates, group, channel + \"$Switch\", power == 1 ? OnOffType.ON : OnOffType.OFF);\n-            }\n-            if (brightness != -1) {\n-                updateChannel(updates, group, channel + \"$Value\",\n-                        toQuantityType(power == 1 ? brightness : 0, DIGITS_NONE, SmartHomeUnits.PERCENT));\n-            }\n-        } else if (profile.hasRelays) {\n-            group = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL : CHANNEL_GROUP_RELAY_CONTROL + id;\n-            updateChannel(updates, group, CHANNEL_OUTPUT, s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n-        } else if (profile.isSensor) {\n-            // Sensor state\n-            if (profile.isDW) { // Door Window has item type Contact\n-                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n-                        s.value != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n-            } else {\n-                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n-                        s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n-            }\n-        }\n-    }\n-\n     private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n+        State v = (State) thingHandler.getChannelValue(group, channel);\n+        if ((v != null) && v.equals(value)) {\n+            return false;\n+        }\n+        logger.trace(\"{}: Updating channel {}.{} from CoIoT, new value={}\", thingName, group, channel, value);\n         updates.put(mkChannelId(group, channel), value);\n         return true;\n \n     }\n \n     /**\n-     * Work around to fix inconsistent sensor types and description. Shelly not uses always the same coding for sen.T\n-     * and sen.D - this helps to unify the format and simplifies processing\n+     * Work around to fix inconsistent sensor types and description\n+     * Shelly not uses always the same coding for sen.T and sen.D - this helps to unify the format and simplifies\n+     * processing\n      *\n-     * @param sen Semsor description\n+     * @param sen\n      * @return updated sen\n      */\n     private CoIotDescrSen fixDescription(CoIotDescrSen sen) {\n+        Validate.notNull(sen, \"sen must not be null!\");\n+\n         // Shelly1: reports null descr+type \"Switch\" -> map to S\n         // Shelly1PM: reports null descr+type \"Overtemp\" -> map to O\n         // Shelly1PM: reports null descr+type \"W\" -> add description\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNTIzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407725237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to initialize, retrying later:\", name, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:14:13Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +96,82 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n-            if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+            address = service.getHostAddress();\n+            if ((address == null) || address.isEmpty()) {\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            String thingType = service.getQualifiedName().contains(SERVICE_TYPE) && name.contains(\"-\")\n+                    ? StringUtils.substringBefore(name, \"-\")\n+                    : name;\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}, type={}\", name, address, thingType);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n                 thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n                     thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: {}\", name, e.toString());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2MzczNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408063737", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNTIzNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\nindex 30f58c1da2..0859a1a4ea 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java\n\n@@ -96,82 +70,89 @@ public class ShellyDiscoveryParticipant implements MDNSDiscoveryParticipant {\n     }\n \n     /**\n-     * Process updates to Binding Config\n+     * Called at the service activation.\n      *\n      * @param componentContext\n      */\n+    @SuppressWarnings(\"null\")\n+    @Activate\n+    protected void activate(ComponentContext componentContext) {\n+        logger.debug(\"Shelly Discovery service activated\");\n+        Validate.notNull(componentContext);\n+        Validate.notNull(bindingConfig);\n+        bindingConfig.updateFromProperties(componentContext.getProperties());\n+    }\n+\n     @Modified\n-    protected void modified(final ComponentContext componentContext) {\n+    @SuppressWarnings(\"null\")\n+    protected void modified(ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(final ServiceInfo service) {\n-        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n-        if (!name.startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n+        Validate.notNull(bindingConfig);\n+        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        try {\n-            String mode = \"\";\n-            String model = \"unknown\";\n-            ThingUID thingUID = null;\n-            ShellyDeviceProfile profile = null;\n-            Map<String, Object> properties = new TreeMap<>();\n+        String name = \"\";\n+        String mode = \"\";\n+        String model = \"unknown\";\n+        String thingType = \"\";\n+        ThingUID thingUID = null;\n+        ShellyDeviceProfile profile = null;\n+        Map<String, Object> properties = new HashMap<>();\n \n+        try {\n             name = service.getName().toLowerCase();\n-            address = service.getHostAddress();\n-            if ((address == null) || address.isEmpty()) {\n-                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n-                        service.toString());\n+            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            if (address == null) {\n+                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n-            String thingType = service.getQualifiedName().contains(SERVICE_TYPE) && name.contains(\"-\")\n-                    ? StringUtils.substringBefore(name, \"-\")\n-                    : name;\n-            logger.debug(\"{}: Shelly device discovered: IP-Adress={}, type={}\", name, address, thingType);\n+            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            // Get device settings\n-            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n-            if (serviceConfig.getProperties() != null) {\n-                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            if (handlerFactory != null) {\n+                bindingConfig = handlerFactory.getBindingConfig();\n             }\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n+            // Get device settings\n+            Validate.notNull(bindingConfig);\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n+            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n-                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n-\n                 profile = api.getDeviceProfile(thingType);\n-                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n-                model = getString(profile.settings.device.type);\n+                Validate.notNull(profile);\n+                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n+                Validate.notNull(profile, \"Unable to get device profile: \");\n+                model = profile.settings.device.type;\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n                 thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (ShellyApiException e) {\n-                ShellyApiResult result = e.getApiResult();\n-                if (result.isHttpAccessUnauthorized()) {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n+            } catch (IOException e) {\n+                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n                     thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: {}\", name, e.toString());\n+                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n+                            e.getMessage(), e.getClass(), e.getStackTrace());\n                 }\n-            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n-                logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());\n             }\n \n             if (thingUID != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjQzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726436", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.info(\"{}: {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n          \n          \n            \n                                    e);", "author": "cpmeister", "createdAt": "2020-04-13T21:16:36Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,26 +312,26 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n+                        e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2Mzg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408063867", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -312,26 +302,26 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (ShellyApiException e) {\n-            ShellyApiResult res = e.getApiResult();\n-            if (isAuthorizationFailed(res)) {\n+        } catch (NullPointerException | IOException e) {\n+            if (authorizationFailed(e.getMessage())) {\n                 return;\n             }\n-            if (res.isNotCalibrtated()) {\n-                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n+            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n+                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n             } else {\n-                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n-                        e.toString());\n+                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n+                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n             }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n+        } finally {\n+            lockUpdates = false;\n         }\n     }\n \n     /**\n      * Update device status and channels\n      */\n-    protected void refreshStatus() {\n+    @SuppressWarnings(\"null\")\n+    protected void updateStatus() {\n         try {\n             boolean updated = false;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726610", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n          \n          \n            \n                        logger.debug(\"{}: {}\", thingName, messages.get(\"command.failed\", command, channelUID), e);", "author": "cpmeister", "createdAt": "2020-04-13T21:16:55Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,26 +312,26 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n+                        e.toString());\n             }\n-        } finally {\n-            lockUpdates = false;\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2ODA0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408068048", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -312,26 +302,26 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (ShellyApiException e) {\n-            ShellyApiResult res = e.getApiResult();\n-            if (isAuthorizationFailed(res)) {\n+        } catch (NullPointerException | IOException e) {\n+            if (authorizationFailed(e.getMessage())) {\n                 return;\n             }\n-            if (res.isNotCalibrtated()) {\n-                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n+            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n+                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n             } else {\n-                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n-                        e.toString());\n+                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n+                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n             }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n+        } finally {\n+            lockUpdates = false;\n         }\n     }\n \n     /**\n      * Update device status and channels\n      */\n-    protected void refreshStatus() {\n+    @SuppressWarnings(\"null\")\n+    protected void updateStatus() {\n         try {\n             boolean updated = false;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726815", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n          \n          \n            \n                        logger.warn(\"{}: {}\", thingName, messages.get(\"statusupdate.failed\"), e);", "author": "cpmeister", "createdAt": "2020-04-13T21:17:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -350,100 +359,104 @@ protected void updateStatus() {\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                if (getThing().getStatus() != ThingStatus.ONLINE) {\n-                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n-                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n-                }\n+                setThingOnline();\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                status = \"offline.status-error-timeout\";\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NjE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408066142", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjgxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -359,104 +350,100 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                setThingOnline();\n+                if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n+                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n+                }\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n-                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n-                // All channels must be created after the first cycle\n-                channelsCreated = true;\n-\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (ShellyApiException e) {\n+        } catch (IOException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            ShellyApiResult res = e.getApiResult();\n-            if (e.isTimeout()) {\n-                status = \"offline.status-error-timeout\";\n-            } else if (res.isHttpAccessUnauthorized()) {\n-                status = \"offline.conf-error-access-denied\";\n+            if (e.getMessage().contains(\"Timeout\")) {\n+                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n+                        skipCount, scheduledUpdates);\n+                status = \"@text/offline.status-error-timeout\";\n+            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n+                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n+                status = \"@text/offline.conf-error-access-denied\";\n+            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n+                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n+                        thingName);\n+                status = \"@text/offline.conf-error-not-calibrated\";\n             } else {\n-                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+                status = \"@text/offline.status-error-unexpected-api-result\";\n             }\n-\n-            if (!status.isEmpty()) {\n-                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n+            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (IllegalArgumentException | NullPointerException e) {\n-            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n+        } catch (NullPointerException e) {\n+            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            } else if ((skipUpdate >= cacheCount) && !cache.isEnabled()) {\n+                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            }\n+            if ((skipUpdate >= cacheCount) && !channelCache) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                cache.enable();\n+                channelCache = true;\n             }\n         }\n-    }\n \n-    public boolean isThingOnline() {\n-        return getThing().getStatus() == ThingStatus.ONLINE;\n-    }\n-\n-    public boolean isThingOffline() {\n-        return getThing().getStatus() == ThingStatus.OFFLINE;\n-    }\n-\n-    public void setThingOnline() {\n-        if (!isThingOnline()) {\n-            updateStatus(ThingStatus.ONLINE);\n-            requestUpdates(!profile.isSensor ? 3 : 1, false); // request 3 updates in a row (during the first 2+3*3 sec)\n-        }\n-    }\n-\n-    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n-        if (!isThingOffline()) {\n-            updateStatus(ThingStatus.OFFLINE, detail, messageKey);\n-            channelsCreated = false; // check for new channels after devices gets re-initialized (e.g. new\n-        }\n     }\n \n+    @SuppressWarnings(\"null\")\n     private void fillDeviceStatus(ShellySettingsStatus status, boolean updated) {\n         String alarm = \"\";\n         boolean force = false;\n-        Map<String, String> propertyUpdates = new TreeMap<>();\n \n-        // Update uptime and WiFi, internal temp\n-        ShellyComponents.updateDeviceStatus(this, status);\n+        Map<String, String> propertyUpdates = new HashMap<>();\n+\n+        // Update uptime and WiFi\n+        if (updated) {\n+            lastUpdateTs = now();\n+        }\n+        long uptime = getLong(status.uptime);\n+        Integer rssi = getInteger(status.wifiSta.rssi);\n+        updateChannel(CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_UPTIME,\n+                toQuantityType(new DecimalType(uptime), SmartHomeUnits.SECOND));\n+        updateChannel(CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_RSSI, mapSignalStrength(rssi));\n \n-        if (api.isInitialized() && (lastTimeoutErros != api.getTimeoutErrors())) {\n+        if ((api != null) && (lastTimeoutErros != api.getTimeoutErrors())) {\n             propertyUpdates.put(PROPERTY_STATS_TIMEOUTS, new Integer(api.getTimeoutErrors()).toString());\n             propertyUpdates.put(PROPERTY_STATS_TRECOVERED, new Integer(api.getTimeoutsRecovered()).toString());\n             lastTimeoutErros = api.getTimeoutErrors();\n         }\n \n         // Check various device indicators like overheating\n-        if ((status.uptime < lastUptime) && (profile.isInitialized()) && !profile.hasBattery) {\n+        if ((status.uptime < lastUptime) && (profile != null) && !profile.hasBattery) {\n             alarm = ALARM_TYPE_RESTARTED;\n             force = true;\n         }\n-        lastUptime = getLong(status.uptime);\n+        lastUptime = uptime;\n \n         if (getBool(status.overtemperature)) {\n             alarm = ALARM_TYPE_OVERTEMP;\n-        } else if (getBool(status.overload)) {\n+        }\n+        if (getBool(status.overload)) {\n             alarm = ALARM_TYPE_OVERLOAD;\n-        } else if (getBool(status.loaderror)) {\n+        }\n+        if (getBool(status.loaderror)) {\n             alarm = ALARM_TYPE_LOADERR;\n         }\n \n         if (!alarm.isEmpty()) {\n-            postEvent(alarm, force);\n+            postAlarm(alarm, force);\n         }\n \n         if (!propertyUpdates.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTk4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407729980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n          \n          \n            \n                        this.statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,", "author": "cpmeister", "createdAt": "2020-04-13T21:23:47Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -641,15 +699,20 @@ private void changeThingType(String thingType, String mode) {\n         }\n     }\n \n+    @Override\n+    public void thingUpdated(Thing thing) {\n+        logger.debug(\"{}: Channel definitions updated.\", thingName);\n+        super.thingUpdated(thing);\n+    }\n+\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {\n-            statusJob = scheduler.scheduleWithFixedDelay(this::updateStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n+            statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2Njc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408066757", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -699,20 +641,15 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n         }\n     }\n \n-    @Override\n-    public void thingUpdated(Thing thing) {\n-        logger.debug(\"{}: Channel definitions updated.\", thingName);\n-        super.thingUpdated(thing);\n-    }\n-\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {\n-            statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n+            statusJob = scheduler.scheduleWithFixedDelay(this::updateStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n                     TimeUnit.SECONDS);\n+            Validate.notNull(statusJob, \"statusJob must not be null\");\n             logger.debug(\"{}: Update status job started, interval={}*{}={}sec.\", thingName, skipCount,\n                     UPDATE_STATUS_INTERVAL_SECONDS, skipCount * UPDATE_STATUS_INTERVAL_SECONDS);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407730283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"null\")\n          \n          \n            \n                protected void startUpdateJob() {\n          \n          \n            \n                    if ((statusJob == null) || statusJob.isCancelled()) {\n          \n          \n            \n                protected void startUpdateJob() {\n          \n          \n            \n                    ScheduledFuture<?> statusJob = this.statusJob;\n          \n          \n            \n                    if ((statusJob == null) || statusJob.isCancelled()) {", "author": "cpmeister", "createdAt": "2020-04-13T21:24:26Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -641,15 +699,20 @@ private void changeThingType(String thingType, String mode) {\n         }\n     }\n \n+    @Override\n+    public void thingUpdated(Thing thing) {\n+        logger.debug(\"{}: Channel definitions updated.\", thingName);\n+        super.thingUpdated(thing);\n+    }\n+\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067057", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -699,20 +641,15 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n         }\n     }\n \n-    @Override\n-    public void thingUpdated(Thing thing) {\n-        logger.debug(\"{}: Channel definitions updated.\", thingName);\n-        super.thingUpdated(thing);\n-    }\n-\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {\n-            statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n+            statusJob = scheduler.scheduleWithFixedDelay(this::updateStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n                     TimeUnit.SECONDS);\n+            Validate.notNull(statusJob, \"statusJob must not be null\");\n             logger.debug(\"{}: Update status job started, interval={}*{}={}sec.\", thingName, skipCount,\n                     UPDATE_STATUS_INTERVAL_SECONDS, skipCount * UPDATE_STATUS_INTERVAL_SECONDS);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407730557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getChannelValue(String group, String channel) {\n          \n          \n            \n                public @Nullable Object getChannelValue(String group, String channel) {", "author": "cpmeister", "createdAt": "2020-04-13T21:25:02Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -704,53 +767,67 @@ public boolean updateInputs(String groupName, ShellySettingsStatus status, int i\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n-                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n+    public void publishState(String channelId, State value) {\n+        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value, boolean force) {\n+        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n+    }\n+\n+    @Nullable\n+    public Object getChannelValue(String group, String channel) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067152", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -767,67 +704,53 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n+                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n-    public void publishState(String channelId, State value) {\n-        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value, boolean force) {\n-        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n-    }\n-\n-    @Nullable\n-    public Object getChannelValue(String group, String channel) {\n-        return cache.getValue(group, channel);\n-    }\n-\n     /**\n-     * Update Thing's channels according to available status information from the API\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n      *\n-     * @param thingHandler\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n      */\n-    protected void updateChannelDefinitions(Map<String, Channel> dynChannels) {\n-        if (channelsCreated) {\n-            return; // already done\n-        }\n-\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n         try {\n-            // Get subset of those channels that currently do not exist\n-            List<Channel> existingChannels = getThing().getChannels();\n-            for (Channel channel : existingChannels) {\n-                String id = channel.getUID().getId();\n-                if (dynChannels.containsKey(id)) {\n-                    dynChannels.remove(id);\n+            Object current = channelData.get(channelId);\n+            // logger.trace(\"{}: Predict channel {}.{} to become {} (type {}).\", thingName,\n+            // group, channel, value, value.getClass());\n+            if (!channelCache || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+                if (current == null) {\n+                    channelData.put(channelId, value);\n+                } else {\n+                    channelData.replace(channelId, value);\n                 }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n             }\n-\n-            if (!dynChannels.isEmpty()) {\n-                logger.debug(\"{}: Updating channel definitions, {} channels\", thingName, dynChannels.size());\n-                ThingBuilder thingBuilder = editThing();\n-                for (Map.Entry<String, Channel> channel : dynChannels.entrySet()) {\n-                    Channel c = channel.getValue();\n-                    logger.debug(\"{}: Adding channel {}\", thingName, c.getUID().getId());\n-                    thingBuilder.withChannel(c);\n-                }\n-                updateThing(thingBuilder.build());\n-                logger.debug(\"{}: Channel definitions updated\", thingName);\n-            }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());\n+        } catch (NullPointerException e) {\n+            logger.debug(\"Unable to update channel {}.{} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass(), e.getMessage(), e.getClass());\n         }\n+        return false;\n     }\n \n-    public boolean areChannelsCreated() {\n-        return channelsCreated;\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407731461", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to update channel definitions:\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:26:54Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -704,53 +767,67 @@ public boolean updateInputs(String groupName, ShellySettingsStatus status, int i\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n-                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n+    public void publishState(String channelId, State value) {\n+        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value, boolean force) {\n+        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n+    }\n+\n+    @Nullable\n+    public Object getChannelValue(String group, String channel) {\n+        return cache.getValue(group, channel);\n+    }\n+\n     /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n+     * Update Thing's channels according to available status information from the API\n      *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n+     * @param thingHandler\n      */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+    protected void updateChannelDefinitions(Map<String, Channel> dynChannels) {\n+        if (channelsCreated) {\n+            return; // already done\n+        }\n+\n         try {\n-            Object current = channelData.get(channelId);\n-            // logger.trace(\"{}: Predict channel {}.{} to become {} (type {}).\", thingName,\n-            // group, channel, value, value.getClass());\n-            if (!channelCache || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n-                if (current == null) {\n-                    channelData.put(channelId, value);\n-                } else {\n-                    channelData.replace(channelId, value);\n+            // Get subset of those channels that currently do not exist\n+            List<Channel> existingChannels = getThing().getChannels();\n+            for (Channel channel : existingChannels) {\n+                String id = channel.getUID().getId();\n+                if (dynChannels.containsKey(id)) {\n+                    dynChannels.remove(id);\n                 }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n             }\n-        } catch (NullPointerException e) {\n-            logger.debug(\"Unable to update channel {}.{} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass(), e.getMessage(), e.getClass());\n+\n+            if (!dynChannels.isEmpty()) {\n+                logger.debug(\"{}: Updating channel definitions, {} channels\", thingName, dynChannels.size());\n+                ThingBuilder thingBuilder = editThing();\n+                for (Map.Entry<String, Channel> channel : dynChannels.entrySet()) {\n+                    Channel c = channel.getValue();\n+                    logger.debug(\"{}: Adding channel {}\", thingName, c.getUID().getId());\n+                    thingBuilder.withChannel(c);\n+                }\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{}: Channel definitions updated\", thingName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067260", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -767,67 +704,53 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n+                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n-    public void publishState(String channelId, State value) {\n-        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value, boolean force) {\n-        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n-    }\n-\n-    @Nullable\n-    public Object getChannelValue(String group, String channel) {\n-        return cache.getValue(group, channel);\n-    }\n-\n     /**\n-     * Update Thing's channels according to available status information from the API\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n      *\n-     * @param thingHandler\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n      */\n-    protected void updateChannelDefinitions(Map<String, Channel> dynChannels) {\n-        if (channelsCreated) {\n-            return; // already done\n-        }\n-\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n         try {\n-            // Get subset of those channels that currently do not exist\n-            List<Channel> existingChannels = getThing().getChannels();\n-            for (Channel channel : existingChannels) {\n-                String id = channel.getUID().getId();\n-                if (dynChannels.containsKey(id)) {\n-                    dynChannels.remove(id);\n+            Object current = channelData.get(channelId);\n+            // logger.trace(\"{}: Predict channel {}.{} to become {} (type {}).\", thingName,\n+            // group, channel, value, value.getClass());\n+            if (!channelCache || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+                if (current == null) {\n+                    channelData.put(channelId, value);\n+                } else {\n+                    channelData.replace(channelId, value);\n                 }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n             }\n-\n-            if (!dynChannels.isEmpty()) {\n-                logger.debug(\"{}: Updating channel definitions, {} channels\", thingName, dynChannels.size());\n-                ThingBuilder thingBuilder = editThing();\n-                for (Map.Entry<String, Channel> channel : dynChannels.entrySet()) {\n-                    Channel c = channel.getValue();\n-                    logger.debug(\"{}: Adding channel {}\", thingName, c.getUID().getId());\n-                    thingBuilder.withChannel(c);\n-                }\n-                updateThing(thingBuilder.build());\n-                logger.debug(\"{}: Channel definitions updated\", thingName);\n-            }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());\n+        } catch (NullPointerException e) {\n+            logger.debug(\"Unable to update channel {}.{} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass(), e.getMessage(), e.getClass());\n         }\n+        return false;\n     }\n \n-    public boolean areChannelsCreated() {\n-        return channelsCreated;\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407732131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (statusJob != null) {\n          \n          \n            \n                        statusJob.cancel(true);\n          \n          \n            \n                        statusJob = null;\n          \n          \n            \n                    ScheduledFuture<?> statusJob = this.statusJob;\n          \n          \n            \n                    if (statusJob != null) {\n          \n          \n            \n                        statusJob.cancel(true);\n          \n          \n            \n                        this.statusJob = null;", "author": "cpmeister", "createdAt": "2020-04-13T21:28:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -865,94 +943,70 @@ public String getProperty(String key) {\n      * @param ForceRefresh true=force refresh before returning, false=return without\n      *            refresh\n      * @return ShellyDeviceProfile instance\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    @Nullable\n-    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws IOException {\n+    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws ShellyApiException {\n         try {\n             refreshSettings |= forceRefresh;\n             if (refreshSettings) {\n-                logger.debug(\"{}: Refresh settings\", thingName);\n-                profile = api.getDeviceProfile(getThing().getThingTypeUID().getId());\n+                profile = api.getDeviceProfile(thingType);\n+                if (!isThingOnline()) {\n+                    logger.debug(\"{}:Device profile re-initialized (thingType={})\", thingName, thingType);\n+                }\n             }\n         } finally {\n             refreshSettings = false;\n         }\n         return profile;\n     }\n \n-    @Nullable\n     public ShellyDeviceProfile getProfile() {\n         return profile;\n     }\n \n-    @Nullable\n     protected ShellyHttpApi getShellyApi() {\n         return api;\n     }\n \n-    @Nullable\n     protected ShellyDeviceProfile getDeviceProfile() {\n         return profile;\n     }\n \n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getChannelValue(String group, String channel) {\n-        String key = mkChannelId(group, channel);\n-        return channelData.get(key);\n-    }\n-\n     public void triggerChannel(String group, String channel, String payload) {\n         triggerChannel(mkChannelId(group, channel), payload);\n     }\n \n+    public void stop() {\n+        logger.debug(\"{}: Shutting down\", thingName);\n+        if (statusJob != null) {\n+            statusJob.cancel(true);\n+            statusJob = null;", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2Nzc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067757", "bodyText": "changed and understood why :-)", "author": "markus7017", "createdAt": "2020-04-14T11:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjEzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\nindex eb85f1617e..1f2335d497 100755\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java\n\n@@ -943,16 +865,16 @@ public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceL\n      * @param ForceRefresh true=force refresh before returning, false=return without\n      *            refresh\n      * @return ShellyDeviceProfile instance\n-     * @throws ShellyApiException\n+     * @throws IOException\n      */\n-    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    @Nullable\n+    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws IOException {\n         try {\n             refreshSettings |= forceRefresh;\n             if (refreshSettings) {\n-                profile = api.getDeviceProfile(thingType);\n-                if (!isThingOnline()) {\n-                    logger.debug(\"{}:Device profile re-initialized (thingType={})\", thingName, thingType);\n-                }\n+                logger.debug(\"{}: Refresh settings\", thingName);\n+                profile = api.getDeviceProfile(getThing().getThingTypeUID().getId());\n             }\n         } finally {\n             refreshSettings = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMzczNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407733734", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to handle command:\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:31:46Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java", "diffHunk": "@@ -74,160 +76,167 @@ public void initialize() {\n         super.initialize();\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n-    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IOException {\n-        String groupName = channelUID.getGroupId();\n-        Integer lightId = getLightIdFromGroup(groupName);\n-        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command.toString(),\n-                channelUID.getAsString(), lightId);\n-\n-        Validate.notNull(profile, \"DeviceProfile must not be null, thing not initialized\");\n-        Validate.notNull(api, \"handleCommand(): api must not be null!\");\n-        ShellyColorUtils oldCol = getCurrentColors(lightId);\n-        Validate.notNull(oldCol, \"oldCol must not be null\");\n-        oldCol.mode = profile.mode;\n-        ShellyColorUtils col = new ShellyColorUtils(oldCol);\n-        Validate.notNull(oldCol, \"copy of oldCol must not be null\");\n-\n-        boolean update = true;\n-        switch (channelUID.getIdWithoutGroup()) {\n-            default: // non-bulb commands will be handled by the generic handler\n-                return false;\n-\n-            case CHANNEL_LIGHT_POWER:\n-                logger.debug(\"{}: Switch light {}\", thingName, command.toString());\n-                Validate.isTrue(command instanceof OnOffType, \"Invalid value for power (ON or OFF): {}\",\n-                        command.toString());\n-                api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n-                        (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                col.power = (OnOffType) command;\n-                update = (OnOffType) command == OnOffType.ON;\n-                break;\n-            case CHANNEL_LIGHT_COLOR_MODE:\n-                logger.debug(\"{}: Select color mode {}\", thingName, command.toString());\n-                Validate.isTrue(command instanceof OnOffType,\n-                        \"Invalid value for color mode (ON or OFF): \" + command.toString());\n-                col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-                break;\n-            case CHANNEL_COLOR_PICKER:\n-                logger.debug(\"{}: Update colors from color picker\", thingName);\n-                update = handleColorPicker(profile, lightId, col, command);\n-                break;\n-            case CHANNEL_COLOR_FULL:\n-                logger.debug(\"{}: Set colors to {}\", thingName, command.toString());\n-                handleFullColor(col, command);\n-                break;\n-            case CHANNEL_COLOR_RED:\n-                col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_GREEN:\n-                col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_BLUE:\n-                col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_WHITE:\n-                col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_GAIN:\n-                col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n-                break;\n-            case CHANNEL_BRIGHTNESS: // only in white mode\n-                Integer value = -1;\n-                if (command instanceof OnOffType) { // Switch\n-                    logger.debug(\"Switch light {}\", command.toString());\n-                    api.setRelayTurn(lightId, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                    requestUpdates(1, false);\n-                    break;\n-                }\n+    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IllegalArgumentException {\n+        String groupName = getString(channelUID.getGroupId());\n+        if (groupName.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty groupName\");\n+        }\n \n-                if (command instanceof PercentType) {\n-                    Float percent = ((PercentType) command).floatValue();\n-                    value = percent.intValue(); // 0..100% = 0..100\n-                    logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n-                } else if (command instanceof DecimalType) {\n-                    value = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n-                }\n-                if (value == 0) {\n-                    logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n-                    api.setRelayTurn(lightId, SHELLY_API_OFF);\n+        int lightId = getLightIdFromGroup(groupName);\n+        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command, channelUID.getAsString(),\n+                lightId);\n+\n+        try {\n+            ShellyColorUtils oldCol = getCurrentColors(lightId);\n+            oldCol.mode = profile.mode;\n+            ShellyColorUtils col = new ShellyColorUtils(oldCol);\n+\n+            boolean update = true;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                default: // non-bulb commands will be handled by the generic handler\n+                    return false;\n+\n+                case CHANNEL_LIGHT_POWER:\n+                    logger.debug(\"{}: Switch light {}\", thingName, command);\n+                    api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n+                            command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                    col.power = (OnOffType) command;\n                     requestUpdates(1, false);\n+                    update = false;\n                     break;\n-                }\n+                case CHANNEL_LIGHT_COLOR_MODE:\n+                    logger.debug(\"{}: Select color mode {}\", thingName, command);\n+                    col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+                    break;\n+                case CHANNEL_COLOR_PICKER:\n+                    logger.debug(\"{}: Update colors from color picker\", thingName);\n+                    update = handleColorPicker(profile, lightId, col, command);\n+                    break;\n+                case CHANNEL_COLOR_FULL:\n+                    logger.debug(\"{}: Set colors to {}\", thingName, command);\n+                    handleFullColor(col, command);\n+                    break;\n+                case CHANNEL_COLOR_RED:\n+                    col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_GREEN:\n+                    col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_BLUE:\n+                    col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_WHITE:\n+                    col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_GAIN:\n+                    col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n+                    break;\n+                case CHANNEL_BRIGHTNESS: // only in white mode\n+                    if (profile.inColor && !profile.isBulb) {\n+                        logger.debug(\"{}: Not in white mode, brightness not available\", thingName);\n+                        break;\n+                    }\n \n-                if (command instanceof IncreaseDecreaseType) {\n-                    ShellyShortLightStatus light = api.getLightStatus(lightId);\n-                    Validate.notNull(light, \"Unable to get Light status for brightness\");\n+                    int value = -1;\n+                    if (command instanceof OnOffType) { // Switch\n+                        logger.debug(\"{}: Switch light {}\", thingName, command);\n+                        ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                        col.brightness = light.brightness;\n+                        col.power = (OnOffType) command;\n+                        api.setRelayTurn(lightId, col.power == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                        // updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Switch\", col.power);\n+                        updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Value\",\n+                                toQuantityType(new Double(col.power == OnOffType.ON ? col.brightness : 0), DIGITS_NONE,\n+                                        SmartHomeUnits.PERCENT));\n+                        update = false;\n+                        break;\n+                    }\n \n-                    if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n-                        value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n+                    if (command instanceof PercentType) {\n+                        Float percent = ((PercentType) command).floatValue();\n+                        value = percent.intValue(); // 0..100% = 0..100\n+                        logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n+                    } else if (command instanceof DecimalType) {\n+                        value = ((DecimalType) command).intValue();\n+                        logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n+                    }\n+                    if (value == 0) {\n+                        logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n+                        api.setRelayTurn(lightId, SHELLY_API_OFF);\n+                        update = false;\n                     } else {\n-                        value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n+\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                            if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n+                                value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n+                            } else {\n+                                value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n+                            }\n+                            logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n+                        }\n+\n+                        validateRange(\"brightness\", value, 0, 100);\n+                        logger.debug(\"{}: Changing brightness from {} to {}\", thingName, oldCol.brightness, value);\n+                        col.setBrightness(value);\n                     }\n-                    logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n-                }\n+                    updateChannel(CHANNEL_GROUP_LIGHT_CONTROL, CHANNEL_LIGHT_POWER,\n+                            value > 0 ? OnOffType.ON : OnOffType.OFF);\n+                    break;\n \n-                validateRange(\"brightness\", value, 0, 100);\n-                logger.debug(\"{}: Set brightness to\", value);\n-                col.setBrightness(value);\n-                break;\n-\n-            case CHANNEL_COLOR_TEMP:\n-                Integer temp = -1;\n-                if (command instanceof PercentType) {\n-                    logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n-                    Float percent = ((PercentType) command).floatValue() / 100;\n-                    temp = new DecimalType(\n-                            MIN_COLOR_TEMPERATURE + ((MAX_COLOR_TEMPERATURE - MIN_COLOR_TEMPERATURE)) * percent)\n-                                    .intValue();\n-                    logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName, percent,\n-                            temp);\n-                } else if (command instanceof DecimalType) {\n-                    temp = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n-                }\n-                validateRange(CHANNEL_COLOR_TEMP, temp, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE);\n-                col.setTemp(temp);\n-                break;\n-\n-            case CHANNEL_COLOR_EFFECT:\n-                Integer effect = ((DecimalType) command).intValue();\n-                logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n-                validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n-                col.setEffect(effect.intValue());\n-                break;\n-        }\n+                case CHANNEL_COLOR_TEMP:\n+                    Integer temp = -1;\n+                    if (command instanceof PercentType) {\n+                        logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n+                        Float percent = ((PercentType) command).floatValue() / 100;\n+                        temp = new DecimalType(col.minTemp + ((col.maxTemp - col.minTemp)) * percent).intValue();\n+                        logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName,\n+                                percent, temp);\n+                    } else if (command instanceof DecimalType) {\n+                        temp = ((DecimalType) command).intValue();\n+                        logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n+                    }\n+                    validateRange(CHANNEL_COLOR_TEMP, temp, col.minTemp, col.maxTemp);\n+                    col.setTemp(temp);\n+                    col.brightness = -1;\n+                    break;\n \n-        if (update) {\n-            // check for switching color mode\n-            if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n-                logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode, col.mode);\n-                api.setLightMode(col.mode);\n+                case CHANNEL_COLOR_EFFECT:\n+                    Integer effect = ((DecimalType) command).intValue();\n+                    logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n+                    validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n+                    col.setEffect(effect.intValue());\n             }\n \n-            // send changed colors to the device\n-            sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n-        }\n-\n-        return true;\n+            if (update) {\n+                // check for switching color mode\n+                if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n+                    logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode,\n+                            col.mode);\n+                    api.setLightMode(col.mode);\n+                }\n \n+                // send changed colors to the device\n+                sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n+            }\n+            return true;\n+        } catch (ShellyApiException | IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067907", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMzczNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java\nindex b88437dd19..eaafd101c9 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java\n\n@@ -76,167 +74,160 @@ public class ShellyLightHandler extends ShellyBaseHandler {\n         super.initialize();\n     }\n \n+    @SuppressWarnings(\"null\")\n     @Override\n-    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IllegalArgumentException {\n-        String groupName = getString(channelUID.getGroupId());\n-        if (groupName.isEmpty()) {\n-            throw new IllegalArgumentException(\"Empty groupName\");\n-        }\n-\n-        int lightId = getLightIdFromGroup(groupName);\n-        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command, channelUID.getAsString(),\n-                lightId);\n-\n-        try {\n-            ShellyColorUtils oldCol = getCurrentColors(lightId);\n-            oldCol.mode = profile.mode;\n-            ShellyColorUtils col = new ShellyColorUtils(oldCol);\n-\n-            boolean update = true;\n-            switch (channelUID.getIdWithoutGroup()) {\n-                default: // non-bulb commands will be handled by the generic handler\n-                    return false;\n-\n-                case CHANNEL_LIGHT_POWER:\n-                    logger.debug(\"{}: Switch light {}\", thingName, command);\n-                    api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n-                            command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                    col.power = (OnOffType) command;\n+    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IOException {\n+        String groupName = channelUID.getGroupId();\n+        Integer lightId = getLightIdFromGroup(groupName);\n+        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command.toString(),\n+                channelUID.getAsString(), lightId);\n+\n+        Validate.notNull(profile, \"DeviceProfile must not be null, thing not initialized\");\n+        Validate.notNull(api, \"handleCommand(): api must not be null!\");\n+        ShellyColorUtils oldCol = getCurrentColors(lightId);\n+        Validate.notNull(oldCol, \"oldCol must not be null\");\n+        oldCol.mode = profile.mode;\n+        ShellyColorUtils col = new ShellyColorUtils(oldCol);\n+        Validate.notNull(oldCol, \"copy of oldCol must not be null\");\n+\n+        boolean update = true;\n+        switch (channelUID.getIdWithoutGroup()) {\n+            default: // non-bulb commands will be handled by the generic handler\n+                return false;\n+\n+            case CHANNEL_LIGHT_POWER:\n+                logger.debug(\"{}: Switch light {}\", thingName, command.toString());\n+                Validate.isTrue(command instanceof OnOffType, \"Invalid value for power (ON or OFF): {}\",\n+                        command.toString());\n+                api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n+                        (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                col.power = (OnOffType) command;\n+                update = (OnOffType) command == OnOffType.ON;\n+                break;\n+            case CHANNEL_LIGHT_COLOR_MODE:\n+                logger.debug(\"{}: Select color mode {}\", thingName, command.toString());\n+                Validate.isTrue(command instanceof OnOffType,\n+                        \"Invalid value for color mode (ON or OFF): \" + command.toString());\n+                col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+                break;\n+            case CHANNEL_COLOR_PICKER:\n+                logger.debug(\"{}: Update colors from color picker\", thingName);\n+                update = handleColorPicker(profile, lightId, col, command);\n+                break;\n+            case CHANNEL_COLOR_FULL:\n+                logger.debug(\"{}: Set colors to {}\", thingName, command.toString());\n+                handleFullColor(col, command);\n+                break;\n+            case CHANNEL_COLOR_RED:\n+                col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n+                break;\n+            case CHANNEL_COLOR_GREEN:\n+                col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n+                break;\n+            case CHANNEL_COLOR_BLUE:\n+                col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n+                break;\n+            case CHANNEL_COLOR_WHITE:\n+                col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n+                break;\n+            case CHANNEL_COLOR_GAIN:\n+                col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n+                break;\n+            case CHANNEL_BRIGHTNESS: // only in white mode\n+                Integer value = -1;\n+                if (command instanceof OnOffType) { // Switch\n+                    logger.debug(\"Switch light {}\", command.toString());\n+                    api.setRelayTurn(lightId, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n                     requestUpdates(1, false);\n-                    update = false;\n-                    break;\n-                case CHANNEL_LIGHT_COLOR_MODE:\n-                    logger.debug(\"{}: Select color mode {}\", thingName, command);\n-                    col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-                    break;\n-                case CHANNEL_COLOR_PICKER:\n-                    logger.debug(\"{}: Update colors from color picker\", thingName);\n-                    update = handleColorPicker(profile, lightId, col, command);\n-                    break;\n-                case CHANNEL_COLOR_FULL:\n-                    logger.debug(\"{}: Set colors to {}\", thingName, command);\n-                    handleFullColor(col, command);\n-                    break;\n-                case CHANNEL_COLOR_RED:\n-                    col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n-                    break;\n-                case CHANNEL_COLOR_GREEN:\n-                    col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n                     break;\n-                case CHANNEL_COLOR_BLUE:\n-                    col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n-                    break;\n-                case CHANNEL_COLOR_WHITE:\n-                    col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n-                    break;\n-                case CHANNEL_COLOR_GAIN:\n-                    col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n+                }\n+\n+                if (command instanceof PercentType) {\n+                    Float percent = ((PercentType) command).floatValue();\n+                    value = percent.intValue(); // 0..100% = 0..100\n+                    logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n+                } else if (command instanceof DecimalType) {\n+                    value = ((DecimalType) command).intValue();\n+                    logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n+                }\n+                if (value == 0) {\n+                    logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n+                    api.setRelayTurn(lightId, SHELLY_API_OFF);\n+                    requestUpdates(1, false);\n                     break;\n-                case CHANNEL_BRIGHTNESS: // only in white mode\n-                    if (profile.inColor && !profile.isBulb) {\n-                        logger.debug(\"{}: Not in white mode, brightness not available\", thingName);\n-                        break;\n-                    }\n+                }\n \n-                    int value = -1;\n-                    if (command instanceof OnOffType) { // Switch\n-                        logger.debug(\"{}: Switch light {}\", thingName, command);\n-                        ShellyShortLightStatus light = api.getLightStatus(lightId);\n-                        col.brightness = light.brightness;\n-                        col.power = (OnOffType) command;\n-                        api.setRelayTurn(lightId, col.power == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                        // updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Switch\", col.power);\n-                        updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Value\",\n-                                toQuantityType(new Double(col.power == OnOffType.ON ? col.brightness : 0), DIGITS_NONE,\n-                                        SmartHomeUnits.PERCENT));\n-                        update = false;\n-                        break;\n-                    }\n+                if (command instanceof IncreaseDecreaseType) {\n+                    ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                    Validate.notNull(light, \"Unable to get Light status for brightness\");\n \n-                    if (command instanceof PercentType) {\n-                        Float percent = ((PercentType) command).floatValue();\n-                        value = percent.intValue(); // 0..100% = 0..100\n-                        logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n-                    } else if (command instanceof DecimalType) {\n-                        value = ((DecimalType) command).intValue();\n-                        logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n-                    }\n-                    if (value == 0) {\n-                        logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n-                        api.setRelayTurn(lightId, SHELLY_API_OFF);\n-                        update = false;\n+                    if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n+                        value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n                     } else {\n-\n-                        if (command instanceof IncreaseDecreaseType) {\n-                            ShellyShortLightStatus light = api.getLightStatus(lightId);\n-                            if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n-                                value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n-                            } else {\n-                                value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n-                            }\n-                            logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n-                        }\n-\n-                        validateRange(\"brightness\", value, 0, 100);\n-                        logger.debug(\"{}: Changing brightness from {} to {}\", thingName, oldCol.brightness, value);\n-                        col.setBrightness(value);\n+                        value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n                     }\n-                    updateChannel(CHANNEL_GROUP_LIGHT_CONTROL, CHANNEL_LIGHT_POWER,\n-                            value > 0 ? OnOffType.ON : OnOffType.OFF);\n-                    break;\n-\n-                case CHANNEL_COLOR_TEMP:\n-                    Integer temp = -1;\n-                    if (command instanceof PercentType) {\n-                        logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n-                        Float percent = ((PercentType) command).floatValue() / 100;\n-                        temp = new DecimalType(col.minTemp + ((col.maxTemp - col.minTemp)) * percent).intValue();\n-                        logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName,\n-                                percent, temp);\n-                    } else if (command instanceof DecimalType) {\n-                        temp = ((DecimalType) command).intValue();\n-                        logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n-                    }\n-                    validateRange(CHANNEL_COLOR_TEMP, temp, col.minTemp, col.maxTemp);\n-                    col.setTemp(temp);\n-                    col.brightness = -1;\n-                    break;\n-\n-                case CHANNEL_COLOR_EFFECT:\n-                    Integer effect = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n-                    validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n-                    col.setEffect(effect.intValue());\n-            }\n+                    logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n+                }\n \n-            if (update) {\n-                // check for switching color mode\n-                if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n-                    logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode,\n-                            col.mode);\n-                    api.setLightMode(col.mode);\n+                validateRange(\"brightness\", value, 0, 100);\n+                logger.debug(\"{}: Set brightness to\", value);\n+                col.setBrightness(value);\n+                break;\n+\n+            case CHANNEL_COLOR_TEMP:\n+                Integer temp = -1;\n+                if (command instanceof PercentType) {\n+                    logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n+                    Float percent = ((PercentType) command).floatValue() / 100;\n+                    temp = new DecimalType(\n+                            MIN_COLOR_TEMPERATURE + ((MAX_COLOR_TEMPERATURE - MIN_COLOR_TEMPERATURE)) * percent)\n+                                    .intValue();\n+                    logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName, percent,\n+                            temp);\n+                } else if (command instanceof DecimalType) {\n+                    temp = ((DecimalType) command).intValue();\n+                    logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n                 }\n+                validateRange(CHANNEL_COLOR_TEMP, temp, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE);\n+                col.setTemp(temp);\n+                break;\n+\n+            case CHANNEL_COLOR_EFFECT:\n+                Integer effect = ((DecimalType) command).intValue();\n+                logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n+                validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n+                col.setEffect(effect.intValue());\n+                break;\n+        }\n \n-                // send changed colors to the device\n-                sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n+        if (update) {\n+            // check for switching color mode\n+            if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n+                logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode, col.mode);\n+                api.setLightMode(col.mode);\n             }\n-            return true;\n-        } catch (ShellyApiException | IllegalArgumentException e) {\n-            logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());\n-            return false;\n+\n+            // send changed colors to the device\n+            sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n         }\n+\n+        return true;\n+\n     }\n \n-    private boolean handleColorPicker(ShellyDeviceProfile profile, Integer lightId, ShellyColorUtils col,\n-            Command command) throws ShellyApiException {\n+    @SuppressWarnings(\"null\")\n+    private boolean handleColorPicker(@Nullable ShellyDeviceProfile profile, Integer lightId, ShellyColorUtils col,\n+            Command command) throws IOException {\n+        Validate.notNull(profile);\n+\n         boolean updated = false;\n         if (command instanceof HSBType) {\n             HSBType hsb = (HSBType) command;\n \n-            logger.debug(\"HSB-Info={}, Hue={}, getRGB={}, toRGB={}/{}/{}\", hsb, hsb.getHue(),\n+            logger.debug(\"HSB-Info={}, Hue={}, getRGB={}, toRGB={}/{}/{}\", hsb.toString(), hsb.getHue(),\n                     String.format(\"0x%08X\", hsb.getRGB()), hsb.toRGB()[0], hsb.toRGB()[1], hsb.toRGB()[2]);\n             if (hsb.toString().contains(\"360,\")) {\n-                logger.trace(\"{}: need to fix the Hue value (360->0)\", thingName);\n+                logger.debug(\"need to fix the Hue value (360->0)\");\n                 HSBType fixHue = new HSBType(new DecimalType(0), hsb.getSaturation(), hsb.getBrightness());\n                 hsb = fixHue;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n          \n          \n            \n                                newValue.getClass(), ShellyUtils.getMessage(e), e.getClass());", "author": "cpmeister", "createdAt": "2020-04-13T21:35:57Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzOTUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408039533", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T10:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 6c63b2cac5..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,133 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n-    private String thingName = \"\";\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        setThingName(thingHandler.thingName);\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n-        try {\n-            State current = null;\n-            if (channelData.containsKey(channelId)) {\n-                current = channelData.get(channelId);\n-            }\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n-                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n-                    return false; // special case for OnOffType\n-                }\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, newValue);\n-                if (current == null) {\n-                    channelData.put(channelId, newValue);\n-                } else {\n-                    channelData.replace(channelId, newValue);\n-                }\n-                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n-                        newValue.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n-                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        return channelData.get(channelId);\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        channelData.remove(channelId);\n-    }\n-\n-    public void clear() {\n-        channelData.clear();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735889", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getValue(String channelId) {\n          \n          \n            \n                public @Nullable State getValue(String channelId) {", "author": "cpmeister", "createdAt": "2020-04-13T21:36:18Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MTkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408051918", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NzIwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408077202", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 6c63b2cac5..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,133 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n-    private String thingName = \"\";\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        setThingName(thingHandler.thingName);\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n-        try {\n-            State current = null;\n-            if (channelData.containsKey(channelId)) {\n-                current = channelData.get(channelId);\n-            }\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n-                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n-                    return false; // special case for OnOffType\n-                }\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, newValue);\n-                if (current == null) {\n-                    channelData.put(channelId, newValue);\n-                } else {\n-                    channelData.replace(channelId, newValue);\n-                }\n-                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n-                        newValue.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n-                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        return channelData.get(channelId);\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        channelData.remove(channelId);\n-    }\n-\n-    public void clear() {\n-        channelData.clear();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getValue(String group, String channel) {\n          \n          \n            \n                public @Nullable State getValue(String group, String channel) {\n          \n      \n    \n    \n  \n\nIn addition would it be possible to get rid of the nullable return value by returning UndefType.NULL instead?", "author": "cpmeister", "createdAt": "2020-04-13T21:36:32Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1NjEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408056129", "bodyText": "yep, changed", "author": "markus7017", "createdAt": "2020-04-14T11:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NzY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408077655", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078454", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\ndeleted file mode 100644\nindex 6c63b2cac5..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java\n+++ /dev/null\n\n@@ -1,133 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-\n-package org.openhab.binding.shelly.internal.util;\n-\n-import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n-\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.types.State;\n-import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyChannelCache {\n-    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n-\n-    private final ShellyBaseHandler thingHandler;\n-    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n-    private String thingName = \"\";\n-    private boolean enabled = false;\n-\n-    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n-        this.thingHandler = thingHandler;\n-        setThingName(thingHandler.thingName);\n-    }\n-\n-    public void setThingName(String thingName) {\n-        this.thingName = thingName;\n-    }\n-\n-    public boolean isEnabled() {\n-        return enabled;\n-    }\n-\n-    public void enable() {\n-        enabled = true;\n-    }\n-\n-    public void disable() {\n-        enabled = false;\n-    }\n-\n-    /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n-     *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n-     */\n-    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n-        try {\n-            State current = null;\n-            if (channelData.containsKey(channelId)) {\n-                current = channelData.get(channelId);\n-            }\n-            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n-                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n-                    return false; // special case for OnOffType\n-                }\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                thingHandler.publishState(channelId, newValue);\n-                if (current == null) {\n-                    channelData.put(channelId, newValue);\n-                } else {\n-                    channelData.replace(channelId, newValue);\n-                }\n-                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n-                        newValue.getClass());\n-                return true;\n-            }\n-        } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n-                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n-        }\n-        return false;\n-    }\n-\n-    public boolean updateChannel(String group, String channel, State value) {\n-        return updateChannel(mkChannelId(group, channel), value, false);\n-    }\n-\n-    public boolean updateChannel(String channelId, State value) {\n-        return updateChannel(channelId, value, false);\n-    }\n-\n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getValue(String group, String channel) {\n-        return getValue(mkChannelId(group, channel));\n-    }\n-\n-    @Nullable\n-    public Object getValue(String channelId) {\n-        return channelData.get(channelId);\n-    }\n-\n-    public void resetChannel(String channelId) {\n-        channelData.remove(channelId);\n-    }\n-\n-    public void clear() {\n-        channelData.clear();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407738024", "bodyText": "Why couldn't you just do this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public int compare(Object o1, Object o2) {\n          \n          \n            \n                    String version1 = (String) o1;\n          \n          \n            \n                    String version2 = (String) o2;\n          \n          \n            \n                public int compare(String version1, String version2) {", "author": "cpmeister", "createdAt": "2020-04-13T21:41:03Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean MoveNext() {\n+            number = 0;\n+            suffix = \"\";\n+\n+            // No more characters\n+            if (position >= length) {\n+                return false;\n+            }\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                number = number * 10 + (c - '0');\n+                position++;\n+            }\n+\n+            int suffixStart = position;\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                position++;\n+            }\n+\n+            suffix = versionString.substring(suffixStart, position);\n+\n+            if (position < length) {\n+                position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        private int getNumber() {\n+            return number;\n+        }\n+\n+        private String getSuffix() {\n+            return suffix;\n+        }\n+    }\n+\n+    public boolean equals(String o1, String o2) {\n+        return compare(o1, o2) == 0;\n+    }\n+\n+    public int compare(Object o1, Object o2) {\n+        String version1 = (String) o1;\n+        String version2 = (String) o2;", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MzA0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408053041", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-14T11:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078196", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078502", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\ndeleted file mode 100644\nindex 27d3227240..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n+++ /dev/null\n\n@@ -1,174 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * {@link ShellyVersionDTO} compares 2 version strings.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyVersionDTO {\n-    private class VersionTokenizer {\n-        private final String versionString;\n-        private final int length;\n-\n-        private int position;\n-        private int number;\n-        private String suffix = \"\";\n-\n-        public VersionTokenizer(@Nullable String versionString) {\n-            if (versionString == null) {\n-                throw new IllegalArgumentException(\"versionString is null\");\n-            }\n-\n-            this.versionString = versionString;\n-            length = versionString.length();\n-        }\n-\n-        private boolean MoveNext() {\n-            number = 0;\n-            suffix = \"\";\n-\n-            // No more characters\n-            if (position >= length) {\n-                return false;\n-            }\n-\n-            while (position < length) {\n-                char c = versionString.charAt(position);\n-                if (c < '0' || c > '9') {\n-                    break;\n-                }\n-                number = number * 10 + (c - '0');\n-                position++;\n-            }\n-\n-            int suffixStart = position;\n-\n-            while (position < length) {\n-                char c = versionString.charAt(position);\n-                if (c == '.') {\n-                    break;\n-                }\n-                position++;\n-            }\n-\n-            suffix = versionString.substring(suffixStart, position);\n-\n-            if (position < length) {\n-                position++;\n-            }\n-\n-            return true;\n-        }\n-\n-        private int getNumber() {\n-            return number;\n-        }\n-\n-        private String getSuffix() {\n-            return suffix;\n-        }\n-    }\n-\n-    public boolean equals(String o1, String o2) {\n-        return compare(o1, o2) == 0;\n-    }\n-\n-    public int compare(Object o1, Object o2) {\n-        String version1 = (String) o1;\n-        String version2 = (String) o2;\n-\n-        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n-        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n-\n-        int number1 = 0, number2 = 0;\n-        String suffix1 = \"\", suffix2 = \"\";\n-\n-        while (tokenizer1.MoveNext()) {\n-            if (!tokenizer2.MoveNext()) {\n-                do {\n-                    number1 = tokenizer1.getNumber();\n-                    suffix1 = tokenizer1.getSuffix();\n-                    if (number1 != 0 || suffix1.length() != 0) {\n-                        // Version one is longer than number two, and non-zero\n-                        return 1;\n-                    }\n-                } while (tokenizer1.MoveNext());\n-\n-                // Version one is longer than version two, but zero\n-                return 0;\n-            }\n-\n-            number1 = tokenizer1.getNumber();\n-            suffix1 = tokenizer1.getSuffix();\n-            number2 = tokenizer2.getNumber();\n-            suffix2 = tokenizer2.getSuffix();\n-\n-            if (number1 < number2) {\n-                // Number one is less than number two\n-                return -1;\n-            }\n-            if (number1 > number2) {\n-                // Number one is greater than number two\n-                return 1;\n-            }\n-\n-            boolean empty1 = suffix1.length() == 0;\n-            boolean empty2 = suffix2.length() == 0;\n-\n-            if (empty1 && empty2) {\n-                continue;\n-            } // No suffixes\n-            if (empty1) {\n-                return 1;\n-            } // First suffix is empty (1.2 > 1.2b)\n-            if (empty2) {\n-                return -1;\n-            } // Second suffix is empty (1.2a < 1.2)\n-\n-            // Lexical comparison of suffixes\n-            int result = suffix1.compareTo(suffix2);\n-            if (result != 0) {\n-                return result;\n-            }\n-\n-        }\n-        if (tokenizer2.MoveNext()) {\n-            do {\n-                number2 = tokenizer2.getNumber();\n-                suffix2 = tokenizer2.getSuffix();\n-                if (number2 != 0 || suffix2.length() != 0) {\n-                    // Version one is longer than version two, and non-zero\n-                    return -1;\n-                }\n-            } while (tokenizer2.MoveNext());\n-\n-            // Version two is longer than version one, but zero\n-            return 0;\n-        }\n-        return 0;\n-    }\n-\n-    public boolean checkBeta(@Nullable String version) {\n-        if (version == null) {\n-            return false;\n-        }\n-        return version.isEmpty() || version.contains(\"???\") || version.toLowerCase().contains(\"master\")\n-                || (version.toLowerCase().contains(\"-rc\"));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407739180", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private boolean MoveNext() {\n          \n          \n            \n                    private boolean moveNext() {", "author": "cpmeister", "createdAt": "2020-04-13T21:43:39Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean MoveNext() {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MzMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408053339", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-14T11:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODMxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078319", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078586", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ea3c676f9f60a737b94db41273eca5de525e9132", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\ndeleted file mode 100644\nindex 27d3227240..0000000000\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n+++ /dev/null\n\n@@ -1,174 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.shelly.internal.util;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-\n-/**\n- * {@link ShellyVersionDTO} compares 2 version strings.\n- *\n- * @author Markus Michels - Initial contribution\n- */\n-@NonNullByDefault\n-public class ShellyVersionDTO {\n-    private class VersionTokenizer {\n-        private final String versionString;\n-        private final int length;\n-\n-        private int position;\n-        private int number;\n-        private String suffix = \"\";\n-\n-        public VersionTokenizer(@Nullable String versionString) {\n-            if (versionString == null) {\n-                throw new IllegalArgumentException(\"versionString is null\");\n-            }\n-\n-            this.versionString = versionString;\n-            length = versionString.length();\n-        }\n-\n-        private boolean MoveNext() {\n-            number = 0;\n-            suffix = \"\";\n-\n-            // No more characters\n-            if (position >= length) {\n-                return false;\n-            }\n-\n-            while (position < length) {\n-                char c = versionString.charAt(position);\n-                if (c < '0' || c > '9') {\n-                    break;\n-                }\n-                number = number * 10 + (c - '0');\n-                position++;\n-            }\n-\n-            int suffixStart = position;\n-\n-            while (position < length) {\n-                char c = versionString.charAt(position);\n-                if (c == '.') {\n-                    break;\n-                }\n-                position++;\n-            }\n-\n-            suffix = versionString.substring(suffixStart, position);\n-\n-            if (position < length) {\n-                position++;\n-            }\n-\n-            return true;\n-        }\n-\n-        private int getNumber() {\n-            return number;\n-        }\n-\n-        private String getSuffix() {\n-            return suffix;\n-        }\n-    }\n-\n-    public boolean equals(String o1, String o2) {\n-        return compare(o1, o2) == 0;\n-    }\n-\n-    public int compare(Object o1, Object o2) {\n-        String version1 = (String) o1;\n-        String version2 = (String) o2;\n-\n-        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n-        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n-\n-        int number1 = 0, number2 = 0;\n-        String suffix1 = \"\", suffix2 = \"\";\n-\n-        while (tokenizer1.MoveNext()) {\n-            if (!tokenizer2.MoveNext()) {\n-                do {\n-                    number1 = tokenizer1.getNumber();\n-                    suffix1 = tokenizer1.getSuffix();\n-                    if (number1 != 0 || suffix1.length() != 0) {\n-                        // Version one is longer than number two, and non-zero\n-                        return 1;\n-                    }\n-                } while (tokenizer1.MoveNext());\n-\n-                // Version one is longer than version two, but zero\n-                return 0;\n-            }\n-\n-            number1 = tokenizer1.getNumber();\n-            suffix1 = tokenizer1.getSuffix();\n-            number2 = tokenizer2.getNumber();\n-            suffix2 = tokenizer2.getSuffix();\n-\n-            if (number1 < number2) {\n-                // Number one is less than number two\n-                return -1;\n-            }\n-            if (number1 > number2) {\n-                // Number one is greater than number two\n-                return 1;\n-            }\n-\n-            boolean empty1 = suffix1.length() == 0;\n-            boolean empty2 = suffix2.length() == 0;\n-\n-            if (empty1 && empty2) {\n-                continue;\n-            } // No suffixes\n-            if (empty1) {\n-                return 1;\n-            } // First suffix is empty (1.2 > 1.2b)\n-            if (empty2) {\n-                return -1;\n-            } // Second suffix is empty (1.2a < 1.2)\n-\n-            // Lexical comparison of suffixes\n-            int result = suffix1.compareTo(suffix2);\n-            if (result != 0) {\n-                return result;\n-            }\n-\n-        }\n-        if (tokenizer2.MoveNext()) {\n-            do {\n-                number2 = tokenizer2.getNumber();\n-                suffix2 = tokenizer2.getSuffix();\n-                if (number2 != 0 || suffix2.length() != 0) {\n-                    // Version one is longer than version two, and non-zero\n-                    return -1;\n-                }\n-            } while (tokenizer2.MoveNext());\n-\n-            // Version two is longer than version one, but zero\n-            return 0;\n-        }\n-        return 0;\n-    }\n-\n-    public boolean checkBeta(@Nullable String version) {\n-        if (version == null) {\n-            return false;\n-        }\n-        return version.isEmpty() || version.contains(\"???\") || version.toLowerCase().contains(\"master\")\n-                || (version.toLowerCase().contains(\"-rc\"));\n-    }\n-}\n"}}, {"oid": "ea3c676f9f60a737b94db41273eca5de525e9132", "url": "https://github.com/openhab/openhab-addons/commit/ea3c676f9f60a737b94db41273eca5de525e9132", "message": "[sensebox] Added German translations (#7384)\n\n* Added German translations\r\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-04-17T05:51:13Z", "type": "forcePushed"}, {"oid": "b4f93244dafd48fcc45c89c612bc7fd90ce338b6", "url": "https://github.com/openhab/openhab-addons/commit/b4f93244dafd48fcc45c89c612bc7fd90ce338b6", "message": "Re-checkin based on latest PR review status\n\nSigned-off-by: Markus Michels <markus7017@gmail.com> (github: markus7017)", "committedDate": "2020-04-17T12:36:41Z", "type": "commit"}, {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "url": "https://github.com/openhab/openhab-addons/commit/0f8b13e2ef4c7b4ec0f58a02905581c384709218", "message": "delete obsolete files from 2.5.2 version\n\nSigned-off-by: Markus Michels <markus7017@gmail.com> (github: markus7017)", "committedDate": "2020-04-17T12:38:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NDE4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410384189", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (tokenizer2.moveNext()) {\n          \n          \n            \n                        do {\n          \n          \n            \n                            number2 = tokenizer2.getNumber();\n          \n          \n            \n                            suffix2 = tokenizer2.getSuffix();\n          \n          \n            \n                            if (number2 != 0 || suffix2.length() != 0) {\n          \n          \n            \n                                // Version one is longer than version two, and non-zero\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            }\n          \n          \n            \n                        } while (tokenizer2.moveNext());\n          \n          \n            \n            \n          \n          \n            \n                        // Version two is longer than version one, but zero\n          \n          \n            \n                        return 0;\n          \n          \n            \n                    }\n          \n          \n            \n                    return 0;\n          \n          \n            \n                    while (tokenizer2.moveNext()) {\n          \n          \n            \n                            number2 = tokenizer2.getNumber();\n          \n          \n            \n                            suffix2 = tokenizer2.getSuffix();\n          \n          \n            \n                            if (number2 != 0 || suffix2.length() != 0) {\n          \n          \n            \n                                // Version one is longer than version two, and non-zero\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            }\n          \n          \n            \n                    }\n          \n          \n            \n                    // Version two is longer than version one, but zero\n          \n          \n            \n                    return 0;", "author": "cpmeister", "createdAt": "2020-04-17T18:01:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean moveNext() {\n+            number = 0;\n+            suffix = \"\";\n+\n+            // No more characters\n+            if (position >= length) {\n+                return false;\n+            }\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                number = number * 10 + (c - '0');\n+                position++;\n+            }\n+\n+            int suffixStart = position;\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                position++;\n+            }\n+\n+            suffix = versionString.substring(suffixStart, position);\n+\n+            if (position < length) {\n+                position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        private int getNumber() {\n+            return number;\n+        }\n+\n+        private String getSuffix() {\n+            return suffix;\n+        }\n+    }\n+\n+    public boolean equals(String s1, String s2) {\n+        return compare(s1, s2) == 0;\n+    }\n+\n+    public int compare(String version1, String version2) {\n+        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n+        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n+\n+        int number1 = 0, number2 = 0;\n+        String suffix1 = \"\", suffix2 = \"\";\n+\n+        while (tokenizer1.moveNext()) {\n+            if (!tokenizer2.moveNext()) {\n+                do {\n+                    number1 = tokenizer1.getNumber();\n+                    suffix1 = tokenizer1.getSuffix();\n+                    if (number1 != 0 || suffix1.length() != 0) {\n+                        // Version one is longer than number two, and non-zero\n+                        return 1;\n+                    }\n+                } while (tokenizer1.moveNext());\n+\n+                // Version one is longer than version two, but zero\n+                return 0;\n+            }\n+\n+            number1 = tokenizer1.getNumber();\n+            suffix1 = tokenizer1.getSuffix();\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+\n+            if (number1 < number2) {\n+                // Number one is less than number two\n+                return -1;\n+            }\n+            if (number1 > number2) {\n+                // Number one is greater than number two\n+                return 1;\n+            }\n+\n+            boolean empty1 = suffix1.length() == 0;\n+            boolean empty2 = suffix2.length() == 0;\n+\n+            if (empty1 && empty2) {\n+                continue;\n+            } // No suffixes\n+            if (empty1) {\n+                return 1;\n+            } // First suffix is empty (1.2 > 1.2b)\n+            if (empty2) {\n+                return -1;\n+            } // Second suffix is empty (1.2a < 1.2)\n+\n+            // Lexical comparison of suffixes\n+            int result = suffix1.compareTo(suffix2);\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+        }\n+        if (tokenizer2.moveNext()) {\n+            do {\n+                number2 = tokenizer2.getNumber();\n+                suffix2 = tokenizer2.getSuffix();\n+                if (number2 != 0 || suffix2.length() != 0) {\n+                    // Version one is longer than version two, and non-zero\n+                    return -1;\n+                }\n+            } while (tokenizer2.moveNext());\n+\n+            // Version two is longer than version one, but zero\n+            return 0;\n+        }\n+        return 0;", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NTgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410655801", "bodyText": "changed, test open", "author": "markus7017", "createdAt": "2020-04-18T06:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NDE4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a01f1148c8e74a4abcc1b7036224da00db917577", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\nindex fe5f829f34..4d19026a46 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java\n\n@@ -145,19 +145,16 @@ public class ShellyVersionDTO {\n             }\n \n         }\n-        if (tokenizer2.moveNext()) {\n-            do {\n-                number2 = tokenizer2.getNumber();\n-                suffix2 = tokenizer2.getSuffix();\n-                if (number2 != 0 || suffix2.length() != 0) {\n-                    // Version one is longer than version two, and non-zero\n-                    return -1;\n-                }\n-            } while (tokenizer2.moveNext());\n \n-            // Version two is longer than version one, but zero\n-            return 0;\n+        while (tokenizer2.moveNext()) {\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+            if (number2 != 0 || suffix2.length() != 0) {\n+                // Version one is longer than version two, and non-zero\n+                return -1;\n+            }\n         }\n+        // Version two is longer than version one, but zero\n         return 0;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMTE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410421150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n          \n          \n            \n                                deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}\",\n          \n          \n            \n                                deviceName, path, data, index, type, request.getParameterMap().toString(), e);", "author": "cpmeister", "createdAt": "2020-04-17T19:15:50Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -113,52 +116,20 @@ protected void service(@Nullable HttpServletRequest request, @Nullable HttpServl\n                 index = \"\";\n                 type = StringUtils.substringAfterLast(path, \"/\").toLowerCase();\n             }\n-            logger.trace(\"Process event of type type={} for device {}, index={}\", type, deviceName, index);\n-            Map<String, String> parms = new HashMap<>();\n+            logger.trace(\"{}: Process event of type type={}, index={}\", deviceName, type, index);\n+            Map<String, String> parms = new TreeMap<>();\n+\n             for (Map.Entry<String, String[]> p : parameters.entrySet()) {\n                 parms.put(p.getKey(), p.getValue()[0]);\n \n             }\n-            handlerFactory.onEvent(deviceName, index, type, parms);\n-\n-        } catch (NullPointerException e) {\n-            logger.debug(\n-                    \"ERROR: Exception processing callback: {} ({}), path={}, data='{}'; deviceName={}, index={}, type={}, parameters={}\\n{}\",\n-                    e.getMessage(), e.getClass(), path, data, deviceName, index, type,\n-                    request.getParameterMap().toString(), e.getStackTrace());\n+            handlerFactory.onEvent(ipAddress, deviceName, index, type, parms);\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n+                    deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NjA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656057", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T06:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMTE1MA=="}], "type": "inlineReview", "revised_code": {"commit": "a01f1148c8e74a4abcc1b7036224da00db917577", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\nindex bf7e25968d..34c35a07e5 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java\n\n@@ -125,8 +125,8 @@ public class ShellyEventServlet extends HttpServlet {\n             }\n             handlerFactory.onEvent(ipAddress, deviceName, index, type, parms);\n         } catch (IllegalArgumentException e) {\n-            logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n-                    deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());\n+            logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}\",\n+                    deviceName, path, data, index, type, request.getParameterMap().toString());\n         } finally {\n             resp.setCharacterEncoding(StandardCharsets.UTF_8.toString());\n             resp.getWriter().write(\"\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410425947", "bodyText": "It would be more concise if you changed your setEventUrl method to accept multiple event types\nprivate void setEventUrl(String deviceClass, Integer index, boolean enabled, String... eventTypes){\n    for(String eventType : eventTypes){\n        if (profile.containsEventUrl(eventType)) {\n        ...\n        }\n    }\n}\n\nThat way you can call it like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n          \n          \n            \n            \n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n          \n          \n            \n            \n          \n          \n            \n                        // Relay output\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF, SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1, SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n          \n          \n            \n            \n          \n          \n            \n                        // Relay output\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);", "author": "cpmeister", "createdAt": "2020-04-17T19:26:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,221 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_CLOSE, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_VIBRATION, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n+        String type = \"\";\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NjM1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656357", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T06:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a01f1148c8e74a4abcc1b7036224da00db917577", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 1af02308a9..373c5e809c 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -366,13 +366,8 @@ public class ShellyHttpApi {\n     private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n         if (profile.isSensor) {\n             logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n-            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_CLOSE, config.eventsSensorReport);\n-            setEventUrl(SHELLY_EVENT_VIBRATION, config.eventsSensorReport);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429024", "bodyText": "I don't know what kind of processing goes on behind response.getSourceContext().getPeerAddress() and response.getPayloadString(). But to be safe you should probably make sure those are only called when necessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n          \n          \n            \n                                response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n          \n          \n            \n                        if(logger.isDebugEnabled()){\n          \n          \n            \n                            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n          \n          \n            \n                                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-04-17T19:33:14Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -141,8 +158,8 @@ public void processResponse(@Nullable Response response) {\n         // int validity = 0;\n         int serial = 0;\n         try {\n-            logger.debug(\"{}: CoIoT Message from {}: {}\", thingName, response.getSourceContext().getPeerAddress(),\n-                    response.toString());\n+            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n+                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NjY4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656688", "bodyText": "those are just picking some attributes of the message\nchanged", "author": "markus7017", "createdAt": "2020-04-18T06:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "a01f1148c8e74a4abcc1b7036224da00db917577", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 680f8bd206..49d0674b54 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -158,8 +158,10 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n         // int validity = 0;\n         int serial = 0;\n         try {\n-            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n-                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n+                        response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n+            }\n             if (response.isCanceled() || response.isDuplicate() || response.isRejected()) {\n                 logger.debug(\"{} ({}): Packet was canceled, rejected or is a duplicate -> discard\", thingName, devId);\n                 return;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429473", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n          \n          \n            \n                                        case \"external temperature f\": // Shelly 1/1PM external temp sensors", "author": "cpmeister", "createdAt": "2020-04-17T19:34:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -329,50 +332,84 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n \n         // Parse Json,\n         CoIotGenericSensorList list = gson.fromJson(payload, CoIotGenericSensorList.class);\n-        Validate.notNull(list, \"sensor list must not be empty!\");\n-        Map<String, State> updates = new HashMap<>();\n-\n         if (list.generic == null) {\n-            logger.debug(\"{}: Sensor list is empty! Payload: {}\", devId, payload);\n+            logger.debug(\"{}: Sensor list has invalid format! Payload: {}\", devId, payload);\n             return;\n         }\n+        List<CoIotSensor> sensorUpdates = list.generic;\n \n-        Validate.notNull(thingHandler, \"thingHandler must not be null!\");\n         ShellyDeviceProfile profile = thingHandler.getProfile();\n-        if (profile == null) {\n-            logger.debug(\"{}: Thing not initialized yet, skip update (ID={})\", thingName, devId);\n-            thingHandler.requestUpdates(1, true);\n-            return;\n-        }\n-\n-        logger.debug(\"{}: {}\u00a0status updates received\", thingName, new Integer(list.generic.size()).toString());\n-        for (int i = 0; i < list.generic.size(); i++) {\n-            CoIotSensor s = list.generic.get(i);\n-            CoIotDescrSen sen = sensorMap.get(s.index);\n-            if (sen != null) {\n-                // find matching sensor definition from device description, use the Link ID as\n-                // index\n-                Validate.notNull(sen.links != null, \"Coap: sen.L must not be null!\");\n+        Map<String, State> updates = new TreeMap<String, State>();\n+        logger.debug(\"{}: {}\u00a0CoAP sensor updates received\", thingName, sensorUpdates.size());\n+        for (int i = 0; i < sensorUpdates.size(); i++) {\n+            try {\n+                CoIotSensor s = sensorUpdates.get(i);\n+                if (!sensorMap.containsKey(s.id)) {\n+                    logger.debug(\"{}: Invalid index in sensor description: {}\", thingName, i);\n+                    continue;\n+                }\n+                CoIotDescrSen sen = sensorMap.get(s.id);\n+                // find matching sensor definition from device description, use the Link ID as index\n                 sen = fixDescription(sen);\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Invalid CoAP description: sen.links({}\", thingName, getString(sen.links));\n+                    continue;\n+                }\n+\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Unable to find BLK for link {} from sen.id={}\", thingName, sen.links, sen.id);\n+                    continue;\n+                }\n                 CoIotDescrBlk element = blockMap.get(sen.links);\n-                logger.debug(\"{}:  Sensor value[{}]: Index={}, Value={} ({}, Type={}, Range={}, Link={}: {})\",\n-                        thingName, i, s.index, s.value, sen.desc, sen.type, sen.range, sen.links,\n-                        element != null ? element.desc : \"n/a\");\n+                logger.trace(\"{}:  Sensor value[{}]: id={}, Value={} ({}, Type={}, Range={}, Link={}: {})\", thingName,\n+                        i, s.id, s.value, sen.desc, sen.type, sen.range, sen.links, element.desc);\n \n                 // Process status information and convert into channel updates\n-                String type = (element != null ? element.desc : \"\").toLowerCase();\n                 Integer rIndex = Integer.parseInt(sen.links) + 1;\n                 String rGroup = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                         : CHANNEL_GROUP_RELAY_CONTROL + rIndex;\n \n-                switch (sen.type.toLowerCase()) /* CoIoT_STypes.valueOf(sen.T) */ {\n+                switch (sen.type.toLowerCase()) {\n                     case \"b\" /* BatteryLevel */:\n                         updateChannel(updates, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL,\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\": // Sensor Temp\n+                                if (getString(profile.settings.temperatureUnits)\n+                                        .equalsIgnoreCase(SHELLY_TEMP_FAHRENHEIT)) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+                            case \"temperature f\": // Device Temp -> ignore (we use C only)\n+                                break;\n+                            case \"temperature c\": // Device Tem\u00fc in C\n+                                // Device temperature\n+                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n+                                        toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n+                                break;\n+                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY2ODQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410668477", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T08:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a01f1148c8e74a4abcc1b7036224da00db917577", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 680f8bd206..49d0674b54 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -393,10 +395,10 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n                                 updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n                                         toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n                                 break;\n-                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                            case \"external temperature f\": // Shelly 1/1PM external temp sensors\n                                 // ignore F, we use C only\n                                 break;\n-                            case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                            case \"external temperature c\": // Shelly 1/1PM external temp sensors\n                             case \"external_temperature\":\n                                 int idx = getExtTempId(sen.id);\n                                 if (idx > 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors\n          \n          \n            \n                                        case \"external temperature c\": // Shelly 1/1PM external temp sensors", "author": "cpmeister", "createdAt": "2020-04-17T19:34:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -329,50 +332,84 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n \n         // Parse Json,\n         CoIotGenericSensorList list = gson.fromJson(payload, CoIotGenericSensorList.class);\n-        Validate.notNull(list, \"sensor list must not be empty!\");\n-        Map<String, State> updates = new HashMap<>();\n-\n         if (list.generic == null) {\n-            logger.debug(\"{}: Sensor list is empty! Payload: {}\", devId, payload);\n+            logger.debug(\"{}: Sensor list has invalid format! Payload: {}\", devId, payload);\n             return;\n         }\n+        List<CoIotSensor> sensorUpdates = list.generic;\n \n-        Validate.notNull(thingHandler, \"thingHandler must not be null!\");\n         ShellyDeviceProfile profile = thingHandler.getProfile();\n-        if (profile == null) {\n-            logger.debug(\"{}: Thing not initialized yet, skip update (ID={})\", thingName, devId);\n-            thingHandler.requestUpdates(1, true);\n-            return;\n-        }\n-\n-        logger.debug(\"{}: {}\u00a0status updates received\", thingName, new Integer(list.generic.size()).toString());\n-        for (int i = 0; i < list.generic.size(); i++) {\n-            CoIotSensor s = list.generic.get(i);\n-            CoIotDescrSen sen = sensorMap.get(s.index);\n-            if (sen != null) {\n-                // find matching sensor definition from device description, use the Link ID as\n-                // index\n-                Validate.notNull(sen.links != null, \"Coap: sen.L must not be null!\");\n+        Map<String, State> updates = new TreeMap<String, State>();\n+        logger.debug(\"{}: {}\u00a0CoAP sensor updates received\", thingName, sensorUpdates.size());\n+        for (int i = 0; i < sensorUpdates.size(); i++) {\n+            try {\n+                CoIotSensor s = sensorUpdates.get(i);\n+                if (!sensorMap.containsKey(s.id)) {\n+                    logger.debug(\"{}: Invalid index in sensor description: {}\", thingName, i);\n+                    continue;\n+                }\n+                CoIotDescrSen sen = sensorMap.get(s.id);\n+                // find matching sensor definition from device description, use the Link ID as index\n                 sen = fixDescription(sen);\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Invalid CoAP description: sen.links({}\", thingName, getString(sen.links));\n+                    continue;\n+                }\n+\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Unable to find BLK for link {} from sen.id={}\", thingName, sen.links, sen.id);\n+                    continue;\n+                }\n                 CoIotDescrBlk element = blockMap.get(sen.links);\n-                logger.debug(\"{}:  Sensor value[{}]: Index={}, Value={} ({}, Type={}, Range={}, Link={}: {})\",\n-                        thingName, i, s.index, s.value, sen.desc, sen.type, sen.range, sen.links,\n-                        element != null ? element.desc : \"n/a\");\n+                logger.trace(\"{}:  Sensor value[{}]: id={}, Value={} ({}, Type={}, Range={}, Link={}: {})\", thingName,\n+                        i, s.id, s.value, sen.desc, sen.type, sen.range, sen.links, element.desc);\n \n                 // Process status information and convert into channel updates\n-                String type = (element != null ? element.desc : \"\").toLowerCase();\n                 Integer rIndex = Integer.parseInt(sen.links) + 1;\n                 String rGroup = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                         : CHANNEL_GROUP_RELAY_CONTROL + rIndex;\n \n-                switch (sen.type.toLowerCase()) /* CoIoT_STypes.valueOf(sen.T) */ {\n+                switch (sen.type.toLowerCase()) {\n                     case \"b\" /* BatteryLevel */:\n                         updateChannel(updates, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL,\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\": // Sensor Temp\n+                                if (getString(profile.settings.temperatureUnits)\n+                                        .equalsIgnoreCase(SHELLY_TEMP_FAHRENHEIT)) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+                            case \"temperature f\": // Device Temp -> ignore (we use C only)\n+                                break;\n+                            case \"temperature c\": // Device Tem\u00fc in C\n+                                // Device temperature\n+                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n+                                        toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n+                                break;\n+                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                                // ignore F, we use C only\n+                                break;\n+                            case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1Njc0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656743", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T06:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a01f1148c8e74a4abcc1b7036224da00db917577", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\nindex 680f8bd206..49d0674b54 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java\n\n@@ -393,10 +395,10 @@ public class ShellyCoapHandler implements ShellyCoapListener {\n                                 updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n                                         toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n                                 break;\n-                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                            case \"external temperature f\": // Shelly 1/1PM external temp sensors\n                                 // ignore F, we use C only\n                                 break;\n-                            case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                            case \"external temperature c\": // Shelly 1/1PM external temp sensors\n                             case \"external_temperature\":\n                                 int idx = getExtTempId(sen.id);\n                                 if (idx > 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410431181", "bodyText": "shouldn't this be synchronized too?", "author": "cpmeister", "createdAt": "2020-04-17T19:37:57Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java", "diffHunk": "@@ -140,20 +122,25 @@ public CoapEndpoint getEndpoint() {\n     /**\n      * Cancel pending requests and shutdown the client\n      */\n-    @SuppressWarnings(\"null\")\n-    public void stop() {\n+    public void stop(ShellyCoapListener listener) {\n+        coapListeners.remove(listener);\n+        if (coapListeners.isEmpty()) {\n+            stop();\n+        }\n+    }\n+\n+    private void stop() {", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1Nzg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410657897", "bodyText": "I added synchronized to addSensor() and stop()", "author": "markus7017", "createdAt": "2020-04-18T06:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMDIxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410710210", "bodyText": "You made start() synchronized which doesn't set the started field to true until the very end. But in this stop() method you are checking it at the very start, unsychronized. What I'm worried about is if start() and stop() are called concurrently that your stop() will exit early thinking that things aren't started when in fact the start() method simply has finished executing yet. Making the stop() method synchronized would prevent this from happening.", "author": "cpmeister", "createdAt": "2020-04-18T15:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMDU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410710596", "bodyText": "Also, shouldn't this method set started to false?", "author": "cpmeister", "createdAt": "2020-04-18T15:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0ODUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410748514", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-18T20:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a11489005e446da3c7f7886065a3a5d42a4acc72", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java\nindex 0fc5146a0f..1ab9638e74 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java\n\n@@ -129,12 +129,13 @@ public class ShellyCoapServer {\n         }\n     }\n \n-    private void stop() {\n+    private synchronized void stop() {\n         if (started) {\n             // Last listener\n             server.stop();\n             statusEndpoint.stop();\n             coapListeners.clear();\n+            started = false;\n             logger.debug(\"CoAP Listener stopped\");\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410432765", "bodyText": "You shouldn't log this, thing status changes are already logged for you.", "author": "cpmeister", "createdAt": "2020-04-17T19:41:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -350,100 +360,113 @@ protected void updateStatus() {\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                if (getThing().getStatus() != ThingStatus.ONLINE) {\n-                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n-                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n-                }\n+                setThingOnline();\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                logger.debug(\"{}: Ignore API Timeout, retry later\", thingName);\n+                // next release will implement a watchdog here\n+                // status = \"offline.status-error-timeout\";\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n+            } else if (e.IsJSONException()) {\n+                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unable to parse API response: {}; json={}\", thingName, res.getUrl(), res.response, e);\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unexpected API result: {}\", thingName, res.response, e);\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to refresh status: {}\", thingName, messages.get(\"statusupdate.failed\"), e);\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            }\n-            if ((skipUpdate >= cacheCount) && !channelCache) {\n+                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            } else if ((skipUpdate >= cacheCount) && !cache.isEnabled()) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                channelCache = true;\n+                cache.enable();\n             }\n         }\n+    }\n+\n+    public boolean isThingOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    public boolean isThingOffline() {\n+        return getThing().getStatus() == ThingStatus.OFFLINE;\n+    }\n+\n+    public void setThingOnline() {\n+        if (!isThingOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n \n+            // request 3 updates in a row (during the first 2+3*3 sec)\n+            requestUpdates(!profile.hasBattery ? 3 : 1, channelsCreated == false);\n+        }\n+    }\n+\n+    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n+        if (!isThingOffline()) {\n+            logger.info(\"{}: Thing goes OFFLINE: {}\", thingName, messages.get(messageKey));", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1Njk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656957", "bodyText": "I need the thingName, this provides an easy way to extract messages relevant for one thing from the big openhab.log", "author": "markus7017", "createdAt": "2020-04-18T06:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjc2NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "a01f1148c8e74a4abcc1b7036224da00db917577", "url": "https://github.com/openhab/openhab-addons/commit/a01f1148c8e74a4abcc1b7036224da00db917577", "message": "More changes from review (functional change to version detection and\nsetting action urls)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T08:29:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410708866", "bodyText": "You forgot to change this\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return;\n          \n          \n            \n                                continue;", "author": "cpmeister", "createdAt": "2020-04-18T15:02:23Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,210 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n-            }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, config.eventsRoller, SHELLY_EVENT_ROLLER_OPEN, SHELLY_EVENT_ROLLER_CLOSE,\n+                    SHELLY_EVENT_ROLLER_STOP);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF,\n+                    SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1,\n+                    SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsButton, SHELLY_EVENT_BTN_ON, SHELLY_EVENT_BTN_OFF);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH, SHELLY_EVENT_LONGPUSH);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        }\n+    }\n+\n+    private void setEventUrl(boolean enabled, String... eventTypes) throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                // Sensors add the type=xx to report_url themself, so we need to ommit here\n+                String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+                String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                        + profile.thingName + \"/\" + eventType + urlParm;\n+                String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+                if (!enabled && !profile.settingsJson.contains(test)) {\n+                    // Don't set URL to null when the current one doesn't point to this OH\n+                    // Don't interfere with a 3rd party App\n+                    return;", "originalCommit": "a01f1148c8e74a4abcc1b7036224da00db917577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxOTMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410719315", "bodyText": "good catch, thanks", "author": "markus7017", "createdAt": "2020-04-18T16:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "91cc31f87382af1c14776d2abb07f329c183d9f6", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 373c5e809c..20941dd9c2 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -413,7 +413,7 @@ public class ShellyHttpApi {\n                 if (!enabled && !profile.settingsJson.contains(test)) {\n                     // Don't set URL to null when the current one doesn't point to this OH\n                     // Don't interfere with a 3rd party App\n-                    return;\n+                    continue;\n                 }\n                 if (!profile.settingsJson.contains(test)) {\n                     // Current Action URL is != new URL\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410709012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return;\n          \n          \n            \n                                    continue;", "author": "cpmeister", "createdAt": "2020-04-18T15:03:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,210 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n-            }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, config.eventsRoller, SHELLY_EVENT_ROLLER_OPEN, SHELLY_EVENT_ROLLER_CLOSE,\n+                    SHELLY_EVENT_ROLLER_STOP);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF,\n+                    SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1,\n+                    SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsButton, SHELLY_EVENT_BTN_ON, SHELLY_EVENT_BTN_OFF);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH, SHELLY_EVENT_LONGPUSH);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        }\n+    }\n+\n+    private void setEventUrl(boolean enabled, String... eventTypes) throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                // Sensors add the type=xx to report_url themself, so we need to ommit here\n+                String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+                String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                        + profile.thingName + \"/\" + eventType + urlParm;\n+                String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+                if (!enabled && !profile.settingsJson.contains(test)) {\n+                    // Don't set URL to null when the current one doesn't point to this OH\n+                    // Don't interfere with a 3rd party App\n+                    return;\n+                }\n+                if (!profile.settingsJson.contains(test)) {\n+                    // Current Action URL is != new URL\n+                    request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n                 }\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n-            }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, boolean enabled, String... eventTypes)\n+            throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                if (profile.containsEventUrl(eventType)) {\n+                    String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                            + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+                    String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                    String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+                    if (!enabled && !profile.settingsJson.contains(test)) {\n+                        // Don't set URL to null when the current one doesn't point to this OH\n+                        // Don't interfere with a 3rd party App\n+                        return;", "originalCommit": "a01f1148c8e74a4abcc1b7036224da00db917577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxOTMxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410719311", "bodyText": "good catch, thanks", "author": "markus7017", "createdAt": "2020-04-18T16:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "91cc31f87382af1c14776d2abb07f329c183d9f6", "chunk": "diff --git a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\nindex 373c5e809c..20941dd9c2 100644\n--- a/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n+++ b/bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java\n\n@@ -413,7 +413,7 @@ public class ShellyHttpApi {\n                 if (!enabled && !profile.settingsJson.contains(test)) {\n                     // Don't set URL to null when the current one doesn't point to this OH\n                     // Don't interfere with a 3rd party App\n-                    return;\n+                    continue;\n                 }\n                 if (!profile.settingsJson.contains(test)) {\n                     // Current Action URL is != new URL\n"}}, {"oid": "91cc31f87382af1c14776d2abb07f329c183d9f6", "url": "https://github.com/openhab/openhab-addons/commit/91cc31f87382af1c14776d2abb07f329c183d9f6", "message": "change fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T16:30:57Z", "type": "commit"}, {"oid": "a60d58e444374efd2752e20d213886e0e50a7330", "url": "https://github.com/openhab/openhab-addons/commit/a60d58e444374efd2752e20d213886e0e50a7330", "message": "synchronize start()\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T20:31:46Z", "type": "commit"}, {"oid": "a11489005e446da3c7f7886065a3a5d42a4acc72", "url": "https://github.com/openhab/openhab-addons/commit/a11489005e446da3c7f7886065a3a5d42a4acc72", "message": "synchronized added to start/stop\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T20:45:52Z", "type": "commit"}]}