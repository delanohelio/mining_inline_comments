{"pr_number": 9187, "pr_title": "[homeconnect] Initial contribution", "pr_createdAt": "2020-11-30T19:03:01Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9187", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536994880", "bodyText": "Generally set directly when defining the variable.\nSame comment for all classes.", "author": "lolodomo", "createdAt": "2020-12-06T09:12:44Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final Queue<Event> eventQueue;\n+\n+    private final Logger logger;\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(EVENT_QUEUE_SIZE));\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2NDAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r544964021", "bodyText": "Is this required? I like it more the way it is. All my variable definitions are made in the constructor. I don't want to mix it.", "author": "bruestel", "createdAt": "2020-12-17T10:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAyNjQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545026453", "bodyText": "All other official bindings I look at in the past are using the other way.\nAn official reviewer will let you know if this is required or not.", "author": "lolodomo", "createdAt": "2020-12-17T11:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg5MzQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558893478", "bodyText": "Changed it.", "author": "bruestel", "createdAt": "2021-01-16T13:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\nindex 6f63732069..69c61dd894 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n\n@@ -15,16 +15,14 @@ package org.openhab.binding.homeconnect.internal.client;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n \n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Queue;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.stream.Collectors;\n \n-import org.apache.commons.collections4.QueueUtils;\n-import org.apache.commons.collections4.queue.CircularFifoQueue;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NTA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536995040", "bodyText": "Connect", "author": "lolodomo", "createdAt": "2020-12-06T09:13:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final Queue<Event> eventQueue;\n+\n+    private final Logger logger;\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(EVENT_QUEUE_SIZE));\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Conncet API. This helps to reduce the", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\nindex 6f63732069..69c61dd894 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n\n@@ -15,16 +15,14 @@ package org.openhab.binding.homeconnect.internal.client;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n \n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.Queue;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.stream.Collectors;\n \n-import org.apache.commons.collections4.QueueUtils;\n-import org.apache.commons.collections4.queue.CircularFifoQueue;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5ODMyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536998320", "bodyText": "Why not using the constant you defined in HomeConnectBindingConstants ?\nSame comment for other methods.", "author": "lolodomo", "createdAt": "2020-12-06T09:32:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+        jsonParser = new JsonParser();\n+        communicationQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(COMMUNICATION_QUEUE_SIZE));\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(\"/api/homeappliances\");\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(\"/api/homeappliances/\" + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, \"BSH.Common.Setting.AmbientLightEnabled\");", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2NTQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r544965440", "bodyText": "I used the API client class in another private project. Will adjust it. It's better to use constants.", "author": "bruestel", "createdAt": "2020-12-17T10:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5ODMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 1b33a1ae37..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -23,6 +23,23 @@ import static java.util.Objects.requireNonNull;\n import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4ODkwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538688908", "bodyText": "You can simplufy your class by extending BaseDynamicStateDescriptionProvider like in most of other bindings.", "author": "lolodomo", "createdAt": "2020-12-08T18:20:03Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.type;\n+\n+import java.util.Locale;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic thing values.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class HomeConnectDynamicStateDescriptionProvider implements DynamicStateDescriptionProvider {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM4MDUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r546380523", "bodyText": "Thanks for the hint. I was able to remove a couple of lines of code. \ud83d\udc4d", "author": "bruestel", "createdAt": "2020-12-20T13:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4ODkwOA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java\nindex 2312c32830..bfa35daa1f 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java\n\n@@ -12,55 +12,18 @@\n  */\n package org.openhab.binding.homeconnect.internal.type;\n \n-import java.util.Locale;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.binding.BaseDynamicStateDescriptionProvider;\n import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n-import org.openhab.core.types.StateDescription;\n-import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic thing values.\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic values.\n  *\n  * @author Jonas Br\u00fcstel - Initial contribution\n  */\n @Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n @NonNullByDefault\n-public class HomeConnectDynamicStateDescriptionProvider implements DynamicStateDescriptionProvider {\n-\n-    private final ConcurrentHashMap<String, StateDescription> stateDescriptions = new ConcurrentHashMap<>();\n-    private final Logger logger;\n-\n-    @Activate\n-    public HomeConnectDynamicStateDescriptionProvider() {\n-        logger = LoggerFactory.getLogger(HomeConnectDynamicStateDescriptionProvider.class);\n-    }\n-\n-    @Override\n-    public @Nullable StateDescription getStateDescription(Channel channel,\n-            @Nullable StateDescription originalStateDescription, @Nullable Locale locale) {\n-        if (stateDescriptions.containsKey(channel.getUID().getAsString())) {\n-            logger.debug(\"Return dynamic state description for channel-uid {}. stateDescription={}\",\n-                    channel.getUID().getAsString(), stateDescriptions.get(channel.getUID().getAsString()));\n-            return stateDescriptions.get(channel.getUID().getAsString());\n-        }\n-\n-        return null;\n-    }\n-\n-    public void putStateDescriptions(String channelUid, StateDescription stateDescription) {\n-        logger.debug(\"Adding state description for channel-uid: {}. stateDescription={}\", channelUid, stateDescription);\n-        stateDescriptions.put(channelUid, stateDescription);\n-    }\n+public class HomeConnectDynamicStateDescriptionProvider extends BaseDynamicStateDescriptionProvider {\n \n-    public void removeStateDescriptions(String channelUid) {\n-        logger.debug(\"Removing state description for channel-uid: {}.\", channelUid);\n-        stateDescriptions.remove(channelUid);\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY5MTU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538691572", "bodyText": "\"were sent\" I believe", "author": "lolodomo", "createdAt": "2020-12-08T18:22:38Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+\n+/**\n+ * The {@link EventHandler} is responsible for handling events, which where send via Server-Sent event interface.", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java\nindex 6e853e2e30..13ee01c863 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java\n\n@@ -16,7 +16,7 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.binding.homeconnect.internal.client.model.Event;\n \n /**\n- * The {@link EventHandler} is responsible for handling events, which where send via Server-Sent event interface.\n+ * The {@link EventHandler} is responsible for handling events, which were sent via Server-Sent event interface.\n  *\n  * @author Jonas Br\u00fcstel - Initial contribution\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538703672", "bodyText": "Implements ThingHandlerService.\nThis will simplify a lot of your thing handler factory.\nIn your bridge handler add, the method getServices.", "author": "lolodomo", "createdAt": "2020-12-08T18:34:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5NTg1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545095859", "bodyText": "I don't get this. Can you please give me more context.", "author": "bruestel", "createdAt": "2020-12-17T13:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk4MzExOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548983118", "bodyText": "Below I provided the code changes.", "author": "lolodomo", "createdAt": "2020-12-26T13:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg5Mzc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558893764", "bodyText": "Changed it", "author": "bruestel", "createdAt": "2021-01-16T13:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwNTIxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538705217", "bodyText": "DEBUG level is better", "author": "lolodomo", "createdAt": "2020-12-08T18:35:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwNzA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538707075", "bodyText": "Add .withRepresentationProperty(HA_ID)", "author": "lolodomo", "createdAt": "2020-12-08T18:37:35Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538709005", "bodyText": "What's the utility of this line ?", "author": "lolodomo", "createdAt": "2020-12-08T18:39:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5NTM0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545095343", "bodyText": "Changed it to if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)), due to other refactoring.\nThis filters the discovered Home Connect appliances. Only certain thing types are allowed. I think I've copied it from another binding.", "author": "bruestel", "createdAt": "2020-12-17T13:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMzM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548503385", "bodyText": "My understanding of this line is that you will get the HA_ID for each thing, but that's all. It will do nothing and looks as useless.", "author": "lolodomo", "createdAt": "2020-12-24T11:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODgzMTA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558831058", "bodyText": "Yes it became useless. I will remove it.", "author": "bruestel", "createdAt": "2021-01-16T09:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538710047", "bodyText": "You could use Map<String, Object> properties = Map.of(HA_ID, appliance.getHaId());", "author": "lolodomo", "createdAt": "2020-12-08T18:40:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA5ODQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545098452", "bodyText": "Cannot change it now. I need to be Java 1.8 compatible.", "author": "bruestel", "createdAt": "2020-12-17T13:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904407", "bodyText": "Why do you need to be Java 8 compatible?", "author": "fwolter", "createdAt": "2021-03-10T22:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMTEzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538711135", "bodyText": "DEBUG level is sufficient.", "author": "lolodomo", "createdAt": "2020-12-08T18:41:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjIxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538712215", "bodyText": "Rather use removeOlderResults(getTimestampOfLastScan(), bridgeHandler.getThing().getUID()); to remove only things attached to your bridge.", "author": "lolodomo", "createdAt": "2020-12-08T18:42:57Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        super.stopScan();\n+        removeOlderResults(getTimestampOfLastScan());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538712522", "bodyText": "Rather use removeOlderResults(new Date().getTime(), bridgeHandler.getThing().getUID()); to remove only things attached to your bridge.", "author": "lolodomo", "createdAt": "2020-12-08T18:43:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMzUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538713519", "bodyText": "Once you use representation property, you don't need anymore to check if the thing already exists.", "author": "lolodomo", "createdAt": "2020-12-08T18:44:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNTQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538715485", "bodyText": "Using the ThingHandlerService solution, you don't have anymore to do that.", "author": "lolodomo", "createdAt": "2020-12-08T18:47:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final HomeConnectServlet homeConnectServlet;\n+\n+    @Activate\n+    public HomeConnectHandlerFactory(@Reference OAuthFactory oAuthFactory,\n+            @Reference HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider,\n+            @Reference HomeConnectServlet homeConnectServlet) {\n+        this.oAuthFactory = oAuthFactory;\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        this.homeConnectServlet = homeConnectServlet;\n+\n+        discoveryServiceRegistrations = new HashMap<>();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_API_BRIDGE.equals(thingTypeUID)) {\n+            HomeConnectBridgeHandler bridgeHandler = new HomeConnectBridgeHandler((Bridge) thing, oAuthFactory,\n+                    homeConnectServlet);\n+\n+            // configure discovery service\n+            HomeConnectDiscoveryService discoveryService = new HomeConnectDiscoveryService(bridgeHandler);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\nindex 9d202f4f07..9c09eb2b49 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNjEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538716101", "bodyText": "Can be removed if you use the ThingHandlerService solution.", "author": "lolodomo", "createdAt": "2020-12-08T18:48:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final HomeConnectServlet homeConnectServlet;\n+\n+    @Activate\n+    public HomeConnectHandlerFactory(@Reference OAuthFactory oAuthFactory,\n+            @Reference HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider,\n+            @Reference HomeConnectServlet homeConnectServlet) {\n+        this.oAuthFactory = oAuthFactory;\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        this.homeConnectServlet = homeConnectServlet;\n+\n+        discoveryServiceRegistrations = new HashMap<>();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_API_BRIDGE.equals(thingTypeUID)) {\n+            HomeConnectBridgeHandler bridgeHandler = new HomeConnectBridgeHandler((Bridge) thing, oAuthFactory,\n+                    homeConnectServlet);\n+\n+            // configure discovery service\n+            HomeConnectDiscoveryService discoveryService = new HomeConnectDiscoveryService(bridgeHandler);\n+            discoveryServiceRegistrations.put(bridgeHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));\n+\n+            return bridgeHandler;\n+        } else if (THING_TYPE_DISHWASHER.equals(thingTypeUID)) {\n+            return new HomeConnectDishwasherHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_OVEN.equals(thingTypeUID)) {\n+            return new HomeConnectOvenHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_WASHER.equals(thingTypeUID)) {\n+            return new HomeConnectWasherHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_WASHER_DRYER.equals(thingTypeUID)) {\n+            return new HomeConnectWasherDryerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_DRYER.equals(thingTypeUID)) {\n+            return new HomeConnectDryerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_FRIDGE_FREEZER.equals(thingTypeUID)) {\n+            return new HomeConnectFridgeFreezerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_COFFEE_MAKER.equals(thingTypeUID)) {\n+            return new HomeConnectCoffeeMakerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_HOOD.equals(thingTypeUID)) {\n+            return new HomeConnectHoodHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_COOKTOP.equals(thingTypeUID)) {\n+            return new HomeConnectCooktopHandler(thing, dynamicStateDescriptionProvider);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    protected void removeHandler(ThingHandler thingHandler) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\nindex 9d202f4f07..9c09eb2b49 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNjMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538716333", "bodyText": "Can be removed if you use the ThingHandlerService solution.", "author": "lolodomo", "createdAt": "2020-12-08T18:48:52Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\nindex 9d202f4f07..9c09eb2b49 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcyMDEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538720132", "bodyText": "DEBUG or WARN level", "author": "lolodomo", "createdAt": "2020-12-08T18:54:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcyOTk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538729941", "bodyText": "If the purpose of a kind of cache, rather than using something from Apache Commons, you have already one cache class in the openHAB core framework.", "author": "lolodomo", "createdAt": "2020-12-08T19:03:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMTQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538731468", "bodyText": "A switch/case might be more appropriate.", "author": "lolodomo", "createdAt": "2020-12-08T19:05:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEwNTk3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545105970", "bodyText": "matter of taste", "author": "bruestel", "createdAt": "2020-12-17T13:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMTQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMzQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538733486", "bodyText": "isThingReadyToHandleCommand() is true, you should not have to do all this stuff.\nGenerally we have a variable bridgeHandler which is set in initialize method.", "author": "lolodomo", "createdAt": "2020-12-08T19:09:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTExNTgyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545115824", "bodyText": "I simplified it. It's a left over", "author": "bruestel", "createdAt": "2020-12-17T14:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMzQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734151", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:10:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDgyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734824", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:11:08Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTExNzM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545117359", "bodyText": "Will change it to info. The user should know why his or her command didn't worked.", "author": "bruestel", "createdAt": "2020-12-17T14:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDg4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734886", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:11:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736069", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:12:56Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736389", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:13:25Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjcxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736714", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:13:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MTkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538741936", "bodyText": "This call will trigger HTTP requests. You should run in a separate thread to be sure that initialize() will return fast.", "author": "lolodomo", "createdAt": "2020-12-08T19:21:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMyMDk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563320952", "bodyText": "This is now done.", "author": "lolodomo", "createdAt": "2021-01-24T17:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MTkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MjQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538742453", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:22:34Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MzM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538743371", "bodyText": "DEBUG lovel", "author": "lolodomo", "createdAt": "2020-12-08T19:24:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMzMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591913314", "bodyText": "Yes, debug.", "author": "fwolter", "createdAt": "2021-03-10T22:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MzM3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744299", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:25:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM4MTU2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r546381563", "bodyText": "The api client should be present. If not, something really serious is going wrong.", "author": "bruestel", "createdAt": "2020-12-20T14:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591914143", "bodyText": "In this case you could throw an unchecked exception to make things easier. But I won't insist on changing it.", "author": "fwolter", "createdAt": "2021-03-10T22:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDM4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744388", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:25:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDc5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744798", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:26:20Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NjE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538746157", "bodyText": "Use UnDefType.UNDEF rather than UnDefType.NULL.\nUnDefType.NULL is normally not used by bindiongs, it is the init state of any channel before it is first set.", "author": "lolodomo", "createdAt": "2020-12-08T19:28:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM4MTg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r546381846", "bodyText": "Thanks for the hint. Will replace it.", "author": "bruestel", "createdAt": "2020-12-20T14:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NjE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538750641", "bodyText": "This is generally something done in initialize() / bridgeStatusChanged()", "author": "lolodomo", "createdAt": "2020-12-08T19:35:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMyMDg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563320869", "bodyText": "This is done now in initialize too.", "author": "lolodomo", "createdAt": "2021-01-24T17:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNjI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591916254", "bodyText": "Can it be removed here, then?", "author": "fwolter", "createdAt": "2021-03-10T22:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MjQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538752432", "bodyText": "One time again, once the bridge is ONLINE, you should have a variable that give you the bridge handler.", "author": "lolodomo", "createdAt": "2020-12-08T19:38:11Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538754727", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:41:54Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755330", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:42:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755650", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:43:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755716", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:43:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTgzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755832", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:43:40Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756028", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T19:44:03Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756439", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:44:36Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756502", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:44:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756664", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:00Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756744", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njg3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756874", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756950", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:45:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757314", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757531", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757655", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:39Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzczMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757733", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:46:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758152", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758227", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758340", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODQxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758418", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:47:51Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758475", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:48:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758545", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T19:48:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538762419", "bodyText": "Then set this.reinitializationFuture1 to null ?", "author": "lolodomo", "createdAt": "2020-12-08T19:54:23Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected State cachePutIfAbsentAndGet(ChannelUID channelUID, Map<ChannelUID, State> cache,\n+            SupplierWithException<State> supplier)\n+            throws AuthorizationException, ApplianceOfflineException, CommunicationException {\n+\n+        // noinspection SynchronizationOnLocalVariableOrMethodParameter\n+        synchronized (cache) {\n+            State state = cache.get(channelUID);\n+            if (state == null) {\n+                state = supplier.get();\n+                cache.put(channelUID, state);\n+            }\n+            return state;\n+        }\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelTemperature.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        createStateDescription(option, this::convertWasherSpinSpeed)\n+                                .ifPresent(stateDescription -> channelSpinSpeed\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        createStateDescription(option, this::convertWasherTemperature)\n+                                .ifPresent(stateDescription -> channelTemperature\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        createStateDescription(option, this::mapStringType)\n+                                .ifPresent(stateDescription -> channelDryingTarget\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private Optional<StateDescription> createStateDescription(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        ArrayList<StateOption> stateOptions = new ArrayList<>();\n+        option.getAllowedValues().forEach(av -> stateOptions.add(new StateOption(av, stateConverter.apply(av))));\n+\n+        @Nullable\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+        return stateDescription == null ? Optional.empty() : Optional.of(stateDescription);\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MzAwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538763007", "bodyText": "Then set this.reinitializationFuture2 to null ?", "author": "lolodomo", "createdAt": "2020-12-08T19:55:14Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected State cachePutIfAbsentAndGet(ChannelUID channelUID, Map<ChannelUID, State> cache,\n+            SupplierWithException<State> supplier)\n+            throws AuthorizationException, ApplianceOfflineException, CommunicationException {\n+\n+        // noinspection SynchronizationOnLocalVariableOrMethodParameter\n+        synchronized (cache) {\n+            State state = cache.get(channelUID);\n+            if (state == null) {\n+                state = supplier.get();\n+                cache.put(channelUID, state);\n+            }\n+            return state;\n+        }\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelTemperature.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        createStateDescription(option, this::convertWasherSpinSpeed)\n+                                .ifPresent(stateDescription -> channelSpinSpeed\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        createStateDescription(option, this::convertWasherTemperature)\n+                                .ifPresent(stateDescription -> channelTemperature\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        createStateDescription(option, this::mapStringType)\n+                                .ifPresent(stateDescription -> channelDryingTarget\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private Optional<StateDescription> createStateDescription(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        ArrayList<StateOption> stateOptions = new ArrayList<>();\n+        option.getAllowedValues().forEach(av -> stateOptions.add(new StateOption(av, stateConverter.apply(av))));\n+\n+        @Nullable\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+        return stateDescription == null ? Optional.empty() : Optional.of(stateDescription);\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);\n+        }\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor2() {\n+        this.reinitializationFuture2 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && !accessible.get()) {\n+                logger.debug(\"Offline monitor 2: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 2: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor2();\n+                }\n+            } else {\n+                scheduleOfflineMonitor2();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_2_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor2() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture2;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 298cfdcb1d..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -12,6 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NjE4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538766183", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:00:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex 311702e363..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -290,6 +290,7 @@ public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n         ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n         if (reinitializationFuture != null) {\n             reinitializationFuture.cancel(true);\n+            this.reinitializationFuture = null;\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2Njk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538766956", "bodyText": "All the code than can take time should be run in a separate thread to be sure to have a fast run of initialize()", "author": "lolodomo", "createdAt": "2020-12-08T20:01:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex 311702e363..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -290,6 +290,7 @@ public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n         ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n         if (reinitializationFuture != null) {\n             reinitializationFuture.cancel(true);\n+            this.reinitializationFuture = null;\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODEyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538768123", "bodyText": "This is normally handled by the thing manager when it disposes your handler.", "author": "lolodomo", "createdAt": "2020-12-08T20:03:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex 311702e363..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -290,6 +290,7 @@ public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n         ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n         if (reinitializationFuture != null) {\n             reinitializationFuture.cancel(true);\n+            this.reinitializationFuture = null;\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538770318", "bodyText": "Then set this.reinitializationFuture to null ?", "author": "lolodomo", "createdAt": "2020-12-08T20:07:08Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {\n+                logger.info(\"Clear oAuth credential store. bridge={}\", getThing().getLabel());\n+                oAuthClientService.remove();\n+            } catch (OAuthException e) {\n+                logger.error(\"Could not clear oAuth credentials. bridge={}\", getThing().getLabel(), e);\n+            }\n+\n+            if (isInitialized()) {\n+                // persist new configuration and reinitialize handler\n+                dispose();\n+                updateConfiguration(configuration);\n+                initialize();\n+            } else {\n+                // persist new configuration and notify Thing Manager\n+                updateConfiguration(configuration);\n+                @Nullable\n+                ThingHandlerCallback callback = getCallback();\n+                if (callback != null) {\n+                    callback.configurationUpdated(this.getThing());\n+                } else {\n+                    logger.warn(\n+                            \"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                            this.getClass().getSimpleName());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return api client instance\n+     */\n+    public HomeConnectApiClient getApiClient() {\n+        return apiClient;\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return event source client instance\n+     */\n+    public HomeConnectEventSourceClient getEventSourceClient() {\n+        return eventSourceClient;\n+    }\n+\n+    /**\n+     * Get children of bridge\n+     *\n+     * @return list of child handlers\n+     */\n+    public List<AbstractHomeConnectThingHandler> getThingHandler() {\n+        return getThing().getThings().stream()\n+                .filter(thing -> thing.getHandler() instanceof AbstractHomeConnectThingHandler)\n+                .map(thing -> (AbstractHomeConnectThingHandler) thing.getHandler()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Get {@link ApiBridgeConfiguration}.\n+     *\n+     * @return bridge configuration (clientId, clientSecret, etc.)\n+     */\n+    public ApiBridgeConfiguration getConfiguration() {\n+        return getConfigAs(ApiBridgeConfiguration.class);\n+    }\n+\n+    /**\n+     * Get {@link OAuthClientService} instance.\n+     *\n+     * @return oAuth client service instance\n+     */\n+    public OAuthClientService getOAuthClientService() {\n+        return oAuthClientService;\n+    }\n+\n+    private void cleanup() {\n+        ArrayList<ApiRequest> apiRequestHistory = new ArrayList<>();\n+        apiRequestHistory.addAll(apiClient.getLatestApiRequests());\n+        this.apiRequestHistory = apiRequestHistory;\n+        apiClient.getLatestApiRequests().clear();\n+\n+        ArrayList<Event> eventHistory = new ArrayList<>();\n+        eventHistory.addAll(eventSourceClient.getLatestEvents());\n+        this.eventHistory = eventHistory;\n+        eventSourceClient.getLatestEvents().clear();\n+        eventSourceClient.dispose();\n+\n+        oAuthFactory.ungetOAuthService(oAuthServiceHandleId);\n+        homeConnectServlet.removeBridgeHandler(this);\n+    }\n+\n+    private synchronized void scheduleReinitialize() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n+        if (reinitializationFuture != null && !reinitializationFuture.isDone()) {\n+            logger.debug(\"Reinitialization is already scheduled. Starting in {} seconds. bridge={}\",\n+                    reinitializationFuture.getDelay(TimeUnit.SECONDS), getThing().getLabel());\n+        } else {\n+            this.reinitializationFuture = scheduler.schedule(() -> {\n+                cleanup();\n+                initialize();\n+            }, HomeConnectBridgeHandler.REINITIALIZATION_DELAY, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized void stopReinitializer() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(true);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex 311702e363..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -290,6 +290,7 @@ public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n         ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n         if (reinitializationFuture != null) {\n             reinitializationFuture.cancel(true);\n+            this.reinitializationFuture = null;\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjQwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772404", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:10:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\nindex d572aee922..1134a8af3b 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n\n@@ -100,7 +100,8 @@ public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandl\n         // register coffee maker specific SSE event handlers\n         handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n             if (event.getValue() == null || event.getValueAsInt() == 0) {\n-                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n             } else {\n                 defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772816", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:11:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\nindex d572aee922..1134a8af3b 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n\n@@ -100,7 +100,8 @@ public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandl\n         // register coffee maker specific SSE event handlers\n         handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n             if (event.getValue() == null || event.getValueAsInt() == 0) {\n-                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n             } else {\n                 defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Mjg5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772893", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:11:28Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\nindex d572aee922..1134a8af3b 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n\n@@ -100,7 +100,8 @@ public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandl\n         // register coffee maker specific SSE event handlers\n         handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n             if (event.getValue() == null || event.getValueAsInt() == 0) {\n-                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n             } else {\n                 defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MzIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538773218", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:11:56Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectCoffeeMakerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\nindex d572aee922..1134a8af3b 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n\n@@ -100,7 +100,8 @@ public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandl\n         // register coffee maker specific SSE event handlers\n         handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n             if (event.getValue() == null || event.getValueAsInt() == 0) {\n-                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n             } else {\n                 defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MzM2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538773363", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:12:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link HomeConnectCooktopHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n+\n+    public HomeConnectCooktopHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+\n+        // specific SSE event handlers\n+        handlers.put(EVENT_ACTIVE_PROGRAM, (event) -> {\n+            defaultActiveProgramEventHandler().handle(event);\n+            if (event.getValue() != null) {\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent((c) -> updateChannel(c.getUID()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectCooktopHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java\nindex ca1df34f61..644ccef747 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java\n\n@@ -88,6 +88,6 @@ public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n     @Override\n     protected void resetProgramStateChannels() {\n         super.resetProgramStateChannels();\n-        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774278", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:13:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\nindex 609c00a936..99b96c87e1 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n\n@@ -167,7 +167,6 @@ public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandle\n                             client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n                         }\n                     }\n-\n                 } catch (ApplianceOfflineException e) {\n                     logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n                             command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774336", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:13:53Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\nindex 609c00a936..99b96c87e1 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n\n@@ -167,7 +167,6 @@ public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandle\n                             client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n                         }\n                     }\n-\n                 } catch (ApplianceOfflineException e) {\n                     logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n                             command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDUxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774510", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:14:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectDishwasherHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\nindex 609c00a936..99b96c87e1 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n\n@@ -167,7 +167,6 @@ public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandle\n                             client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n                         }\n                     }\n-\n                 } catch (ApplianceOfflineException e) {\n                     logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n                             command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774849", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:14:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\nindex f19741df82..106a2e3b7e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n\n@@ -104,7 +104,7 @@ public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n         // register dryer specific event handlers\n         handlers.put(EVENT_DRYER_DRYING_TARGET,\n                 event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTA0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775041", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:07Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+\n+            // only handle these commands if operation state allows it\n+            if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                // set drying target option\n+                if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                    getApiClient().ifPresent(apiClient -> {\n+                        try {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        } catch (ApplianceOfflineException e) {\n+                            logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                                    command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                            updateStatus(OFFLINE);\n+                            resetChannelsOnOfflineEvent();\n+                            resetProgramStateChannels();\n+                        } catch (CommunicationException e) {\n+                            logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+                        } catch (AuthorizationException e) {\n+                            logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                            handleAuthenticationError(e);\n+                        }\n+                    });\n+                }\n+            } else {\n+                logger.debug(\"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                        command, operationState, getThingLabel(), getThingHaId());\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectDryerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\nindex f19741df82..106a2e3b7e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n\n@@ -104,7 +104,7 @@ public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n         // register dryer specific event handlers\n         handlers.put(EVENT_DRYER_DRYING_TARGET,\n                 event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775188", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775255", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:26Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775297", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTM5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775397", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:42Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775450", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTQ5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775493", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:15:55Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775567", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:16:02Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTYzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775634", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:16:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776174", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:16:54Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjIyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776228", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776328", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:11Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776417", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:17Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Njc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776750", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:17:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSelectedProgramStateDescription() {\n+        // update hood program actions\n+        if (isBridgeOffline() || !isThingAccessibleViaServerSentEvents()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId()).forEach(availableProgram -> {\n+                    if (PROGRAM_HOOD_AUTOMATIC.equals(availableProgram.getKey())) {\n+                        stateOptions.add(new StateOption(COMMAND_AUTOMATIC, mapStringType(availableProgram.getKey())));\n+                    } else if (PROGRAM_HOOD_DELAYED_SHUT_OFF.equals(availableProgram.getKey())) {\n+                        stateOptions.add(\n+                                new StateOption(COMMAND_DELAYED_SHUT_OFF, mapStringType(availableProgram.getKey())));\n+                    } else if (PROGRAM_HOOD_VENTING.equals(availableProgram.getKey())) {\n+                        try {\n+                            apiClient.get().getProgramOptions(getThingHaId(), PROGRAM_HOOD_VENTING).forEach(option -> {\n+                                if (OPTION_HOOD_VENTING_LEVEL.equalsIgnoreCase(option.getKey())) {\n+                                    option.getAllowedValues().stream().filter(s -> !STAGE_FAN_OFF.equalsIgnoreCase(s))\n+                                            .forEach(s -> stateOptions.add(createVentingStateOption(s)));\n+                                } else if (OPTION_HOOD_INTENSIVE_LEVEL.equalsIgnoreCase(option.getKey())) {\n+                                    option.getAllowedValues().stream()\n+                                            .filter(s -> !STAGE_INTENSIVE_STAGE_OFF.equalsIgnoreCase(s))\n+                                            .forEach(s -> stateOptions.add(createVentingStateOption(s)));\n+                                }\n+                            });\n+                        } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                            logger.warn(\"Could not fetch hood program options. error={}\", e.getMessage());\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_01));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_02));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_03));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_04));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_05));\n+                            stateOptions.add(createVentingStateOption(STAGE_INTENSIVE_STAGE_1));\n+                            stateOptions.add(createVentingStateOption(STAGE_INTENSIVE_STAGE_2));\n+                        }\n+                    }\n+                });\n+                stateOptions.add(new StateOption(COMMAND_STOP, \"Stop\"));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_HOOD_ACTIONS_STATE)\n+                            .ifPresent(channel -> getDynamicStateDescriptionProvider()\n+                                    .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    @Override\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_HOOD_ACTIONS_STATE).ifPresent(channel -> getDynamicStateDescriptionProvider()\n+                .removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectHoodHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Njk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776986", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:18:11Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 58ad3be283..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -45,7 +45,7 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n-import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.library.unit.Units.SECOND;\n import static org.openhab.core.thing.ThingStatus.OFFLINE;\n \n import java.util.Arrays;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NzE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777152", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:18:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 58ad3be283..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -45,7 +45,7 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n-import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.library.unit.Units.SECOND;\n import static org.openhab.core.thing.ThingStatus.OFFLINE;\n \n import java.util.Arrays;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NzUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777503", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:19:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        cavityTemperatureFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            @Nullable\n+            String operationState = getOperationState();\n+            boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature;\n+\n+            if (STATE_OPERATION_RUN.equals(operationState)) {\n+                getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(c -> {\n+                    if (manuallyUpdateCavityTemperature) {\n+                        logger.debug(\"Update cavity temperature manually via API. haId={}\", getThingHaId());\n+                        updateChannel(c.getUID());\n+                    } else {\n+                        logger.debug(\"Update cavity temperature via SSE, don't need to fetch manually. haId={}\",\n+                                getThingHaId());\n+                    }\n+                });\n+            }\n+        }, CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, CAVITY_TEMPERATURE_SCHEDULER_PERIOD, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        @Nullable\n+        ScheduledFuture<?> cavityTemperatureFuture = this.cavityTemperatureFuture;\n+        if (cavityTemperatureFuture != null) {\n+            cavityTemperatureFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectOvenHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE)\n+                .ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 58ad3be283..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -45,7 +45,7 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n-import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.library.unit.Units.SECOND;\n import static org.openhab.core.thing.ThingStatus.OFFLINE;\n \n import java.util.Arrays;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Nzc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777768", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:19:23Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectWasherDryerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\nindex 00cfe346e4..8d467e4923 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n\n@@ -128,13 +128,13 @@ public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandl\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_DRYER_DRYING_TARGET,\n                 event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778101", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:19:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 46aefd1132..e0958a1ad8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -132,16 +132,16 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778433", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:20:12Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectWasherHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 46aefd1132..e0958a1ad8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -132,16 +132,16 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODY4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778681", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:20:36Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 46aefd1132..e0958a1ad8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -132,16 +132,16 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778735", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:20:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 46aefd1132..e0958a1ad8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -132,16 +132,16 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n                 event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779070", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:21:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\nindex 00cfe346e4..8d467e4923 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n\n@@ -128,13 +128,13 @@ public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandl\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_DRYER_DRYING_TARGET,\n                 event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779147", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:21:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\nindex 00cfe346e4..8d467e4923 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n\n@@ -128,13 +128,13 @@ public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandl\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_DRYER_DRYING_TARGET,\n                 event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779473", "bodyText": "UnDefType.UNDEF", "author": "lolodomo", "createdAt": "2020-12-08T20:21:54Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\nindex 00cfe346e4..8d467e4923 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n\n@@ -128,13 +128,13 @@ public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandl\n         // register washer specific event handlers\n         handlers.put(EVENT_WASHER_TEMPERATURE,\n                 event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_WASHER_SPIN_SPEED,\n                 event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n         handlers.put(EVENT_DRYER_DRYING_TARGET,\n                 event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n-                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTY5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779696", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:22:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 58ad3be283..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -45,7 +45,7 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n-import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.library.unit.Units.SECOND;\n import static org.openhab.core.thing.ThingStatus.OFFLINE;\n \n import java.util.Arrays;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779764", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:22:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 58ad3be283..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -45,7 +45,7 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n-import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.library.unit.Units.SECOND;\n import static org.openhab.core.thing.ThingStatus.OFFLINE;\n \n import java.util.Arrays;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780369", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:23:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780403", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:23:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 3ff49919a7..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.homeconnect.internal.handler;\n \n import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780831", "bodyText": "DEBUG level", "author": "lolodomo", "createdAt": "2020-12-08T20:24:07Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                    String value;\n+                    String unit;\n+\n+                    if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                            || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                        unit = quantity.getUnit().toString();\n+                        value = String.valueOf(quantity.intValue());\n+                    } else {\n+                        logger.debug(\"Converting target setpoint temperature from {}{} to \u00b0C value. thing={}, haId={}\",\n+                                quantity.intValue(), quantity.getUnit().toString(), getThingLabel(), getThingHaId());\n+                        unit = \"\u00b0C\";\n+                        value = String.valueOf(\n+                                quantity.getUnit().getConverterToAny(SIUnits.CELSIUS).convert(quantity).intValue());\n+                        logger.debug(\"{}{}\", value, unit);\n+                    }\n+\n+                    logger.debug(\"Set setpoint temperature to {} {}. thing={}, haId={}\", value, unit, getThingLabel(),\n+                            getThingHaId());\n+\n+                    if (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setFridgeSetpointTemperature(getThingHaId(), value, unit);\n+                    } else if (CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setFreezerSetpointTemperature(getThingHaId(), value, unit);\n+                    }\n+\n+                } else if (command instanceof OnOffType && apiClient.isPresent()) {\n+                    if (CHANNEL_FREEZER_SUPER_MODE.equals(channelUID.getId())) {\n+                        apiClient.get().setFreezerSuperMode(getThingHaId(), OnOffType.ON.equals(command));\n+                    } else if (CHANNEL_REFRIGERATOR_SUPER_MODE.equals(channelUID.getId())) {\n+                        apiClient.get().setFridgeSuperMode(getThingHaId(), OnOffType.ON.equals(command));\n+                    }\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                        command.toFullString(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                        command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                handleAuthenticationError(e);\n+            } catch (IncommensurableException | UnconvertibleException e) {\n+                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(), e.getMessage());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 61b99ac2ae..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -73,46 +73,46 @@ public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHan\n \n         // register fridge/freezer specific handlers\n         handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n                         if (data.getValue() != null) {\n                             return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n                     if (apiClient.isPresent()) {\n                         Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n                         if (data.getValue() != null) {\n                             return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n                         } else {\n-                            return UnDefType.NULL;\n+                            return UnDefType.UNDEF;\n                         }\n                     }\n-                    return UnDefType.NULL;\n+                    return UnDefType.UNDEF;\n                 })));\n         handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n-                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n                     Optional<HomeConnectApiClient> apiClient = getApiClient();\n \n                     if (apiClient.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NjEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540866102", "bodyText": "Use the implicit last argument to the logging functions to log exceptions:\nlogger.error(\"Could not parse event! haId={}\", haId, e);\n(Valid verywhere `e.getMessage() is passed to a logging method)", "author": "t-8ch", "createdAt": "2020-12-11T11:01:33Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.EVENT;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.NOTIFY;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.STATUS;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.valueOfType;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSourceListener;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener extends EventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger;\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final Queue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            Queue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    @Override\n+    public void onOpen(@Nullable EventSource eventSource, @Nullable Response response) {\n+        logger.debug(\"Event source listener channel opened ({}).\", haId);\n+    }\n+\n+    @Override\n+    public void onEvent(@Nullable EventSource eventSource, @Nullable String id, @Nullable String type,\n+            @Nullable String data) {\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    @Override\n+    public void onClosed(@Nullable EventSource eventSource) {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    @Override\n+    public void onFailure(@Nullable EventSource eventSource, @Nullable Throwable throwable,\n+            @Nullable Response response) {\n+        @Nullable\n+        String throwableMessage = throwable != null ? throwable.getMessage() : null;\n+        @Nullable\n+        String throwableClass = throwable != null ? throwable.getClass().getName() : null;\n+        @Nullable\n+        String responseCode = response != null ? String.valueOf(response.code()) : null;\n+\n+        String responseBody = \"\";\n+        try {\n+            if (response != null) {\n+                @Nullable\n+                ResponseBody responseBodyObject = response.body();\n+                if (responseBodyObject != null) {\n+                    responseBody = responseBodyObject.string();\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Could not get HTTP response body as string.\", e);\n+        }\n+\n+        logger.debug(\n+                \"Event source listener connection failure occurred. haId={}, responseCode={}, responseBody={}, throwable={}, throwableMessage={}\",\n+                haId, responseCode, responseBody, throwableClass, throwableMessage);\n+\n+        if (response != null) {\n+            response.close();\n+        }\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            if (\"429\".equals(responseCode)) {\n+                logger.warn(\n+                        \"More than 10 active event monitoring channels was reached. Further event monitoring requests are blocked. haId={}\",\n+                        haId);\n+                eventListener.onRateLimitReached();\n+            } else {\n+                eventListener.onClosed();\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    private ScheduledFuture<?> createMonitor(ScheduledExecutorService scheduler) {\n+        return scheduler.scheduleWithFixedDelay(() -> {\n+            logger.trace(\"Check event source connection ({}). Last event package received at {}.\", haId,\n+                    lastEventReceived);\n+            if (lastEventReceived != null\n+                    && ChronoUnit.MINUTES.between(lastEventReceived, now()) > SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT) {\n+                logger.warn(\"Dead event source connection detected ({}).\", haId);\n+\n+                client.unregisterEventListener(eventListener);\n+\n+                try {\n+                    eventListener.onClosed();\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+                }\n+                stopMonitor();\n+            }\n+        }, SSE_MONITOR_INITIAL_DELAY, SSE_MONITOR_INTERVAL, TimeUnit.MINUTES);\n+    }\n+\n+    private void stopMonitor() {\n+        logger.debug(\"Dispose event source connection monitor of appliance ({}).\", haId);\n+        eventSourceMonitorFuture.cancel(true);\n+    }\n+\n+    private List<Event> mapEventSourceEventToEvent(String haId, EventType type, @Nullable String data) {\n+        List<Event> events = new ArrayList<>();\n+\n+        if ((STATUS.equals(type) || EVENT.equals(type) || NOTIFY.equals(type)) && data != null && !isEmpty(data)\n+                && !EMPTY_DATA.equals(data)) {\n+            try {\n+                JsonObject responseObject = jsonParser.parse(data).getAsJsonObject();\n+                JsonArray items = responseObject.getAsJsonArray(\"items\");\n+\n+                items.forEach(item -> {\n+                    JsonObject obj = (JsonObject) item;\n+                    @Nullable\n+                    String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                    @Nullable\n+                    String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull()\n+                            ? obj.get(\"value\").getAsString()\n+                            : null;\n+                    @Nullable\n+                    String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+                    @Nullable\n+                    String name = obj.get(\"name\") != null ? obj.get(\"name\").getAsString() : null;\n+                    @Nullable\n+                    String uri = obj.get(\"uri\") != null ? obj.get(\"uri\").getAsString() : null;\n+                    @Nullable\n+                    EventLevel level = obj.get(\"level\") != null\n+                            ? EventLevel.valueOfLevel(obj.get(\"level\").getAsString())\n+                            : null;\n+                    @Nullable\n+                    EventHandling handling = obj.get(\"handling\") != null\n+                            ? EventHandling.valueOfHandling(obj.get(\"handling\").getAsString())\n+                            : null;\n+                    @Nullable\n+                    Long timestamp = obj.get(\"timestamp\") != null ? obj.get(\"timestamp\").getAsLong() : null;\n+                    @Nullable\n+                    ZonedDateTime creation = timestamp != null\n+                            ? ZonedDateTime.ofInstant(Instant.ofEpochSecond(timestamp),\n+                                    TimeZone.getDefault().toZoneId())\n+                            : null;\n+\n+                    events.add(new Event(haId, type, key, name, uri, creation, level, handling, value, unit));\n+                });\n+            } catch (IllegalStateException e) {\n+                logger.error(\"Could not parse event! haId={}, error={}\", haId, e.getMessage());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex 526fc8a1b6..733ab4c06c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -26,7 +26,6 @@ import java.time.ZonedDateTime;\n import java.time.temporal.ChronoUnit;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Queue;\n import java.util.TimeZone;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540867130", "bodyText": "Is this meant to stay this way?\nIt shouldn't.", "author": "t-8ch", "createdAt": "2020-12-11T11:03:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_HOST;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_PORT;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.ProxySetupException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+import okhttp3.OkHttpClient;\n+import okhttp3.OkHttpClient.Builder;\n+import okhttp3.Request;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class OkHttpHelper {\n+    private static final String HEADER_AUTHORIZATION = \"Authorization\";\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OkHttpHelper.class);\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1))).withInitialTokens(0)).build();\n+\n+    public static Builder builder(boolean enableRateLimiting) {\n+        Builder builder;\n+        if (HTTP_PROXY_ENABLED) {\n+            LOGGER.warn(\"Using http proxy! {}:{}\", HTTP_PROXY_HOST, HTTP_PROXY_PORT);\n+            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(HTTP_PROXY_HOST, HTTP_PROXY_PORT));\n+\n+            try {\n+                TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNjAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545136017", "bodyText": "Removed it. I used it to reproduce error cases while using a proxy.", "author": "bruestel", "createdAt": "2020-12-17T14:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nindex be0eee8347..c4ac029cb9 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\n\n@@ -14,32 +14,20 @@ package org.openhab.binding.homeconnect.internal.client;\n \n import static io.github.bucket4j.Bandwidth.classic;\n import static io.github.bucket4j.Refill.intervally;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_ENABLED;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_HOST;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_PORT;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n-import java.net.Proxy;\n import java.time.Duration;\n import java.time.LocalDateTime;\n \n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLSocketFactory;\n-import javax.net.ssl.TrustManager;\n-import javax.net.ssl.X509TrustManager;\n-\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.jetty.http.HttpMethod;\n import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n-import org.openhab.binding.homeconnect.internal.client.exception.ProxySetupException;\n import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n import org.openhab.core.auth.client.oauth2.OAuthClientService;\n import org.openhab.core.auth.client.oauth2.OAuthException;\n import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n-import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540868629", "bodyText": "Is the timezone information useful here?\nShould be java.time.Instant in my opinion.\n(Same  goes for all usages of ZonedDateTime", "author": "t-8ch", "createdAt": "2020-12-11T11:05:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.time.ZonedDateTime;\n+import java.util.UUID;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * API request model.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class ApiRequest {\n+    private final String id;\n+    private final ZonedDateTime time;\n+    private final HomeConnectRequest homeConnectRequest;\n+    private final @Nullable HomeConnectResponse homeConnectResponse;\n+\n+    public ApiRequest(ZonedDateTime time, HomeConnectRequest homeConnectRequest,", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545135502", "bodyText": "Yes it is very useful to debug problems. I just changed it before creating this pull request. One tester was in a different time zone and it was very confusing.", "author": "bruestel", "createdAt": "2020-12-17T14:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0MDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545140557", "bodyText": "Where was the Instant logged?\nIt should be serialized as ISO8601 string which is unambiguous.", "author": "t-8ch", "createdAt": "2020-12-17T14:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1NjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545156625", "bodyText": "The Instant is visible in the binding UI request and event log.\n\nI also use it in the event and request log export (json format).\n\nI'm not persisting the Instant object (like a log file etc.), it's only used in a in-memory FIFO queue.", "author": "bruestel", "createdAt": "2020-12-17T15:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java\nindex c0d7911b4d..a86e3fbfbd 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540869444", "bodyText": "Could be a java.time.Instant", "author": "t-8ch", "createdAt": "2020-12-11T11:07:12Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Date;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Token model\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Token {\n+\n+    private final String accessToken;\n+    private final String refreshToken;\n+    private final long accessTokenExpiration;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMjUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591902524", "bodyText": "If you don't want to make it Instant, you could at least add the time suffix to the field name.", "author": "fwolter", "createdAt": "2021-03-10T21:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzOTA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624639059", "bodyText": "Added suffix", "author": "bruestel", "createdAt": "2021-05-02T06:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java\nindex 0c91e42ca2..c0c79e9719 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MDIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540870218", "bodyText": "You can directly assign the logger here.\nIt will remove the requirement to add it to all constructors and clutter those.\nprivate final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);", "author": "t-8ch", "createdAt": "2020-12-11T11:08:34Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540871069", "bodyText": "Should be a java.time.Duration to have proper typing.", "author": "t-8ch", "createdAt": "2020-12-11T11:09:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzOTk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624639948", "bodyText": "Added suffix to SEARCH_TIME.\n    private static final int SEARCH_TIME_SEC = 20;\n\n...\n    public HomeConnectDiscoveryService() {\n        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME_SEC, true);\n    }\n\nSEARCH_TIME is used as int constructor parameter for org.openhab.core.config.discovery.AbstractDiscoveryService . If I use a Duration I have to cast long Duration.getSeconds() back to int.", "author": "bruestel", "createdAt": "2021-05-02T06:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MTA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MjM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540872394", "bodyText": "java.time API would be better, not that it would make a lot of difference here.", "author": "t-8ch", "createdAt": "2020-12-11T11:12:10Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzMzU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545133588", "bodyText": "Changed it to System.currentTimeMillis()", "author": "bruestel", "createdAt": "2020-12-17T14:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MjM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 382053913c..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -25,7 +25,6 @@ import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstan\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n \n-import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NzMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540877327", "bodyText": "Why not ISO8601?", "author": "t-8ch", "createdAt": "2020-12-11T11:21:22Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MDYwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624640607", "bodyText": "Will change it to ISO_OFFSET_DATE_TIME", "author": "bruestel", "createdAt": "2021-05-02T06:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NzMyNw=="}], "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex afed67d8e5..c7760bb474 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NDM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540884384", "bodyText": "Doesn't seem to do much.\nIt would make more sense to get the proxy configuration from where the rest of OpenHab also get its from, so all components behave uniformly.", "author": "t-8ch", "createdAt": "2020-12-11T11:34:49Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link HomeConnectBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBindingConstants {\n+\n+    public static final String BINDING_ID = \"homeconnect\";\n+\n+    public static final String HA_ID = \"haId\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_API_BRIDGE = new ThingTypeUID(BINDING_ID, \"api_bridge\");\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+    public static final ThingTypeUID THING_TYPE_WASHER = new ThingTypeUID(BINDING_ID, \"washer\");\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washerdryer\");\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridgefreezer\");\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+    public static final ThingTypeUID THING_TYPE_COFFEE_MAKER = new ThingTypeUID(BINDING_ID, \"coffeemaker\");\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+    public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    // SSE Event types\n+    public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String EVENT_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String EVENT_CONNECTED = \"CONNECTED\";\n+    public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n+    public static final String EVENT_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String EVENT_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n+    public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+    public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String EVENT_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String EVENT_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String EVENT_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String EVENT_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String EVENT_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String EVENT_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String EVENT_FRIDGE_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String EVENT_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+    public static final String EVENT_FRIDGE_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String EVENT_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.BeanContainerEmpty\";\n+    public static final String EVENT_COFFEEMAKER_WATER_TANK_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.WaterTankEmpty\";\n+    public static final String EVENT_COFFEEMAKER_DRIP_TRAY_FULL = \"ConsumerProducts.CoffeeMaker.Event.DripTrayFull\";\n+    public static final String EVENT_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String EVENT_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_STATE = \"Cooking.Common.Setting.Lighting\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String EVENT_AMBIENT_LIGHT_STATE = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String EVENT_AMBIENT_LIGHT_COLOR_STATE = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+\n+    // Channel IDs\n+    public static final String CHANNEL_DOOR_STATE = \"door_state\";\n+    public static final String CHANNEL_ELAPSED_PROGRAM_TIME = \"elapsed_program_time\";\n+    public static final String CHANNEL_POWER_STATE = \"power_state\";\n+    public static final String CHANNEL_OPERATION_STATE = \"operation_state\";\n+    public static final String CHANNEL_ACTIVE_PROGRAM_STATE = \"active_program_state\";\n+    public static final String CHANNEL_SELECTED_PROGRAM_STATE = \"selected_program_state\";\n+    public static final String CHANNEL_BASIC_ACTIONS_STATE = \"basic_actions_state\";\n+    public static final String CHANNEL_REMOTE_START_ALLOWANCE_STATE = \"remote_start_allowance_state\";\n+    public static final String CHANNEL_REMOTE_CONTROL_ACTIVE_STATE = \"remote_control_active_state\";\n+    public static final String CHANNEL_LOCAL_CONTROL_ACTIVE_STATE = \"local_control_active_state\";\n+    public static final String CHANNEL_REMAINING_PROGRAM_TIME_STATE = \"remaining_program_time_state\";\n+    public static final String CHANNEL_PROGRAM_PROGRESS_STATE = \"program_progress_state\";\n+    public static final String CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE = \"oven_current_cavity_temperature\";\n+    public static final String CHANNEL_SETPOINT_TEMPERATURE = \"setpoint_temperature\";\n+    public static final String CHANNEL_DURATION = \"duration\";\n+    public static final String CHANNEL_WASHER_TEMPERATURE = \"laundry_care_washer_temperature\";\n+    public static final String CHANNEL_WASHER_SPIN_SPEED = \"laundry_care_washer_spin_speed\";\n+    public static final String CHANNEL_WASHER_IDOS1 = \"laundry_care_washer_idos1\";\n+    public static final String CHANNEL_WASHER_IDOS2 = \"laundry_care_washer_idos2\";\n+    public static final String CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE = \"setpoint_temperature_refrigerator\";\n+    public static final String CHANNEL_REFRIGERATOR_SUPER_MODE = \"super_mode_refrigerator\";\n+    public static final String CHANNEL_FREEZER_SETPOINT_TEMPERATURE = \"setpoint_temperature_freezer\";\n+    public static final String CHANNEL_FREEZER_SUPER_MODE = \"super_mode_freezer\";\n+    public static final String CHANNEL_DRYER_DRYING_TARGET = \"dryer_drying_target\";\n+    public static final String CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE = \"coffeemaker_drip_tray_full_state\";\n+    public static final String CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE = \"coffeemaker_water_tank_empty_state\";\n+    public static final String CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE = \"coffeemaker_bean_container_empty_state\";\n+    public static final String CHANNEL_HOOD_VENTING_LEVEL = \"hood_venting_level\";\n+    public static final String CHANNEL_HOOD_INTENSIVE_LEVEL = \"hood_intensive_level\";\n+    public static final String CHANNEL_HOOD_ACTIONS_STATE = \"hood_program_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_STATE = \"functional_light_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"functional_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_STATE = \"ambient_light_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"ambient_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_COLOR_STATE = \"ambient_light_color_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"ambient_light_custom_color_state\";\n+\n+    // List of all supported devices\n+    public static final Set<ThingTypeUID> SUPPORTED_DEVICE_THING_TYPES_UIDS = Stream.of(THING_TYPE_API_BRIDGE,\n+            THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+            THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // Discoverable devices\n+    public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n+            .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // List of state values\n+    public static final String STATE_POWER_OFF = \"BSH.Common.EnumType.PowerState.Off\";\n+    public static final String STATE_POWER_ON = \"BSH.Common.EnumType.PowerState.On\";\n+    public static final String STATE_POWER_STANDBY = \"BSH.Common.EnumType.PowerState.Standby\";\n+    public static final String STATE_DOOR_OPEN = \"BSH.Common.EnumType.DoorState.Open\";\n+    public static final String STATE_DOOR_LOCKED = \"BSH.Common.EnumType.DoorState.Locked\";\n+    public static final String STATE_DOOR_CLOSED = \"BSH.Common.EnumType.DoorState.Closed\";\n+    public static final String STATE_OPERATION_READY = \"BSH.Common.EnumType.OperationState.Ready\";\n+    public static final String STATE_OPERATION_FINISHED = \"BSH.Common.EnumType.OperationState.Finished\";\n+    public static final String STATE_OPERATION_RUN = \"BSH.Common.EnumType.OperationState.Run\";\n+    public static final String STATE_EVENT_PRESENT_STATE_OFF = \"BSH.Common.EnumType.EventPresentState.Off\";\n+\n+    // List of program options\n+    public static final String OPTION_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String OPTION_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String OPTION_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String OPTION_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String OPTION_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String OPTION_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String OPTION_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String OPTION_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String OPTION_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String OPTION_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String OPTION_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String OPTION_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+\n+    // List of stages\n+    public static final String STAGE_FAN_OFF = \"Cooking.Hood.EnumType.Stage.FanOff\";\n+    public static final String STAGE_FAN_STAGE_01 = \"Cooking.Hood.EnumType.Stage.FanStage01\";\n+    public static final String STAGE_FAN_STAGE_02 = \"Cooking.Hood.EnumType.Stage.FanStage02\";\n+    public static final String STAGE_FAN_STAGE_03 = \"Cooking.Hood.EnumType.Stage.FanStage03\";\n+    public static final String STAGE_FAN_STAGE_04 = \"Cooking.Hood.EnumType.Stage.FanStage04\";\n+    public static final String STAGE_FAN_STAGE_05 = \"Cooking.Hood.EnumType.Stage.FanStage05\";\n+    public static final String STAGE_INTENSIVE_STAGE_OFF = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStageOff\";\n+    public static final String STAGE_INTENSIVE_STAGE_1 = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1\";\n+    public static final String STAGE_INTENSIVE_STAGE_2 = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStage2\";\n+    public static final String STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR = \"BSH.Common.EnumType.AmbientLightColor.CustomColor\";\n+\n+    // List of programs\n+    public static final String PROGRAM_HOOD_AUTOMATIC = \"Cooking.Common.Program.Hood.Automatic\";\n+    public static final String PROGRAM_HOOD_VENTING = \"Cooking.Common.Program.Hood.Venting\";\n+    public static final String PROGRAM_HOOD_DELAYED_SHUT_OFF = \"Cooking.Common.Program.Hood.DelayedShutOff\";\n+\n+    // Network and oAuth constants\n+    public static final String API_BASE_URL = \"https://api.home-connect.com\";\n+    public static final String API_SIMULATOR_BASE_URL = \"https://simulator.home-connect.com\";\n+    public static final String OAUTH_TOKEN_PATH = \"/security/oauth/token\";\n+    public static final String OAUTH_AUTHORIZE_PATH = \"/security/oauth/authorize\";\n+    public static final String OAUTH_SCOPE = \"IdentifyAppliance Monitor Settings Dishwasher-Control Washer-Control Dryer-Control WasherDryer-Control CoffeeMaker-Control Hood-Control CleaningRobot-Control\";\n+\n+    // Operation states\n+    public static final String OPERATION_STATE_INACTIVE = \"BSH.Common.EnumType.OperationState.Inactive\";\n+    public static final String OPERATION_STATE_READY = \"BSH.Common.EnumType.OperationState.Ready\";\n+    public static final String OPERATION_STATE_DELAYED_START = \"BSH.Common.EnumType.OperationState.DelayedStart\";\n+    public static final String OPERATION_STATE_RUN = \"BSH.Common.EnumType.OperationState.Run\";\n+    public static final String OPERATION_STATE_PAUSE = \"BSH.Common.EnumType.OperationState.Pause\";\n+    public static final String OPERATION_STATE_ACTION_REQUIRED = \"BSH.Common.EnumType.OperationState.ActionRequired\";\n+    public static final String OPERATION_STATE_FINISHED = \"BSH.Common.EnumType.OperationState.Finished\";\n+    public static final String OPERATION_STATE_ERROR = \"BSH.Common.EnumType.OperationState.Error\";\n+    public static final String OPERATION_STATE_ABORTING = \"BSH.Common.EnumType.OperationState.Aborting\";\n+\n+    // Commands\n+    public static final String COMMAND_START = \"start\";\n+    public static final String COMMAND_STOP = \"stop\";\n+    public static final String COMMAND_SELECTED = \"selected\";\n+    public static final String COMMAND_VENTING_1 = \"venting1\";\n+    public static final String COMMAND_VENTING_2 = \"venting2\";\n+    public static final String COMMAND_VENTING_3 = \"venting3\";\n+    public static final String COMMAND_VENTING_4 = \"venting4\";\n+    public static final String COMMAND_VENTING_5 = \"venting5\";\n+    public static final String COMMAND_VENTING_INTENSIVE_1 = \"ventingIntensive1\";\n+    public static final String COMMAND_VENTING_INTENSIVE_2 = \"ventingIntensive2\";\n+    public static final String COMMAND_AUTOMATIC = \"automatic\";\n+    public static final String COMMAND_DELAYED_SHUT_OFF = \"delayed\";\n+\n+    // proxy settings\n+    public static final boolean HTTP_PROXY_ENABLED = false;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyMzQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545123441", "bodyText": "Removed it", "author": "bruestel", "createdAt": "2020-12-17T14:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NDM4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java\nindex 19b3acc4fb..d8aa1cbd51 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java\n\n@@ -44,19 +44,40 @@ public class HomeConnectBindingConstants {\n     public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n     public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n \n+    // Setting\n+    public static final String SETTING_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String SETTING_LIGHTING = \"Cooking.Common.Setting.Lighting\";\n+    public static final String SETTING_AMBIENT_LIGHT_ENABLED = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String SETTING_LIGHTING_BRIGHTNESS = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_BRIGHTNESS = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_COLOR = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String SETTING_AMBIENT_LIGHT_CUSTOM_COLOR = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+    public static final String SETTING_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String SETTING_REFRIGERATOR_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String SETTING_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+\n+    // Status\n+    public static final String STATUS_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String STATUS_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String STATUS_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String STATUS_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String STATUS_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+\n     // SSE Event types\n     public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n-    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n-    public static final String EVENT_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+    public static final String EVENT_POWER_STATE = SETTING_POWER_STATE;\n     public static final String EVENT_CONNECTED = \"CONNECTED\";\n     public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n-    public static final String EVENT_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n-    public static final String EVENT_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String EVENT_DOOR_STATE = STATUS_DOOR_STATE;\n+    public static final String EVENT_OPERATION_STATE = STATUS_OPERATION_STATE;\n     public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n     public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n-    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n-    public static final String EVENT_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n-    public static final String EVENT_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = STATUS_REMOTE_CONTROL_START_ALLOWED;\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = STATUS_REMOTE_CONTROL_ACTIVE;\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = STATUS_LOCAL_CONTROL_ACTIVE;\n     public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n     public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n     public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540885839", "bodyText": "I would prefer to have the URL handling at the very outset of the binding and use full URI/Strings throught the plumbing.\nThis would also make it possible for users to specify their own URLs for testing etc.", "author": "t-8ch", "createdAt": "2020-12-11T11:37:26Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyNjkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545126939", "bodyText": "The Home Connect ecosystem only uses two addresses. One for production and one for the simulated environment. There is no need to specify a custom URL.", "author": "bruestel", "createdAt": "2020-12-17T14:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0NDIwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545144208", "bodyText": "What about using a mock service for tests?\nOr maybe someone reimplements the service as a self-hosted version.\nCurrently all low-level components have to contain the same conditional and know about all possible URLs.\nWhen the URLs pulled farther up the stack (maybe even to the bridge settings itself)\nit will be much easier to enable those usecases. It also simplifies to low-level components.", "author": "t-8ch", "createdAt": "2020-12-17T14:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2OTQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545169479", "bodyText": "What about using a mock service for tests?\n\nIf you mock the Home Connect API (maybe in a unit test), you don't necessarily need to change the API URL.\n\nOr maybe someone reimplements the service as a self-hosted version.\n\nThe Home Connect system is closed source. There are no open clients. At least I haven't heard of it yet. The official App is using a different protocol to communicate.\n\nCurrently all low-level components have to contain the same conditional and know about all possible URLs.\n\nWe are talking about two URLs. In the bridge configuration the user can decide whether to use the simulated or the productive environment. https://developer.home-connect.com/docs/general/endpoints_dataencoding\n\nWhen the URLs pulled farther up the stack (maybe even to the bridge settings itself)\nit will be much easier to enable those usecases. It also simplifies to low-level components.\n\nI think the bridge don't need to know details about the API. The knowledge of the API endpoint is not needed. The user shouldn't know about it. It would confuse the users if they can edit the URL in the bridge configuration.", "author": "bruestel", "createdAt": "2020-12-17T15:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE4MTc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r545181786", "bodyText": "What about using a mock service for tests?\nIf you mock the Home Connect API (maybe in a unit test), you don't necessarily need to change the API URL.\n\n\nThe imagination was to use something like wiremock to mock the API on the HTTP level.\n\n\nOr maybe someone reimplements the service as a self-hosted version.\nThe Home Connect system is closed source. There are no open clients. At least I haven't heard of it yet. The official\nApp is using a different protocol to communicate.\n\n\nThis is more about an open API server.\nHomekit is also closed source, and yet OpenHab implements it's interface.\n\n\nWhen the URLs pulled farther up the stack (maybe even to the bridge settings itself)\nit will be much easier to enable those usecases. It also simplifies to low-level components.\nI think the bridge don't need to know details about the API. The knowledge of the API endpoint is not needed.\n\n\nThe user shouldn't know about it. It would confuse the users if they can edit the URL in the bridge configuration.\nIt would be the default value of an advanced setting, not visible to users.\nNo component actually has to know about the distinction between prod and sandbox.\nIf you want, leave it as is.\nIt's just a pet-peeve of mine when enumerations of configurations are passed around instead of the raw configuration value.\nIt complicates the code and reduces the functionality without any upsides.", "author": "t-8ch", "createdAt": "2020-12-17T15:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 1b33a1ae37..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -23,6 +23,23 @@ import static java.util.Objects.requireNonNull;\n import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NjE4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540886184", "bodyText": "Now that OpenHab depends on Java 11, the new Java 11 HTTP client could be used, slashing the size of the binding considerably.", "author": "t-8ch", "createdAt": "2020-12-11T11:38:08Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,", "originalCommit": "366b0044e000f523d11023f78481aeddc77cc058", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 1b33a1ae37..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -23,6 +23,23 @@ import static java.util.Objects.requireNonNull;\n import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n \n"}}, {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "url": "https://github.com/openhab/openhab-addons/commit/c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2020-12-20T16:38:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548500781", "bodyText": "I am surprised the class is empty. Normally, there is a method to get the state options + the handling of the reference to ChannelTypeI18nLocalizationService .", "author": "lolodomo", "createdAt": "2020-12-24T11:26:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.type;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.binding.BaseDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic values.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class HomeConnectDynamicStateDescriptionProvider extends BaseDynamicStateDescriptionProvider {\n+", "originalCommit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxNzI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558917248", "bodyText": "Please add this code to your class:\n\n    @Reference\n    protected void setChannelTypeI18nLocalizationService(\n            final ChannelTypeI18nLocalizationService channelTypeI18nLocalizationService) {\n        this.channelTypeI18nLocalizationService = channelTypeI18nLocalizationService;\n    }\n\n    protected void unsetChannelTypeI18nLocalizationService(\n            final ChannelTypeI18nLocalizationService channelTypeI18nLocalizationService) {\n        this.channelTypeI18nLocalizationService = null;\n    }", "author": "lolodomo", "createdAt": "2021-01-16T15:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MTkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585781925", "bodyText": "Was done, included in my PR.", "author": "lolodomo", "createdAt": "2021-03-02T17:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java\nindex bfa35daa1f..556f86e2e6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMjIyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548502226", "bodyText": "Replace appliance.getHaId() by HA_ID. What is expected is the parameter name, not its value.", "author": "lolodomo", "createdAt": "2020-12-24T11:32:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.debug(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withRepresentationProperty(appliance.getHaId())", "originalCommit": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex fc7425183d..9e04fd1169 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"oid": "b2bab267d8b772fc4a62951e9bc00f5d1e5e8cad", "url": "https://github.com/openhab/openhab-addons/commit/b2bab267d8b772fc4a62951e9bc00f5d1e5e8cad", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T11:05:11Z", "type": "forcePushed"}, {"oid": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "url": "https://github.com/openhab/openhab-addons/commit/5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "message": "Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T13:15:27Z", "type": "forcePushed"}, {"oid": "979af11d1f80ae7c43b80407039a64f1675b8502", "url": "https://github.com/openhab/openhab-addons/commit/979af11d1f80ae7c43b80407039a64f1675b8502", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T13:38:47Z", "type": "forcePushed"}, {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "url": "https://github.com/openhab/openhab-addons/commit/9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-01-16T13:46:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxOTQxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558919410", "bodyText": "Minor: please fix the comment as now the bridgeHandler is no more a parameter of the constructor.", "author": "lolodomo", "createdAt": "2021-01-16T15:07:41Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2ODkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563268915", "bodyText": "Ok", "author": "bruestel", "createdAt": "2021-01-24T10:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxOTQxMA=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 9e04fd1169..6afcbee9b1 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -61,8 +61,7 @@ public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n     private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n \n     /**\n-     * Construct an {@link HomeConnectDiscoveryService} with the given\n-     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     * Construct an {@link HomeConnectDiscoveryService}.\n      *\n      */\n     public HomeConnectDiscoveryService() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk3MjQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558972456", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T17:26:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\nindex bc677b5f16..f4fc98d210 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java\n\n@@ -65,7 +65,6 @@ public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandl\n     public HomeConnectCoffeeMakerHandler(Thing thing,\n             HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n         super(thing, dynamicStateDescriptionProvider);\n-        resetProgramStateChannels();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MDEyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558980120", "bodyText": "Is there a reason to not use the scheduler provided by the thing handler ?", "author": "lolodomo", "createdAt": "2021-01-16T17:46:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3MjU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563272591", "bodyText": "No :-)", "author": "bruestel", "createdAt": "2021-01-24T10:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MDEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex e8c6c94108..879925bd40 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -52,7 +52,6 @@ import java.util.Arrays;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MTU4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558981580", "bodyText": "It may be better to first cancel your job before calling super.dispose()", "author": "lolodomo", "createdAt": "2021-01-16T17:49:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.debug(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.debug(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        cavityTemperatureFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            @Nullable\n+            String operationState = getOperationState();\n+            boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature;\n+\n+            if (STATE_OPERATION_RUN.equals(operationState)) {\n+                getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(c -> {\n+                    if (manuallyUpdateCavityTemperature) {\n+                        logger.debug(\"Update cavity temperature manually via API. haId={}\", getThingHaId());\n+                        updateChannel(c.getUID());\n+                    } else {\n+                        logger.debug(\"Update cavity temperature via SSE, don't need to fetch manually. haId={}\",\n+                                getThingHaId());\n+                    }\n+                });\n+            }\n+        }, CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, CAVITY_TEMPERATURE_SCHEDULER_PERIOD, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2ODg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563268879", "bodyText": "Will change it", "author": "bruestel", "createdAt": "2021-01-24T10:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MTU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex e8c6c94108..879925bd40 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -52,7 +52,6 @@ import java.util.Arrays;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4NjYwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558986606", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:02:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2OTE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563269172", "bodyText": "Agree", "author": "bruestel", "createdAt": "2021-01-24T10:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4NjYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex e8c6c94108..879925bd40 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -52,7 +52,6 @@ import java.util.Arrays;\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzg4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558987883", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:05:43Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI2OTQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563269476", "bodyText": "Agree", "author": "bruestel", "createdAt": "2021-01-24T10:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\nindex 50d6c60e79..4892fd8bf6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n\n@@ -145,23 +145,21 @@ public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandl\n             getApiClient().ifPresent(apiClient -> {\n                 try {\n                     // only handle these commands if operation state allows it\n-                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n-                        // set temperature option\n-                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n-                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n-                                    command.toFullString(), null, false, false);\n-                        }\n-\n-                        // set spin speed option\n-                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n-                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n-                                    command.toFullString(), null, false, false);\n-                        }\n-\n-                        // set drying target option\n-                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n-                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n-                                    command.toFullString(), null, false, false);\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof StringType) {\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_WASHER_TEMPERATURE:\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                        command.toFullString(), null, false, false);\n+                                break;\n+                            case CHANNEL_WASHER_SPIN_SPEED:\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                        command.toFullString(), null, false, false);\n+                                break;\n+                            case CHANNEL_DRYER_DRYING_TARGET:\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                        command.toFullString(), null, false, false);\n+                                break;\n                         }\n                     } else {\n                         logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558987942", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:05:48Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\nindex 50d6c60e79..4892fd8bf6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java\n\n@@ -145,23 +145,21 @@ public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandl\n             getApiClient().ifPresent(apiClient -> {\n                 try {\n                     // only handle these commands if operation state allows it\n-                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n-                        // set temperature option\n-                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n-                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n-                                    command.toFullString(), null, false, false);\n-                        }\n-\n-                        // set spin speed option\n-                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n-                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n-                                    command.toFullString(), null, false, false);\n-                        }\n-\n-                        // set drying target option\n-                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n-                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n-                                    command.toFullString(), null, false, false);\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof StringType) {\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_WASHER_TEMPERATURE:\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                        command.toFullString(), null, false, false);\n+                                break;\n+                            case CHANNEL_WASHER_SPIN_SPEED:\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                        command.toFullString(), null, false, false);\n+                                break;\n+                            case CHANNEL_DRYER_DRYING_TARGET:\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                        command.toFullString(), null, false, false);\n+                                break;\n                         }\n                     } else {\n                         logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989012", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:08:33Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3MDE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563270157", "bodyText": "I switched to a switch statement.", "author": "bruestel", "createdAt": "2021-01-24T10:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 4435069681..e853aa8655 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -153,29 +153,25 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n \n             try {\n                 // only handle these commands if operation state allows it\n-                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n-                    // set temperature option\n-                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set spin speed option\n-                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set iDos 1 option\n-                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set iDos 2 option\n-                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n-                                command.toFullString(), null, false, false);\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()\n+                        && command instanceof StringType) {\n+                    switch (channelUID.getId()) {\n+                        case CHANNEL_WASHER_TEMPERATURE:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_SPIN_SPEED:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_IDOS1:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_IDOS2:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n                     }\n                 } else {\n                     logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989076", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:08:38Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 4435069681..e853aa8655 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -153,29 +153,25 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n \n             try {\n                 // only handle these commands if operation state allows it\n-                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n-                    // set temperature option\n-                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set spin speed option\n-                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set iDos 1 option\n-                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set iDos 2 option\n-                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n-                                command.toFullString(), null, false, false);\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()\n+                        && command instanceof StringType) {\n+                    switch (channelUID.getId()) {\n+                        case CHANNEL_WASHER_TEMPERATURE:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_SPIN_SPEED:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_IDOS1:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_IDOS2:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n                     }\n                 } else {\n                     logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTEwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989105", "bodyText": "I rather suggest \"else if\" but I let you decide.", "author": "lolodomo", "createdAt": "2021-01-16T18:08:44Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\nindex 4435069681..e853aa8655 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java\n\n@@ -153,29 +153,25 @@ public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n \n             try {\n                 // only handle these commands if operation state allows it\n-                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n-                    // set temperature option\n-                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set spin speed option\n-                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set iDos 1 option\n-                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n-                                command.toFullString(), null, false, false);\n-                    }\n-\n-                    // set iDos 2 option\n-                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n-                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n-                                command.toFullString(), null, false, false);\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()\n+                        && command instanceof StringType) {\n+                    switch (channelUID.getId()) {\n+                        case CHANNEL_WASHER_TEMPERATURE:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_SPIN_SPEED:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_IDOS1:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n+                        case CHANNEL_WASHER_IDOS2:\n+                            apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                    command.toFullString(), null, false, false);\n+                            break;\n                     }\n                 } else {\n                     logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989915", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T18:11:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link HomeConnectCooktopHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n+\n+    public HomeConnectCooktopHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3NjQ1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563276452", "bodyText": "Will remove and test it.", "author": "bruestel", "createdAt": "2021-01-24T11:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3ODUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563278521", "bodyText": "I don't say this is useless, I rather say that it is not called at the right place ;)", "author": "lolodomo", "createdAt": "2021-01-24T11:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzI3OTI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r563279278", "bodyText": "I think it is useless at that place, as it resets some channels back to UnDefType.UNDEF.\nIt should be only used if a program finished or if something went wrong (API error etc.).", "author": "bruestel", "createdAt": "2021-01-24T11:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java\nindex 0f06b4c968..d6937a77d7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java\n\n@@ -46,7 +46,6 @@ public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n     public HomeConnectCooktopHandler(Thing thing,\n             HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n         super(thing, dynamicStateDescriptionProvider);\n-        resetProgramStateChannels();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558990022", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T18:11:42Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\nindex b4a64ebfa1..8c415c987c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java\n\n@@ -76,7 +76,6 @@ public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandle\n     public HomeConnectDishwasherHandler(Thing thing,\n             HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n         super(thing, dynamicStateDescriptionProvider);\n-        resetProgramStateChannels();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDI2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558990263", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "author": "lolodomo", "createdAt": "2021-01-16T18:12:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 468e29cbfc..2edea442ac 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -123,7 +123,6 @@ public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n     public HomeConnectHoodHandler(Thing thing,\n             HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n         super(thing, dynamicStateDescriptionProvider);\n-        resetProgramStateChannels();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r559004792", "bodyText": "If method is called while your thing (bridge) was not yet initialized, oAuthClientService will be null.\nIt would be safer to check that this variable is not null.", "author": "lolodomo", "createdAt": "2021-01-16T18:56:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {", "originalCommit": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928933", "bodyText": "Maybe it should be made Nullable.", "author": "fwolter", "createdAt": "2021-03-10T22:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MTQ3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624641471", "bodyText": "will adjust it", "author": "bruestel", "createdAt": "2021-05-02T06:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex b1368f7856..dfddd57640 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -12,11 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.handler;\n \n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n \n import java.io.IOException;\n import java.time.ZonedDateTime;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NDE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564794169", "bodyText": "It looks like this class is not used.", "author": "lolodomo", "createdAt": "2021-01-26T19:59:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/exception/ProxySetupException.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * HTTP proxy setup exception\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class ProxySetupException extends RuntimeException {", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MzE2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585783165", "bodyText": "Now deleted (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NDE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/exception/ProxySetupException.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/exception/ProxySetupException.java\ndeleted file mode 100644\nindex f581ff36e1..0000000000\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/exception/ProxySetupException.java\n+++ /dev/null\n\n@@ -1,30 +0,0 @@\n-/**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.homeconnect.internal.client.exception;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-\n-/**\n- * HTTP proxy setup exception\n- *\n- * @author Jonas Br\u00fcstel - Initial contribution\n- *\n- */\n-@NonNullByDefault\n-public class ProxySetupException extends RuntimeException {\n-    private static final long serialVersionUID = 1L;\n-\n-    public ProxySetupException(Throwable cause) {\n-        super(cause);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NTMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564795313", "bodyText": "Call to super() is useless I believe", "author": "lolodomo", "createdAt": "2021-01-26T20:01:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * HTTP response model.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectResponse {\n+    private final int code;\n+    private final Map<String, String> header;\n+    private final @Nullable String body;\n+\n+    public HomeConnectResponse(int code, Map<String, String> header, @Nullable String body) {\n+        super();", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585783605", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NTMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java\nindex ae869ac3c5..655ec4cf77 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java\n\n@@ -30,7 +30,6 @@ public class HomeConnectResponse {\n     private final @Nullable String body;\n \n     public HomeConnectResponse(int code, Map<String, String> header, @Nullable String body) {\n-        super();\n         this.code = code;\n         this.header = header;\n         this.body = body;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5ODQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564798430", "bodyText": "Please don't use org.apache.commons.lang.StringUtils, we search to remove tthis dependency.\nThis can easily be replaced I believe.", "author": "lolodomo", "createdAt": "2021-01-26T20:06:30Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        String path = BASE_PATH + haId + \"/programs/available/\" + programKey;\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.code() == HTTP_OK) {\n+                return responseBody;\n+            }\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(asList(HTTP_OK, HTTP_NOT_FOUND), request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.code() == HTTP_OK) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(ACCEPT, BSH_JSON_V1).delete()\n+                .build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, Response response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, Response response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HTTP_UNAUTHORIZED) && response.code() == HTTP_UNAUTHORIZED) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = \"\";\n+            try {\n+                responseBody = mapToString(response.body());\n+            } catch (IOException e) {\n+                logger.error(\"Could not get HTTP response body as string.\", e);\n+            }\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.code())) {\n+            int code = response.code();\n+            String message = response.message();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = \"\";\n+            try {\n+                responseBody = mapToString(response.body());\n+            } catch (IOException e) {\n+                logger.error(\"Could not get HTTP response body as string.\", e);\n+            }\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            if (code == HTTP_CONFLICT && containsIgnoreCase(responseBody, \"error\")", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4MzgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585783838", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5ODQzMA=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 2c0824606b..3ae3f9c874 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -12,39 +12,11 @@\n  */\n package org.openhab.binding.homeconnect.internal.client;\n \n-import static java.net.HttpURLConnection.HTTP_CONFLICT;\n-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n import static java.util.Arrays.asList;\n import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n-import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n-import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n-import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n-\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n import java.time.ZonedDateTime;\n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5OTc0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564799741", "bodyText": "Please remove use of org.apache.commons.lang.StringUtils\nShould be easy here.", "author": "lolodomo", "createdAt": "2021-01-26T20:08:37Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NDA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585784058", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5OTc0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex c7a1c505e8..f81b07d8f9 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -13,13 +13,8 @@\n package org.openhab.binding.homeconnect.internal.client;\n \n import static java.time.LocalDateTime.now;\n-import static org.apache.commons.lang.StringUtils.isEmpty;\n-import static org.openhab.binding.homeconnect.internal.client.model.EventType.EVENT;\n-import static org.openhab.binding.homeconnect.internal.client.model.EventType.NOTIFY;\n-import static org.openhab.binding.homeconnect.internal.client.model.EventType.STATUS;\n-import static org.openhab.binding.homeconnect.internal.client.model.EventType.valueOfType;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n \n-import java.io.IOException;\n import java.time.Instant;\n import java.time.LocalDateTime;\n import java.time.ZonedDateTime;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxMjIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564812214", "bodyText": "Please add the missing parameter haId", "author": "lolodomo", "createdAt": "2021-01-26T20:30:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = new CircularQueue<>(EVENT_QUEUE_SIZE);\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Connect API. This helps to reduce the\n+     * amount of request you would usually need to update all channels.\n+     *\n+     * Checkout rate limits of the API at. https://developer.home-connect.com/docs/general/ratelimiting\n+     *\n+     * @param eventListener appliance event listener", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NDg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585784869", "bodyText": "Done (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxMjIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\nindex dcc279f2ef..a0fbe38563 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n\n@@ -12,8 +12,7 @@\n  */\n package org.openhab.binding.homeconnect.internal.client;\n \n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n \n import java.util.Collection;\n import java.util.HashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDMwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564820309", "bodyText": "Please add the missing parameter unit", "author": "lolodomo", "createdAt": "2021-01-26T20:44:33Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NDMwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585784302", "bodyText": "Done (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDMwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 2c0824606b..3ae3f9c874 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -12,39 +12,11 @@\n  */\n package org.openhab.binding.homeconnect.internal.client;\n \n-import static java.net.HttpURLConnection.HTTP_CONFLICT;\n-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n import static java.util.Arrays.asList;\n import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n-import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n-import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n-import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n-\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n import java.time.ZonedDateTime;\n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDYwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564820603", "bodyText": "Please add the missing parameter unit", "author": "lolodomo", "createdAt": "2021-01-26T20:45:06Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NTYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585785631", "bodyText": "Done (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 2c0824606b..3ae3f9c874 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -12,39 +12,11 @@\n  */\n package org.openhab.binding.homeconnect.internal.client;\n \n-import static java.net.HttpURLConnection.HTTP_CONFLICT;\n-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n-import static java.net.HttpURLConnection.HTTP_OK;\n-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n import static java.util.Arrays.asList;\n import static java.util.Collections.singletonList;\n-import static java.util.Objects.requireNonNull;\n-import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n-import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n-import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n-\n-import java.io.IOException;\n-import java.nio.charset.StandardCharsets;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n import java.time.ZonedDateTime;\n import java.util.ArrayList;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564830030", "bodyText": "Please remove use of org.apache.commons.lang.StringUtils", "author": "lolodomo", "createdAt": "2021-01-26T21:01:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,628 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzk0OTAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r567949021", "bodyText": "Yes, will do. One user reported it on the weekend. In some circumstances Apache Commons was missing in the OH3 environment.", "author": "bruestel", "createdAt": "2021-02-01T16:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTc4NTI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585785283", "bodyText": "Now removed (included in my PR).", "author": "lolodomo", "createdAt": "2021-03-02T17:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex c7760bb474..d2d58f6233 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -14,12 +14,7 @@ package org.openhab.binding.homeconnect.internal.servlet;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n import static java.time.ZonedDateTime.now;\n-import static org.apache.commons.lang.StringUtils.isEmpty;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n \n import java.io.IOException;\n import java.io.PrintWriter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMjE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564832143", "bodyText": "You need to try a second time ?", "author": "lolodomo", "createdAt": "2021-01-26T21:05:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,628 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {", "originalCommit": "e1eb8165e67aa1a262cf44187224c4f151420c11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MTgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624641830", "bodyText": "Left over. Will remove it", "author": "bruestel", "createdAt": "2021-05-02T06:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMjE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex c7760bb474..d2d58f6233 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -14,12 +14,7 @@ package org.openhab.binding.homeconnect.internal.servlet;\n \n import static java.nio.charset.StandardCharsets.UTF_8;\n import static java.time.ZonedDateTime.now;\n-import static org.apache.commons.lang.StringUtils.isEmpty;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n-import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n \n import java.io.IOException;\n import java.io.PrintWriter;\n"}}, {"oid": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "url": "https://github.com/openhab/openhab-addons/commit/77806786a7e91f9029fb1ba90a236d87ca371f7e", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T16:55:29Z", "type": "forcePushed"}, {"oid": "edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "url": "https://github.com/openhab/openhab-addons/commit/edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T16:59:18Z", "type": "forcePushed"}, {"oid": "4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "url": "https://github.com/openhab/openhab-addons/commit/4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T17:06:32Z", "type": "forcePushed"}, {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d", "url": "https://github.com/openhab/openhab-addons/commit/d87bf3c15b837ef0487e30f37e609e29f9aa438d", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-03-02T17:13:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591873349", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n          \n          \n            \n                        .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n          \n          \n            \n                        .collect(Collectors.toSet());\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Set\n          \n          \n            \n                        .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP);", "author": "fwolter", "createdAt": "2021-03-10T21:09:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link HomeConnectBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBindingConstants {\n+\n+    public static final String BINDING_ID = \"homeconnect\";\n+\n+    public static final String HA_ID = \"haId\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_API_BRIDGE = new ThingTypeUID(BINDING_ID, \"api_bridge\");\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+    public static final ThingTypeUID THING_TYPE_WASHER = new ThingTypeUID(BINDING_ID, \"washer\");\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washerdryer\");\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridgefreezer\");\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+    public static final ThingTypeUID THING_TYPE_COFFEE_MAKER = new ThingTypeUID(BINDING_ID, \"coffeemaker\");\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+    public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    // Setting\n+    public static final String SETTING_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String SETTING_LIGHTING = \"Cooking.Common.Setting.Lighting\";\n+    public static final String SETTING_AMBIENT_LIGHT_ENABLED = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String SETTING_LIGHTING_BRIGHTNESS = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_BRIGHTNESS = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_COLOR = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String SETTING_AMBIENT_LIGHT_CUSTOM_COLOR = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+    public static final String SETTING_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String SETTING_REFRIGERATOR_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String SETTING_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+\n+    // Status\n+    public static final String STATUS_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String STATUS_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String STATUS_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String STATUS_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String STATUS_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+\n+    // SSE Event types\n+    public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+    public static final String EVENT_POWER_STATE = SETTING_POWER_STATE;\n+    public static final String EVENT_CONNECTED = \"CONNECTED\";\n+    public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n+    public static final String EVENT_DOOR_STATE = STATUS_DOOR_STATE;\n+    public static final String EVENT_OPERATION_STATE = STATUS_OPERATION_STATE;\n+    public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n+    public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = STATUS_REMOTE_CONTROL_START_ALLOWED;\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = STATUS_REMOTE_CONTROL_ACTIVE;\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = STATUS_LOCAL_CONTROL_ACTIVE;\n+    public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String EVENT_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String EVENT_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String EVENT_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String EVENT_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String EVENT_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String EVENT_FREEZER_SETPOINT_TEMPERATURE = SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+    public static final String EVENT_FRIDGE_SETPOINT_TEMPERATURE = SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+    public static final String EVENT_FREEZER_SUPER_MODE = SETTING_FREEZER_SUPER_MODE;\n+    public static final String EVENT_FRIDGE_SUPER_MODE = SETTING_REFRIGERATOR_SUPER_MODE;\n+    public static final String EVENT_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.BeanContainerEmpty\";\n+    public static final String EVENT_COFFEEMAKER_WATER_TANK_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.WaterTankEmpty\";\n+    public static final String EVENT_COFFEEMAKER_DRIP_TRAY_FULL = \"ConsumerProducts.CoffeeMaker.Event.DripTrayFull\";\n+    public static final String EVENT_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String EVENT_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_STATE = SETTING_LIGHTING;\n+    public static final String EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = SETTING_LIGHTING_BRIGHTNESS;\n+    public static final String EVENT_AMBIENT_LIGHT_STATE = SETTING_AMBIENT_LIGHT_ENABLED;\n+    public static final String EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE = SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+    public static final String EVENT_AMBIENT_LIGHT_COLOR_STATE = SETTING_AMBIENT_LIGHT_COLOR;\n+    public static final String EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+\n+    // Channel IDs\n+    public static final String CHANNEL_DOOR_STATE = \"door_state\";\n+    public static final String CHANNEL_ELAPSED_PROGRAM_TIME = \"elapsed_program_time\";\n+    public static final String CHANNEL_POWER_STATE = \"power_state\";\n+    public static final String CHANNEL_OPERATION_STATE = \"operation_state\";\n+    public static final String CHANNEL_ACTIVE_PROGRAM_STATE = \"active_program_state\";\n+    public static final String CHANNEL_SELECTED_PROGRAM_STATE = \"selected_program_state\";\n+    public static final String CHANNEL_BASIC_ACTIONS_STATE = \"basic_actions_state\";\n+    public static final String CHANNEL_REMOTE_START_ALLOWANCE_STATE = \"remote_start_allowance_state\";\n+    public static final String CHANNEL_REMOTE_CONTROL_ACTIVE_STATE = \"remote_control_active_state\";\n+    public static final String CHANNEL_LOCAL_CONTROL_ACTIVE_STATE = \"local_control_active_state\";\n+    public static final String CHANNEL_REMAINING_PROGRAM_TIME_STATE = \"remaining_program_time_state\";\n+    public static final String CHANNEL_PROGRAM_PROGRESS_STATE = \"program_progress_state\";\n+    public static final String CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE = \"oven_current_cavity_temperature\";\n+    public static final String CHANNEL_SETPOINT_TEMPERATURE = \"setpoint_temperature\";\n+    public static final String CHANNEL_DURATION = \"duration\";\n+    public static final String CHANNEL_WASHER_TEMPERATURE = \"laundry_care_washer_temperature\";\n+    public static final String CHANNEL_WASHER_SPIN_SPEED = \"laundry_care_washer_spin_speed\";\n+    public static final String CHANNEL_WASHER_IDOS1 = \"laundry_care_washer_idos1\";\n+    public static final String CHANNEL_WASHER_IDOS2 = \"laundry_care_washer_idos2\";\n+    public static final String CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE = \"setpoint_temperature_refrigerator\";\n+    public static final String CHANNEL_REFRIGERATOR_SUPER_MODE = \"super_mode_refrigerator\";\n+    public static final String CHANNEL_FREEZER_SETPOINT_TEMPERATURE = \"setpoint_temperature_freezer\";\n+    public static final String CHANNEL_FREEZER_SUPER_MODE = \"super_mode_freezer\";\n+    public static final String CHANNEL_DRYER_DRYING_TARGET = \"dryer_drying_target\";\n+    public static final String CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE = \"coffeemaker_drip_tray_full_state\";\n+    public static final String CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE = \"coffeemaker_water_tank_empty_state\";\n+    public static final String CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE = \"coffeemaker_bean_container_empty_state\";\n+    public static final String CHANNEL_HOOD_VENTING_LEVEL = \"hood_venting_level\";\n+    public static final String CHANNEL_HOOD_INTENSIVE_LEVEL = \"hood_intensive_level\";\n+    public static final String CHANNEL_HOOD_ACTIONS_STATE = \"hood_program_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_STATE = \"functional_light_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"functional_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_STATE = \"ambient_light_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"ambient_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_COLOR_STATE = \"ambient_light_color_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"ambient_light_custom_color_state\";\n+\n+    // List of all supported devices\n+    public static final Set<ThingTypeUID> SUPPORTED_DEVICE_THING_TYPES_UIDS = Stream.of(THING_TYPE_API_BRIDGE,\n+            THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+            THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // Discoverable devices\n+    public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n+            .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM0MTY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593341656", "bodyText": "This is Java 11 syntax only, isn't it ?\n@bruestel tries to maintain a common code for OH 2.5 and OH3.", "author": "lolodomo", "createdAt": "2021-03-12T17:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyMTUwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600221507", "bodyText": "Will change it", "author": "bruestel", "createdAt": "2021-03-24T07:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java\nindex 3af65a89ea..d8aa1cbd51 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3NjAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591876008", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2021-03-10T21:14:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 3ae3f9c874..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591882899", "bodyText": "As this pattern occurs quite often, you could simplify code by including the message in the exception. Then, you only need to log the message once, where the exception is caught finally.\nAlso, take care to handle the InterruptedException appropriately. The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n          \n          \n            \n                        logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n          \n          \n            \n                        trackAndLogApiRequest(null, request, null, null, null);\n          \n          \n            \n                        throw new CommunicationException(e);\n          \n          \n            \n                    }\n          \n          \n            \n                    } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n          \n          \n            \n                        trackAndLogApiRequest(null, request, null, null, null);\n          \n          \n            \n                        throw new CommunicationException(\"Failed to fetch home appliances\", e);\n          \n          \n            \n                    }", "author": "fwolter", "createdAt": "2021-03-10T21:25:41Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyNDAyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600224020", "bodyText": "The trackAndLogApiRequest just logs the HTTP request for the web UI. If debug logging level is enabled it also prints the request to the console.\n--> if debug level is set to info or higher, the user won't be able to recognize the communication problem\nI would like to distinguish request from \"normal\" logging.", "author": "bruestel", "createdAt": "2021-03-24T07:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MjI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624642260", "bodyText": "@fwolter Can I resolve this conversation?", "author": "bruestel", "createdAt": "2021-05-02T06:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NzM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647350", "bodyText": "Yes", "author": "fwolter", "createdAt": "2021-05-02T07:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 3ae3f9c874..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4ODE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591888151", "bodyText": "As this can also happen if the JSON contains unexpected data, this should be warn. error can be used if a bug in your code has been detected, for example.", "author": "fwolter", "createdAt": "2021-03-10T21:34:12Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId + \"/programs/available/\" + programKey);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.getStatus() == HttpStatus.OK_200) {\n+                return responseBody;\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(asList(HttpStatus.OK_200, HttpStatus.NOT_FOUND_404), request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.DELETE, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, ContentResponse response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, ContentResponse response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HttpStatus.UNAUTHORIZED_401)\n+                && response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.getStatus())) {\n+            int code = response.getStatus();\n+            String message = response.getReason();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            responseBody = responseBody == null ? \"\" : responseBody;\n+            if (code == HttpStatus.CONFLICT_409 && responseBody.toLowerCase().contains(\"error\")\n+                    && responseBody.toLowerCase().contains(\"offline\")) {\n+                throw new ApplianceOfflineException(code, message, responseBody);\n+            } else {\n+                throw new CommunicationException(code, message, responseBody);\n+            }\n+        }\n+    }\n+\n+    private Program mapToProgram(String json) {\n+        ArrayList<Option> optionList = new ArrayList<>();\n+        JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+        JsonObject data = responseObject.getAsJsonObject(\"data\");\n+        Program result = new Program(data.get(\"key\").getAsString(), optionList);\n+        JsonArray options = data.getAsJsonArray(\"options\");\n+\n+        options.forEach(option -> {\n+            JsonObject obj = (JsonObject) option;\n+\n+            @Nullable\n+            String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+            @Nullable\n+            String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull() ? obj.get(\"value\").getAsString()\n+                    : null;\n+            @Nullable\n+            String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+\n+            optionList.add(new Option(key, value, unit));\n+        });\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgram> mapToAvailablePrograms(String json, String haId) {\n+        ArrayList<AvailableProgram> result = new ArrayList<>();\n+\n+        try {\n+            JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+\n+            JsonArray programs = responseObject.getAsJsonObject(\"data\").getAsJsonArray(\"programs\");\n+            programs.forEach(program -> {\n+                JsonObject obj = (JsonObject) program;\n+                @Nullable\n+                String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                JsonObject constraints = obj.getAsJsonObject(\"constraints\");\n+                boolean available = constraints.get(\"available\") != null && constraints.get(\"available\").getAsBoolean();\n+                @Nullable\n+                String execution = constraints.get(\"execution\") != null ? constraints.get(\"execution\").getAsString()\n+                        : null;\n+\n+                if (key != null && execution != null) {\n+                    result.add(new AvailableProgram(key, available, execution));\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.error(\"Could not parse available programs response! haId={}, error={}\", haId, e.getMessage());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyNDU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600224568", "bodyText": "will change it", "author": "bruestel", "createdAt": "2021-03-24T07:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4ODE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 3ae3f9c874..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4OTA5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591889099", "bodyText": "Is there any reason why you don't use DTOs for the mapping methods?", "author": "fwolter", "createdAt": "2021-03-10T21:35:48Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId + \"/programs/available/\" + programKey);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.getStatus() == HttpStatus.OK_200) {\n+                return responseBody;\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(asList(HttpStatus.OK_200, HttpStatus.NOT_FOUND_404), request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.DELETE, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, ContentResponse response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, ContentResponse response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HttpStatus.UNAUTHORIZED_401)\n+                && response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.getStatus())) {\n+            int code = response.getStatus();\n+            String message = response.getReason();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            responseBody = responseBody == null ? \"\" : responseBody;\n+            if (code == HttpStatus.CONFLICT_409 && responseBody.toLowerCase().contains(\"error\")\n+                    && responseBody.toLowerCase().contains(\"offline\")) {\n+                throw new ApplianceOfflineException(code, message, responseBody);\n+            } else {\n+                throw new CommunicationException(code, message, responseBody);\n+            }\n+        }\n+    }\n+\n+    private Program mapToProgram(String json) {\n+        ArrayList<Option> optionList = new ArrayList<>();\n+        JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+        JsonObject data = responseObject.getAsJsonObject(\"data\");\n+        Program result = new Program(data.get(\"key\").getAsString(), optionList);\n+        JsonArray options = data.getAsJsonArray(\"options\");\n+\n+        options.forEach(option -> {\n+            JsonObject obj = (JsonObject) option;\n+\n+            @Nullable\n+            String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+            @Nullable\n+            String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull() ? obj.get(\"value\").getAsString()\n+                    : null;\n+            @Nullable\n+            String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+\n+            optionList.add(new Option(key, value, unit));\n+        });\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgram> mapToAvailablePrograms(String json, String haId) {\n+        ArrayList<AvailableProgram> result = new ArrayList<>();\n+\n+        try {\n+            JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+\n+            JsonArray programs = responseObject.getAsJsonObject(\"data\").getAsJsonArray(\"programs\");\n+            programs.forEach(program -> {\n+                JsonObject obj = (JsonObject) program;\n+                @Nullable\n+                String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                JsonObject constraints = obj.getAsJsonObject(\"constraints\");\n+                boolean available = constraints.get(\"available\") != null && constraints.get(\"available\").getAsBoolean();\n+                @Nullable\n+                String execution = constraints.get(\"execution\") != null ? constraints.get(\"execution\").getAsString()\n+                        : null;\n+\n+                if (key != null && execution != null) {\n+                    result.add(new AvailableProgram(key, available, execution));\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.error(\"Could not parse available programs response! haId={}, error={}\", haId, e.getMessage());\n+        }\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgramOption> mapToAvailableProgramOption(String json, String haId) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIyNTI3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600225272", "bodyText": "No there is no reason for it.", "author": "bruestel", "createdAt": "2021-03-24T07:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4OTA5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\nindex 3ae3f9c874..1d4ee0c67d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MTgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591891816", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed.", "author": "fwolter", "createdAt": "2021-03-10T21:40:01Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.sse.SseEventSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, SseEventSource> eventSourceConnections;\n+    private final Map<SseEventSource, HomeConnectEventSourceListener> eventSourceListeners;\n+    private final ScheduledExecutorService scheduler;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+\n+    public HomeConnectEventSourceClient(ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            OAuthClientService oAuthClientService, boolean simulated, ScheduledExecutorService scheduler,\n+            @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceConnections = new HashMap<>();\n+        eventSourceListeners = new HashMap<>();\n+        eventQueue = new CircularQueue<>(EVENT_QUEUE_SIZE);\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Connect API. This helps to reduce the\n+     * amount of request you would usually need to update all channels.\n+     *\n+     * Checkout rate limits of the API at. https://developer.home-connect.com/docs/general/ratelimiting\n+     *\n+     * @param haId appliance id\n+     * @param eventListener appliance event listener\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public synchronized void registerEventListener(final String haId, final HomeConnectEventListener eventListener)\n+            throws CommunicationException, AuthorizationException {\n+        logger.debug(\"Register event listener for '{}': {}\", haId, eventListener);\n+\n+        if (!eventSourceConnections.containsKey(eventListener)) {\n+            logger.debug(\"Create new event source listener for '{}'.\", haId);\n+            Client client = clientBuilder.readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).register(\n+                    new HomeConnectStreamingRequestFilter(HttpHelper.getAuthorizationHeader(oAuthClientService)))\n+                    .build();\n+            SseEventSource eventSource = eventSourceFactory\n+                    .newSource(client.target(apiUrl + \"/api/homeappliances/\" + haId + \"/events\"));\n+            HomeConnectEventSourceListener eventSourceListener = new HomeConnectEventSourceListener(haId, eventListener,\n+                    this, scheduler, eventQueue);\n+            eventSource.register(eventSourceListener::onEvent, eventSourceListener::onError,\n+                    eventSourceListener::onComplete);\n+            eventSourceListeners.put(eventSource, eventSourceListener);\n+            eventSourceConnections.put(eventListener, eventSource);\n+            eventSource.open();\n+        }\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener) {\n+        unregisterEventListener(eventListener, false, false);\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     * @param completed true when the event source is known as already completed by the server\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener, boolean completed) {\n+        unregisterEventListener(eventListener, false, completed);\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     * @param immediate true when the unregistering of the event source has to be fast\n+     * @param completed true when the event source is known as already completed by the server\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener, boolean immediate,\n+            boolean completed) {\n+        if (eventSourceConnections.containsKey(eventListener)) {\n+            @Nullable\n+            SseEventSource eventSource = eventSourceConnections.get(eventListener);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIzMTAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600231030", "bodyText": "will fix it", "author": "bruestel", "createdAt": "2021-03-24T07:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MTgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\nindex a0fbe38563..69c61dd894 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MjY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591892664", "bodyText": "See above. Suffix.", "author": "fwolter", "createdAt": "2021-03-10T21:41:28Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex f81b07d8f9..733ab4c06c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893144", "bodyText": "See above. Could be removed. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T21:42:14Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex f81b07d8f9..733ab4c06c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893544", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2021-03-10T21:42:57Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIzNjc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600236778", "bodyText": "Unfortunately not, at this point all HomeConnectEventListener implementations get informed about a new event. Any class which is implementing this interface could throw an exception. To ensure that all listeners get the event, the errors are caught.", "author": "bruestel", "createdAt": "2021-03-24T07:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzU0NA=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex f81b07d8f9..733ab4c06c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5Mzg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893882", "bodyText": "See above. Concrete type. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T21:43:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    public void onComplete() {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener, true);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDIzNjkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600236923", "bodyText": "Same as above", "author": "bruestel", "createdAt": "2021-03-24T07:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5Mzg4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex f81b07d8f9..733ab4c06c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591895901", "bodyText": "If I see correctly, this is run in a framework thread, which shouldn't be blocked by sleeps. You could submit an executor task with a delay.", "author": "fwolter", "createdAt": "2021-03-10T21:47:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    public void onComplete() {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener, true);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    public void onError(Throwable error) {\n+        @Nullable\n+        String throwableMessage = error.getMessage();\n+        String throwableClass = error.getClass().getName();\n+\n+        logger.debug(\"Event source listener connection failure occurred. haId={}, throwable={}, throwableMessage={}\",\n+                haId, throwableClass, throwableMessage);\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            if (throwableMessage != null\n+                    && throwableMessage.contains(String.valueOf(HttpStatus.TOO_MANY_REQUESTS_429))) {\n+                logger.warn(\n+                        \"More than 10 active event monitoring channels was reached. Further event monitoring requests are blocked. haId={}\",\n+                        haId);\n+                eventListener.onRateLimitReached();\n+            } else {\n+                // The SSE connection is closed by the server every 24 hours.\n+                // When you try to reconnect, it often fails with a NotAuthorizedException (401) for the next few\n+                // seconds. So we wait few seconds before trying again.\n+                if (error instanceof NotAuthorizedException) {\n+                    logger.debug(\n+                            \"Event source listener connection failure due to unauthorized exception : wait 5 seconds... haId={}\",\n+                            haId);\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException e1) {\n+                    }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM0NzkwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593347903", "bodyText": "No this is not handled by a framework thread.\nI believe it is handled by a thread created by JAX-RS SSE.\nScheduling a task with a delay here will add complexity to the code IMHO.", "author": "lolodomo", "createdAt": "2021-03-12T17:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Mzc4NDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593784437", "bodyText": "I would consider JAX-RS SSE as part of the framework. I couldn't figure out at first glance which thread pool is used or if any is used at all. If it is a shared thread pool, sleep must not be used. You could break into it and check the stack trace.\nI don't think it would make the code much more complicated.", "author": "fwolter", "createdAt": "2021-03-13T18:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0MDMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600240326", "bodyText": "Would it be ok to change it to:\n                if (error instanceof NotAuthorizedException) {\n                    logger.debug(\n                            \"Event source listener connection failure due to unauthorized exception : wait 5 seconds... haId={}\",\n                            haId);\n\n                    scheduler.schedule(() -> eventListener.onClosed(), 5, TimeUnit.SECONDS);\n                } else {\n                    eventListener.onClosed();\n                }", "author": "bruestel", "createdAt": "2021-03-24T07:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ3NTA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r602475063", "bodyText": "Sure!", "author": "fwolter", "createdAt": "2021-03-26T17:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\nindex f81b07d8f9..733ab4c06c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591897838", "bodyText": "Is this bucket valid for all Things/accounts by intention, as it is static? I would expect the rate limiting only valid per account.", "author": "fwolter", "createdAt": "2021-03-10T21:50:21Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM1NzcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593357725", "bodyText": "You're certainly right.\n@bruestel : do you agree ?", "author": "lolodomo", "createdAt": "2021-03-12T17:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0NTU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600245540", "bodyText": "Yes, good thought. Thanks @fwolter . I will move the code to the HomeConnectApiClient. Each account is using it's own client instance.", "author": "bruestel", "createdAt": "2021-03-24T07:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nsimilarity index 64%\nrename from bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java\nrename to bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nindex 365431e05b..c4ac029cb9 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591898419", "bodyText": "If you need to access the logger in a static way, you can make it a static field. This should be debug or warn.", "author": "fwolter", "createdAt": "2021-03-10T21:51:24Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ0OTkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619449919", "bodyText": "Does the error message suite the exception type? An InterruptedException is thrown when the current Thread is interrupted. E.g. when OH is shut down.\nBindings should only log to error if something severe happened, like the detection of a bug in your code. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging\nThis method throws InterruptedException, but it is cought here.", "author": "fwolter", "createdAt": "2021-04-23T19:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0MjU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624642569", "bodyText": "Changed log level to debug and adjusted error message. \"Could not consume from bucket! clientId={}, error={}\"", "author": "bruestel", "createdAt": "2021-05-02T06:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nsimilarity index 64%\nrename from bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java\nrename to bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nindex 365431e05b..c4ac029cb9 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591899971", "bodyText": "As you already set the exception's cause, you don't need to also add the message.", "author": "fwolter", "createdAt": "2021-03-10T21:54:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());\n+            }\n+        }\n+        return request.send();\n+    }\n+\n+    public static String formatJsonBody(@Nullable String jsonString) {\n+        if (jsonString == null) {\n+            return \"\";\n+        }\n+        try {\n+            JsonObject json = JSON_PARSER.parse(jsonString).getAsJsonObject();\n+            return GSON.toJson(json);\n+        } catch (Exception e) {\n+            return jsonString;\n+        }\n+    }\n+\n+    public static String getAuthorizationHeader(OAuthClientService oAuthClientService)\n+            throws AuthorizationException, CommunicationException {\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            // refresh the token if it's about to expire\n+            if (accessTokenResponse != null\n+                    && accessTokenResponse.isExpired(LocalDateTime.now(), OAUTH_EXPIRE_BUFFER)) {\n+                LoggerFactory.getLogger(HttpHelper.class).debug(\"Requesting a refresh of the access token.\");\n+                accessTokenResponse = oAuthClientService.refreshToken();\n+            }\n+\n+            if (accessTokenResponse != null) {\n+                String lastToken = lastAccessToken;\n+                if (lastToken == null) {\n+                    LoggerFactory.getLogger(HttpHelper.class).debug(\"The used access token was created at {}\",\n+                            accessTokenResponse.getCreatedOn().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n+                } else if (!lastToken.equals(accessTokenResponse.getAccessToken())) {\n+                    LoggerFactory.getLogger(HttpHelper.class).debug(\"The access token changed. New one created at {}\",\n+                            accessTokenResponse.getCreatedOn().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n+                }\n+                lastAccessToken = accessTokenResponse.getAccessToken();\n+                return BEARER + accessTokenResponse.getAccessToken();\n+            } else {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"No access token available! Fatal error.\");\n+                throw new AuthorizationException(\"No access token available!\");\n+            }\n+        } catch (IOException e) {\n+            @Nullable\n+            String errorMessage = e.getMessage();\n+            throw new CommunicationException(errorMessage != null ? errorMessage : \"IOException\", e);\n+        } catch (OAuthException | OAuthResponseException e) {\n+            @Nullable\n+            String errorMessage = e.getMessage();\n+            throw new AuthorizationException(errorMessage != null ? errorMessage : \"oAuth exception\", e);\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0Njk0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600246949", "bodyText": "I did it because the exception message is shown in the UI. Makes it easier for the users to see what's wrong.", "author": "bruestel", "createdAt": "2021-03-24T07:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ3NzEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r602477136", "bodyText": "You could move this code to where the exception is translated into a string to pass it as status detail message. That would remove the redundant error message.", "author": "fwolter", "createdAt": "2021-03-26T17:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nsimilarity index 64%\nrename from bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java\nrename to bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\nindex 365431e05b..c4ac029cb9 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMzU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591903583", "bodyText": "This could by null due to concurrency.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n          \n          \n            \n                private @Nullable HomeConnectBridgeHandler bridgeHandler;", "author": "fwolter", "createdAt": "2021-03-10T22:00:35Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0OTQ2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600249460", "bodyText": "will change it", "author": "bruestel", "createdAt": "2021-03-24T08:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMzU4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 6afcbee9b1..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904014", "bodyText": "This could be removed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {\n          \n          \n            \n                public void setThingHandler(ThingHandler handler) {", "author": "fwolter", "createdAt": "2021-03-10T22:01:28Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService}.\n+     *\n+     */\n+    public HomeConnectDiscoveryService() {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 6afcbee9b1..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904764", "bodyText": "See above. Concrete type. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T22:02:55Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService}.\n+     *\n+     */\n+    public HomeConnectDiscoveryService() {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {\n+        if (handler instanceof HomeConnectBridgeHandler) {\n+            this.bridgeHandler = (HomeConnectBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (thingTypeUID != null) {\n+                    logger.debug(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties).withRepresentationProperty(HA_ID)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\nindex 6afcbee9b1..fc7425183d 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTM2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905365", "bodyText": "See above. Suffix.", "author": "fwolter", "createdAt": "2021-03-10T22:04:02Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905691", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-03-10T22:04:39Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM1MTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593351069", "bodyText": "You mean here using logger.trace ?\nThis is a typical DEBUG log you can find in many bindings.", "author": "lolodomo", "createdAt": "2021-03-12T17:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1MTg1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619451856", "bodyText": "This is already logged by the framework and can therefore be removed. See the popular loggers table: https://www.openhab.org/docs/administration/logging.html#defining-what-to-log", "author": "fwolter", "createdAt": "2021-04-23T19:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905963", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2021-03-10T22:05:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591907411", "bodyText": "Actually this is handled by the framework. Any child Things are set to OFFLINE if the bridge is offline. This is done if the child Things are UNKNOWN or ONLINE.", "author": "fwolter", "createdAt": "2021-03-10T22:07:29Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NDEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624644104", "bodyText": "Is it harmful if I put it explicitly? I do it because the initialize() method can also be called by a scheduler (\"monitor\") within the binding.", "author": "bruestel", "createdAt": "2021-05-02T07:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NzU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647567", "bodyText": "No, you can leave it as is.", "author": "fwolter", "createdAt": "2021-05-02T07:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591907740", "bodyText": "See above. Logging could be removed. Same for below.", "author": "fwolter", "createdAt": "2021-03-10T22:08:02Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591909783", "bodyText": "You could add the message to updateStatus() as an argument, to display it in the UI. The log message can be removed, then. Same for below.", "author": "fwolter", "createdAt": "2021-03-10T22:11:53Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1MjM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619452370", "bodyText": "Can you comment on my comment?", "author": "fwolter", "createdAt": "2021-04-23T19:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NTA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624645076", "bodyText": "In my opinion, the message 'Could not handle command...' in the Thing status is not appropriate. It is an error message as a result of an action. I think it is ok to set the status to OFFLINE without a message.", "author": "bruestel", "createdAt": "2021-05-02T07:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0NzkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647931", "bodyText": "If it can only fail if the device is offline, you could add \"Communication timed out\" or so, to the status detail message.\nWill the Thing come online again, when it is reachable again?", "author": "fwolter", "createdAt": "2021-05-02T07:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY2MjIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624662214", "bodyText": "Yes will come online again. Will change it as suggested.", "author": "bruestel", "createdAt": "2021-05-02T09:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMDA3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591910071", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-03-10T22:12:27Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMjQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591912498", "bodyText": "Are these checks necessary? If I see correctly, the Thing is set OFFLINE if there is no bridge or the bridge is offline. Then, the third check would be sufficient.", "author": "fwolter", "createdAt": "2021-03-10T22:16:47Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2MDc4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600260782", "bodyText": "Yes the thing should be offline when the bridge is not present.\nI added it to make sure everything is fine before executing a command. Sometimes concurrent processes run, so I wanted to be sure. I think the check doesn't hurt and I would like to keep it.", "author": "bruestel", "createdAt": "2021-03-24T08:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMjQ5OA=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591914566", "bodyText": "Can you use isThingReadyToHandleCommand() here?", "author": "fwolter", "createdAt": "2021-03-10T22:20:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2NDA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600264068", "bodyText": "yes", "author": "bruestel", "createdAt": "2021-03-24T08:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNTg5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591915892", "bodyText": "What is the reason for catching RuntimeExceptions? Actually, these are handled by the framework.", "author": "fwolter", "createdAt": "2021-03-10T22:23:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2NTExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600265112", "bodyText": "leftover", "author": "bruestel", "createdAt": "2021-03-24T08:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNTg5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxODYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591918616", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n          \n          \n            \n                            STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n          \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n          \n          \n            \n                            OnOffType.from(!STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()))));", "author": "fwolter", "createdAt": "2021-03-10T22:28:17Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxOTE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591919167", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(\n          \n          \n            \n                            channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n          \n          \n            \n                    return event -> getThingChannel(channelId)\n          \n          \n            \n                            .ifPresent(channel -> updateState(channel.getUID(), OnOffType.from(event.getValueAsBoolean())));", "author": "fwolter", "createdAt": "2021-03-10T22:29:16Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyMDEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591920130", "bodyText": "See above. Use from(). Please check all.", "author": "fwolter", "createdAt": "2021-03-10T22:31:09Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyMzY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591923672", "bodyText": "Can you use isThingReadyToHandleCommand() here?", "author": "fwolter", "createdAt": "2021-03-10T22:38:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelTemperature.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelDryingTarget.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        channelSpinSpeed\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherSpinSpeed)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        channelTemperature\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherTemperature)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                                .setStateOptions(channel.getUID(), createStateOptions(option, this::mapStringType)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private List<StateOption> createStateOptions(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        return option.getAllowedValues().stream().map(av -> new StateOption(av, stateConverter.apply(av)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591924952", "bodyText": "Is there any difference between the two, beside the delay?", "author": "fwolter", "createdAt": "2021-03-10T22:40:32Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelTemperature.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelDryingTarget.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        channelSpinSpeed\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherSpinSpeed)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        channelTemperature\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherTemperature)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                                .setStateOptions(channel.getUID(), createStateOptions(option, this::mapStringType)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private List<StateOption> createStateOptions(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        return option.getAllowedValues().stream().map(av -> new StateOption(av, stateConverter.apply(av)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    reinitialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);\n+            this.reinitializationFuture1 = null;\n+        }\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor2() {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0Nzg0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624647847", "bodyText": "It's complicated :-D\nMonitor 1\nChecks every 30 minutes if thing is ONLINE again (isBridgeOnline() && isThingOffline()). This is the 'normal' monitor.\nMonitor 2\nChecks every 4 minutes if thing is accessible again (isBridgeOnline() && !accessible.get()). Things can be OFFLINE but still be connect to the cloud. The appliances are not really OFFLINE, they are just turned off and in the UI it's shown as OFFLINE.\nIf an appliance is not connected, it's usually caused by a network or Home Connect service problem.", "author": "bruestel", "createdAt": "2021-05-02T07:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0ODQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624648432", "bodyText": "OK", "author": "fwolter", "createdAt": "2021-05-02T07:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 4fae1b9295..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNTUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591925519", "bodyText": "See above. Suffix.", "author": "fwolter", "createdAt": "2021-03-10T22:41:44Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex dfddd57640..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNjQ5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591926499", "bodyText": "Is there any reason for logging the OH version?", "author": "fwolter", "createdAt": "2021-03-10T22:43:46Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2ODI5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600268293", "bodyText": "leftover from previous logging system", "author": "bruestel", "createdAt": "2021-03-24T08:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNjQ5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex dfddd57640..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNzUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591927530", "bodyText": "These can be null if the user forgets to specify them with textual configuration.", "author": "fwolter", "createdAt": "2021-03-10T22:45:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link ApiBridgeConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiBridgeConfiguration {\n+\n+    private @NonNullByDefault({}) String clientId;\n+    private @NonNullByDefault({}) String clientSecret;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzcyODUxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593728518", "bodyText": "I would suggest to set it by default to an empty string and then check in the thing handler initialization that the value is not empty. If value is empty, you set a CONFIGURATION_ERROR.\nprivate String clientId = \"\";", "author": "lolodomo", "createdAt": "2021-03-13T09:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNzUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java\nindex a29f21ff3e..1c8a80b4b3 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODIwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928209", "bodyText": "See above. Could be removed. Please check all.", "author": "fwolter", "createdAt": "2021-03-10T22:47:05Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex dfddd57640..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928503", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-03-10T22:47:36Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(true);\n+    }\n+\n+    public void reinitialize() {\n+        logger.debug(\"Reinitialize bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(false);\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex dfddd57640..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyOTIwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591929201", "bodyText": "See above, info and error.", "author": "fwolter", "createdAt": "2021-03-10T22:49:00Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(true);\n+    }\n+\n+    public void reinitialize() {\n+        logger.debug(\"Reinitialize bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(false);\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {\n+                logger.info(\"Clear oAuth credential store. bridge={}\", getThing().getLabel());\n+                oAuthClientService.remove();\n+            } catch (OAuthException e) {\n+                logger.error(\"Could not clear oAuth credentials. bridge={}\", getThing().getLabel(), e);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex dfddd57640..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzMzIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591933236", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n          \n          \n            \n                private static final List<String> INACTIVE_STATE = List.of(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "author": "fwolter", "createdAt": "2021-03-10T22:56:52Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\nindex 597d1b7bdd..106a2e3b7e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzMzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591933773", "bodyText": "The super type should be used where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n          \n          \n            \n                protected void configureChannelUpdateHandlers(Map<String, ChannelUpdateHandler> handlers) {", "author": "fwolter", "createdAt": "2021-03-10T22:57:45Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\nindex 597d1b7bdd..106a2e3b7e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNDM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591934370", "bodyText": "You could handle these exceptions in the abstract class, as they seem to be repeated in each handler.", "author": "fwolter", "createdAt": "2021-03-10T22:59:00Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+\n+            // only handle these commands if operation state allows it\n+            if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                // set drying target option\n+                if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                    getApiClient().ifPresent(apiClient -> {\n+                        try {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        } catch (ApplianceOfflineException e) {\n+                            logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                                    command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                            updateStatus(OFFLINE);\n+                            resetChannelsOnOfflineEvent();\n+                            resetProgramStateChannels();\n+                        } catch (CommunicationException e) {\n+                            logger.debug(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+                        } catch (AuthorizationException e) {\n+                            logger.debug(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                            handleAuthenticationError(e);\n+                        }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY3OTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624679730", "bodyText": "Very good point. Moved them to the abstract class. Was able to remove a lot of boilerplate code.", "author": "bruestel", "createdAt": "2021-05-02T11:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNDM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\nindex 597d1b7bdd..106a2e3b7e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591935053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                                QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n          \n          \n            \n                                QuantityType<?> quantity = (QuantityType<?>) command;", "author": "fwolter", "createdAt": "2021-03-10T23:00:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 31bac350d1..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzODAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591938032", "bodyText": "If the unit is Fahrenheit, it needs to be converted to celsius by calling quantity.toUnit(CELSIUS). Keep in mind that toUnit() can return null if the unit cannot be converted.\nWhat is the purpose of the else branch? Are there any other units (beside Kelvin) which can be converted to a temperature?", "author": "fwolter", "createdAt": "2021-03-10T23:06:39Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                    String value;\n+                    String unit;\n+\n+                    if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                            || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                        unit = quantity.getUnit().toString();\n+                        value = String.valueOf(quantity.intValue());\n+                    } else {\n+                        logger.debug(\"Converting target setpoint temperature from {}{} to \u00b0C value. thing={}, haId={}\",\n+                                quantity.intValue(), quantity.getUnit().toString(), getThingLabel(), getThingHaId());\n+                        unit = \"\u00b0C\";\n+                        value = String.valueOf(\n+                                quantity.getUnit().getConverterToAny(SIUnits.CELSIUS).convert(quantity).intValue());\n+                        logger.debug(\"{}{}\", value, unit);\n+                    }", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\nindex 31bac350d1..b5853045d6 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzOTMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591939336", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;", "author": "fwolter", "createdAt": "2021-03-10T23:09:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 2edea442ac..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzOTY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591939649", "bodyText": "See above. from()", "author": "fwolter", "createdAt": "2021-03-10T23:09:56Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 2edea442ac..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MDUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591940521", "bodyText": "This seems redundant tothe dishwasher. Can you re-use the code?", "author": "fwolter", "createdAt": "2021-03-10T23:11:52Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.UNDEF);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.UNDEF);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\nindex 2edea442ac..42f150b1c8 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTQyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591941425", "bodyText": "This seems to be used quite often. You could make it a global constant.", "author": "fwolter", "createdAt": "2021-03-10T23:13:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI5MzI0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r600293244", "bodyText": "It differs sometimes", "author": "bruestel", "createdAt": "2021-03-24T09:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTQyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 879925bd40..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591941724", "bodyText": "See above", "author": "fwolter", "createdAt": "2021-03-10T23:14:31Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 879925bd40..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjExNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591942115", "bodyText": "See above. Make wildcard. Same for below.", "author": "fwolter", "createdAt": "2021-03-10T23:15:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof QuantityType) {\n+                        // set setpoint temperature\n+                        if (CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 879925bd40..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591942457", "bodyText": "This seems to be redundant to the FridgeFreeze handler.", "author": "fwolter", "createdAt": "2021-03-10T23:15:58Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof QuantityType) {\n+                        // set setpoint temperature\n+                        if (CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDcxMDg3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624710871", "bodyText": "moved it to abstract class", "author": "bruestel", "createdAt": "2021-05-02T15:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\nindex 879925bd40..1ec30b379c 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NDg2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591944862", "bodyText": "See above. Logging to error.", "author": "fwolter", "createdAt": "2021-03-10T23:21:15Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex d2d58f6233..afed67d8e5 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NTE0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591945146", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-03-10T23:21:51Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex d2d58f6233..afed67d8e5 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NTM0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591945345", "bodyText": "See above. Handled by the framework.", "author": "fwolter", "createdAt": "2021-03-10T23:22:19Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);\n+            httpService.unregister(SERVLET_PATH);\n+            httpService.unregister(ASSETS_PATH);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not unregister Home Connect servlet. Failed wth {}\", e.getMessage());", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex d2d58f6233..afed67d8e5 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591948207", "bodyText": "You could make this a method to be able to re-use it. Then, you get also rid of the curly brackets at the cases.", "author": "fwolter", "createdAt": "2021-03-10T23:24:50Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);\n+            httpService.unregister(SERVLET_PATH);\n+            httpService.unregister(ASSETS_PATH);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not unregister Home Connect servlet. Failed wth {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws IOException {\n+        if (request == null || response == null) {\n+            return;\n+        }\n+        response.setContentType(DEFAULT_CONTENT_TYPE);\n+        response.setCharacterEncoding(UTF_8.name());\n+\n+        String path = request.getPathInfo();\n+        if (path == null || path.isEmpty() || path.equals(ROOT_PATH)) {\n+            @Nullable\n+            String code = request.getParameter(PARAM_CODE);\n+            @Nullable\n+            String state = request.getParameter(PARAM_STATE);\n+            if (code != null && state != null && !code.trim().isEmpty() && !state.trim().isEmpty()) {\n+                getBridgeAuthenticationPage(request, response, code, state);\n+            } else {\n+                getBridgesPage(request, response);\n+            }\n+        } else if (pathMatches(path, REQUEST_COUNT_PATH)) {\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (action != null && bridgeId != null && !action.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getApiRequestsPerSecondCsv(response, bridgeId);\n+            } else {\n+                getRequestCountPage(request, response);\n+            }\n+        } else if (pathMatches(path, APPLIANCES_PATH)) {\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String thingId = request.getParameter(PARAM_THING_ID);\n+            if (action != null && thingId != null && !action.trim().isEmpty() && !thingId.trim().isEmpty()) {\n+                processApplianceActions(response, action, thingId);\n+            } else {\n+                getAppliancesPage(request, response);\n+            }\n+        } else if (pathMatches(path, REQUEST_LOG_PATH)) {\n+            @Nullable\n+            String export = request.getParameter(PARAM_EXPORT);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (export != null && bridgeId != null && !export.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getRequestLogExport(response, bridgeId);\n+            } else {\n+                getRequestLogPage(request, response);\n+            }\n+        } else if (pathMatches(path, EVENT_LOG_PATH)) {\n+            @Nullable\n+            String export = request.getParameter(PARAM_EXPORT);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (export != null && bridgeId != null && !export.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getEventLogExport(response, bridgeId);\n+            } else {\n+                getEventLogPage(request, response);\n+            }\n+        } else {\n+            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws IOException {\n+        if (request == null || response == null) {\n+            return;\n+        }\n+        response.setContentType(\"text/html; charset=UTF-8\");\n+        response.setCharacterEncoding(\"UTF-8\");\n+\n+        String path = request.getPathInfo();\n+        if (path == null || path.isEmpty() || path.equals(ROOT_PATH)) {\n+            if (request.getParameter(PARAM_ACTION) != null && request.getParameter(PARAM_BRIDGE_ID) != null) {\n+                postBridgesPage(request, response);\n+            } else {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+            }\n+        } else if (pathMatches(path, APPLIANCES_PATH)) {\n+            String requestPayload = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String thingId = request.getParameter(PARAM_THING_ID);\n+            @Nullable\n+            String targetPath = request.getParameter(PARAM_PATH);\n+\n+            if ((ACTION_PUT_RAW.equals(action) || ACTION_GET_RAW.equals(action)) && thingId != null\n+                    && targetPath != null && action != null) {\n+                processRawApplianceActions(response, action, thingId, targetPath, requestPayload);\n+            } else {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+            }\n+        } else {\n+            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+        }\n+    }\n+\n+    /**\n+     * Add Home Connect bridge handler to configuration servlet, to allow user to authenticate against Home Connect API.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public void addBridgeHandler(HomeConnectBridgeHandler bridgeHandler) {\n+        bridgeHandlers.add(bridgeHandler);\n+    }\n+\n+    /**\n+     * Remove Home Connect bridge handler from configuration servlet.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public void removeBridgeHandler(HomeConnectBridgeHandler bridgeHandler) {\n+        bridgeHandlers.remove(bridgeHandler);\n+    }\n+\n+    private void getRequestCountPage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n+        if (bridgeHandlers.isEmpty()) {\n+            getBridgesPage(request, response);\n+        } else {\n+            WebContext context = new WebContext(request, response, request.getServletContext());\n+            context.setVariable(\"bridgeHandlers\", bridgeHandlers);\n+            templateEngine.process(\"requests\", context, response.getWriter());\n+        }\n+    }\n+\n+    private void getApiRequestsPerSecondCsv(HttpServletResponse response, String bridgeId) throws IOException {\n+        Optional<HomeConnectBridgeHandler> bridgeHandler = getBridgeHandler(bridgeId);\n+        if (bridgeHandler.isPresent()) {\n+            response.setContentType(\"text/csv\");\n+            PrintWriter writer = response.getWriter();\n+\n+            writer.println(String.format(\"%s,%s\", \"time\", \"requests\"));\n+            bridgeHandler.get().getApiClient().getLatestApiRequests().forEach(apiRequest -> writer.println(\n+                    String.format(\"%s,%s\", apiRequest.getTime().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME), 1)));\n+        } else {\n+            response.sendError(HttpStatus.BAD_REQUEST_400, \"Unknown bridge\");\n+        }\n+    }\n+\n+    private void getAppliancesPage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n+        WebContext context = new WebContext(request, response, request.getServletContext());\n+        context.setVariable(\"bridgeHandlers\", bridgeHandlers);\n+        templateEngine.process(\"appliances\", context, response.getWriter());\n+    }\n+\n+    private void processApplianceActions(HttpServletResponse response, String action, String thingId)\n+            throws IOException {\n+        Optional<HomeConnectBridgeHandler> bridgeHandler = getBridgeHandlerForThing(thingId);\n+        Optional<AbstractHomeConnectThingHandler> thingHandler = getThingHandler(thingId);\n+\n+        if (bridgeHandler.isPresent() && thingHandler.isPresent()) {\n+            try {\n+                response.setContentType(MediaType.APPLICATION_JSON);\n+                String haId = thingHandler.get().getThingHaId();\n+\n+                switch (action) {\n+                    case ACTION_SHOW_DETAILS: {\n+                        @Nullable\n+                        String actionResponse = bridgeHandler.get().getApiClient().getRaw(haId,\n+                                \"/api/homeappliances/\" + haId);\n+                        response.getWriter().write(actionResponse != null ? actionResponse : \"{}\");", "originalCommit": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDY0ODkyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624648926", "bodyText": "Unfortunately, I don't exactly understand your suggestion. Could you please give me a hand.", "author": "bruestel", "createdAt": "2021-05-02T07:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMTc3MTcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r631771705", "bodyText": "Like so:\n...\n                    case ACTION_ALL_PROGRAMS: {\n                        write(response, bridgeHandler, haId, \"/programs\");\n                        break;\n                    }\n...\n    private void write(HttpServletResponse response, Optional<HomeConnectBridgeHandler> bridgeHandler, String haId,\n            String suffix)\n            throws CommunicationException, AuthorizationException, ApplianceOfflineException, IOException {\n        String actionResponse = bridgeHandler.get().getApiClient().getRaw(haId, \"/api/homeappliances/\" + haId + suffix);\n        response.getWriter().write(actionResponse != null ? actionResponse : EMPTY_RESPONSE);\n    }", "author": "fwolter", "createdAt": "2021-05-13T12:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMTc4OTEzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r631789137", "bodyText": "I merge it for now. You could file a follow-up PR.", "author": "fwolter", "createdAt": "2021-05-13T12:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\nindex d2d58f6233..afed67d8e5 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "url": "https://github.com/openhab/openhab-addons/commit/61c803d47eb79e1579e7962736369b3c0d9dbd99", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-03-08T17:33:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1NDU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619454570", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.\nPlease check all.", "author": "fwolter", "createdAt": "2021-04-23T19:36:10Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1277 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL_SEC = 2;\n+    private static final int OFFLINE_MONITOR_1_DELAY_MIN = 30;\n+    private static final int OFFLINE_MONITOR_2_DELAY_MIN = 4;\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY_MIN = 10;\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL_SEC));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(final Map<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final Map<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (!isThingReadyToHandleCommand()) {\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);", "originalCommit": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzNzUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624637531", "bodyText": "will change it", "author": "bruestel", "createdAt": "2021-05-02T06:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1NDU3MA=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 83b6d79cfd..c40079e73e 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1Nzk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619457957", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded.\nThe log message could be removed, as the status update is already logged by the framework and displayed in the UI.", "author": "fwolter", "createdAt": "2021-04-23T19:43:34Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY_SEC = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory,\n+                config);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());", "originalCommit": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDYzNzcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r624637722", "bodyText": "will remove it", "author": "bruestel", "createdAt": "2021-05-02T06:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1Nzk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex ca132249f6..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1ODMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619458318", "bodyText": "See above. Remove log message.", "author": "fwolter", "createdAt": "2021-04-23T19:44:18Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY_SEC = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory,\n+                config);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY_SEC);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);", "originalCommit": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\nindex ca132249f6..df1cdbe1c7 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"oid": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "url": "https://github.com/openhab/openhab-addons/commit/7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:31Z", "type": "commit"}, {"oid": "21f01062b30ff53fc6e59be90afc9556602eb9b0", "url": "https://github.com/openhab/openhab-addons/commit/21f01062b30ff53fc6e59be90afc9556602eb9b0", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "ba0589cba09faab8de11cba443adda6d175a3d74", "url": "https://github.com/openhab/openhab-addons/commit/ba0589cba09faab8de11cba443adda6d175a3d74", "message": "[homeconnect] Applied review feedback and improved README\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "15ea75b12c9c11bac1803c32ed3c944cddc4f6e0", "url": "https://github.com/openhab/openhab-addons/commit/15ea75b12c9c11bac1803c32ed3c944cddc4f6e0", "message": "[homeconnect] Remove Okhttp dependency\n\nUse the Jetty HTTP client provided by the core framework\nUse JAX-RS SSE for SSE\n\nAlso remove dependency on org.apache.commons.lang.*\n\nFix: cancel any job when disposing thing handler\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "1099fcfd28997a8c6ae2e223a4756d31d3869954", "url": "https://github.com/openhab/openhab-addons/commit/1099fcfd28997a8c6ae2e223a4756d31d3869954", "message": "Consider all review comments except the one relative to bucket4j\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "aa71ba75ee064eaa8ddb78766ef89f03eb45f378", "url": "https://github.com/openhab/openhab-addons/commit/aa71ba75ee064eaa8ddb78766ef89f03eb45f378", "message": "Review comment: way to use bucket4j\n\nIncrease OAUTH_EXPIRE_BUFFER to 30 seconds\n\nSet the variable ignoreEventSourceClosedEvent to true at beginning of\nregisterEventListener\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "7eed8286d12f5010bcc42aa477b391df905d66e2", "url": "https://github.com/openhab/openhab-addons/commit/7eed8286d12f5010bcc42aa477b391df905d66e2", "message": "Add Cache-Control header to SSE request\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:32Z", "type": "commit"}, {"oid": "8ec45b27481b628d8bdcea5409d1261a570b1ff8", "url": "https://github.com/openhab/openhab-addons/commit/8ec45b27481b628d8bdcea5409d1261a570b1ff8", "message": "Restore value 10 (seconds) for OAUTH_EXPIRY_BUFFER\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "896168f81c47ba82b07fe68304000593d2ea4dac", "url": "https://github.com/openhab/openhab-addons/commit/896168f81c47ba82b07fe68304000593d2ea4dac", "message": "SSE failure due to NotAuthorizedException: wait 5 seconds\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "ff91273022d4ed57870710cc497dde5b8eeb8e81", "url": "https://github.com/openhab/openhab-addons/commit/ff91273022d4ed57870710cc497dde5b8eeb8e81", "message": "Log something when the binding requests a refresh of the access token\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "c6f0d1726e979f766dbfa7ec4ea79d83c7ea5f5b", "url": "https://github.com/openhab/openhab-addons/commit/c6f0d1726e979f766dbfa7ec4ea79d83c7ea5f5b", "message": "Log when the access token changed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "37cdd410e8d47fdad0656c169e1c55e581c571e5", "url": "https://github.com/openhab/openhab-addons/commit/37cdd410e8d47fdad0656c169e1c55e581c571e5", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "10225c77938c481e38def9f850bff48cf491e4ac", "url": "https://github.com/openhab/openhab-addons/commit/10225c77938c481e38def9f850bff48cf491e4ac", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "f9bda8c8bed3e47613d38c3a0fd191cb3969722b", "url": "https://github.com/openhab/openhab-addons/commit/f9bda8c8bed3e47613d38c3a0fd191cb3969722b", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:33Z", "type": "commit"}, {"oid": "0fb5481ca70f94d6add9a04adad11396f8b68fbd", "url": "https://github.com/openhab/openhab-addons/commit/0fb5481ca70f94d6add9a04adad11396f8b68fbd", "message": "Fixed bucket4j bug\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "551429a3597bcf6ca7036b97e90eacc83172a219", "url": "https://github.com/openhab/openhab-addons/commit/551429a3597bcf6ca7036b97e90eacc83172a219", "message": "[homeconnect] Removed Plotly charts\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "e9a4d58f8319873184904d2d549f613b90fbceb2", "url": "https://github.com/openhab/openhab-addons/commit/e9a4d58f8319873184904d2d549f613b90fbceb2", "message": "[homeconnect] Fixed compile warnings\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "e38efe08f75eac1bdd5ac326257456ffdb11043b", "url": "https://github.com/openhab/openhab-addons/commit/e38efe08f75eac1bdd5ac326257456ffdb11043b", "message": "[homeconnect] Revered gson changes\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "3de2f9d0e6706e9e436d355c781f6e046f3f0576", "url": "https://github.com/openhab/openhab-addons/commit/3de2f9d0e6706e9e436d355c781f6e046f3f0576", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "d451257d6baa89a89d41871deaeda021caf9a018", "url": "https://github.com/openhab/openhab-addons/commit/d451257d6baa89a89d41871deaeda021caf9a018", "message": "[homeconnect] Refactored and optimized general and light related command handling\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "a3a31018244d13b5390d13f13ff3f2cb77f722e3", "url": "https://github.com/openhab/openhab-addons/commit/a3a31018244d13b5390d13f13ff3f2cb77f722e3", "message": "[homeconnect] Moved temperature command handling to abstract class and use channel type 'system.power' instead of custom type\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:34Z", "type": "commit"}, {"oid": "1364ae8bcdef364f4b2f6193b87d48f62428eae0", "url": "https://github.com/openhab/openhab-addons/commit/1364ae8bcdef364f4b2f6193b87d48f62428eae0", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:35Z", "type": "commit"}, {"oid": "1364ae8bcdef364f4b2f6193b87d48f62428eae0", "url": "https://github.com/openhab/openhab-addons/commit/1364ae8bcdef364f4b2f6193b87d48f62428eae0", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-02T15:29:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTY3NDk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r625674960", "bodyText": "You already have the apiClient as parameter.", "author": "lolodomo", "createdAt": "2021-05-04T10:33:13Z", "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -157,51 +157,55 @@ private void reinitialize() {\n         initialize();\n     }\n \n+    protected void handleCommand(ChannelUID channelUID, Command command, HomeConnectApiClient apiClient)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();", "originalCommit": "3de2f9d0e6706e9e436d355c781f6e046f3f0576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTc0MTQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r625741419", "bodyText": "PR created", "author": "lolodomo", "createdAt": "2021-05-04T12:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTY3NDk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "86d863e36a92d405a8081f9fa00d57e900537373", "chunk": "diff --git a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\nindex 6d6e30f786..20af6c24c9 100644\n--- a/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n+++ b/bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java\n\n@@ -157,10 +161,21 @@ public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler i\n         initialize();\n     }\n \n+    /**\n+     * Handles a command for a given channel.\n+     * <p>\n+     * This method is only called, if the thing has been initialized (status ONLINE/OFFLINE/UNKNOWN).\n+     * <p>\n+     *\n+     * @param channelUID the {@link ChannelUID} of the channel to which the command was sent\n+     * @param command the {@link Command}\n+     * @param apiClient the {@link HomeConnectApiClient}\n+     * @throws CommunicationException communication problem\n+     * @throws AuthorizationException authorization problem\n+     * @throws ApplianceOfflineException appliance offline\n+     */\n     protected void handleCommand(ChannelUID channelUID, Command command, HomeConnectApiClient apiClient)\n             throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n-        Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n-\n         if (command instanceof RefreshType) {\n             updateChannel(channelUID);\n         } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n"}}, {"oid": "86d863e36a92d405a8081f9fa00d57e900537373", "url": "https://github.com/openhab/openhab-addons/commit/86d863e36a92d405a8081f9fa00d57e900537373", "message": "Fix for handleCommand\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2021-05-04T12:27:08Z", "type": "commit"}, {"oid": "55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec", "url": "https://github.com/openhab/openhab-addons/commit/55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec", "message": "Merge pull request #3 from lolodomo/homeconnect\n\nFix for handleCommand", "committedDate": "2021-05-04T14:44:14Z", "type": "commit"}, {"oid": "36c008fc19d232e795b09454da99de14c8ad1421", "url": "https://github.com/openhab/openhab-addons/commit/36c008fc19d232e795b09454da99de14c8ad1421", "message": "[homeconnect] Fixed warnings\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-04T15:03:33Z", "type": "commit"}, {"oid": "97eeb29e929257c5154ff19e0c810a3fff519c4a", "url": "https://github.com/openhab/openhab-addons/commit/97eeb29e929257c5154ff19e0c810a3fff519c4a", "message": "[homeconnect] Workaround event listener bug\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>", "committedDate": "2021-05-06T09:55:24Z", "type": "commit"}]}