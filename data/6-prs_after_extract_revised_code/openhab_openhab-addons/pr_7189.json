{"pr_number": 7189, "pr_title": "[alarmdecoder] Initial contribution", "pr_createdAt": "2020-03-18T16:16:21Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7189", "timeline": [{"oid": "bda7f27ac9e06c3232ed06a4d4623d0e06e49975", "url": "https://github.com/openhab/openhab-addons/commit/bda7f27ac9e06c3232ed06a4d4623d0e06e49975", "message": "[alarmdecoder] Initial commit of OH2 version\n\nSigned-off-by: Bob Adair <bob.github@att.net>\nAlso-by: Bill Forsyth (github: billfor)", "committedDate": "2020-03-25T20:07:13Z", "type": "commit"}, {"oid": "526f16ff6353858040787e3b376fa6d5cd20c2ca", "url": "https://github.com/openhab/openhab-addons/commit/526f16ff6353858040787e3b376fa6d5cd20c2ca", "message": "[alarmdecoder] Update pom.xml files\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-25T20:07:13Z", "type": "commit"}, {"oid": "bd2338a2a253257adeb8764a478430959d53cd16", "url": "https://github.com/openhab/openhab-addons/commit/bd2338a2a253257adeb8764a478430959d53cd16", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-25T20:07:13Z", "type": "commit"}, {"oid": "bd2338a2a253257adeb8764a478430959d53cd16", "url": "https://github.com/openhab/openhab-addons/commit/bd2338a2a253257adeb8764a478430959d53cd16", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-25T20:07:13Z", "type": "forcePushed"}, {"oid": "c0e92a4a86be44bdc06a397c9057f3d3d7983f8b", "url": "https://github.com/openhab/openhab-addons/commit/c0e92a4a86be44bdc06a397c9057f3d3d7983f8b", "message": "[alarmdecoder] Update to LRR msg parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-29T17:29:08Z", "type": "commit"}, {"oid": "c376c907d7f913bebbeb0d14d1574c6928bc9337", "url": "https://github.com/openhab/openhab-addons/commit/c376c907d7f913bebbeb0d14d1574c6928bc9337", "message": "[alarmdecoder] Update to KP msg parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-03-31T20:08:28Z", "type": "commit"}, {"oid": "f97e80b5dcb7e7977ca7f9e3a4f6cf0517b333a7", "url": "https://github.com/openhab/openhab-addons/commit/f97e80b5dcb7e7977ca7f9e3a4f6cf0517b333a7", "message": "[alarmdecoder] Don't update keypad channels on repeated messages\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-04T22:13:44Z", "type": "commit"}, {"oid": "1d72a334168728bd56c07aa1e928e58fa4d6c493", "url": "https://github.com/openhab/openhab-addons/commit/1d72a334168728bd56c07aa1e928e58fa4d6c493", "message": "[alarmdecoder] Update to README and thing-type.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-08T02:15:56Z", "type": "commit"}, {"oid": "7e9b18163906e36ac88e1caea8ce58e9933bd904", "url": "https://github.com/openhab/openhab-addons/commit/7e9b18163906e36ac88e1caea8ce58e9933bd904", "message": "[alarmdecoder] Minor clean-up\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-09T15:33:30Z", "type": "commit"}, {"oid": "99c6bb2b3edce8a2534d0d694d6c44daece8a175", "url": "https://github.com/openhab/openhab-addons/commit/99c6bb2b3edce8a2534d0d694d6c44daece8a175", "message": "[alarmdecoder] Move off of gnu.io for serial bridge\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-09T16:00:26Z", "type": "commit"}, {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "url": "https://github.com/openhab/openhab-addons/commit/79bce4d41c750de5b53188bb8694c9a7dfd3af25", "message": "[alarmdecoder] Flag write exceptions\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-10T18:21:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022327", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n          \n          \n            \n                protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);", "author": "cpmeister", "createdAt": "2020-04-11T05:50:24Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\nindex 7d36acb43f..497da2226e 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\n\n@@ -34,7 +34,7 @@ import org.slf4j.LoggerFactory;\n public abstract class ADThingHandler extends BaseThingHandler {\n \n     private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n-    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+    protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n \n     public ADThingHandler(Thing thing) {\n         super(thing);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022338", "bodyText": "use it or lose it", "author": "cpmeister", "createdAt": "2020-04-11T05:50:38Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+\n+    public ADThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected abstract void initDeviceState();\n+\n+    public abstract void initChannelState();\n+\n+    /**\n+     * Notify handler that panel is in ready state so that any un-updated contact channels can be set to default\n+     * (closed).\n+     */\n+    public abstract void notifyPanelReady();\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} for AD handler\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE\n+                && getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.BRIDGE_OFFLINE) {\n+            initDeviceState();\n+\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            // thingOfflineNotify();", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4NjY4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407086682", "bodyText": "Lost it. :-)", "author": "bobadair", "createdAt": "2020-04-11T17:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\nindex 7d36acb43f..497da2226e 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\n\n@@ -34,7 +34,7 @@ import org.slf4j.LoggerFactory;\n public abstract class ADThingHandler extends BaseThingHandler {\n \n     private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n-    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+    protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n \n     public ADThingHandler(Thing thing) {\n         super(thing);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022543", "bodyText": "Why do you need these fields if you can just pull them from the config instance?", "author": "cpmeister", "createdAt": "2020-04-11T05:52:57Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    /** hostname for the alarmdecoder process */\n+    private @Nullable String tcpHostName = null;\n+    /** port for the alarmdecoder process */\n+    private int tcpPort;", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njc0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407086741", "bodyText": "Those were an artifact from the V1 code. Removed.", "author": "bobadair", "createdAt": "2020-04-11T17:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjU0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex a057fa3d60..2fdd7fa4df 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -45,10 +45,6 @@ public class IPBridgeHandler extends ADBridgeHandler {\n \n     private @NonNullByDefault({}) IPBridgeConfig config;\n \n-    /** hostname for the alarmdecoder process */\n-    private @Nullable String tcpHostName = null;\n-    /** port for the alarmdecoder process */\n-    private int tcpPort;\n     private @Nullable Socket socket = null;\n \n     public IPBridgeHandler(Bridge bridge) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzA0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023046", "bodyText": "Why not just put this logic on line 92 so you can do away with the connectionSuccess variable?", "author": "cpmeister", "createdAt": "2020-04-11T05:59:25Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    /** hostname for the alarmdecoder process */\n+    private @Nullable String tcpHostName = null;\n+    /** port for the alarmdecoder process */\n+    private int tcpPort;\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            return;\n+        }\n+        tcpHostName = config.hostname;\n+        tcpPort = config.tcpPort;\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        boolean connectionSuccess = false;\n+\n+        try {\n+            disconnect(); // make sure we are disconnected\n+            writeException = false;\n+            if (tcpHostName != null && tcpPort > 0 && tcpPort < 65536) {\n+                socket = new Socket(tcpHostName, tcpPort);\n+                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n+                logger.debug(\"connected to {}:{}\", tcpHostName, tcpPort);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);\n+                connectionSuccess = true;\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"invalid hostname/tcpPort configured\");\n+            }\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", tcpHostName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", tcpHostName, tcpPort, e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(config.reconnect); // Possibly a retryable error. Try again later.\n+        }\n+\n+        // Start connection check job\n+        if (connectionSuccess) {\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407086767", "bodyText": "Good point. Done.", "author": "bobadair", "createdAt": "2020-04-11T17:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex a057fa3d60..2fdd7fa4df 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -45,10 +45,6 @@ public class IPBridgeHandler extends ADBridgeHandler {\n \n     private @NonNullByDefault({}) IPBridgeConfig config;\n \n-    /** hostname for the alarmdecoder process */\n-    private @Nullable String tcpHostName = null;\n-    /** port for the alarmdecoder process */\n-    private int tcpPort;\n     private @Nullable Socket socket = null;\n \n     public IPBridgeHandler(Bridge bridge) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzIyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023225", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n          \n          \n            \n                private static final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "author": "cpmeister", "createdAt": "2020-04-11T06:01:55Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.KeypadConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.IntCommandMap;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KeypadHandler} is responsible for handling keypad messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(KeypadHandler.class);\n+\n+    private @NonNullByDefault({}) KeypadConfig config;\n+    private boolean singleAddress;\n+    private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java\nindex 454fff4bbc..e081622234 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java\n\n@@ -48,7 +48,7 @@ public class KeypadHandler extends ADThingHandler {\n \n     private @NonNullByDefault({}) KeypadConfig config;\n     private boolean singleAddress;\n-    private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n     private @Nullable IntCommandMap intCommandMap;\n     private @Nullable KeypadMessage previousMessage;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023775", "bodyText": "You still need to handle a RefreshType command if possible.", "author": "cpmeister", "createdAt": "2020-04-11T06:09:16Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.LRRConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LRRHandler} is responsible for handling long range radio (LRR) messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(LRRHandler.class);\n+\n+    private @NonNullByDefault({}) LRRConfig config;\n+\n+    public LRRHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the supplied partition.\n+     * This is true is this handler's partition is 0 (all), the supplied partition is 0 (all), or if this handler's\n+     * partition matches the supplied partition.\n+     */\n+    public Boolean responsibleFor(final int partition) {\n+        return (config.partition == partition || config.partition == 0 || partition == 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(LRRConfig.class);\n+\n+        if (config.partition < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"LRR handler initializing for partition {}\", config.partition);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"LRR handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for RLL partition {}\", config.partition);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            initChannelState();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    @Override\n+    public void initChannelState() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // All channels are read-only, so ignore all commands.", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4OTg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407089881", "bodyText": "I thought about this, but the AD device mainly just passively listens on the panel's serial bus and passes along the messages it sees. There is no way to query it for state, as I would want to do when receiving a RefreshType command. So I thought it best to just ignore RefreshType along with all other commands.", "author": "bobadair", "createdAt": "2020-04-11T17:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MDM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407150353", "bodyText": "If there is no way to handle a RefreshType then I guess you can just ignore it.", "author": "cpmeister", "createdAt": "2020-04-12T05:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI0MDA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407240077", "bodyText": "Ok. Thanks. I'm open to suggestions, but I can't really thing of an appropriate REFRESH action that the AD would support.", "author": "bobadair", "createdAt": "2020-04-12T19:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java\nindex a52112b846..ae670c71b2 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java\n\n@@ -50,7 +50,7 @@ public class LRRHandler extends ADThingHandler {\n      * This is true is this handler's partition is 0 (all), the supplied partition is 0 (all), or if this handler's\n      * partition matches the supplied partition.\n      */\n-    public Boolean responsibleFor(final int partition) {\n+    public boolean responsibleFor(final int partition) {\n         return (config.partition == partition || config.partition == 0 || partition == 0);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024142", "bodyText": "you can remove this annotation, it serves no purpose here", "author": "cpmeister", "createdAt": "2020-04-11T06:13:56Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.osgi.service.component.annotations.Activate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    @Activate", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\nindex d9e88ef56b..a4b4137c3a 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n\n@@ -154,7 +154,6 @@ public class SerialBridgeHandler extends ADBridgeHandler {\n         if (writer != null) {\n             logger.trace(\"Closing writer\");\n             try {\n-                // writer.flush();\n                 writer.close();\n             } catch (IOException e) {\n                 logger.info(\"IO Exception closing writer: {}\", e.getMessage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024196", "bodyText": "not even a refresh command?", "author": "cpmeister", "createdAt": "2020-04-11T06:14:33Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.RFZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RFZoneHandler} is responsible for handling wired zones (i.e. RFX messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RFZoneHandler.class);\n+\n+    private @NonNullByDefault({}) RFZoneConfig config;\n+\n+    public RFZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public Boolean responsibleFor(final int serial) {\n+        return (config.serial != null && config.serial.equals(serial));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RFZoneConfig.class);\n+\n+        if (config.serial == null || config.serial < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"RF Zone handler initializing for serial {}\", config.serial);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"RF Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for RF Zone {}\", config.serial);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            firstUpdateReceived.set(false);\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Set contact channel states to \"UNDEF\" at init time. The real states will be set either when the first message\n+     * arrives for the zone, or they will be set to \"CLOSED\" the first time the panel goes into the \"READY\" state.\n+     */\n+    @Override\n+    public void initChannelState() {\n+        UnDefType state = UnDefType.UNDEF;\n+        updateState(CHANNEL_RF_LOWBAT, state);\n+        updateState(CHANNEL_RF_SUPERVISION, state);\n+        updateState(CHANNEL_RF_LOOP1, state);\n+        updateState(CHANNEL_RF_LOOP2, state);\n+        updateState(CHANNEL_RF_LOOP3, state);\n+        updateState(CHANNEL_RF_LOOP4, state);\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        logger.trace(\"RF Zone handler for {} received panel ready notification.\", config.serial);\n+        if (firstUpdateReceived.compareAndSet(false, true)) {\n+            updateState(CHANNEL_RF_LOOP1, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP2, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP3, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP4, OpenClosedType.CLOSED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Does not accept any commands", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4OTg4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407089888", "bodyText": "Same as above.", "author": "bobadair", "createdAt": "2020-04-11T17:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java\nindex 31bb795cb4..5743fb338d 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java\n\n@@ -49,7 +49,7 @@ public class RFZoneHandler extends ADThingHandler {\n     /**\n      * Returns true if this handler is responsible for the zone with the supplied address and channel.\n      */\n-    public Boolean responsibleFor(final int serial) {\n+    public boolean responsibleFor(final int serial) {\n         return (config.serial != null && config.serial.equals(serial));\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024236", "bodyText": "remove", "author": "cpmeister", "createdAt": "2020-04-11T06:15:07Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.osgi.service.component.annotations.Activate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    @Activate\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // serialPort.disableReceiveFraming();\n+                // serialPort.disableReceiveThreshold();\n+\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                logger.debug(\"connected to serial port: {}\", serialDeviceName);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Serial device name not configured\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"port name not configured\");\n+            }\n+        } catch (PortInUseException e) {\n+            logger.debug(\"Cannot open serial port: {}, it is already in use\", serialDeviceName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Serial port already in use\");\n+        } catch (UnsupportedCommOperationException | IOException | IllegalStateException e) {\n+            logger.debug(\"Error connecting to serial port: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void disconnect() {\n+        logger.trace(\"Disconnecting\");\n+        if (serialPort != null) {\n+            logger.trace(\"Closing serial port\");\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        stopMsgReader();\n+\n+        if (reader != null) {\n+            logger.trace(\"Closing reader\");\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.info(\"IO Exception closing reader: {}\", e.getMessage());\n+            } finally {\n+                reader = null;\n+            }\n+        }\n+        if (writer != null) {\n+            logger.trace(\"Closing writer\");\n+            try {\n+                // writer.flush();", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\nindex d9e88ef56b..a4b4137c3a 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n\n@@ -154,7 +154,6 @@ public class SerialBridgeHandler extends ADBridgeHandler {\n         if (writer != null) {\n             logger.trace(\"Closing writer\");\n             try {\n-                // writer.flush();\n                 writer.close();\n             } catch (IOException e) {\n                 logger.info(\"IO Exception closing writer: {}\", e.getMessage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024516", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(command);\n          \n          \n            \n                    return command;", "author": "cpmeister", "createdAt": "2020-04-11T06:18:57Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link ADCCommand} class represents an alarm decoder command, and contains the static methods and definitions\n+ * used to construct one. Not all supported AD commands are necessarily used by the current binding.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class ADCommand {\n+\n+    public static final String SPECIAL_KEY_1 = \"\\u0001\\u0001\\u0001\";\n+    public static final String SPECIAL_KEY_2 = \"\\u0002\\u0002\\u0002\";\n+    public static final String SPECIAL_KEY_3 = \"\\u0003\\u0003\\u0003\";\n+    public static final String SPECIAL_KEY_4 = \"\\u0004\\u0004\\u0004\";\n+    public static final String SPECIAL_KEY_5 = \"\\u0005\\u0005\\u0005\";\n+    public static final String SPECIAL_KEY_6 = \"\\u0006\\u0006\\u0006\";\n+    public static final String SPECIAL_KEY_7 = \"\\u0007\\u0007\\u0007\";\n+    public static final String SPECIAL_KEY_8 = \"\\u0008\\u0008\\u0008\";\n+\n+    // public static final String KEYPAD_COMMAND_CHARACTERS = \"0123456789*#<>\";\n+    public static final String KEYPAD_COMMAND_REGEX = \"^[0-9A-H*#<>]+$\";\n+\n+    private static final String TERM = \"\\r\\n\";\n+\n+    private static final String COMMAND_REBOOT = \"=\";\n+    private static final String COMMAND_CONFIG = \"C\";\n+    private static final String COMMAND_ZONE = \"L\";\n+    private static final String COMMAND_ERROR = \"E\";\n+    private static final String COMMAND_VERSION = \"V\";\n+    private static final String COMMAND_ADDRMSG = \"K\";\n+    private static final String COMMAND_ACKCRC = \"R\";\n+\n+    public final String command;\n+\n+    public ADCommand(String command) {\n+        this.command = command + TERM;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(command);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java\nindex ac4c5ee745..e2a773c2b3 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java\n\n@@ -54,7 +54,7 @@ public final class ADCommand {\n \n     @Override\n     public String toString() {\n-        return new String(command);\n+        return command;\n     }\n \n     public static ADCommand reboot() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDYwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024606", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(message);\n          \n          \n            \n                    return message;", "author": "cpmeister", "createdAt": "2020-04-11T06:20:05Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Superclass for all Alarm Decoder protocol message types.\n+ * Includes code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADMessage {\n+\n+    protected static final Pattern SPLIT_REGEX = Pattern.compile(\"[^\\\\,\\\"]+|\\\"[^\\\"]*\\\"\");\n+\n+    /** string containing the original unparsed message */\n+    public final String message;\n+\n+    public ADMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(message);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java\nindex 4feed48ba5..72111655be 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java\n\n@@ -39,7 +39,7 @@ public abstract class ADMessage {\n \n     @Override\n     public String toString() {\n-        return new String(message);\n+        return message;\n     }\n \n     /** Utility routine to split an AD message into its component parts */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:22:46Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link EXPMessage} class represents a parsed zone (EXP or REL) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class EXPMessage extends ADMessage {\n+\n+    // Example: !EXP:07,01,01\n+    // Example: !REL:12,01,01\n+\n+    /** Address number */\n+    public final int address;\n+\n+    /** Channel number */\n+    public final int channel;\n+\n+    /** Message data */\n+    public final int data;\n+\n+    public EXPMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"Multiple colons found in EXP message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        if (parts.size() != 3) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in EXP message\");\n+        }\n+\n+        try {\n+            address = Integer.parseInt(parts.get(0));\n+            channel = Integer.parseInt(parts.get(1));\n+            data = Integer.parseInt(parts.get(2));\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java\nindex 0d61eeaef5..094c174e5f 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java\n\n@@ -56,7 +56,7 @@ public class EXPMessage extends ADMessage {\n             channel = Integer.parseInt(parts.get(1));\n             data = Integer.parseInt(parts.get(2));\n         } catch (NumberFormatException e) {\n-            throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());\n+            throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage(), e);\n         }\n \n         if ((data & ~0x1) != 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024817", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new IllegalArgumentException(\"Unable to parse integer in mapping\");\n          \n          \n            \n                            throw new IllegalArgumentException(\"Unable to parse integer in mapping\", e);", "author": "cpmeister", "createdAt": "2020-04-11T06:23:05Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    public IntCommandMap(String mappingString) throws IllegalArgumentException {\n+        commandMap = new HashMap<Integer, String>();\n+\n+        String mstring = mappingString.replace(\"POUND\", \"#\");\n+        String[] elements = mstring.split(\",\");\n+        for (String element : elements) {\n+            String[] kvPair = element.split(\"=\");\n+            if (kvPair.length != 2) {\n+                throw new IllegalArgumentException(\"Invalid key-value pair format\");\n+            }\n+\n+            Matcher matcher = validCommandPattern.matcher(kvPair[1]);\n+            if (!matcher.matches()) {\n+                throw new IllegalArgumentException(\"Invalid command characters in mapping\");\n+            }\n+\n+            try {\n+                commandMap.put(Integer.parseInt(kvPair[0]), kvPair[1]);\n+            } catch (NumberFormatException e) {\n+                throw new IllegalArgumentException(\"Unable to parse integer in mapping\");", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\nindex cedaa2a4d8..104bf4eeea 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n\n@@ -28,7 +28,7 @@ import org.eclipse.jdt.annotation.Nullable;\n @NonNullByDefault\n public class IntCommandMap {\n     private final Map<Integer, String> commandMap;\n-    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n \n     public IntCommandMap(String mappingString) throws IllegalArgumentException {\n         commandMap = new HashMap<Integer, String>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n          \n          \n            \n                private static final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "author": "cpmeister", "createdAt": "2020-04-11T06:23:21Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\nindex cedaa2a4d8..104bf4eeea 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n\n@@ -28,7 +28,7 @@ import org.eclipse.jdt.annotation.Nullable;\n @NonNullByDefault\n public class IntCommandMap {\n     private final Map<Integer, String> commandMap;\n-    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n \n     public IntCommandMap(String mappingString) throws IllegalArgumentException {\n         commandMap = new HashMap<Integer, String>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDk0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:24:08Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\nindex 8873536af1..949dcf1562 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\n\n@@ -84,7 +84,7 @@ public class KeypadMessage extends ADMessage {\n             this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n \n         } catch (NumberFormatException e) {\n-            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNTAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407025035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:25:28Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+\n+        if (parts.size() == 4) {\n+            reportCode = parts.get(3);\n+        } else {\n+            reportCode = \"\";\n+        }\n+\n+        try {\n+            int p = 0;\n+            try {\n+                p = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                p = Integer.parseInt(parts.get(1), 16);\n+            }\n+            partition = p;\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\nindex 198c086303..cfda34e141 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\n\n@@ -72,7 +72,7 @@ public class LRRMessage extends ADMessage {\n             }\n             partition = p;\n         } catch (NumberFormatException e) {\n-            throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());\n+            throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage(), e);\n         }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407025074", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-04-11T06:26:02Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link RFXMessage} class represents a parsed RF zone (RFX) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFXMessage extends ADMessage {\n+\n+    // Example: !RFX:0180036,80\n+\n+    public static final int BIT_LOWBAT = 0x02;\n+    public static final int BIT_SUPER = 0x04;\n+    public static final int BIT_LOOP3 = 0x10;\n+    public static final int BIT_LOOP2 = 0x20;\n+    public static final int BIT_LOOP4 = 0x40;\n+    public static final int BIT_LOOP1 = 0x80;\n+\n+    /** Address serial number */\n+    public final int serial;\n+\n+    /** Message data */\n+    public final int data;\n+\n+    public RFXMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"Multiple colons found in RFX message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        if (parts.size() != 2) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in RFX message\");\n+        }\n+\n+        try {\n+            serial = Integer.parseInt(parts.get(0));\n+            data = Integer.parseInt(parts.get(1), 16);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());", "originalCommit": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java\nindex df791a31f6..9aa60ec29a 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java\n\n@@ -58,7 +58,7 @@ public class RFXMessage extends ADMessage {\n             serial = Integer.parseInt(parts.get(0));\n             data = Integer.parseInt(parts.get(1), 16);\n         } catch (NumberFormatException e) {\n-            throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());\n+            throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage(), e);\n         }\n     }\n }\n"}}, {"oid": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "url": "https://github.com/openhab/openhab-addons/commit/310488e29c2265cef1367c2bf3a4ef30a4a853ae", "message": "[alarmdecoder] Address review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-11T17:58:43Z", "type": "commit"}, {"oid": "dbd1f70710e0ef73f0aecb9684bd9fbc3c01c0b5", "url": "https://github.com/openhab/openhab-addons/commit/dbd1f70710e0ef73f0aecb9684bd9fbc3c01c0b5", "message": "[alarmdecoder] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-11T20:17:15Z", "type": "commit"}, {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "url": "https://github.com/openhab/openhab-addons/commit/72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "message": "[alarmdecoder] Doc update\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-11T20:42:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MDU3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407150577", "bodyText": "couldn't this have been checked in the initialize method instead?", "author": "cpmeister", "createdAt": "2020-04-12T05:53:34Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            if (config.hostname != null && config.tcpPort > 0 && config.tcpPort < 65536) {", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 2fdd7fa4df..2e6942b1ab 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -58,7 +58,11 @@ public class IPBridgeHandler extends ADBridgeHandler {\n         discovery = config.discovery;\n \n         if (config.hostname == null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n             return;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410598060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Boolean responsibleFor(final int address, final int channel) {\n          \n          \n            \n                public boolean responsibleFor(final int address, final int channel) {", "author": "cpmeister", "createdAt": "2020-04-18T03:51:48Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public Boolean responsibleFor(final int address, final int channel) {", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\nindex d31c6f53ef..38b95d90d5 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n\n@@ -52,7 +52,7 @@ public class ZoneHandler extends ADThingHandler {\n     /**\n      * Returns true if this handler is responsible for the zone with the supplied address and channel.\n      */\n-    public Boolean responsibleFor(final int address, final int channel) {\n+    public boolean responsibleFor(final int address, final int channel) {\n         return (config.address != null && config.channel != null && config.address.equals(address)\n                 && config.channel.equals(channel));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODIwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410598209", "bodyText": "use or lose", "author": "cpmeister", "createdAt": "2020-04-18T03:52:12Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // serialPort.disableReceiveFraming();\n+                // serialPort.disableReceiveThreshold();", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMDEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410730132", "bodyText": "The original V1 code using gnu.io (RXTX) called these here, but org.eclipse.smarthome.io.transport.serial does not seem to provide them for some reason. I assume they default to off? I removed them and added a different comment as a reminder.", "author": "bobadair", "createdAt": "2020-04-18T18:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\nindex 89fba4f7b8..f20ee76c9d 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n\n@@ -64,8 +64,8 @@ public class SerialBridgeHandler extends ADBridgeHandler {\n         config = getConfigAs(SerialBridgeConfig.class);\n         discovery = config.discovery;\n \n-        if (config.serialPort == null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+        if (config.serialPort == null || config.serialPort.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"no serial port configured\");\n             return;\n         } else {\n             serialDeviceName = config.serialPort;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTgzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410599836", "bodyText": "Shouldn't his logic be in the initialize method?", "author": "cpmeister", "createdAt": "2020-04-18T03:55:59Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMzA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410733085", "bodyText": "Maybe. I moved it, but I'm hoping that we can get rid of it in 3.0 since the new serial library update. I added a comment to that effect. See openhab/openhab-core/#1426", "author": "bobadair", "createdAt": "2020-04-18T18:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTgzNg=="}], "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\nindex 89fba4f7b8..f20ee76c9d 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n\n@@ -64,8 +64,8 @@ public class SerialBridgeHandler extends ADBridgeHandler {\n         config = getConfigAs(SerialBridgeConfig.class);\n         discovery = config.discovery;\n \n-        if (config.serialPort == null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+        if (config.serialPort == null || config.serialPort.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"no serial port configured\");\n             return;\n         } else {\n             serialDeviceName = config.serialPort;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410599893", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-04-18T03:56:07Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczMzUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410733503", "bodyText": "I don't know. That depends on whether or not serial ports can be dynamically added/removed on a system. I thought it was safer to leave it in connect().", "author": "bobadair", "createdAt": "2020-04-18T18:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwMzc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410803774", "bodyText": "Since the name of the port is configured by the user beforehand it should be expected that the serial port exists and is available at the time of handler initialization. The binding should fail-fast with regards to configuration errors otherwise you are wasting the user's time.", "author": "cpmeister", "createdAt": "2020-04-19T03:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMDI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411020247", "bodyText": "Ok. I moved it.", "author": "bobadair", "createdAt": "2020-04-19T23:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\nindex 89fba4f7b8..f20ee76c9d 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n\n@@ -64,8 +64,8 @@ public class SerialBridgeHandler extends ADBridgeHandler {\n         config = getConfigAs(SerialBridgeConfig.class);\n         discovery = config.discovery;\n \n-        if (config.serialPort == null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+        if (config.serialPort == null || config.serialPort.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"no serial port configured\");\n             return;\n         } else {\n             serialDeviceName = config.serialPort;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMTQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410601497", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    commandMap = new HashMap<Integer, String>();\n          \n          \n            \n                    commandMap = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-04-18T03:59:59Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    public IntCommandMap(String mappingString) throws IllegalArgumentException {\n+        commandMap = new HashMap<Integer, String>();", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\nindex 104bf4eeea..d95a35c8aa 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n\n@@ -31,7 +31,7 @@ public class IntCommandMap {\n     private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n \n     public IntCommandMap(String mappingString) throws IllegalArgumentException {\n-        commandMap = new HashMap<Integer, String>();\n+        commandMap = new HashMap<>();\n \n         String mstring = mappingString.replace(\"POUND\", \"#\");\n         String[] elements = mstring.split(\",\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603096", "bodyText": "You should override the .equals(Object obj) method instead of overloading.", "author": "cpmeister", "createdAt": "2020-04-18T04:04:13Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public int getZone() {\n+        return numericCode;\n+    }\n+\n+    /**\n+     * Returns a string containing the keypad text\n+     */\n+    public String getText() {\n+        return new String(alphaMessage);\n+    }\n+\n+    /**\n+     * Returns the value of an individual bit in the status field\n+     *\n+     * @param bit status field bit to test\n+     * @return true if bit is 1, false if bit is 0\n+     */\n+    public boolean getStatus(int bit) {\n+        int v = (status >> bit) & 0x1;\n+        return (v == 0) ? false : true;\n+    }\n+\n+    /**\n+     * Returns true if the READY status bit is set\n+     */\n+    public boolean panelClear() {\n+        return ((status & (1 << BIT_READY)) != 0);\n+    }\n+\n+    /**\n+     * Returns a string containing the address mask of the message in hex\n+     */\n+    public String getAddressMask() {\n+        return rawData.substring(3, 11);\n+    }\n+\n+    /**\n+     * Returns an int containing the address mask of the message\n+     */\n+    public int getIntAddressMask() {\n+        return Integer.parseInt(getAddressMask(), 16);\n+    }\n+\n+    /**\n+     * Compares two KeypadMessage objects\n+     *\n+     * @param other KeypadMessage to compare against\n+     * @return true if messages are equal, false if other is null or messages are not equal\n+     */\n+    public boolean equals(@Nullable KeypadMessage other) {", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\nindex 949dcf1562..75869792a8 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\n\n@@ -96,7 +96,7 @@ public class KeypadMessage extends ADMessage {\n      * Returns a string containing the keypad text\n      */\n     public String getText() {\n-        return new String(alphaMessage);\n+        return alphaMessage;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzI4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(alphaMessage);\n          \n          \n            \n                    return alphaMessage;", "author": "cpmeister", "createdAt": "2020-04-18T04:04:43Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public int getZone() {\n+        return numericCode;\n+    }\n+\n+    /**\n+     * Returns a string containing the keypad text\n+     */\n+    public String getText() {\n+        return new String(alphaMessage);", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\nindex 949dcf1562..75869792a8 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java\n\n@@ -96,7 +96,7 @@ public class KeypadMessage extends ADMessage {\n      * Returns a string containing the keypad text\n      */\n     public String getText() {\n-        return new String(alphaMessage);\n+        return alphaMessage;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603725", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (parts.size() == 4) {\n          \n          \n            \n                        reportCode = parts.get(3);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        reportCode = \"\";\n          \n          \n            \n                    }\n          \n          \n            \n                    reportCode = parts.size() == 4 ? parts.get(3) : \"\";", "author": "cpmeister", "createdAt": "2020-04-18T04:05:50Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+\n+        if (parts.size() == 4) {\n+            reportCode = parts.get(3);\n+        } else {\n+            reportCode = \"\";\n+        }", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\nindex cfda34e141..5204fd55a7 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\n\n@@ -56,12 +56,7 @@ public class LRRMessage extends ADMessage {\n \n         eventData = parts.get(0);\n         cidMessage = parts.get(2);\n-\n-        if (parts.size() == 4) {\n-            reportCode = parts.get(3);\n-        } else {\n-            reportCode = \"\";\n-        }\n+        reportCode = parts.size() == 4 ? parts.get(3) : \"\";\n \n         try {\n             int p = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410607801", "bodyText": "Please make sure to set the thread as daemon.", "author": "cpmeister", "createdAt": "2020-04-18T04:15:33Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");", "originalCommit": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczOTA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410739074", "bodyText": "Done.", "author": "bobadair", "createdAt": "2020-04-18T19:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzgwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex 53956a5343..ed427a93b5 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -127,6 +127,7 @@ public abstract class ADBridgeHandler extends BaseBridgeHandler {\n     protected void startMsgReader() {\n         synchronized (msgReaderThreadLock) {\n             msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n             msgReaderThread.start();\n         }\n     }\n"}}, {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "url": "https://github.com/openhab/openhab-addons/commit/3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "message": "[alarmdecoder] Address review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-18T19:07:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwMjM1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410802355", "bodyText": "You should specify the Charset that these streams should use.\nThe default charset varies from system to system so it is better to specify it yourself instead of using the default.", "author": "cpmeister", "createdAt": "2020-04-19T03:19:26Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "931d565f12f9dce717c720505077d35cc30c53a1", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 2e6942b1ab..851e816e2b 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -78,8 +78,8 @@ public class IPBridgeHandler extends ADBridgeHandler {\n         writeException = false;\n         try {\n             socket = new Socket(config.hostname, config.tcpPort);\n-            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n-            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n             logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n             panelReadyReceived = false;\n             startMsgReader();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNDEzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410804136", "bodyText": "This logic should be abstracted into the ADBridgeHandler. The ADBridgeHandler should be responsible for opening and closing the input/output streams leaving the subclasses only having to handle sending and parsing messages.", "author": "cpmeister", "createdAt": "2020-04-19T03:31:55Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null || config.serialPort.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"no serial port configured\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        // Exit if no identifiers exist to work around possible library bug. May not be needed in 3.0.\n+        Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+        if (!serialPortIdentifiers.findAny().isPresent()) {\n+            logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+            return;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // Note: The V1 code called disableReceiveFraming() and disableReceiveThreshold() here\n+\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                logger.debug(\"connected to serial port: {}\", serialDeviceName);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk5MzAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410993030", "bodyText": "It's actually the other way around. The ADBridgeHandler class contains all of the message sending, receiving, and parsing, and the subclasses (IPBridgeHandler & SerialBridgeHandler) contain mostly the IO setup, tear-down, retry and monitoring logic for their specific type of communication. The lines you indicate are shared between the two, and so could be abstracted out, but I wasn't sure it was really worth the effort given that they are wrapped in common exception handling, etc., along with the more subclass-specific connection setup code.", "author": "bobadair", "createdAt": "2020-04-19T21:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNDEzNg=="}], "type": "inlineReview", "revised_code": {"commit": "931d565f12f9dce717c720505077d35cc30c53a1", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\nindex f20ee76c9d..5a6a120bd1 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java\n\n@@ -108,8 +108,8 @@ public class SerialBridgeHandler extends ADBridgeHandler {\n                 serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n                 // Note: The V1 code called disableReceiveFraming() and disableReceiveThreshold() here\n \n-                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n-                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream(), AD_CHARSET_NAME));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream(), AD_CHARSET_NAME));\n                 logger.debug(\"connected to serial port: {}\", serialDeviceName);\n                 panelReadyReceived = false;\n                 startMsgReader();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410806323", "bodyText": "There is nothing the user could do about this even if you informed him. I suggest changing the logging level to debug.", "author": "cpmeister", "createdAt": "2020-04-19T03:47:23Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3MzU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410973554", "bodyText": "Well, at least for now, I would really like users to be warned of any parse errors so that they can report the problem. Otherwise there may be silent failures in some cases which we won't know about. Do you think it would make sense to leave it at INFO for now and bump it down to DEBUG later? Or I can bump it up to WARN for now if you would rather reserve INFO level.", "author": "bobadair", "createdAt": "2020-04-19T19:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4OTk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414789967", "bodyText": "If this is something that should be reported, I would suggest to include that in the message (e.e. \"This is a bug and should be reported\") and increase to WARN", "author": "J-N-K", "createdAt": "2020-04-24T18:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "931d565f12f9dce717c720505077d35cc30c53a1", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex ed427a93b5..5aada8246b 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -56,6 +56,7 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n \n     private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410808825", "bodyText": "Right now you have this designed such that the bridge searches out handlers that should process a given message. This requires the bridge to have knowledge of all of the ADHandler subclasses and also a two step approach:\n\nBridge must identify which handlers could handle a message.\nBridge then passes on message to handlers found in step 1\n\nI think it would be simpler if instead you just send the message to all of the handlers and let the handlers decide whether or not they want to handle it. This allows the bridge to be ignorant of the types of handlers as well as possibly allowing the bridge to be ignorant of the message type as well. Also instead of each handler having to implement 2 methods (one to judge if it can handle the message and another to actually handle it), each handler would only have to implement a single method which optionally handles the message.", "author": "cpmeister", "createdAt": "2020-04-19T04:05:09Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        // Notify appropriate KeypadHandlers\n+        Collection<KeypadHandler> handlers = findKeypadHandlers(kpm.getIntAddressMask());\n+        for (KeypadHandler handler : handlers) {\n+            handler.handleUpdate(kpm);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        ZoneHandler handler = findZoneHandler(expm.address, expm.channel);\n+        if (handler != null) {\n+            handler.handleUpdate(expm.data);\n+        }\n+\n+        if (discovery && discoveryService != null) {\n+            discoveryService.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        RFZoneHandler handler = findRFZoneHandler(rfxm.serial);\n+        if (handler != null) {\n+            handler.handleUpdate(rfxm.data);\n+        }\n+\n+        if (discovery && discoveryService != null) {\n+            discoveryService.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        // Notify appropriate LRRHandlers\n+        Collection<LRRHandler> handlers = findLRRHandlers(lrrm.partition);\n+        for (LRRHandler handler : handlers) {\n+            handler.handleUpdate(lrrm);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify all child thing handlers that the alarm panel is in the ready state. Since there is no way to poll, all\n+     * channels are initialized into the UNDEF state. This method is called when there is reason to assume that there\n+     * are no faulted zones, because the alarm panel is in state READY. Zone handlers that have not yet received updates\n+     * can then set their contact states to CLOSED. Only executes the first time panel is ready after bridge\n+     * connect/reconnect.\n+     */\n+    private void notifyChildHandlersPanelReady() {\n+        if (!panelReadyReceived) {\n+            panelReadyReceived = true;\n+            logger.trace(\"Notifying child handlers that panel is in ready state\");\n+\n+            // Notify child zone handlers by calling notifyPanelReady() for each\n+            for (Thing thing : getThing().getThings()) {\n+                if (thing.getHandler() instanceof ZoneHandler || thing.getHandler() instanceof RFZoneHandler) {\n+                    ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+                    if (handler != null) {\n+                        handler.notifyPanelReady();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the ZoneHandler for the given address and channel, or null if no handler exists and is initialized.\n+     */\n+    private @Nullable ZoneHandler findZoneHandler(int address, int channel) {", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMDI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411000279", "bodyText": "Yeah, I'll admit I don't love the way this works at the moment. I'm not sure I really like the idea of sending every message to every handler either, though, although it would probably eliminate a lot of code.  The AD protocol can be very chatty, especially with keypad messages which it seems to send every few seconds. I'd rather not hit every zone/rfzone handler with every keypad message, since there can be a lot of both. Sending each message to every handler of the correct type may be ok, but that would still require maintaining or generating a list of the child handlers of each type. Originally I was planning on registering all of the child handlers in maps in the bridge so that look-ups would be very efficient, but that seemed complex and error-prone, especially given the address mask comparisons necessary for finding the appropriate keypad or lrr handler for a given message.\nGiven a choice, I would rather not mess with this for now, since it works well enough, and come up with a better scheme later.", "author": "bobadair", "createdAt": "2020-04-19T21:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNTY5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411805698", "bodyText": "Ok. I had some time today, so I rewrote this part of the code. The bridge now sends messages to all child handlers of the correct type, and they decide in their handleUpdate(ADMessage) methods whether or not they should act on them. I'll merge it in to this branch after a bit more testing.", "author": "bobadair", "createdAt": "2020-04-21T01:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "931d565f12f9dce717c720505077d35cc30c53a1", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex ed427a93b5..5aada8246b 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -56,6 +56,7 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n \n     private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwOTM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410809389", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-19T04:09:12Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public boolean responsibleFor(final int address, final int channel) {\n+        return (config.address != null && config.channel != null && config.address.equals(address)\n+                && config.channel.equals(channel));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(ZoneConfig.class);\n+\n+        if (config.address == null || config.channel == null || config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n+\n+        String id = zoneID(config.address, config.channel);\n+        updateProperty(PROPERTY_ID, id); // set representation property used by discovery\n+\n+        initDeviceState();\n+        logger.trace(\"Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for Zone {},{}\", config.address, config.channel);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            firstUpdateReceived.set(false);\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Set contact channel state to \"UNDEF\" at init time. The real state will be set either when the first message\n+     * arrives for the zone, or it should be set to \"CLOSED\" the first time the panel goes into the \"READY\" state.\n+     */\n+    @Override\n+    public void initChannelState() {\n+        UnDefType state = UnDefType.UNDEF;\n+        updateState(CHANNEL_CONTACT, state);\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        logger.trace(\"Zone handler for {},{} received panel ready notification.\", config.address, config.channel);\n+        if (firstUpdateReceived.compareAndSet(false, true)) {\n+            updateState(CHANNEL_CONTACT, OpenClosedType.CLOSED);\n+        }\n+", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "931d565f12f9dce717c720505077d35cc30c53a1", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\nindex 38b95d90d5..46eb534efe 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n\n@@ -105,7 +105,6 @@ public class ZoneHandler extends ADThingHandler {\n         if (firstUpdateReceived.compareAndSet(false, true)) {\n             updateState(CHANNEL_CONTACT, OpenClosedType.CLOSED);\n         }\n-\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwOTczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410809739", "bodyText": "please put static fields before non-static fields", "author": "cpmeister", "createdAt": "2020-04-19T04:12:06Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "931d565f12f9dce717c720505077d35cc30c53a1", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\nindex d95a35c8aa..9c1c6602ca 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java\n\n@@ -27,9 +27,10 @@ import org.eclipse.jdt.annotation.Nullable;\n  */\n @NonNullByDefault\n public class IntCommandMap {\n-    private final Map<Integer, String> commandMap;\n     private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n \n+    private final Map<Integer, String> commandMap;\n+\n     public IntCommandMap(String mappingString) throws IllegalArgumentException {\n         commandMap = new HashMap<>();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410810085", "bodyText": "How would you know this is correct if you are given a hexadecimal number that doesn't have any letters in it?", "author": "cpmeister", "createdAt": "2020-04-19T04:14:26Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+        reportCode = parts.size() == 4 ? parts.get(3) : \"\";\n+\n+        try {\n+            int p = 0;\n+            try {\n+                p = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                p = Integer.parseInt(parts.get(1), 16);", "originalCommit": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk0Nzk2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410947969", "bodyText": "Looking through the docs again, I think this field is unlikely to ever be a hex number. However, if it were, I believe it would have a 0x prefix. There is equivalent code in the keypad message parser, which comes from the V1 binding.", "author": "bobadair", "createdAt": "2020-04-19T17:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk1OTg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410959846", "bodyText": "I could not find precisely what the protocol specs say about that field. The specs don't even say it's an integer, but the example they are giving is:\n\"Event Data:\nThis is either the user number of the person performing the action or the zone that was bypassed.\"\nhttp://www.alarmdecoder.com/wiki/index.php/Protocol#Format_5\nI don't know, might be safest to treat it as a string? (Sorry, I don't receive LRR messages on my system, so I don't have any example messages).", "author": "berndpfrommer", "createdAt": "2020-04-19T18:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2NzczNA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410967734", "bodyText": "Thanks @berndpfrommer. Yes, the AD protocol spec wasn't too much help. From looking at the SIA DC-05-1999.09 document (pp. 5-8) it seems clear that zone and user are both integers, but there is no clear indication as to what number system the AD would use to send them other than the example in there docs which appears to be decimal. Maybe @LuckyMallari would have some input on this?\nUsing a string could work as well if we can't come up with a definitive answer.  BTW - I've been planning to add another channel to the lrr thing that provides the whole LRR message payload as a string for better backward compatibility with the V1 binding, but I thought I would do that after this initial submission was merged.", "author": "bobadair", "createdAt": "2020-04-19T18:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3NTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r411875752", "bodyText": "Thanks @berndpfrommer. Yes, the AD protocol spec wasn't too much help. From looking at the SIA DC-05-1999.09 document (pp. 5-8) it seems clear that zone and user are both integers, but there is no clear indication as to what number system the AD would use to send them other than the example in there docs which appears to be decimal. Maybe @LuckyMallari would have some input on this?\nUsing a string could work as well if we can't come up with a definitive answer. BTW - I've been planning to add another channel to the lrr thing that provides the whole LRR message payload as a string for better backward compatibility with the V1 binding, but I thought I would do that after this initial submission was merged.\n\nSorry for being inactive on the thread.. busy with stuff ;) Had to dig from my old posts, but here's some info:\nhttps://www.openhab.org/addons/bindings/alarmdecoder1/\nLRR format from Alarm Decoder is:\n\n!LRR:<data>,<partition>,<event>\n\nand\nBecause <data> could be anything, it cannot be tied to a particular item as opposed to item bindings such as Contacts mentioned above. Instead, the entire message is sent to the binding.\n\n!LRR:<entiremessage>\n\nNow, if you look at the history story of the page, it has not been updated since 2013, so my comments are still correct.\nI am still using the AD binding v1, and still works flawlessly at the time of this writing. Here are some same LRR messages captured from my Vista20P:\n!SER2SOCK Connected\n!SER2SOCK SERIAL_CONNECTED\n##1\n!Sending.done\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n#1\n!Sending.done\n!RFX:0746846,80\n#\n!Sending.done\n1\n!RFX:0746846,00\n!Sending.done\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n#2\n!Sending.done\n[0101050100000000----],008,[f70000ff1008050c0c020000000000],\"ARMED ***AWAY***You                                                                              may exit now\"\n!LRR:000,1,ARM_AWAY\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!RFX:0322328,84\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!LRR:003,1,OPEN\n!Sending.done\n!Sending.done\n!LRR:000,1,ARM_STAY\n[0011030100000000----],008,[f70000ff1008038c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!LRR:003,1,OPEN\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[0011030100000000----],008,[f70000ff1008038c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!LRR:003,1,ARM_STAY\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     R                                                                             eady to Arm  \"\n!LRR:002,1,OPEN\n!Sending.done\n!LRR:002,1,ARM_STAY\n[0011030100000000----],008,[f70000ff1008038c08020000000000],\"ARMED ***STAY***You                                                                              may exit now\"\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!Sending.done\n!RFX:0702437,84\n[0011000100000000----],008,[f70000ff1008008c08020000000000],\"ARMED ***STAY***You may exit now\"\n!Sending.done\n!Sending.done\n!Sending..done\n!RFX:0638432,80\n!Sending.done\n[1001010100000000----],008,[f70000ff1008011c08020000000000],\"THE MALLARI'S     Ready to Arm  \"\n!RFX:0638432,00\n[1001000100000000----],008,[f70000ff1008001c08020000000000],\"THE MALLARI'S     Ready to Arm  \"\n!LRR:002,1,OPEN\n\nHere's how to interpret the LRR messages:\n\n!LRR:000,1,ARM_AWAY - I simply sent # 2 (which is same as hitting # 2 on keypad. This means the system was Armed (away), but it is 000 because there is no user. In my OH rules, I treat 000 as \"system\" user, which means an arm was invoked without using a PIN (like doing a # 2) from keypad.\n!LRR:002,1,OPEN - Disarmed by User 2\n!LRR:003,1,ARM_STAY - Armed stay by user 3. This is when you hit PIN then Stay (in Vista20P keypads, this is 3). For example, if user 3 pin code is 1234, then you get this by hitting 12343 on keypad.\n!LRR:00,1,OPEN - Disarmed by User 3\n\nLRR Event Types can be retrieved here\nNote that LRR events will need to be enabled by user on the alarm itself. For example, for OPEN to show up in LRR, OPEN reports should be enabled (field *65)\nYou need to\n\nFilter (or switch/case) events such as OPEN/ARM_AWAY/ARM_STAY and treat the field as USER\n\nI just dont have enough free time to test which events are user events and which are system/partition events\nBut to quickly answer your question,  Data field are always INTEGERS", "author": "LuckyMallari", "createdAt": "2020-04-21T05:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412316536", "bodyText": "Thanks @LuckyMallari ! That is great info. So we can assume that data and partition will always be decimal integers. I've removed the hex parsing code that @cpmeister originally commented on, and also added your LRR messages to the test data I'm using.\nDo you know what determines whether the LRR messages will be of the format in your data or the \"CID\" format mentioned in the current protocol docs (e.g. \"!LRR:012,1,CID_1441,ff\")? The parsing code will work with either, so I only ask out of curiosity, and maybe for purposes of documentation. I see there is an AD firmware capability called \"L2 - Long range radio messages (!LRR) with CID reporting format\", so I've been assuming it is related to firmware version and/or configuration.", "author": "bobadair", "createdAt": "2020-04-21T16:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM1MTE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412351141", "bodyText": "I thought I read someplace that LRR is always in Ademco Contact ID format (CID) regardless of the alarm setting for the phoneline.\nThe LRR seems to be another destination for reports. What is the benefit of LRR support in the binding if the same messages are sent to the keypad?", "author": "billfor", "createdAt": "2020-04-21T17:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\nindex 5204fd55a7..18284481e2 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java\n\n@@ -26,6 +26,7 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n public class LRRMessage extends ADMessage {\n \n     // Example: !LRR:012,1,CID_1441,ff\n+    // or: !LRR:000,1,ARM_AWAY\n \n     /** Event data contains user number or zone number for the event */\n     public final String eventData;\n"}}, {"oid": "931d565f12f9dce717c720505077d35cc30c53a1", "url": "https://github.com/openhab/openhab-addons/commit/931d565f12f9dce717c720505077d35cc30c53a1", "message": "[alarmdecoder] Address a few more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-19T17:48:09Z", "type": "commit"}, {"oid": "463495df30a70361a0618afa8e0d4f5e25c76791", "url": "https://github.com/openhab/openhab-addons/commit/463495df30a70361a0618afa8e0d4f5e25c76791", "message": "[alarmdecoder] Minor update to SerialBridgeHandler\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-19T23:47:16Z", "type": "commit"}, {"oid": "7491fe7def52bb535d9a6dc95348281bf7f21567", "url": "https://github.com/openhab/openhab-addons/commit/7491fe7def52bb535d9a6dc95348281bf7f21567", "message": "[alarmdecoder] Change message dispatching model\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T02:40:26Z", "type": "commit"}, {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "url": "https://github.com/openhab/openhab-addons/commit/9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "message": "[alarmdecoder] Update to LRR message parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T16:55:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412505290", "bodyText": "There has been a consensus among the addon maintainers to not allow use of @NonNullByDefault({}) on config fields. There are several alternatives that are allowed:\n\nmake field nullable\nwrap config in a non-null Optional field\nmake config field non-null by initializing to a default configuration.", "author": "cpmeister", "createdAt": "2020-04-21T21:30:10Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MjA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412562069", "bodyText": "Ok. Easy enough to fix. It's a bit silly, though, isn't it? Now in every handler we're just creating a dummy config object in the constructor that is then immediately thrown away and replaced with the real one in the initialize() method. The other alternatives seem even more annoying, though.", "author": "bobadair", "createdAt": "2020-04-21T23:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNjUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412616538", "bodyText": "A little silly yes, but it is preferable to NPEs. The null checker may have its annoyances but I've generally grown to like it since helps address possible concurrency issues as well as preventing NPEs. I just really wish it handled maps properly.", "author": "cpmeister", "createdAt": "2020-04-22T02:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "605e2624207e1806c20ed0e515fc447652ff5656", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\nindex 575e00ca82..8a85160173 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n\n@@ -40,23 +40,23 @@ public class ZoneHandler extends ADThingHandler {\n \n     private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n \n-    private @NonNullByDefault({}) ZoneConfig config;\n+    private ZoneConfig config = new ZoneConfig();\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n \n     /** Construct zone id from address and channel */\n     public static final String zoneID(int address, int channel) {\n         return String.format(\"%d-%d\", address, channel);\n     }\n \n-    public ZoneHandler(Thing thing) {\n-        super(thing);\n-    }\n-\n     @Override\n     public void initialize() {\n         config = getConfigAs(ZoneConfig.class);\n \n-        if (config.address == null || config.channel == null || config.address < 0 || config.channel < 0) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        if (config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid address/channel setting\");\n             return;\n         }\n         logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNjMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412506323", "bodyText": "Please either make these fields nullable or provide a default value for them. Do not use @NonNullByDefault({}) in any config classes.", "author": "cpmeister", "createdAt": "2020-04-21T21:32:03Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n+\n+/**\n+ * The {@link ZoneConfig} class contains fields mapping thing configuration parameters for {@link ZoneHandler}.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneConfig {\n+    public @NonNullByDefault({}) Integer address;", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412566014", "bodyText": "Ok. Done for all of the config classes.", "author": "bobadair", "createdAt": "2020-04-21T23:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNjMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "605e2624207e1806c20ed0e515fc447652ff5656", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java\nindex 6076bcb9c7..68a45e0bdf 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java\n\n@@ -22,6 +22,6 @@ import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n  */\n @NonNullByDefault\n public class ZoneConfig {\n-    public @NonNullByDefault({}) Integer address;\n-    public @NonNullByDefault({}) Integer channel;\n+    public int address = -1;\n+    public int channel = -1;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412509174", "bodyText": "Is this handled properly?", "author": "cpmeister", "createdAt": "2020-04-21T21:37:27Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412564713", "bodyText": "I believe so. This comes from the original V1 binding code, so it has been running happily lo these many years. :-) I expect that in the rare instances this field contains a hex number, it will be prefixed with 0x so that the first parseInt will reliably throw an exception.\nAs a side note... who comes up with a protocol where an integer represented as text may be either decimal or hex? Sigh.", "author": "bobadair", "createdAt": "2020-04-21T23:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxODY3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412618670", "bodyText": "As a side note... who comes up with a protocol where an integer represented as text may be either decimal or hex? Sigh.\n\nProbably not one person, but a group of people that don't check or correct each-other's work managed by a manager that doesn't care.", "author": "cpmeister", "createdAt": "2020-04-22T02:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MzU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413183589", "bodyText": "LOL. That's the sort of thing that slips through as a team approaches a release deadline.", "author": "bobadair", "createdAt": "2020-04-22T17:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTY4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412515689", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-04-21T21:49:44Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The various message types that come from the ad2usb/ad2pi interface\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1)\n+ * @author Bob Adair - Re-factored and removed methods unused in OH2 binding\n+ */\n+public enum ADMsgType {", "originalCommit": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4NDUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413184530", "bodyText": "This is done, even though the comment isn't flagged as \"Outdated\".", "author": "bobadair", "createdAt": "2020-04-22T17:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "605e2624207e1806c20ed0e515fc447652ff5656", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java\nindex aca5ac5d08..b12ed7411d 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java\n\n@@ -14,6 +14,7 @@ package org.openhab.binding.alarmdecoder.internal.protocol;\n \n import java.util.HashMap;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n \n /**\n"}}, {"oid": "605e2624207e1806c20ed0e515fc447652ff5656", "url": "https://github.com/openhab/openhab-addons/commit/605e2624207e1806c20ed0e515fc447652ff5656", "message": "[alarmdecoder] Change null annotations in config classes\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T23:45:58Z", "type": "commit"}, {"oid": "33b706af73c1b1f0704478f9e386513dffcd2e15", "url": "https://github.com/openhab/openhab-addons/commit/33b706af73c1b1f0704478f9e386513dffcd2e15", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-21T23:50:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412707677", "bodyText": "Almost all of the of the handlers implement this method the same way, is it possible to have it refactored?", "author": "cpmeister", "createdAt": "2020-04-22T06:35:10Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private ZoneConfig config = new ZoneConfig();\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(ZoneConfig.class);\n+\n+        if (config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid address/channel setting\");\n+            return;\n+        }\n+        logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n+\n+        String id = zoneID(config.address, config.channel);\n+        updateProperty(PROPERTY_ID, id); // set representation property used by discovery\n+\n+        initDeviceState();\n+        logger.trace(\"Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {", "originalCommit": "33b706af73c1b1f0704478f9e386513dffcd2e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyODI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413128254", "bodyText": "Yeah, I had actually meant to do that. Done.", "author": "bobadair", "createdAt": "2020-04-22T16:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzY3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\nindex 8a85160173..fa00f2a4d0 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java\n\n@@ -16,7 +16,6 @@ import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConst\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.library.types.OpenClosedType;\n-import org.eclipse.smarthome.core.thing.Bridge;\n import org.eclipse.smarthome.core.thing.ChannelUID;\n import org.eclipse.smarthome.core.thing.Thing;\n import org.eclipse.smarthome.core.thing.ThingStatus;\n"}}, {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa", "url": "https://github.com/openhab/openhab-addons/commit/8a4be504a4c3bdf74696491625be23fbb73704fa", "message": "[alarmecoder] Move device state init to handler superclass\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T16:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5NDA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413194086", "bodyText": "It is very easy to get a NPE here if another thread sets reader to null in-between your null check and your readLine call.", "author": "cpmeister", "createdAt": "2020-04-22T17:53:23Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex cee5f1b992..26c69c1931 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -106,9 +106,10 @@ public abstract class ADBridgeHandler extends BaseBridgeHandler {\n     public void sendADCommand(ADCommand command) {\n         logger.debug(\"Sending AD command: {}\", command);\n         try {\n-            if (writer != null) {\n-                writer.write(command.toString());\n-                writer.flush();\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n             }\n         } catch (IOException e) {\n             logger.info(\"Exception while sending command: {}\", e.getMessage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5ODAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413198038", "bodyText": "Please cache bridgeStatusInfo.getStatus() in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-04-22T17:58:51Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+\n+    public ADThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Initialize device state and set status for handler. Should be called at the end of initialize(). Calls\n+     * initChannelState() to initialize channels if setting status to ONLINE.\n+     */\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state\");\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Initialize channel states if necessary\n+     */\n+    public abstract void initChannelState();\n+\n+    /**\n+     * Notify handler that panel is in ready state so that any un-updated contact channels can be set to default\n+     * (closed).\n+     */\n+    public abstract void notifyPanelReady();\n+\n+    /**\n+     * Notify handler of a message from the AD via the bridge\n+     *\n+     * @param msg The ADMessage to handle\n+     */\n+    public abstract void handleUpdate(ADMessage msg);\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} for AD handler\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\nindex 6d731e574c..bba2c6a93c 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java\n\n@@ -42,8 +42,9 @@ public abstract class ADThingHandler extends BaseThingHandler {\n     }\n \n     /**\n-     * Initialize device state and set status for handler. Should be called at the end of initialize(). Calls\n-     * initChannelState() to initialize channels if setting status to ONLINE.\n+     * Initialize device state and set status for handler. Should be called at the end of initialize(). Also called by\n+     * bridgeStatusChanged() when bridge status changes from OFFLINE to ONLINE. Calls initChannelState() to initialize\n+     * channels if setting status to ONLINE.\n      */\n     protected void initDeviceState() {\n         logger.trace(\"Initializing device state\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMDY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413200664", "bodyText": "For instance, the warnings on the following two lines can be fixed like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        socket = new Socket(config.hostname, config.tcpPort);\n          \n          \n            \n                        Socket socket = new Socket(config.hostname, config.tcpPort);\n          \n          \n            \n                        this.socket = socket;", "author": "cpmeister", "createdAt": "2020-04-22T18:02:22Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 34c93859ba..0bd28ef8fa 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -20,6 +20,7 @@ import java.io.OutputStreamWriter;\n import java.net.Socket;\n import java.net.UnknownHostException;\n import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMjg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413202889", "bodyText": "This is how you fix the warning here. It can be annoying, but it makes the code much more thread-safe. You get the general idea though, so I'll let you fix the rest.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (msgReaderThread != null && !msgReaderThread.isAlive()) {\n          \n          \n            \n                    Thread msgReaderThread = this.msgReaderThread;\n          \n          \n            \n                    if (msgReaderThread != null && !msgReaderThread.isAlive()) {", "author": "cpmeister", "createdAt": "2020-04-22T18:05:33Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", config.hostname, config.tcpPort, e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(config.reconnect); // Possibly a retryable error. Try again later.\n+        }\n+    }\n+\n+    protected synchronized void connectionCheck() {\n+        logger.trace(\"Connection check job running\");\n+\n+        if (msgReaderThread != null && !msgReaderThread.isAlive()) {", "originalCommit": "8a4be504a4c3bdf74696491625be23fbb73704fa", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 34c93859ba..0bd28ef8fa 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -20,6 +20,7 @@ import java.io.OutputStreamWriter;\n import java.net.Socket;\n import java.net.UnknownHostException;\n import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n"}}, {"oid": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "url": "https://github.com/openhab/openhab-addons/commit/7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "message": "[alarmecoder] Fix all compiler warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T20:27:49Z", "type": "commit"}, {"oid": "4a7995bb300539cf99378c2a13fd93d4eb046ce1", "url": "https://github.com/openhab/openhab-addons/commit/4a7995bb300539cf99378c2a13fd93d4eb046ce1", "message": "[alarmecoder] Run spotless apply\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T21:02:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413337457", "bodyText": "This would solve the only warning left.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void reboot() {\n          \n          \n            \n                    if (bridge != null) {\n          \n          \n            \n                public void reboot() {\n          \n          \n            \n                    ADBridgeHandler bridge = this.bridge;\n          \n          \n            \n                    if (bridge != null) {", "author": "cpmeister", "createdAt": "2020-04-22T21:14:06Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.actions;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BridgeActions} class defines thing actions for alarmdecoder bridges.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@ThingActionsScope(name = \"alarmdecoder\")\n+@NonNullByDefault\n+public class BridgeActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BridgeActions.class);\n+\n+    private @Nullable ADBridgeHandler bridge;\n+\n+    public BridgeActions() {\n+        logger.trace(\"Alarm Decoder bridge actions service created\");\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ADBridgeHandler) {\n+            this.bridge = (ADBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridge;\n+    }\n+\n+    /**\n+     * Reboot thing action\n+     */\n+    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n+    public void reboot() {\n+        if (bridge != null) {", "originalCommit": "4a7995bb300539cf99378c2a13fd93d4eb046ce1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0NzA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413347092", "bodyText": "How did I miss that one? That was one of that warnings that wasn't showing up in Eclipse.\nFixed.", "author": "bobadair", "createdAt": "2020-04-22T21:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java\nindex 3229a1d8f0..fc5b9024de 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java\n\n@@ -57,6 +57,7 @@ public class BridgeActions implements ThingActions {\n      */\n     @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n     public void reboot() {\n+        ADBridgeHandler bridge = this.bridge;\n         if (bridge != null) {\n             bridge.sendADCommand(ADCommand.reboot());\n             logger.debug(\"Sending reboot command.\");\n"}}, {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "url": "https://github.com/openhab/openhab-addons/commit/09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "message": "[alarmecoder] Really fix all compiler warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-22T21:29:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4Mzg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414783866", "bodyText": "Does this pass the codestyle-check without warning?", "author": "J-N-K", "createdAt": "2020-04-24T18:37:41Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/AlarmDecoderDiscoveryService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AlarmDecoderDiscoveryService} handles discovery of devices as they are identified by the bridge handler.\n+ * Requests from the framework to startScan() are ignored, since no active scanning is possible.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AlarmDecoderDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(AlarmDecoderDiscoveryService.class);\n+\n+    private ADBridgeHandler bridgeHandler;", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwNDQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414904448", "bodyText": "Yes. There are no SCA warnings.", "author": "bobadair", "createdAt": "2020-04-24T22:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4Mzg2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414785752", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n          \n          \n            \n                @RuleAction(label = \"Reboot\", description = \"Reboot the Alarm Decoder device\")", "author": "J-N-K", "createdAt": "2020-04-24T18:40:54Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.actions;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BridgeActions} class defines thing actions for alarmdecoder bridges.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@ThingActionsScope(name = \"alarmdecoder\")\n+@NonNullByDefault\n+public class BridgeActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BridgeActions.class);\n+\n+    private @Nullable ADBridgeHandler bridge;\n+\n+    public BridgeActions() {\n+        logger.trace(\"Alarm Decoder bridge actions service created\");\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ADBridgeHandler) {\n+            this.bridge = (ADBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridge;\n+    }\n+\n+    /**\n+     * Reboot thing action\n+     */\n+    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "09de463dbcb35337177de90b967e8f4727c840ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java\nindex fc5b9024de..dac7696cc9 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java\n\n@@ -55,7 +55,7 @@ public class BridgeActions implements ThingActions {\n     /**\n      * Reboot thing action\n      */\n-    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n+    @RuleAction(label = \"Reboot\", description = \"Reboot the Alarm Decoder device\")\n     public void reboot() {\n         ADBridgeHandler bridge = this.bridge;\n         if (bridge != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414787562", "bodyText": "I don't think this is a valid serial port. Wouldn't it be better to use @nullable here?", "author": "J-N-K", "createdAt": "2020-04-24T18:43:51Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/SerialBridgeConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link SerialBridgeConfig} class contains fields mapping thing configuration parameters for SerialBridgeHandler.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfig {\n+    public String serialPort = \"\";", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkzMzEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414933108", "bodyText": "LOL. I just changed this from being a @nullable, It was previously annotated @NonNullByDefault({}). When I removed that, it caused too many null check warnings, so I went with this method instead. The handler will indicate a config error if it is unchanged.", "author": "bobadair", "createdAt": "2020-04-25T00:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg0NTA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r416845045", "bodyText": "IMO @Nullable would be the correct way, but we can leave it as-is.", "author": "J-N-K", "createdAt": "2020-04-28T18:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4ODkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414788929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ADMsgType mt = ADMsgType.getMsgType(msg);\n          \n          \n            \n                            ADMsgType msgType = ADMsgType.getMsgType(msg);\n          \n      \n    \n    \n  \n\nuse meaningful names where possible", "author": "J-N-K", "createdAt": "2020-04-24T18:46:13Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex 26c69c1931..dba4780606 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -17,6 +17,8 @@ import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConst\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MDM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414790362", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    KeypadMessage kpm;\n          \n          \n            \n                    KeypadMessage keyPadMessage;\n          \n      \n    \n    \n  \n\nIt would be nice if you could check other occurences of two/three letter variable/field/parameter names and refactor them to something more readable.", "author": "J-N-K", "createdAt": "2020-04-24T18:48:46Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex 26c69c1931..dba4780606 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -17,6 +17,8 @@ import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConst\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MzI1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414793257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Thing thing : getThing().getThings()) {\n          \n          \n            \n                    getThing().getThings().forEach(thing -> {", "author": "J-N-K", "createdAt": "2020-04-24T18:53:55Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        notifyChildHandlers(kpm);\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(expm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(rfxm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(lrrm);\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify appropriate child thing handlers of an AD message by calling their handleUpdate() methods.\n+     *\n+     * @param msg message to forward to child handler(s)\n+     */\n+    private void notifyChildHandlers(ADMessage msg) {\n+        for (Thing thing : getThing().getThings()) {", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex 26c69c1931..dba4780606 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -17,6 +17,8 @@ import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConst\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414795567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (Thing thing : getThing().getThings()) {\n          \n          \n            \n                            ADThingHandler handler = (ADThingHandler) thing.getHandler();\n          \n          \n            \n                            if (handler != null && (handler instanceof ZoneHandler || handler instanceof RFZoneHandler)) {\n          \n          \n            \n                                handler.notifyPanelReady();\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        getThing().getThings().stream().map(Thing::getHandler).filter(Objects::nonNull).forEach(handler -> {\n          \n          \n            \n                            if (handler instanceof ZoneHandler || handler instanceof RFZoneHandler) {\n          \n          \n            \n                                ((ADThingHandler) handler).notifyPanelReady();\n          \n          \n            \n                            }\n          \n          \n            \n                        });", "author": "J-N-K", "createdAt": "2020-04-24T18:57:54Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        notifyChildHandlers(kpm);\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(expm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(rfxm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(lrrm);\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify appropriate child thing handlers of an AD message by calling their handleUpdate() methods.\n+     *\n+     * @param msg message to forward to child handler(s)\n+     */\n+    private void notifyChildHandlers(ADMessage msg) {\n+        for (Thing thing : getThing().getThings()) {\n+            ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+            //@formatter:off\n+            if (handler != null && ((handler instanceof ZoneHandler && msg instanceof EXPMessage) ||\n+                                    (handler instanceof RFZoneHandler && msg instanceof RFXMessage) ||\n+                                    (handler instanceof KeypadHandler && msg instanceof KeypadMessage) ||\n+                                    (handler instanceof LRRHandler && msg instanceof LRRMessage))) {\n+                handler.handleUpdate(msg);\n+            }\n+            //@formatter:on\n+        }\n+    }\n+\n+    /**\n+     * Notify child thing handlers that the alarm panel is in the ready state. Since there is no way to poll, all\n+     * contact channels are initialized into the UNDEF state. This method is called when there is reason to assume that\n+     * there are no faulted zones, because the alarm panel is in state READY. Zone handlers that have not yet received\n+     * updates can then set their contact states to CLOSED. Only executes the first time panel is ready after bridge\n+     * connect/reconnect. Currently only notifies ZoneHandler and RFZoneHandler things.\n+     */\n+    private void notifyChildHandlersPanelReady() {\n+        if (!panelReadyReceived) {\n+            panelReadyReceived = true;\n+            logger.trace(\"Notifying child handlers that panel is in ready state\");\n+\n+            // Notify child zone handlers by calling notifyPanelReady() for each\n+            for (Thing thing : getThing().getThings()) {\n+                ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+                if (handler != null && (handler instanceof ZoneHandler || handler instanceof RFZoneHandler)) {\n+                    handler.notifyPanelReady();\n+                }\n+            }", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMDMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414830333", "bodyText": "Technically instanceof will only return true for a non-null object, so you don't need to filter them out explicitly.\n@J-N-K Also I think this suggested change is less readable than the original.\nIn addition, it is less performant and includes the overhead of generating anonymous lambda classes in the bytecode.\nLambdas are fun and useful, but you shouldn't treat them as the only trick in your toolbox otherwise you will try to use them for everything.", "author": "cpmeister", "createdAt": "2020-04-24T20:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNTUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414835516", "bodyText": "I think readability is probably a bit personal preference. But I\u2018m ok to leave it as-is.", "author": "J-N-K", "createdAt": "2020-04-24T20:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\nindex 26c69c1931..dba4780606 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java\n\n@@ -17,6 +17,8 @@ import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConst\n import java.io.BufferedReader;\n import java.io.BufferedWriter;\n import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NjIxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414796215", "bodyText": "see above: does this pass the codestyle check?", "author": "J-N-K", "createdAt": "2020-04-24T18:59:00Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwNDY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414904684", "bodyText": "Yes. There are no SCA warnings.", "author": "bobadair", "createdAt": "2020-04-24T22:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NjIxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5ODYxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414798611", "bodyText": "better set StandardCharsets.UTF8 instead of the UTF-8 string.", "author": "J-N-K", "createdAt": "2020-04-24T19:03:21Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 0bd28ef8fa..997af946a6 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -80,8 +80,8 @@ public class IPBridgeHandler extends ADBridgeHandler {\n         try {\n             Socket socket = new Socket(config.hostname, config.tcpPort);\n             this.socket = socket;\n-            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n-            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET));\n             logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n             panelReadyReceived = false;\n             startMsgReader();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5ODk4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414798985", "bodyText": "no need to add debug logging, thing status changes are already logged", "author": "J-N-K", "createdAt": "2020-04-24T19:04:00Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 0bd28ef8fa..997af946a6 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -80,8 +80,8 @@ public class IPBridgeHandler extends ADBridgeHandler {\n         try {\n             Socket socket = new Socket(config.hostname, config.tcpPort);\n             this.socket = socket;\n-            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n-            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET));\n             logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n             panelReadyReceived = false;\n             startMsgReader();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5OTE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414799193", "bodyText": "see above", "author": "J-N-K", "createdAt": "2020-04-24T19:04:22Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", config.hostname, config.tcpPort, e.getMessage());", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\nindex 0bd28ef8fa..997af946a6 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java\n\n@@ -80,8 +80,8 @@ public class IPBridgeHandler extends ADBridgeHandler {\n         try {\n             Socket socket = new Socket(config.hostname, config.tcpPort);\n             this.socket = socket;\n-            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n-            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET));\n             logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n             panelReadyReceived = false;\n             startMsgReader();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwMjUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414802525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);\n          \n          \n            \n                    updateState(CHANNEL_KP_READY, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_READY)));", "author": "J-N-K", "createdAt": "2020-04-24T19:10:34Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.KeypadConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.IntCommandMap;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KeypadHandler} is responsible for handling keypad messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadHandler extends ADThingHandler {\n+\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    private final Logger logger = LoggerFactory.getLogger(KeypadHandler.class);\n+\n+    private KeypadConfig config = new KeypadConfig();\n+    private boolean singleAddress;\n+    private @Nullable IntCommandMap intCommandMap;\n+    private @Nullable KeypadMessage previousMessage;\n+\n+    public KeypadHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(KeypadConfig.class);\n+\n+        if (config.addressMask < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid addressMask setting\");\n+            return;\n+        }\n+        singleAddress = (Integer.bitCount(config.addressMask) == 1);\n+\n+        try {\n+            intCommandMap = new IntCommandMap(config.commandMapping);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Invalid commmandMapping parameter supplied. Error: {}.\", e.getMessage());\n+            intCommandMap = null;\n+        }\n+\n+        logger.debug(\"Keypad handler initializing for address mask {}\", config.addressMask);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"Keypad handler finished initializing\");\n+    }\n+\n+    @Override\n+    public void initChannelState() {\n+        previousMessage = null;\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntCommandMap intCommandMap = this.intCommandMap;\n+\n+        if (channelUID.getId().equals(CHANNEL_KP_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = ((StringType) command).toString();\n+                handleKeypadCommand(cmd);\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_KP_INTCOMMAND)) {\n+            if (command instanceof Number) {\n+                int icmd = ((Number) command).intValue();\n+                if (intCommandMap != null) {\n+                    String cmd = intCommandMap.getCommand(icmd);\n+                    if (cmd != null) {\n+                        handleKeypadCommand(cmd);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleKeypadCommand(String command) {\n+        String cmd = command;\n+        if (cmd.length() > 0) {\n+            if (!config.sendCommands) {\n+                logger.info(\"Sending keypad commands is disabled. Enable using the sendCommands keypad parameter.\");\n+                return;\n+            }\n+\n+            // check that received command is valid\n+            Matcher matcher = VALID_COMMAND_PATTERN.matcher(cmd);\n+            if (!matcher.matches()) {\n+                logger.info(\"Invalid characters in command. Ignoring command: {}\", cmd);\n+                return;\n+            }\n+\n+            // Replace A-H in command string with special key strings\n+            cmd = cmd.replace(\"A\", ADCommand.SPECIAL_KEY_1);\n+            cmd = cmd.replace(\"B\", ADCommand.SPECIAL_KEY_2);\n+            cmd = cmd.replace(\"C\", ADCommand.SPECIAL_KEY_3);\n+            cmd = cmd.replace(\"D\", ADCommand.SPECIAL_KEY_4);\n+            cmd = cmd.replace(\"E\", ADCommand.SPECIAL_KEY_5);\n+            cmd = cmd.replace(\"F\", ADCommand.SPECIAL_KEY_6);\n+            cmd = cmd.replace(\"G\", ADCommand.SPECIAL_KEY_7);\n+            cmd = cmd.replace(\"H\", ADCommand.SPECIAL_KEY_8);\n+\n+            if (singleAddress) {\n+                sendCommand(ADCommand.addressedMessage(config.addressMask, cmd)); // send from keypad address\n+            } else {\n+                sendCommand(new ADCommand(cmd)); // send from AD address\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleUpdate(ADMessage msg) {\n+        // This will ignore a received message unless it is a KeypadMessage and either this handler's address mask is 0\n+        // (all), the message's address mask is 0 (all), or any bits in this handler's address mask match bits set in\n+        // the message's address mask.\n+        if (!(msg instanceof KeypadMessage)) {\n+            return;\n+        }\n+        KeypadMessage kpm = (KeypadMessage) msg;\n+        int addressMask = kpm.getIntAddressMask();\n+        if (!(((config.addressMask & addressMask) != 0) || config.addressMask == 0 || addressMask == 0)) {\n+            return;\n+        }\n+        logger.trace(\"Keypad handler for address mask {} received update: {}\", config.addressMask, kpm);\n+\n+        if (kpm.equals(previousMessage)) {\n+            return; // ignore repeated messages\n+        }\n+\n+        if (config.sendStar) {\n+            if (kpm.alphaMessage.contains(\"Hit * for faults\") || kpm.alphaMessage.contains(\"Press * to show faults\")\n+                    || kpm.alphaMessage.contains(\"Press * Key\")) {\n+                logger.debug(\"Sending * command to show faults.\");\n+                if (singleAddress) {\n+                    sendCommand(ADCommand.addressedMessage(config.addressMask, \"*\")); // send from keypad address\n+                } else {\n+                    sendCommand(new ADCommand(\"*\")); // send from AD address\n+                }\n+            }\n+        }\n+\n+        updateState(CHANNEL_KP_ZONE, new DecimalType(kpm.getZone()));\n+        updateState(CHANNEL_KP_TEXT, new StringType(kpm.alphaMessage));\n+\n+        updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwOTkyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414909927", "bodyText": "Nice. Didn't know about that method.", "author": "bobadair", "createdAt": "2020-04-24T23:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwMjUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "chunk": "diff --git a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java\nindex a26420343d..07b8d0f7c1 100644\n--- a/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java\n+++ b/bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java\n\n@@ -180,25 +180,24 @@ public class KeypadHandler extends ADThingHandler {\n         updateState(CHANNEL_KP_ZONE, new DecimalType(kpm.getZone()));\n         updateState(CHANNEL_KP_TEXT, new StringType(kpm.alphaMessage));\n \n-        updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_ARMEDAWAY, (kpm.getStatus(KeypadMessage.BIT_ARMEDAWAY)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_ARMEDHOME, (kpm.getStatus(KeypadMessage.BIT_ARMEDHOME)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_BACKLIGHT, (kpm.getStatus(KeypadMessage.BIT_BACKLIGHT)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_PRORGAM, (kpm.getStatus(KeypadMessage.BIT_PRORGAM)) ? OnOffType.ON : OnOffType.OFF);\n+        updateState(CHANNEL_KP_READY, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_READY)));\n+        updateState(CHANNEL_KP_ARMEDAWAY, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_ARMEDAWAY)));\n+        updateState(CHANNEL_KP_ARMEDHOME, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_ARMEDHOME)));\n+        updateState(CHANNEL_KP_BACKLIGHT, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_BACKLIGHT)));\n+        updateState(CHANNEL_KP_PRORGAM, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_PRORGAM)));\n \n         updateState(CHANNEL_KP_BEEPS, new DecimalType(kpm.nbeeps));\n \n-        updateState(CHANNEL_KP_BYPASSED, (kpm.getStatus(KeypadMessage.BIT_BYPASSED)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_ACPOWER, (kpm.getStatus(KeypadMessage.BIT_ACPOWER)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_CHIME, (kpm.getStatus(KeypadMessage.BIT_CHIME)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_ALARMOCCURRED,\n-                (kpm.getStatus(KeypadMessage.BIT_ALARMOCCURRED)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_ALARM, (kpm.getStatus(KeypadMessage.BIT_ALARM)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_LOWBAT, (kpm.getStatus(KeypadMessage.BIT_LOWBAT)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_DELAYOFF, (kpm.getStatus(KeypadMessage.BIT_DELAYOFF)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_FIRE, (kpm.getStatus(KeypadMessage.BIT_FIRE)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_SYSFAULT, (kpm.getStatus(KeypadMessage.BIT_SYSFAULT)) ? OnOffType.ON : OnOffType.OFF);\n-        updateState(CHANNEL_KP_PERIMETER, (kpm.getStatus(KeypadMessage.BIT_PERIMETER)) ? OnOffType.ON : OnOffType.OFF);\n+        updateState(CHANNEL_KP_BYPASSED, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_BYPASSED)));\n+        updateState(CHANNEL_KP_ACPOWER, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_ACPOWER)));\n+        updateState(CHANNEL_KP_CHIME, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_CHIME)));\n+        updateState(CHANNEL_KP_ALARMOCCURRED, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_ALARMOCCURRED)));\n+        updateState(CHANNEL_KP_ALARM, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_ALARM)));\n+        updateState(CHANNEL_KP_LOWBAT, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_LOWBAT)));\n+        updateState(CHANNEL_KP_DELAYOFF, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_DELAYOFF)));\n+        updateState(CHANNEL_KP_FIRE, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_FIRE)));\n+        updateState(CHANNEL_KP_SYSFAULT, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_SYSFAULT)));\n+        updateState(CHANNEL_KP_PERIMETER, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_PERIMETER)));\n \n         previousMessage = kpm;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMTUxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414811515", "bodyText": "After reading the code below, this seems to be an invalid value. Leave it out if that is correct", "author": "J-N-K", "createdAt": "2020-04-24T19:27:28Z", "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/RFZoneConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link RFZoneConfig} class contains fields mapping thing configuration parameters for RFZoneHandler.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFZoneConfig {\n+    public int serial = -1;", "originalCommit": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMDQ5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414920491", "bodyText": "Yes, I think that is a recent change. I initialize it to an invalid value (0 is potentially a valid value) rather than using a @nullable Integer to determine if it was not set by the user. As a general rule, anything weird like this in the code was done to get rid of  null annotation warnings. I think here it isn't strictly necessary because that parameter should be marked as required, but it still seemed like a good idea to have the code enforce it.", "author": "bobadair", "createdAt": "2020-04-24T23:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMTUxNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "url": "https://github.com/openhab/openhab-addons/commit/96149fa6df32bfe52e14a63a7170e25596d7b9ca", "message": "[alarmecoder] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-24T23:51:50Z", "type": "commit"}, {"oid": "09de463dbcb35337177de90b967e8f4727c840ca", "url": "https://github.com/openhab/openhab-addons/commit/09de463dbcb35337177de90b967e8f4727c840ca", "message": "[alarmecoder] And a couple more\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-25T00:57:25Z", "type": "commit"}, {"oid": "1f30d0ba54af3e2013d2e179035187e840e5be72", "url": "https://github.com/openhab/openhab-addons/commit/1f30d0ba54af3e2013d2e179035187e840e5be72", "message": "[alarmecoder] Address more comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-26T00:09:51Z", "type": "commit"}, {"oid": "448031fecb6a720084a72c9f375ecac0fa1d615e", "url": "https://github.com/openhab/openhab-addons/commit/448031fecb6a720084a72c9f375ecac0fa1d615e", "message": "[alarmecoder] Address two comments I had missed\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-27T17:19:02Z", "type": "commit"}, {"oid": "490f62138745e3d9411b2f34a18d90ed64ecae47", "url": "https://github.com/openhab/openhab-addons/commit/490f62138745e3d9411b2f34a18d90ed64ecae47", "message": "[alarmecoder] README file updates\n\nSigned-off-by: Bob Adair <bob.github@att.net>", "committedDate": "2020-04-29T01:56:59Z", "type": "commit"}]}