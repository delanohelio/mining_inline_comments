{"pr_number": 7870, "pr_title": "[mpd]: Music Player Daemon initial contribution", "pr_createdAt": "2020-06-07T09:14:41Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7870", "timeline": [{"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "url": "https://github.com/openhab/openhab-addons/commit/7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "message": "[mpd]: reduce number of requests at startup\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-07-04T17:13:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTg2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451801861", "bodyText": "Are you aware of this bug openhab/openhab-core#1265?\nIf you want, you could add a workaround like this:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "author": "fwolter", "createdAt": "2020-07-08T20:19:10Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mpd.internal.handler.MPDHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link @MPDActions} defines rule actions for the Music Player Daemon binding. *\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@ThingActionsScope(name = \"mpd\")\n+@NonNullByDefault\n+public class MPDActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDActions.class);\n+\n+    private @Nullable MPDHandler handler = null;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof MPDHandler) {\n+            this.handler = (MPDHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command,\n+            @ActionInput(name = \"parameter\") @Nullable String parameter) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        if (handler != null) {\n+            handler.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        if (handler != null) {\n+            handler.sendCommand(command);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    public static void sendCommand(@Nullable ThingActions actions, @Nullable String command,", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003148", "bodyText": "I faced this bug during development - I have implemented the workaround and would appreciate if you could have a look.", "author": "stefanroellin", "createdAt": "2020-07-10T18:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java\nindex fbdf154ba2..181652bad0 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java\n\n@@ -12,6 +12,9 @@\n  */\n package org.openhab.binding.mpd.internal.action;\n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.thing.binding.ThingActions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzU0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451803547", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (uid == null || host == null || \"\".equals(host)) {\n          \n          \n            \n                    if (uid == null || host == null || host.isEmpty()) {", "author": "fwolter", "createdAt": "2020-07-08T20:22:29Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || \"\".equals(host)) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003195", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzU0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\nindex cd076dd13e..46ed92b361 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\n\n@@ -63,18 +63,21 @@ public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n \n         logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n \n-        if (uid == null || host == null || \"\".equals(host)) {\n+        if (uid == null || host == null || host.isEmpty()) {\n             return null;\n         }\n \n+        String uniquePropVal = String.format(\"%s-%d\", host, port);\n+\n         final Map<String, Object> properties = new HashMap<>(2);\n         properties.put(MPDBindingConstants.PARAMETER_IPADDRESS, host);\n         properties.put(MPDBindingConstants.PARAMETER_PORT, port);\n+        properties.put(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n \n         String name = service.getName();\n \n-        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(name)\n-                .build();\n+        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withLabel(name).withProperties(properties)\n+                .withRepresentationProperty(MPDBindingConstants.UNIQUE_ID).build();\n         return result;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451803777", "bodyText": "Can you add a representation property?", "author": "fwolter", "createdAt": "2020-07-08T20:22:51Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || \"\".equals(host)) {\n+            return null;\n+        }\n+\n+        final Map<String, Object> properties = new HashMap<>(2);\n+        properties.put(MPDBindingConstants.PARAMETER_IPADDRESS, host);\n+        properties.put(MPDBindingConstants.PARAMETER_PORT, port);\n+\n+        String name = service.getName();\n+\n+        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(name)\n+                .build();", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzM1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003354", "bodyText": "Did not know of the representation property. I have added it.", "author": "stefanroellin", "createdAt": "2020-07-10T18:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\nindex cd076dd13e..46ed92b361 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\n\n@@ -63,18 +63,21 @@ public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n \n         logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n \n-        if (uid == null || host == null || \"\".equals(host)) {\n+        if (uid == null || host == null || host.isEmpty()) {\n             return null;\n         }\n \n+        String uniquePropVal = String.format(\"%s-%d\", host, port);\n+\n         final Map<String, Object> properties = new HashMap<>(2);\n         properties.put(MPDBindingConstants.PARAMETER_IPADDRESS, host);\n         properties.put(MPDBindingConstants.PARAMETER_PORT, port);\n+        properties.put(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n \n         String name = service.getName();\n \n-        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(name)\n-                .build();\n+        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withLabel(name).withProperties(properties)\n+                .withRepresentationProperty(MPDBindingConstants.UNIQUE_ID).build();\n         return result;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTMxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451805319", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently). You might want to move it to the end of this method.", "author": "fwolter", "createdAt": "2020-07-08T20:25:52Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003957", "bodyText": "In theory, the thread could update the status before updateStatus from the main thread is called. Therefore I would prefer to leave it before the start of the thread.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTMxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\nindex 09cf09834b..605e4f6e80 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n\n@@ -18,8 +18,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTYxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451805614", "bodyText": "No harm in cancelling a task that is already cancelled. Same for below.", "author": "fwolter", "createdAt": "2020-07-08T20:26:25Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null && !future.isCancelled()) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMzk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453003996", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\nindex 09cf09834b..605e4f6e80 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n\n@@ -18,8 +18,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNjM2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451806366", "bodyText": "Syntactical sugar. Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.futureUpdateCurrentSong = scheduler.schedule(() -> doUpdateCurrentSong(), 100, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        this.futureUpdateStatus = scheduler.schedule(this::doUpdateStatus, 100, TimeUnit.MILLISECONDS);", "author": "fwolter", "createdAt": "2020-07-08T20:27:56Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateStatus = scheduler.schedule(() -> doUpdateStatus(), 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateStatus() {\n+        connection.updateStatus();\n+    }\n+\n+    private synchronized void scheduleUpdateCurrentSong() {\n+        logger.debug(\"scheduleUpdateCurrentSong\");\n+        ScheduledFuture<?> future = this.futureUpdateCurrentSong;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateCurrentSong = scheduler.schedule(() -> doUpdateCurrentSong(), 100, TimeUnit.MILLISECONDS);", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453004070", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNjM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\nindex 09cf09834b..605e4f6e80 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n\n@@ -18,8 +18,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwOTU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451809540", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)", "author": "fwolter", "createdAt": "2020-07-08T20:34:22Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNDExOA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453004118", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-07-10T18:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwOTU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 794d1d1e32..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -119,7 +119,7 @@ public class MPDConnectionThread extends Thread {\n     }\n \n     private void insertCommand(MPDCommand command, int position) {\n-        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        logger.trace(\"insert command '{}' at position {}\", command.getCommand(), position);\n         int index = position;\n         synchronized (pendingCommands) {\n             if (index < 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMTYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451811637", "bodyText": "Thing.dispose() should return fast. Can't you just close the socket?", "author": "fwolter", "createdAt": "2020-07-08T20:38:38Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNDY2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453004664", "bodyText": "You are right. I have tried before with closeSocket(), but that did not work, since it blocked somewhere. Now, the socket is closed.", "author": "stefanroellin", "createdAt": "2020-07-10T18:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMTYzNw=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 794d1d1e32..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -119,7 +119,7 @@ public class MPDConnectionThread extends Thread {\n     }\n \n     private void insertCommand(MPDCommand command, int position) {\n-        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        logger.trace(\"insert command '{}' at position {}\", command.getCommand(), position);\n         int index = position;\n         synchronized (pendingCommands) {\n             if (index < 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMjc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451812740", "bodyText": "Do you ignore the exception by intention? Is it worth to log it?", "author": "fwolter", "createdAt": "2020-07-08T20:40:52Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));\n+            sendNoIdleIfInIdle();\n+            interrupt();\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNTAwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453005008", "bodyText": "I have added a log, since it might fail.", "author": "stefanroellin", "createdAt": "2020-07-10T18:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMjc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 794d1d1e32..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -119,7 +119,7 @@ public class MPDConnectionThread extends Thread {\n     }\n \n     private void insertCommand(MPDCommand command, int position) {\n-        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        logger.trace(\"insert command '{}' at position {}\", command.getCommand(), position);\n         int index = position;\n         synchronized (pendingCommands) {\n             if (index < 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451814387", "bodyText": "If I see correctly, you need to store InputStreamReader to close it, too.", "author": "fwolter", "createdAt": "2020-07-08T20:44:10Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));\n+            sendNoIdleIfInIdle();\n+            interrupt();\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", this.address, this.port);\n+        Socket socket = new Socket(this.address, this.port);\n+\n+        reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNTcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453005725", "bodyText": "From the documentation it is not clear, whether the InputStreamReader is automatically closed by the BufferedReader. Looking at the code, it is closed. Since it does not harm, I have added it.", "author": "stefanroellin", "createdAt": "2020-07-10T18:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNDM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 794d1d1e32..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -119,7 +119,7 @@ public class MPDConnectionThread extends Thread {\n     }\n \n     private void insertCommand(MPDCommand command, int position) {\n-        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        logger.trace(\"insert command '{}' at position {}\", command.getCommand(), position);\n         int index = position;\n         synchronized (pendingCommands) {\n             if (index < 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNTkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451815931", "bodyText": "Is this expected to fail? Otherwise, you could log it.", "author": "fwolter", "createdAt": "2020-07-08T20:47:20Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for representing a song.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDSong {\n+    private final String filename;\n+    private final String album;\n+    private final String artist;\n+    private final String name;\n+    private final int song;\n+    private final int songId;\n+    private final String title;\n+    private final int track;\n+\n+    public MPDSong(MPDResponse response) {\n+        Map<String, String> values = MPDResponseParser.responseToMap(response);\n+        filename = values.getOrDefault(\"file\", \"\");\n+        album = values.getOrDefault(\"Album\", \"\");\n+        artist = values.getOrDefault(\"Artist\", \"\");\n+        name = values.getOrDefault(\"Name\", \"\");\n+        song = parseInteger(values.getOrDefault(\"Pos\", \"0\"), 0);\n+        songId = parseInteger(values.getOrDefault(\"Id\", \"0\"), 0);\n+        title = values.getOrDefault(\"Title\", \"\");\n+        track = parseInteger(values.getOrDefault(\"Track\", \"-1\"), -1);\n+    }\n+\n+    public String getFilename() {\n+        return filename;\n+    }\n+\n+    public String getAlbum() {\n+        return album;\n+    }\n+\n+    public String getArtist() {\n+        return artist;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getSong() {\n+        return song;\n+    }\n+\n+    public int getSongId() {\n+        return songId;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public int getTrack() {\n+        return track;\n+    }\n+\n+    private int parseInteger(String value, int aDefault) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453005975", "bodyText": "It should not fail, but I have added a log anyway.", "author": "stefanroellin", "createdAt": "2020-07-10T18:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNTkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java\nindex 71ba5e0ca5..c9453ba257 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java\n\n@@ -15,6 +15,8 @@ package org.openhab.binding.mpd.internal.protocol;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Class for representing a song.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNjUzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451816534", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-07-08T20:48:34Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for representing the status of a Music Player Daemon.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDStatus {\n+\n+    public enum State {\n+        PLAY,\n+        PAUSE,\n+        STOP\n+    }\n+\n+    private final State state;\n+    private final int volume;\n+\n+    public MPDStatus(MPDResponse response) {\n+        Map<String, String> values = MPDResponseParser.responseToMap(response);\n+        state = parseState(values.getOrDefault(\"state\", \"\"));\n+        volume = parseVolume(values.getOrDefault(\"volume\", \"0\"));\n+    }\n+\n+    public State getState() {\n+        return state;\n+    }\n+\n+    public int getVolume() {\n+        return volume;\n+    }\n+\n+    private State parseState(String value) {\n+        switch (value) {\n+            case \"play\":\n+                return State.PLAY;\n+            case \"pause\":\n+                return State.PAUSE;\n+            case \"stop\":\n+                return State.STOP;\n+        }\n+\n+        return State.STOP;\n+    }\n+\n+    private int parseVolume(String value) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {", "originalCommit": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNjAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r453006021", "bodyText": "It should not fail, but I have added a log anyway.", "author": "stefanroellin", "createdAt": "2020-07-10T18:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNjUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java\nindex 869778ef77..f014e1904c 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java\n\n@@ -15,6 +15,8 @@ package org.openhab.binding.mpd.internal.protocol;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Class for representing the status of a Music Player Daemon.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768325", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new IllegalArgumentException(\"Actions is not an instance of EcobeeActions\");\n          \n          \n            \n                    throw new IllegalArgumentException(\"Actions is not an instance of MPDActions\");", "author": "fwolter", "createdAt": "2020-07-18T08:57:44Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.action;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mpd.internal.handler.MPDHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link @MPDActions} defines rule actions for the Music Player Daemon binding. *\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@ThingActionsScope(name = \"mpd\")\n+@NonNullByDefault\n+public class MPDActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDActions.class);\n+\n+    private @Nullable MPDHandler handler = null;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof MPDHandler) {\n+            this.handler = (MPDHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command,\n+            @ActionInput(name = \"parameter\") @Nullable String parameter) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        MPDHandler handler = this.handler;\n+        if (handler != null) {\n+            handler.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        MPDHandler handler = this.handler;\n+        if (handler != null) {\n+            handler.sendCommand(command);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    private static MPDActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(MPDActions.class.getName())) {\n+            if (actions instanceof MPDActions) {\n+                return (MPDActions) actions;\n+            } else {\n+                return (MPDActions) Proxy.newProxyInstance(MPDActions.class.getClassLoader(),\n+                        new Class[] { MPDActions.class }, (Object proxy, Method method, Object[] args) -> {\n+                            Method m = actions.getClass().getDeclaredMethod(method.getName(),\n+                                    method.getParameterTypes());\n+                            return m.invoke(actions, args);\n+                        });\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Actions is not an instance of EcobeeActions\");", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwNjIxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456806217", "bodyText": "Copy-Paste error. I also realized that my fix for bug openhab/openhab-core#1265 was not correct, which I have fixed now.", "author": "stefanroellin", "createdAt": "2020-07-18T16:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java\nindex 181652bad0..fbdf154ba2 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java\n\n@@ -12,9 +12,6 @@\n  */\n package org.openhab.binding.mpd.internal.action;\n \n-import java.lang.reflect.Method;\n-import java.lang.reflect.Proxy;\n-\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.thing.binding.ThingActions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(2);\n          \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(3);", "author": "fwolter", "createdAt": "2020-07-18T08:58:29Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || host.isEmpty()) {\n+            return null;\n+        }\n+\n+        String uniquePropVal = String.format(\"%s-%d\", host, port);\n+\n+        final Map<String, Object> properties = new HashMap<>(2);", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\nindex 46ed92b361..cd076dd13e 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java\n\n@@ -63,21 +63,18 @@ public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n \n         logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n \n-        if (uid == null || host == null || host.isEmpty()) {\n+        if (uid == null || host == null || \"\".equals(host)) {\n             return null;\n         }\n \n-        String uniquePropVal = String.format(\"%s-%d\", host, port);\n-\n         final Map<String, Object> properties = new HashMap<>(2);\n         properties.put(MPDBindingConstants.PARAMETER_IPADDRESS, host);\n         properties.put(MPDBindingConstants.PARAMETER_PORT, port);\n-        properties.put(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n \n         String name = service.getName();\n \n-        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withLabel(name).withProperties(properties)\n-                .withRepresentationProperty(MPDBindingConstants.UNIQUE_ID).build();\n+        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(name)\n+                .build();\n         return result;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODg0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768842", "bodyText": "You might want to add the timeout parameter to join() in case the thread blocks for some reason.", "author": "fwolter", "createdAt": "2020-07-18T09:03:27Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public MPDConnection(MPDEventListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * start the connection\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public void start(String address, Integer port, String password) {\n+        if (connectionThread == null) {\n+            connectionThread = new MPDConnectionThread(this, address, port, password);\n+            connectionThread.start();\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        final MPDConnectionThread connectionThread = this.connectionThread;\n+        if (connectionThread != null) {\n+            connectionThread.dispose();\n+            connectionThread.interrupt();\n+            try {\n+                connectionThread.join();", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\nindex fc614838cb..b7a1eb1906 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\n\n@@ -65,7 +65,6 @@ public class MPDConnection implements MPDResponseListener {\n         final MPDConnectionThread connectionThread = this.connectionThread;\n         if (connectionThread != null) {\n             connectionThread.dispose();\n-            connectionThread.interrupt();\n             try {\n                 connectionThread.join();\n             } catch (InterruptedException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768928", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2020-07-18T09:04:31Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex aa73e56f9d..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -49,7 +49,6 @@ public class MPDConnectionThread extends Thread {\n     private final String password;\n \n     private @Nullable Socket socket = null;\n-    private @Nullable InputStreamReader inputStreamReader = null;\n     private @Nullable BufferedReader reader = null;\n     private @Nullable DataOutputStream writer = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456769129", "bodyText": "Named threads make debugging easier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n          \n          \n            \n                public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n          \n          \n            \n                    super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);", "author": "fwolter", "createdAt": "2020-07-18T09:06:56Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex aa73e56f9d..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -49,7 +49,6 @@ public class MPDConnectionThread extends Thread {\n     private final String password;\n \n     private @Nullable Socket socket = null;\n-    private @Nullable InputStreamReader inputStreamReader = null;\n     private @Nullable BufferedReader reader = null;\n     private @Nullable DataOutputStream writer = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456769224", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } catch (IOException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            } catch (MPDException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n          \n          \n            \n                            }\n          \n          \n            \n                            } catch (IOException | MPDException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            }", "author": "fwolter", "createdAt": "2020-07-18T09:08:04Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }", "originalCommit": "62425d3d7e497b6ecd049214055b9613dd5db5cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwNDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456804566", "bodyText": "The first exception will update the thing status to ThingStatusDetail.COMMUNICATION_ERROR, whereas the second updates it to ThingStatusDetail.CONFIGURATION_ERROR\nTherefore, I would prefer not to combine those exceptions. Do you agree?", "author": "stefanroellin", "createdAt": "2020-07-18T16:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg3NDA0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456874046", "bodyText": "Sorry, I missed the fine difference.", "author": "fwolter", "createdAt": "2020-07-19T07:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex aa73e56f9d..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -49,7 +49,6 @@ public class MPDConnectionThread extends Thread {\n     private final String password;\n \n     private @Nullable Socket socket = null;\n-    private @Nullable InputStreamReader inputStreamReader = null;\n     private @Nullable BufferedReader reader = null;\n     private @Nullable DataOutputStream writer = null;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNTUwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469115505", "bodyText": "nice!", "author": "martinvw", "createdAt": "2020-08-12T09:06:07Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        String uniquePropVal = String.format(\"%s-%d\", config.getIpAddress(), config.getPort());\n+        updateProperty(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\nindex 2830fe739a..605e4f6e80 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n\n@@ -18,8 +18,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNjUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469116530", "bodyText": "Remark: This method-name could be slightly confusing because this class also has updateStatus which updates the thing status.", "author": "martinvw", "createdAt": "2020-08-12T09:07:54Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        String uniquePropVal = String.format(\"%s-%d\", config.getIpAddress(), config.getPort());\n+        updateProperty(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateStatus = scheduler.schedule(this::doUpdateStatus, 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateStatus() {\n+        connection.updateStatus();\n+    }\n+\n+    private synchronized void scheduleUpdateCurrentSong() {\n+        logger.debug(\"scheduleUpdateCurrentSong\");\n+        ScheduledFuture<?> future = this.futureUpdateCurrentSong;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateCurrentSong = scheduler.schedule(this::doUpdateCurrentSong, 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateCurrentSong() {\n+        connection.updateCurrentSong();\n+    }\n+\n+    private void handlePlayerCommand(String channelId, Command command) {\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+                handleCommandControl(command);\n+                break;\n+            case CHANNEL_STOP:\n+                handleCommandStop(command);\n+                break;\n+            case CHANNEL_VOLUME:\n+                handleCommandVolume(command);\n+                break;\n+        }\n+    }\n+\n+    private void handleCommandControl(Command command) {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connection.play();\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connection.pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connection.playNext();\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connection.playPrevious();\n+            }\n+        } else {\n+            // Rewind and Fast Forward are currently not implemented by the binding\n+            logger.debug(\"Control command {} is not supported\", command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (command instanceof OnOffType) {\n+            if (command == OnOffType.ON) {\n+                connection.stop();\n+            } else if (command == OnOffType.OFF) {\n+                connection.play();\n+            }\n+        } else {\n+            logger.debug(\"Stop Command {} is not supported\", command);\n+            return;\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command) {\n+        int newValue = 0;\n+        if (command instanceof IncreaseDecreaseType) {\n+            if (command == IncreaseDecreaseType.INCREASE) {\n+                newValue = Math.min(100, volume + 1);\n+            } else if (command == IncreaseDecreaseType.DECREASE) {\n+                newValue = Math.max(0, volume - 1);\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (command == OnOffType.ON) {\n+                newValue = 100;\n+            } else if (command == OnOffType.OFF) {\n+                newValue = 0;\n+            }\n+        } else if (command instanceof DecimalType) {\n+            newValue = ((DecimalType) command).intValue();\n+        } else if (command instanceof PercentType) {\n+            newValue = ((PercentType) command).intValue();\n+        } else {\n+            logger.debug(\"Command {} is not supported to change volume\", command);\n+            return;\n+        }\n+\n+        connection.setVolume(newValue);\n+    }\n+\n+    private void updateChannel(String channelID, State state) {\n+        State previousState = stateMap.put(channelID, state);\n+        if (previousState == null || !previousState.equals(state)) {\n+            updateState(channelID, state);\n+        }\n+    }\n+\n+    @Override\n+    public void updateStatus(MPDStatus status) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzOTY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473239649", "bodyText": "I have renamed it to updateMPDStatus, as well as updateSong to updateMPDSong.", "author": "stefanroellin", "createdAt": "2020-08-19T18:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNjUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\nindex 2830fe739a..605e4f6e80 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java\n\n@@ -18,8 +18,6 @@ import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNzYzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469117636", "bodyText": "You could consider renaming e to ignore this makes the ignoring of the exception explicit and documented.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                    } catch (InterruptedException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:09:43Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExODIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469118205", "bodyText": "Both fields could be final, it makes it more explicit that this class is immutable and helps to guard that in the future.", "author": "martinvw", "createdAt": "2020-08-12T09:10:42Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for encapsulating an MPD command\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class MPDCommand {\n+\n+    private String command;", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f90431733dca95340b791a4cf6c893d24bee9e91", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java\nindex d148601ab1..1434f72a48 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java\n\n@@ -28,8 +28,8 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n @NonNullByDefault\n public class MPDCommand {\n \n-    private String command;\n-    private List<String> parameters = new ArrayList<>();\n+    private final String command;\n+    private final List<String> parameters = new ArrayList<>();\n \n     /**\n      * Create an MPD command without parameters\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExOTAwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469119001", "bodyText": "Consider marking this field final", "author": "martinvw", "createdAt": "2020-08-12T09:12:07Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private static final int DISPOSE_TIMEOUT_MS = 1000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\nindex 46395018e7..b7a1eb1906 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\n\n@@ -28,8 +28,6 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnection implements MPDResponseListener {\n \n-    private static final int DISPOSE_TIMEOUT_MS = 1000;\n-\n     private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n \n     private @Nullable MPDConnectionThread connectionThread = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExOTQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469119420", "bodyText": "Consider renaming to ignore\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                        } catch (InterruptedException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:12:48Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private static final int DISPOSE_TIMEOUT_MS = 1000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public MPDConnection(MPDEventListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * start the connection\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public void start(String address, Integer port, String password) {\n+        if (connectionThread == null) {\n+            connectionThread = new MPDConnectionThread(this, address, port, password);\n+            connectionThread.start();\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        final MPDConnectionThread connectionThread = this.connectionThread;\n+        if (connectionThread != null) {\n+            connectionThread.dispose();\n+            connectionThread.interrupt();\n+            try {\n+                connectionThread.join(DISPOSE_TIMEOUT_MS);\n+            } catch (InterruptedException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\nindex 46395018e7..b7a1eb1906 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java\n\n@@ -28,8 +28,6 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnection implements MPDResponseListener {\n \n-    private static final int DISPOSE_TIMEOUT_MS = 1000;\n-\n     private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n \n     private @Nullable MPDConnectionThread connectionThread = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyMTAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469121027", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:15:25Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469125129", "bodyText": "It does not seem completely guaranteed to me that this is a configuration error, this could maybe just be a communication problem (daemon/host not running) however it is reported to the end-user as a configuration error with text \"could not connect\". Throwing it as an IOException could fix that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MPDException(\"could not connect\");\n          \n          \n            \n                        throw new IOException (\"Failed to connect to \" + this.address \":\" + this.port);", "author": "martinvw", "createdAt": "2020-08-12T09:22:25Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0MDQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473240477", "bodyText": "If the daemon or the host is not running, there is an IOException, when the socket is opened. Therefore I have left the MPDException, but I have changed the text.", "author": "stefanroellin", "createdAt": "2020-08-19T18:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNjExNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473936114", "bodyText": "\ud83d\udc4d", "author": "martinvw", "createdAt": "2020-08-20T12:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNzc2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469127769", "bodyText": "@Hilbrand recently suggested a more uniform naming of Threads, could you update the Thread-name, I'm really sorry that it conflicts a bit with @fwolter earlier comment:\n#8216", "author": "martinvw", "createdAt": "2020-08-12T09:26:51Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyODUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469128533", "bodyText": "Would it make sense to check to basic sanity of the configuration parameters before connecting? A malformed/empty host address or port is of course a configuration error.", "author": "martinvw", "createdAt": "2020-08-12T09:28:10Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0MDYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473240610", "bodyText": "Done.", "author": "stefanroellin", "createdAt": "2020-08-19T18:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyODUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyOTU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469129569", "bodyText": "This message is displayed to the end-user consider making it more user friendly for example by suggesting to validate the password.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new MPDException(\"could not authenticate\");\n          \n          \n            \n                            throw new MPDException(\"Could not authenticate, please validate your password\");", "author": "martinvw", "createdAt": "2020-08-12T09:29:55Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyOTc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469129774", "bodyText": "Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false. source: PMD", "author": "martinvw", "createdAt": "2020-08-12T09:30:15Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:30:39Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "author": "martinvw", "createdAt": "2020-08-12T09:30:51Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130784", "bodyText": "Do you really need to close all of them? Will closing some of them not take a long the rest. E.g closing both the reader and inputStreamReader is AFAIK not needed.\nA quick peak in the javadoc suggested that closing the socket will do all the work at one.", "author": "martinvw", "createdAt": "2020-08-12T09:32:01Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0NTcwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473245703", "bodyText": "I have realized that the writer (DataOutputStream) is not necessary, since one can use socket.getOutputStream() directly.\n@fwolter has suggested in #7870 (comment) to also close the InputStreamReader, which is in contrast to your suggestion. From the mentioned javadoc it is clear that the InputStream and the OutputStream will also be closed, when the socket is closed. I do not close these streams explicitly.\nHowever, I would at least close the BufferedReader. But it does not harm, if I also close the InputStreamReader. I prefer to close too much than too little. wdyt?", "author": "stefanroellin", "createdAt": "2020-08-19T18:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNzkwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473937904", "bodyText": "I'm okay with keeping it like this. But there is a reason they mention it. Sometimes closing twice could lead to errors/exceptions and when not explicitly documented I would rather not.", "author": "martinvw", "createdAt": "2020-08-20T12:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469132473", "bodyText": "asLine is now always performed consider depending on toString instead then the logging framework will only call to toString when the content is actually being logged. If you cannot you might consider wrapping it in logger.isTraceEnabled()", "author": "martinvw", "createdAt": "2020-08-12T09:34:46Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469132973", "bodyText": "This ends up in the UI if I read correctly what can the user do about this? Did it lose the connection. Please update the message.", "author": "martinvw", "createdAt": "2020-08-12T09:35:35Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());\n+        final DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            String line = command.asLine();\n+            byte[] bytes = line.getBytes(StandardCharsets.UTF_8);\n+            writer.write(bytes);\n+            writer.write('\\n');\n+        } else {\n+            throw new IOException(\"writer is null\");", "originalCommit": "3a26da84dba97d76a21a16002675f7c5bd5656df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469134457", "bodyText": "Please validate other messages when. might end up in the UI because of the behaviour at https://github.com/openhab/openhab-addons/pull/7870/files#diff-eac6da5ab58546ad9466910baded0b5fR86", "author": "martinvw", "createdAt": "2020-08-12T09:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 562a49ff68..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -38,7 +38,7 @@ import org.slf4j.LoggerFactory;\n @NonNullByDefault\n public class MPDConnectionThread extends Thread {\n \n-    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n \n     private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473939226", "bodyText": "Very minor:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MPDException(\"Invalid parameter port\");\n          \n          \n            \n                        throw new MPDException(\"Invalid port parameter\");\n          \n      \n    \n    \n  \n\nOtherwise, it might suggest that the parameter port is invalid and should not be supplied.", "author": "martinvw", "createdAt": "2020-08-20T12:41:28Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -147,38 +146,45 @@ private void sendNoIdleIfInIdle() {\n             try {\n                 sendCommand(new MPDCommand(\"noidle\"));\n             } catch (IOException e) {\n-                logger.debug(\"sendCommand(noidle) failed\");\n+                logger.debug(\"sendCommand(noidle) failed\", e);\n             }\n         }\n     }\n \n-    private void establishConnection() throws IOException, MPDException {\n+    private void establishConnection() throws UnknownHostException, IOException, MPDException {\n         openSocket();\n \n         MPDCommand currentCommand = new MPDCommand(\"connect\");\n         MPDResponse response = readResponse(currentCommand);\n \n         if (!response.isOk()) {\n-            throw new MPDException(\"could not connect\");\n+            throw new MPDException(\"Failed to connect to \" + this.address + \":\" + this.port);\n         }\n \n         if (!password.isEmpty()) {\n             currentCommand = new MPDCommand(\"password\", password);\n             sendCommand(currentCommand);\n             response = readResponse(currentCommand);\n             if (!response.isOk()) {\n-                throw new MPDException(\"could not authenticate\");\n+                throw new MPDException(\"Could not authenticate, please validate your password\");\n             }\n         }\n     }\n \n-    private void openSocket() throws IOException {\n+    private void openSocket() throws UnknownHostException, IOException, MPDException {\n         logger.debug(\"opening connection to {} port {}\", address, port);\n+\n+        if (address.isEmpty()) {\n+            throw new MPDException(\"Missing parameter ipAddress\");\n+        }\n+        if (port < 1 || port > 65335) {\n+            throw new MPDException(\"Invalid parameter port\");", "originalCommit": "7963e82e0e0ee8511713e62eb5783450349eb090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MTQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473941472", "bodyText": "@stefanroellin please let me know if you want to fix this tiny comment otherwise I'm fine merging as is, thanks for your work!", "author": "martinvw", "createdAt": "2020-08-20T12:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NTE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r474195175", "bodyText": "I will push a fix for it.", "author": "stefanroellin", "createdAt": "2020-08-20T18:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 3d403d6f20..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -146,19 +141,18 @@ public class MPDConnectionThread extends Thread {\n             try {\n                 sendCommand(new MPDCommand(\"noidle\"));\n             } catch (IOException e) {\n-                logger.debug(\"sendCommand(noidle) failed\", e);\n             }\n         }\n     }\n \n-    private void establishConnection() throws UnknownHostException, IOException, MPDException {\n+    private void establishConnection() throws IOException, MPDException {\n         openSocket();\n \n         MPDCommand currentCommand = new MPDCommand(\"connect\");\n         MPDResponse response = readResponse(currentCommand);\n \n         if (!response.isOk()) {\n-            throw new MPDException(\"Failed to connect to \" + this.address + \":\" + this.port);\n+            throw new MPDException(\"could not connect\");\n         }\n \n         if (!password.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473940244", "bodyText": "It might make sense to fetch the socket.getOutputStream() here so that you don't have to fetch it twice or was there a specific reason to do it like this?", "author": "martinvw", "createdAt": "2020-08-20T12:43:21Z", "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -223,40 +229,32 @@ private void closeSocket() {\n         if (inputStreamReader != null) {\n             try {\n                 inputStreamReader.close();\n-            } catch (IOException e) {\n+            } catch (IOException ignore) {\n             }\n             this.inputStreamReader = null;\n         }\n \n-        DataOutputStream writer = this.writer;\n-        if (writer != null) {\n-            try {\n-                writer.close();\n-            } catch (IOException e) {\n-            }\n-            this.writer = null;\n-        }\n-\n         Socket socket = this.socket;\n         if (socket != null) {\n             try {\n                 socket.close();\n-            } catch (IOException e) {\n+            } catch (IOException ignore) {\n             }\n             this.socket = null;\n         }\n     }\n \n     private void sendCommand(MPDCommand command) throws IOException {\n-        logger.trace(\"send command '{}'\", command.asLine());\n-        final DataOutputStream writer = this.writer;\n-        if (writer != null) {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"send command '{}'\", command.asLine());\n+        }\n+        final Socket socket = this.socket;", "originalCommit": "7963e82e0e0ee8511713e62eb5783450349eb090", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473940831", "bodyText": "Or maybe socket can be nulled out and socket. getOutputStream not, sensible enough :-)", "author": "martinvw", "createdAt": "2020-08-20T12:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r474234978", "bodyText": "I thought of using a local variable for getOutputStream(), but I find the current code is easier to read and circumvents the problem you describe.", "author": "stefanroellin", "createdAt": "2020-08-20T19:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "chunk": "diff --git a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\nindex 3d403d6f20..5071d7ce00 100644\n--- a/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n+++ b/bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java\n\n@@ -220,41 +206,42 @@ public class MPDConnectionThread extends Thread {\n         if (reader != null) {\n             try {\n                 reader.close();\n-            } catch (IOException ignore) {\n+            } catch (IOException e) {\n             }\n             this.reader = null;\n         }\n \n-        InputStreamReader inputStreamReader = this.inputStreamReader;\n-        if (inputStreamReader != null) {\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n             try {\n-                inputStreamReader.close();\n-            } catch (IOException ignore) {\n+                writer.close();\n+            } catch (IOException e) {\n             }\n-            this.inputStreamReader = null;\n+            this.writer = null;\n         }\n \n         Socket socket = this.socket;\n         if (socket != null) {\n             try {\n                 socket.close();\n-            } catch (IOException ignore) {\n+            } catch (IOException e) {\n             }\n             this.socket = null;\n+            this.reader = null;\n+            this.writer = null;\n         }\n     }\n \n     private void sendCommand(MPDCommand command) throws IOException {\n-        if (logger.isTraceEnabled()) {\n-            logger.trace(\"send command '{}'\", command.asLine());\n-        }\n-        final Socket socket = this.socket;\n-        if (socket != null) {\n+        logger.trace(\"send command '{}'\", command.asLine());\n+        final DataOutputStream writer = this.writer;\n+        if (writer != null) {\n             String line = command.asLine();\n-            socket.getOutputStream().write(line.getBytes(StandardCharsets.UTF_8));\n-            socket.getOutputStream().write('\\n');\n+            byte[] bytes = line.getBytes(StandardCharsets.UTF_8);\n+            writer.write(bytes);\n+            writer.write('\\n');\n         } else {\n-            throw new IOException(\"Connection closed unexpectedly.\");\n+            throw new IOException(\"writer is null\");\n         }\n     }\n \n"}}, {"oid": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "url": "https://github.com/openhab/openhab-addons/commit/cccf21d363f6f75e6115d92dbd03cdc227e1a329", "message": "[mpd]: Music Player Daemon initial contribution\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "309214dfa0796498ef8a11b827549d7bbeab24a3", "url": "https://github.com/openhab/openhab-addons/commit/309214dfa0796498ef8a11b827549d7bbeab24a3", "message": "[mpd]: increase version to 2.5.7-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "d0bcd9a6e3758c85df961f834b84ce95c2cf91d1", "url": "https://github.com/openhab/openhab-addons/commit/d0bcd9a6e3758c85df961f834b84ce95c2cf91d1", "message": "[mpd]: reduce number of requests at startup\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "url": "https://github.com/openhab/openhab-addons/commit/80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "message": "fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "d24cd4ce855321c69d347c9d1a1fbff6ce2e5388", "url": "https://github.com/openhab/openhab-addons/commit/d24cd4ce855321c69d347c9d1a1fbff6ce2e5388", "message": "fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "f90431733dca95340b791a4cf6c893d24bee9e91", "url": "https://github.com/openhab/openhab-addons/commit/f90431733dca95340b791a4cf6c893d24bee9e91", "message": "[mpd]: fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "0a85bbd6a3ee8a53156e8251efd06bf67bdfbda5", "url": "https://github.com/openhab/openhab-addons/commit/0a85bbd6a3ee8a53156e8251efd06bf67bdfbda5", "message": "[mpd]: increase version to 2.5.8-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:16:05Z", "type": "commit"}, {"oid": "3a178c21ce913b0ce53656483a28a7d6a6f5be45", "url": "https://github.com/openhab/openhab-addons/commit/3a178c21ce913b0ce53656483a28a7d6a6f5be45", "message": "[mpd]: make exception text more understandable\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T18:29:34Z", "type": "commit"}, {"oid": "f320b217ef531c1d3a38452e93b12ff4c1205b74", "url": "https://github.com/openhab/openhab-addons/commit/f320b217ef531c1d3a38452e93b12ff4c1205b74", "message": "[mpd]: do not write password to log file\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T19:38:53Z", "type": "commit"}, {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6", "url": "https://github.com/openhab/openhab-addons/commit/b257f624d1319c3f8a9360b5353a34bde75514c6", "message": "[mpd]: set thing to offline, if there is a permission problem\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T19:39:37Z", "type": "commit"}, {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6", "url": "https://github.com/openhab/openhab-addons/commit/b257f624d1319c3f8a9360b5353a34bde75514c6", "message": "[mpd]: set thing to offline, if there is a permission problem\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>", "committedDate": "2020-08-20T19:39:37Z", "type": "forcePushed"}]}