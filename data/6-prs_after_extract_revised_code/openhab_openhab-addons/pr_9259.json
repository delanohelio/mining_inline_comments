{"pr_number": 9259, "pr_title": "[androiddebugbridge] initial contribution", "pr_createdAt": "2020-12-06T16:17:37Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9259", "timeline": [{"oid": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "url": "https://github.com/openhab/openhab-addons/commit/a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "message": "initial contribution\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-06T15:56:13Z", "type": "commit"}, {"oid": "a0b12d2b8096e71f24c281493069fe7b201c9848", "url": "https://github.com/openhab/openhab-addons/commit/a0b12d2b8096e71f24c281493069fe7b201c9848", "message": "fix start package on devices without keys\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-13T00:17:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NDM5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541984392", "bodyText": "Is this field package-private by intention by not specifying private or public?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                static AdbCrypto adbCrypto;\n          \n          \n            \n                static @Nullable AdbCrypto ADB_CRYPTO;", "author": "fwolter", "createdAt": "2020-12-13T19:04:28Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985546", "bodyText": "You could create these files in OH's userdata directory. There are constants available to get the path.", "author": "fwolter", "createdAt": "2020-12-13T19:11:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985640", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:11:43Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985849", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:12:42Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NTk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541985975", "bodyText": "AndroidDebugBridgeDeviceException is never thrown.", "author": "fwolter", "createdAt": "2020-12-13T19:13:35Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541986294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n          \n          \n            \n                    String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", stream, \"--get\", \"|\",", "author": "fwolter", "createdAt": "2020-12-13T19:15:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwMTMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542501329", "bodyText": "Seems like I can't apply this change. runAdbShell expect this \"String... args\".", "author": "GiviMAD", "createdAt": "2020-12-14T16:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxMDc5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542510797", "bodyText": "You're right, that won't work.", "author": "fwolter", "createdAt": "2020-12-14T16:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NjM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541986383", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T19:15:53Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 7c47283a6c..067934e79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -25,12 +25,13 @@ import java.util.regex.Pattern;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.cgutman.adblib.AdbBase64;\n-import com.cgutman.adblib.AdbConnection;\n-import com.cgutman.adblib.AdbCrypto;\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n \n /**\n  * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987175", "bodyText": "If you don't need to distinguish between the exception types, you could use the same type with a different message.", "author": "fwolter", "createdAt": "2020-12-13T19:20:09Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex 15b082f8b4..3b673ec79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -27,6 +27,7 @@ import java.util.Map;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.core.config.discovery.AbstractDiscoveryService;\n import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingUID;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987476", "bodyText": "Please use Thing.PROPERTY_* where applicable.", "author": "fwolter", "createdAt": "2020-12-13T19:21:49Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip)\n+            throws AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException, InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, discoveryPort);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, discoveryPort);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, discoveryPort, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_SERIAL, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(PARAMETER_MODEL, model);\n+        properties.put(PARAMETER_BRAND, brand);\n+        properties.put(PARAMETER_ANDROID_VERSION, androidVersion);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex 15b082f8b4..3b673ec79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -27,6 +27,7 @@ import java.util.Map;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.core.config.discovery.AbstractDiscoveryService;\n import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingUID;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4NzU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987572", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .withProperties(properties).withLabel(String.format(\"%s(%s)\", model, serialNo)).build());\n          \n          \n            \n                            .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());", "author": "fwolter", "createdAt": "2020-12-13T19:22:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private int discoveryPort = 5555;\n+    private int reachableTimeoutMs = 3000;\n+    private boolean discoveryRunning = false;\n+    private int discoveryIpRangeMin = 0;\n+    private int discoveryIpRangeMax = 255;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    public void updateConfig(AndroidDebugBridgeBindingConfiguration bindingConfiguration) {\n+        this.discoveryPort = bindingConfiguration.discoveryPort;\n+        this.reachableTimeoutMs = bindingConfiguration.discoveryReachableMs;\n+        this.discoveryIpRangeMin = bindingConfiguration.discoveryIpRangeMin;\n+        this.discoveryIpRangeMax = bindingConfiguration.discoveryIpRangeMax;\n+        logger.debug(\"config updated: { 'port': {}, 'reachable ms': {}, 'min ip': {}, 'max ip': {} }\",\n+                this.discoveryPort, this.reachableTimeoutMs, this.discoveryIpRangeMin, this.discoveryIpRangeMax);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets = null;\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = this.discoveryIpRangeMin; i <= this.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(reachableTimeoutMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip)\n+            throws AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException, InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, discoveryPort);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, discoveryPort);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, discoveryPort, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PARAMETER_SERIAL, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(PARAMETER_MODEL, model);\n+        properties.put(PARAMETER_BRAND, brand);\n+        properties.put(PARAMETER_ANDROID_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(PARAMETER_SERIAL)\n+                .withProperties(properties).withLabel(String.format(\"%s(%s)\", model, serialNo)).build());", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex 15b082f8b4..3b673ec79f 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -27,6 +27,7 @@ import java.util.Map;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.core.config.discovery.AbstractDiscoveryService;\n import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingUID;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541987981", "bodyText": "How long can this take at maximum? dispose() is supposed to return fast.", "author": "fwolter", "createdAt": "2020-12-13T19:24:50Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxMjc1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542712750", "bodyText": "I made some test and it takes less than 5 ms always.", "author": "GiviMAD", "createdAt": "2020-12-14T19:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMDYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561200600", "bodyText": "What if there is a network problem? Would disconnect still execute quickly?", "author": "cpmeister", "createdAt": "2021-01-20T18:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMxMTYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561311639", "bodyText": "I've never face that problem when I was testing the device disconnection and reconnection. Also I have reviewed the implementation and I don't see any reason why its execution could be blocked by a network problem.", "author": "GiviMAD", "createdAt": "2021-01-20T21:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4Nzk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex adbf33b5fa..e57e55f4a2 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,9 +70,7 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n-                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n-                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n         } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988173", "bodyText": "Unchecked exceptions are handled by the framework. So, this could be removed.", "author": "fwolter", "createdAt": "2020-12-13T19:26:14Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)\n+                    updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            } else {\n+                if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    updateStatus(ThingStatus.OFFLINE);\n+                }\n+                try {\n+                    adbConnection.connect();\n+                } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                        | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException e) {\n+                    logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                    return;\n+                }\n+                if (adbConnection.isConnected()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    refreshStatus();\n+                }\n+            }\n+        } catch (Exception e) {\n+            // retry on unexpected errors", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex adbf33b5fa..e57e55f4a2 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,9 +70,7 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n-                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n-                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n         } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541988324", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "author": "fwolter", "createdAt": "2020-12-13T19:27:03Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)\n+public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n+    @Nullable\n+    private AndroidDebugBridgeDiscoveryService discoveryService;\n+    @Nullable\n+    private ServiceRegistration<?> discoveryServiceRegistration;\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        if (THING_TYPE_ANDROID_DEVICE.equals(thingTypeUID)) {\n+            return new AndroidDebugBridgeHandler(thing, new AndroidDebugBridgeDevice());\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void registerDiscoveryService(AndroidDebugBridgeBindingConfiguration config) {\n+        AndroidDebugBridgeDiscoveryService androidADBDiscoveryService = discoveryService;\n+        if (androidADBDiscoveryService != null) {\n+            androidADBDiscoveryService.updateConfig(config);\n+        } else {\n+            androidADBDiscoveryService = new AndroidDebugBridgeDiscoveryService();\n+            androidADBDiscoveryService.updateConfig(config);\n+            discoveryService = androidADBDiscoveryService;\n+            discoveryServiceRegistration = bundleContext.registerService(DiscoveryService.class.getName(),\n+                    androidADBDiscoveryService, null);\n+        }\n+    }\n+\n+    private void unregisterDiscoveryService() {\n+        var adbDiscoveryServiceRegistration = discoveryServiceRegistration;\n+        if (adbDiscoveryServiceRegistration != null) {\n+            adbDiscoveryServiceRegistration.unregister();\n+            discoveryServiceRegistration = null;\n+        }\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> config) {\n+        super.activate(componentContext);\n+        modified(config);\n+    }", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY5NzAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r542697016", "bodyText": "I was reviewing the documentation in the pr and seems like I need to create a bridge, right now I'm just passing the binding configurations to the discovery.\nIs there any other way to access to the binding configuration from the discovery service?\nOr should I create a bridge just to configure the service discovery?\nMaybe I'm missing something.\nThanks in advance.", "author": "GiviMAD", "createdAt": "2020-12-14T19:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0MTQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543441409", "bodyText": "If your discovery implements ThingHandlerService you need to implement the interface method setThingHandler(ThingHandler handler). Then, you can retrieve the bridge's config from the handler: handler.getThing().getConfiguration()", "author": "fwolter", "createdAt": "2020-12-15T15:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3Mzc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543473751", "bodyText": "It doesn't seem to fit my case because I don't have any bridge implemented on the binding. I configure the discovery through the binding configuration.", "author": "GiviMAD", "createdAt": "2020-12-15T16:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxMTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r543511346", "bodyText": "Now I get it. The binding configuration is stored as properties in the AndroidDebugBridgeHandlerFactory service. I never done this, but if you're keen, you could retrieve the config by injecting ConfigurationAdmin in the discovery class:\n    @Reference\n    void setConfigurationAdmin(ConfigurationAdmin admin) {\n        this.admin = admin;\n    }\n \n    public void ranking() throws IOException {\n        Configuration configOnline =\n            this.admin.getConfiguration(\n                \"org.fipro.ds.data.online.OnlineDataService\",\n                null);\n        Dictionary<String, Object> propsOnline = null;\n        if (configOnline != null\n                && configOnline.getProperties() != null) {\n            propsOnline = configOnline.getProperties();\n        }\n\nThe string argument to admin.getConfiguration() must be the PID of your factory: \"binding.androiddebugbridge\"\nThen, you should be able to obtain a config parameter by calling for example propsOnline.get(\"discoveryPort\"). I'm curious if this works.\nEDIT: I got the code frome here http://blog.vogella.com/2016/09/26/configuring-osgi-declarative-services/", "author": "fwolter", "createdAt": "2020-12-15T16:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4ODMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7f05e731424a489b28055c07a99da45736ed60", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\nindex 0e307c1852..56fad12499 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\n\n@@ -14,22 +14,14 @@ package org.openhab.binding.androiddebugbridge.internal;\n \n import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n \n-import java.util.Map;\n-\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n-import org.openhab.core.config.core.Configuration;\n-import org.openhab.core.config.discovery.DiscoveryService;\n import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingTypeUID;\n import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n import org.openhab.core.thing.binding.ThingHandler;\n import org.openhab.core.thing.binding.ThingHandlerFactory;\n-import org.osgi.framework.ServiceRegistration;\n-import org.osgi.service.component.ComponentContext;\n-import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n-import org.osgi.service.component.annotations.Modified;\n \n /**\n  * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk4OTczMw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r541989733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Refresh device {} status\", config.ip);\n          \n          \n            \n                        logger.debug(\"Refresh device {} status\", currentConfig.ip);", "author": "fwolter", "createdAt": "2020-12-13T19:35:01Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);", "originalCommit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex adbf33b5fa..e57e55f4a2 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,9 +70,7 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n-                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n-                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n         } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n"}}, {"oid": "034b86b1e5da198b5c627fd0ddc774820ee675db", "url": "https://github.com/openhab/openhab-addons/commit/034b86b1e5da198b5c627fd0ddc774820ee675db", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-14T18:00:20Z", "type": "commit"}, {"oid": "4d5a456df2ef9cb0f643af9703311e218ce97bc4", "url": "https://github.com/openhab/openhab-addons/commit/4d5a456df2ef9cb0f643af9703311e218ce97bc4", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-14T19:42:50Z", "type": "commit"}, {"oid": "bc7f05e731424a489b28055c07a99da45736ed60", "url": "https://github.com/openhab/openhab-addons/commit/bc7f05e731424a489b28055c07a99da45736ed60", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-15T22:41:42Z", "type": "commit"}, {"oid": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "url": "https://github.com/openhab/openhab-addons/commit/50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "message": "fix adb keys path\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T01:23:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2OTc5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544469793", "bodyText": "Great to see this works!\nYou could inject this via the constructor to get rid of the Nullable annotation.", "author": "fwolter", "createdAt": "2020-12-16T17:06:13Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private @Nullable ConfigurationAdmin admin;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip, int port)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, port);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, port);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, port, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(Thing.PROPERTY_MODEL_ID, model);\n+        properties.put(Thing.PROPERTY_VENDOR, brand);\n+        properties.put(Thing.PROPERTY_FIRMWARE_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER)\n+                .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());\n+    }\n+\n+    @Reference\n+    void setConfigurationAdmin(ConfigurationAdmin admin) {\n+        this.admin = admin;\n+    }", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex f98576cdd8..ad492b4a78 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -30,6 +30,7 @@ import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingUID;\n import org.osgi.service.cm.Configuration;\n import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n import org.osgi.service.component.annotations.Reference;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3MDQ5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544470494", "bodyText": "Can you make \"binding.androiddebugbridge\" a constant?", "author": "fwolter", "createdAt": "2020-12-16T17:07:08Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private @Nullable ConfigurationAdmin admin;\n+\n+    public AndroidDebugBridgeDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (SocketException | InterruptedException e) {\n+            logger.warn(\"Error while discovering: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void discoverWithADB(String ip, int port)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        var device = new AndroidDebugBridgeDevice();\n+        device.configure(ip, port);\n+        try {\n+            device.connect();\n+            logger.debug(\"connected adb at {}:{}\", ip, port);\n+            String serialNo = device.getSerialNo();\n+            String model = device.getModel();\n+            String androidVersion = device.getAndroidVersion();\n+            String brand = device.getBrand();\n+            logger.debug(\"discovered: {} - {} - {} - {}\", model, serialNo, androidVersion, brand);\n+            onDiscoverResult(serialNo, ip, port, model, androidVersion, brand);\n+        } finally {\n+            device.disconnect();\n+        }\n+    }\n+\n+    @Override\n+    protected void stopScan() {\n+        super.stopScan();\n+        discoveryRunning = false;\n+        logger.debug(\"scan stopped\");\n+    }\n+\n+    private void onDiscoverResult(String serialNo, String ip, int port, String model, String androidVersion,\n+            String brand) {\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(Thing.PROPERTY_SERIAL_NUMBER, serialNo);\n+        properties.put(PARAMETER_IP, ip);\n+        properties.put(PARAMETER_PORT, port);\n+        properties.put(Thing.PROPERTY_MODEL_ID, model);\n+        properties.put(Thing.PROPERTY_VENDOR, brand);\n+        properties.put(Thing.PROPERTY_FIRMWARE_VERSION, androidVersion);\n+        thingDiscovered(DiscoveryResultBuilder.create(new ThingUID(THING_TYPE_ANDROID_DEVICE, serialNo))\n+                .withTTL(DISCOVERY_RESULT_TTL_SEC).withRepresentationProperty(Thing.PROPERTY_SERIAL_NUMBER)\n+                .withProperties(properties).withLabel(String.format(\"%s (%s)\", model, serialNo)).build());\n+    }\n+\n+    @Reference\n+    void setConfigurationAdmin(ConfigurationAdmin admin) {\n+        this.admin = admin;\n+    }\n+\n+    private @Nullable Dictionary<String, Object> getConfig() {\n+        var currentAdmin = admin;\n+        if (currentAdmin == null) {\n+            logger.warn(\"Configuration admin not ready\");\n+            return null;\n+        }\n+        try {\n+            Configuration configOnline = currentAdmin.getConfiguration(\"binding.androiddebugbridge\", null);", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex f98576cdd8..ad492b4a78 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -30,6 +30,7 @@ import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingUID;\n import org.osgi.service.cm.Configuration;\n import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n import org.osgi.service.component.annotations.Reference;\n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3MjIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r544472236", "bodyText": "I think you could use the constant here, too.", "author": "fwolter", "createdAt": "2020-12-16T17:09:37Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)", "originalCommit": "50e9f4c0a77ecf9e6d9b58a02e13d9b953c3e2f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\nindex 56fad12499..aa80a95708 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\n\n@@ -30,7 +30,7 @@ import org.osgi.service.component.annotations.Component;\n  * @author Miguel \u00c1lvarez - Initial contribution\n  */\n @NonNullByDefault\n-@Component(configurationPid = \"binding.androiddebugbridge\", service = ThingHandlerFactory.class)\n+@Component(configurationPid = BINDING_CONFIGURATION_PID, service = ThingHandlerFactory.class)\n public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n \n     @Override\n"}}, {"oid": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "url": "https://github.com/openhab/openhab-addons/commit/b2774c159d3dd1e130df482e59b7644f8ce5b636", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T19:49:50Z", "type": "commit"}, {"oid": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "url": "https://github.com/openhab/openhab-addons/commit/b2774c159d3dd1e130df482e59b7644f8ce5b636", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-16T19:49:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NTc5NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548345794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private Socket socket;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                private AdbConnection connection;\n          \n          \n            \n                private @Nullable Socket socket;\n          \n          \n            \n                private @Nullable AdbConnection connection;", "author": "cpmeister", "createdAt": "2020-12-24T01:47:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 186183c6b3..5d77b802c1 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -64,10 +64,8 @@ public class AndroidDebugBridgeDevice {\n \n     private String ip = \"127.0.0.1\";\n     private int port = 5555;\n-    @Nullable\n-    private Socket socket;\n-    @Nullable\n-    private AdbConnection connection;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n \n     public void configure(String ip, int port) {\n         this.ip = ip;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346264", "bodyText": "Please do not perform sleep operations in the startScan method. Those are called from a UI thread and as such you should make sure that startScan returns quickly.", "author": "cpmeister", "createdAt": "2020-12-24T01:50:04Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, discoveryPort);\n+                                    } catch (IOException e) {\n+                                        var message = e.getMessage();\n+                                        if (message != null && message.contains(\"rejected by remote peer\")) {\n+                                            retries++;\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            Thread.sleep(5000);", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex ad492b4a78..c8ceb1dcc3 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -67,38 +67,40 @@ public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService\n         if (props == null) {\n             return;\n         }\n-        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n-        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n-        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n-        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        int discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        int discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        int discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        int discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n         try {\n             nets = NetworkInterface.getNetworkInterfaces();\n             for (NetworkInterface netint : Collections.list(nets)) {\n                 Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n                 for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n-                    if (!discoveryRunning)\n+                    if (!discoveryRunning) {\n                         break;\n+                    }\n                     if (!(inetAddress instanceof Inet4Address))\n                         continue;\n                     if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n                         continue;\n                     String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n-                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n-                        if (!discoveryRunning)\n+                    for (int i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning) {\n                             break;\n+                        }\n                         ipParts[3] = Integer.toString(i);\n-                        var currentIp = String.join(\".\", ipParts);\n+                        String currentIp = String.join(\".\", ipParts);\n                         try {\n                             var currentAddress = InetAddress.getByName(currentIp);\n                             logger.debug(\"address: {}\", currentIp);\n                             if (currentAddress.isReachable(discoveryReachableMs)) {\n                                 logger.debug(\"Reachable ip: {}\", currentIp);\n-                                var retries = 0;\n+                                int retries = 0;\n                                 while (retries < MAX_RETRIES) {\n                                     try {\n                                         discoverWithADB(currentIp, discoveryPort);\n                                     } catch (IOException e) {\n-                                        var message = e.getMessage();\n+                                        String message = e.getMessage();\n                                         if (message != null && message.contains(\"rejected by remote peer\")) {\n                                             retries++;\n                                             logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjM4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346384", "bodyText": "super.dispose() should be called last.", "author": "cpmeister", "createdAt": "2020-12-24T01:50:52Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex e57e55f4a2..88240280b1 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,17 +70,16 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+        } catch (AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+        } catch (AndroidDebugBridgeDeviceReadException e) {\n             logger.debug(\"read error: {}\", e.getMessage());\n         }\n     }\n \n-    private void handleCommandInternal(ChannelUID channelUID, Command command)\n-            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n-            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n         if (!isLinked(channelUID))\n             return;\n         String channelId = channelUID.getId();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NjcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346725", "bodyText": "InterruptExceptions should cause an immediate return from the current method. You should not perform additional operations once an interrupt has been received since you would be delaying openhab from shutting down.", "author": "cpmeister", "createdAt": "2020-12-24T01:52:32Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        logger.debug(\"Refresh device {} status\", currentConfig.ip);\n+        if (adbConnection.isConnected()) {\n+            if (thing.getStatus() != ThingStatus.ONLINE)\n+                updateStatus(ThingStatus.ONLINE);\n+            refreshStatus();\n+        } else {\n+            if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+            try {\n+                adbConnection.connect();\n+            } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException e) {\n+                logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                return;\n+            }\n+            if (adbConnection.isConnected()) {\n+                updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            }\n+        }\n+    }\n+\n+    private void refreshStatus() {\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_VOLUME_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh media volume: {}\", e.getMessage());\n+        }\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_CONTROL_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh play status: {}\", e.getMessage());\n+        }\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh current package: {}\", e.getMessage());\n+        }", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex e57e55f4a2..88240280b1 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,17 +70,16 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+        } catch (AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+        } catch (AndroidDebugBridgeDeviceReadException e) {\n             logger.debug(\"read error: {}\", e.getMessage());\n         }\n     }\n \n-    private void handleCommandInternal(ChannelUID channelUID, Command command)\n-            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n-            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n         if (!isLinked(channelUID))\n             return;\n         String channelId = channelUID.getId();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548346848", "bodyText": "Should such errors also cause the thing status to go offline?", "author": "cpmeister", "createdAt": "2020-12-24T01:53:10Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        logger.debug(\"Refresh device {} status\", currentConfig.ip);\n+        if (adbConnection.isConnected()) {\n+            if (thing.getStatus() != ThingStatus.ONLINE)\n+                updateStatus(ThingStatus.ONLINE);\n+            refreshStatus();\n+        } else {\n+            if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+            try {\n+                adbConnection.connect();\n+            } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException e) {\n+                logger.debug(\"Error connecting to device: {}\", e.getMessage());\n+                return;\n+            }\n+            if (adbConnection.isConnected()) {\n+                updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            }\n+        }\n+    }\n+\n+    private void refreshStatus() {\n+        try {\n+            handleCommandInternal(new ChannelUID(this.thing.getUID(), MEDIA_VOLUME_CHANNEL), RefreshType.REFRESH);\n+        } catch (IOException | InterruptedException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"Unable to refresh media volume: {}\", e.getMessage());", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc2ODc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548768758", "bodyText": "It will allow to detect that the device is offline sooner, so yes I'll change it", "author": "GiviMAD", "createdAt": "2020-12-25T00:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzNDE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551834158", "bodyText": "For my Fire TV Stick this warning is logged all the time. I think we should reduce logging level here. Otherwise it will be very annoying. Or I have to reduce logging to ERROR for this binding in my logging config.", "author": "cweitkamp", "createdAt": "2021-01-05T10:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Njg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex e57e55f4a2..88240280b1 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,17 +70,16 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n+        } catch (AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+        } catch (AndroidDebugBridgeDeviceReadException e) {\n             logger.debug(\"read error: {}\", e.getMessage());\n         }\n     }\n \n-    private void handleCommandInternal(ChannelUID channelUID, Command command)\n-            throws InterruptedException, IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n-            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n         if (!isLinked(channelUID))\n             return;\n         String channelId = channelUID.getId();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0NzI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347277", "bodyText": "Please don't use var for primitives, it just leads to possible confusion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            var retries = 0;\n          \n          \n            \n                                            int retries = 0;", "author": "cpmeister", "createdAt": "2020-12-24T01:55:16Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning)\n+                            break;\n+                        ipParts[3] = Integer.toString(i);\n+                        var currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                var retries = 0;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex ad492b4a78..c8ceb1dcc3 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -67,38 +67,40 @@ public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService\n         if (props == null) {\n             return;\n         }\n-        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n-        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n-        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n-        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        int discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        int discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        int discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        int discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n         try {\n             nets = NetworkInterface.getNetworkInterfaces();\n             for (NetworkInterface netint : Collections.list(nets)) {\n                 Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n                 for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n-                    if (!discoveryRunning)\n+                    if (!discoveryRunning) {\n                         break;\n+                    }\n                     if (!(inetAddress instanceof Inet4Address))\n                         continue;\n                     if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n                         continue;\n                     String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n-                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n-                        if (!discoveryRunning)\n+                    for (int i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning) {\n                             break;\n+                        }\n                         ipParts[3] = Integer.toString(i);\n-                        var currentIp = String.join(\".\", ipParts);\n+                        String currentIp = String.join(\".\", ipParts);\n                         try {\n                             var currentAddress = InetAddress.getByName(currentIp);\n                             logger.debug(\"address: {}\", currentIp);\n                             if (currentAddress.isReachable(discoveryReachableMs)) {\n                                 logger.debug(\"Reachable ip: {}\", currentIp);\n-                                var retries = 0;\n+                                int retries = 0;\n                                 while (retries < MAX_RETRIES) {\n                                     try {\n                                         discoverWithADB(currentIp, discoveryPort);\n                                     } catch (IOException e) {\n-                                        var message = e.getMessage();\n+                                        String message = e.getMessage();\n                                         if (message != null && message.contains(\"rejected by remote peer\")) {\n                                             retries++;\n                                             logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Nzc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347747", "bodyText": "Since these exceptions are used outside of this class, please move these exceptions to their own files.", "author": "cpmeister", "createdAt": "2020-12-24T01:57:06Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isPlayingMedia() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            adbConnection.connect();\n+        } catch (IOException | InterruptedException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+        connection = adbConnection;\n+        socket = sock;\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        synchronized (adb) {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;\n+            }\n+            return byteArrayOutputStream.toString(StandardCharsets.US_ASCII);\n+        }\n+    }\n+\n+    private static AdbBase64 getBase64Impl() {\n+        return bytes -> new String(Base64.getEncoder().encode(bytes));\n+    }\n+\n+    private static AdbCrypto loadKeyPair(String pubKeyFile, String privKeyFile)\n+            throws NoSuchAlgorithmException, IOException, InvalidKeySpecException {\n+        File pub = new File(pubKeyFile);\n+        File priv = new File(privKeyFile);\n+        AdbCrypto c = null;\n+        // load key pair\n+        if (pub.exists() && priv.exists()) {\n+            try {\n+                c = AdbCrypto.loadAdbKeyPair(getBase64Impl(), priv, pub);\n+            } catch (IOException ignored) {\n+                // Keys don't exits\n+            }\n+        }\n+        if (c == null) {\n+            // generate key pair\n+            c = AdbCrypto.generateAdbKeyPair(getBase64Impl());\n+            c.saveAdbKeyPair(priv, pub);\n+        }\n+        return c;\n+    }\n+\n+    public void disconnect() {\n+        var adb = connection;\n+        var sock = socket;\n+        if (adb != null) {\n+            try {\n+                adb.close();\n+            } catch (IOException ignored) {\n+            }\n+            connection = null;\n+        }\n+        if (sock != null) {\n+            try {\n+                sock.close();\n+            } catch (IOException ignored) {\n+            }\n+            socket = null;\n+        }\n+    }\n+\n+    static class AndroidDebugBridgeDeviceException extends Exception {\n+        public AndroidDebugBridgeDeviceException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    static class AndroidDebugBridgeDeviceReadException extends Exception {\n+        public AndroidDebugBridgeDeviceReadException(String message) {\n+            super(message);\n+        }\n+    }", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 186183c6b3..5d77b802c1 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -64,10 +64,8 @@ public class AndroidDebugBridgeDevice {\n \n     private String ip = \"127.0.0.1\";\n     private int port = 5555;\n-    @Nullable\n-    private Socket socket;\n-    @Nullable\n-    private AdbConnection connection;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n \n     public void configure(String ip, int port) {\n         this.ip = ip;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0Nzg3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r548347874", "bodyText": "Please use brackets for every if statement.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!discoveryRunning)\n          \n          \n            \n                                    break;\n          \n          \n            \n                                if (!discoveryRunning) {\n          \n          \n            \n                                    break;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2020-12-24T01:57:55Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        Dictionary<String, Object> props = getConfig();\n+        if (props == null) {\n+            return;\n+        }\n+        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning)\n+                        break;", "originalCommit": "b2774c159d3dd1e130df482e59b7644f8ce5b636", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "72083e308970c6f374ee9c086b2444f8305536d7", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex ad492b4a78..c8ceb1dcc3 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -67,38 +67,40 @@ public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService\n         if (props == null) {\n             return;\n         }\n-        var discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n-        var discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n-        var discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n-        var discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n+        int discoveryPort = Integer.parseInt((String) props.get(\"discoveryPort\"));\n+        int discoveryReachableMs = Integer.parseInt((String) props.get(\"discoveryReachableMs\"));\n+        int discoveryIpRangeMin = Integer.parseInt((String) props.get(\"discoveryIpRangeMin\"));\n+        int discoveryIpRangeMax = Integer.parseInt((String) props.get(\"discoveryIpRangeMax\"));\n         try {\n             nets = NetworkInterface.getNetworkInterfaces();\n             for (NetworkInterface netint : Collections.list(nets)) {\n                 Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n                 for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n-                    if (!discoveryRunning)\n+                    if (!discoveryRunning) {\n                         break;\n+                    }\n                     if (!(inetAddress instanceof Inet4Address))\n                         continue;\n                     if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n                         continue;\n                     String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n-                    for (var i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n-                        if (!discoveryRunning)\n+                    for (int i = discoveryIpRangeMin; i <= discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning) {\n                             break;\n+                        }\n                         ipParts[3] = Integer.toString(i);\n-                        var currentIp = String.join(\".\", ipParts);\n+                        String currentIp = String.join(\".\", ipParts);\n                         try {\n                             var currentAddress = InetAddress.getByName(currentIp);\n                             logger.debug(\"address: {}\", currentIp);\n                             if (currentAddress.isReachable(discoveryReachableMs)) {\n                                 logger.debug(\"Reachable ip: {}\", currentIp);\n-                                var retries = 0;\n+                                int retries = 0;\n                                 while (retries < MAX_RETRIES) {\n                                     try {\n                                         discoverWithADB(currentIp, discoveryPort);\n                                     } catch (IOException e) {\n-                                        var message = e.getMessage();\n+                                        String message = e.getMessage();\n                                         if (message != null && message.contains(\"rejected by remote peer\")) {\n                                             retries++;\n                                             logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n"}}, {"oid": "72083e308970c6f374ee9c086b2444f8305536d7", "url": "https://github.com/openhab/openhab-addons/commit/72083e308970c6f374ee9c086b2444f8305536d7", "message": "apply pr review changes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2020-12-25T00:32:16Z", "type": "commit"}, {"oid": "1d82987a176827aa9a51aa11f790181a09d940ac", "url": "https://github.com/openhab/openhab-addons/commit/1d82987a176827aa9a51aa11f790181a09d940ac", "message": "upgrade adblib dependency\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-03T23:28:54Z", "type": "commit"}, {"oid": "1d82987a176827aa9a51aa11f790181a09d940ac", "url": "https://github.com/openhab/openhab-addons/commit/1d82987a176827aa9a51aa11f790181a09d940ac", "message": "upgrade adblib dependency\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-03T23:28:54Z", "type": "forcePushed"}, {"oid": "bee1864a2b3e97e7f260f83cb65fd8051c5dcb87", "url": "https://github.com/openhab/openhab-addons/commit/bee1864a2b3e97e7f260f83cb65fd8051c5dcb87", "message": "Merge branch 'main' of https://github.com/openhab/openhab-addons into androiddebugbridge", "committedDate": "2021-01-04T10:34:16Z", "type": "commit"}, {"oid": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "url": "https://github.com/openhab/openhab-addons/commit/8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "message": "update copyright message and version number\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-04T10:43:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NTcxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537695710", "bodyText": "Can we set the reason why the thing is offline? And I think we should do this only if the connect() fails e.g. in the catch block below.", "author": "cweitkamp", "createdAt": "2020-12-07T17:36:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)\n+                    updateStatus(ThingStatus.ONLINE);\n+                refreshStatus();\n+            } else {\n+                if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    updateStatus(ThingStatus.OFFLINE);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex adbf33b5fa..e57e55f4a2 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,9 +70,7 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n-                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n-                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n         } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5ODAzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537698037", "bodyText": "Do not do this. The OHC framweork takes care of it.", "author": "cweitkamp", "createdAt": "2020-12-07T17:39:59Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, AndroidDebugBridgeDevice adbConnection) {\n+        super(thing);\n+        this.adbConnection = adbConnection;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null)\n+            return;\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n+                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n+                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n+            logger.debug(\"read error: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws InterruptedException, IOException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (!isLinked(channelUID))\n+            return;\n+        String channelId = channelUID.getId();\n+        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendKeyEvent(command.toFullString());\n+        } else if (TEXT_CHANNEL.equals(channelId)) {\n+            adbConnection.sendText(command.toFullString());\n+        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n+            handleMediaVolume(channelUID, command);\n+        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n+            handleMediaControlCommand(channelUID, command);\n+        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.startPackage(command.toFullString());\n+            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                    new StringType(command.toFullString()));\n+        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n+            adbConnection.stopPackage(command.toFullString());\n+        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n+            if (command instanceof RefreshType) {\n+                var packageName = adbConnection.getCurrentPackage();\n+                updateState(channelUID, new StringType(packageName));\n+            }\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command) throws IOException, InterruptedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException,\n+            AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException {\n+        if (command instanceof RefreshType) {\n+            AndroidDebugBridgeDevice.VolumeInfo volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0)\n+                return; // We can not transform percentage\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command) throws InterruptedException,\n+            IOException, AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException {\n+        if (command instanceof RefreshType) {\n+            boolean playing = adbConnection.isPlayingMedia();\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        adbConnection.configure(currentConfig.ip, currentConfig.port);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTimeSec, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        var schedule = connectionCheckerSchedule;\n+        if (schedule != null) {\n+            schedule.cancel(true);\n+            connectionCheckerSchedule = null;\n+        }\n+        adbConnection.disconnect();\n+    }\n+\n+    public void checkConnection() {\n+        try {\n+            var currentConfig = config;\n+            if (currentConfig == null)\n+                return;\n+            logger.debug(\"Refresh device {} status\", config.ip);\n+            if (adbConnection.isConnected()) {\n+                if (thing.getStatus() != ThingStatus.ONLINE)", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "034b86b1e5da198b5c627fd0ddc774820ee675db", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex adbf33b5fa..e57e55f4a2 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -70,9 +70,7 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n                 adbConnection.connect();\n             }\n             handleCommandInternal(channelUID, command);\n-        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException\n-                | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceCryptographyException | InterruptedException\n-                | IOException | AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceNotConnectedException e) {\n+        } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceException | InterruptedException | IOException e) {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n             adbConnection.disconnect();\n         } catch (AndroidDebugBridgeDevice.AndroidDebugBridgeDeviceReadException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNDQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537704403", "bodyText": "This is not clear enough. Even if we add the exception message to the ThingStatusDetails the user does not know what to do next. We should give a clear advice or at least add a debug log.", "author": "cweitkamp", "createdAt": "2020-12-07T17:48:56Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 0c985181e4..7c47283a6c 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -88,7 +88,7 @@ public class AndroidDebugBridgeDevice {\n \n     public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n             InterruptedException, AndroidDebugBridgeDeviceException {\n-        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n         if (out.contains(\"monkey aborted\"))\n             throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwNDUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r537704522", "bodyText": "This is not clear enough. Even if we add the exception message to the ThingStatusDetails the user does not know what to do next. We should give a clear advice or at least add a debug log.", "author": "cweitkamp", "createdAt": "2020-12-07T17:49:05Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cgutman.adblib.AdbBase64;\n+import com.cgutman.adblib.AdbConnection;\n+import com.cgutman.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    @Nullable\n+    static AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(\".adb\");\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(\".adb/adb_pub.key\", \".adb/adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    @Nullable\n+    private Socket socket;\n+    @Nullable\n+    private AdbConnection connection;\n+\n+    public AndroidDebugBridgeDevice() {\n+    }\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\", \"&&\", \"sleep\", \"0.3\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    // public String[] getPackages(String packageName)\n+    // throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+    // var out = runAdbShell(\"cmd\", \"package\", \"list\", \"packages\");\n+    // return Arrays.asList(out.split(\"\\n\")).stream().filter(line -> line.contains(\"package:\"))\n+    // .map(line -> line.substring(\"package:\".length())).toArray(String[]::new);\n+    // }\n+\n+    public boolean isPlayingMedia()\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\", \"&&\", \"sleep\", \"0.3\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\", \"&&\", \"sleep\",\n+                    \"0.3\");\n+            return devicesResp.contains(\"PlaybackState {state=3\");\n+        }\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws IOException, AndroidDebugBridgeDeviceNotConnectedException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n+            InterruptedException, AndroidDebugBridgeDeviceReadException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\", \"&&\", \"sleep\", \"0.3\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceCryptographyException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceCryptographyException();\n+        }\n+        try {\n+            sock = new Socket(ip, port);\n+            sock.setTcpNoDelay(true);\n+            // sock.setSoTimeout(5000);\n+        } catch (IOException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            adbConnection.connect();\n+        } catch (IOException | InterruptedException e) {\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);", "originalCommit": "a7a755b244ffe3339c719d77dd5b2f15c6509ab5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0b12d2b8096e71f24c281493069fe7b201c9848", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 0c985181e4..7c47283a6c 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -88,7 +88,7 @@ public class AndroidDebugBridgeDevice {\n \n     public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceNotConnectedException,\n             InterruptedException, AndroidDebugBridgeDeviceException {\n-        var out = runAdbShell(\"monkey\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\", \"&&\", \"sleep\", \"0.3\");\n         if (out.contains(\"monkey aborted\"))\n             throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r551830720", "bodyText": "I personally would check on \"media_sesssion\" first before \"audio\". At least for Android TV or Fire TV. Wdyt?\nIn general I am not very happy with the isPlaying() detection. E.g. My Fire TV Stick is playing all the time, event when I am on the home screen. Maybe we can add a configuration parameter to exclude specific, user-defined packages (e.g. \"com.amazon.tv.launcher\") for.\nIIRC I somewhere read about kind of \"state_detection_rules\" for Android TV:\nstate_detection_rules = {\n    'com.amazon.tv.launcher': ['idle'],\n    'com.netflix.ninja': ['media_session_state'],\n    'com.ellation.vrv': ['audio_state'],\n    'com.hulu.plus': [{'playing': {'wake_lock_size': 4}}, {'paused': {'wake_lock_size': 2}}],\n    'com.plexapp.android': [{'paused': {'media_session_state': 3,'wake_lock_size': 1}}, {'playing': {'media_session_state\u02d3': 3}}, 'idle']\n}\n\nVALID_STATES = ('idle', 'off', 'playing', 'paused', 'standby')", "author": "cweitkamp", "createdAt": "2021-01-05T10:01:40Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+\n+    public void configure(String ip, int port) {\n+        this.ip = ip;\n+        this.port = port;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws IOException, InterruptedException, AndroidDebugBridgeDeviceException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text) throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName) throws IOException, AndroidDebugBridgeDeviceException,\n+            InterruptedException, AndroidDebugBridgeDeviceException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isPlayingMedia() throws IOException, AndroidDebugBridgeDeviceException, InterruptedException {\n+        // Try to get players info from audio dump\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        if (audioDump.length() == 0) {\n+            // Fallback to media session dump\n+            String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"PlaybackState\");", "originalCommit": "8dcf0ce84e4b61f7dba7c308ee6d7d20472c186f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MzkyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r552883924", "bodyText": "I wasn't taking in account the current app for the playing check, now it should work better.\nAlso I ended up implementing different ways of detect the player state, I have added the documentation. It's something similar to the solution implemented by HA. Basically you can configure a different detection mode by package name.", "author": "GiviMAD", "createdAt": "2021-01-06T18:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r554426991", "bodyText": "Did you test them? What is your personal feeling?", "author": "cweitkamp", "createdAt": "2021-01-09T13:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgzMDcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "df6d0c31577b6dab608946b51b061370b9e00731", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex fbb7b299e9..96277fad01 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -20,6 +20,10 @@ import java.security.NoSuchAlgorithmException;\n import java.security.spec.InvalidKeySpecException;\n import java.util.Arrays;\n import java.util.Base64;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n"}}, {"oid": "df6d0c31577b6dab608946b51b061370b9e00731", "url": "https://github.com/openhab/openhab-addons/commit/df6d0c31577b6dab608946b51b061370b9e00731", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:05:18Z", "type": "forcePushed"}, {"oid": "373b1264e9511d102d6aa0aa7b84c9d252a40195", "url": "https://github.com/openhab/openhab-addons/commit/373b1264e9511d102d6aa0aa7b84c9d252a40195", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:47:29Z", "type": "commit"}, {"oid": "373b1264e9511d102d6aa0aa7b84c9d252a40195", "url": "https://github.com/openhab/openhab-addons/commit/373b1264e9511d102d6aa0aa7b84c9d252a40195", "message": "improve media state detection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-06T18:47:29Z", "type": "forcePushed"}, {"oid": "785e2da4b4858005d59048334aeb38ea00624be2", "url": "https://github.com/openhab/openhab-addons/commit/785e2da4b4858005d59048334aeb38ea00624be2", "message": "fix device reconnection\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-09T17:50:06Z", "type": "commit"}, {"oid": "c6776489b88dfb2b3d441bf122e77366efcc2ad7", "url": "https://github.com/openhab/openhab-addons/commit/c6776489b88dfb2b3d441bf122e77366efcc2ad7", "message": "fix dispose errors\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T00:52:22Z", "type": "commit"}, {"oid": "ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "url": "https://github.com/openhab/openhab-addons/commit/ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "message": "minor fixes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T01:19:54Z", "type": "commit"}, {"oid": "ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "url": "https://github.com/openhab/openhab-addons/commit/ab399bb4d4eff2cc0ed2b8f6ba41dd8e95450827", "message": "minor fixes\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-10T01:19:54Z", "type": "forcePushed"}, {"oid": "38017de65a87a9a8f582af1ce951add2acc4e111", "url": "https://github.com/openhab/openhab-addons/commit/38017de65a87a9a8f582af1ce951add2acc4e111", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-18T23:28:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA4MTY0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r560081646", "bodyText": "You can use a switch-statement instead of the if-else combination.\nswitch(channelId) {\n    case STOP_CURRENT_PACKAGE_CHANNEL:\n        ...\n        break;\n...\n}", "author": "cweitkamp", "createdAt": "2021-01-19T10:43:24Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -110,6 +110,10 @@ private void handleCommandInternal(ChannelUID channelUID, Command command)\n                     new StringType(command.toFullString()));\n         } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n             adbConnection.stopPackage(command.toFullString());\n+        } else if (STOP_CURRENT_PACKAGE_CHANNEL.equals(channelId)) {", "originalCommit": "38017de65a87a9a8f582af1ce951add2acc4e111", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "770e2c4871110b709efd035278fd0922095179cc", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex f7f28a19cd..caa9e792c3 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -96,39 +96,50 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n         if (!isLinked(channelUID))\n             return;\n         String channelId = channelUID.getId();\n-        if (KEY_EVENT_CHANNEL.equals(channelId)) {\n-            adbConnection.sendKeyEvent(command.toFullString());\n-        } else if (TEXT_CHANNEL.equals(channelId)) {\n-            adbConnection.sendText(command.toFullString());\n-        } else if (MEDIA_VOLUME_CHANNEL.equals(channelId)) {\n-            handleMediaVolume(channelUID, command);\n-        } else if (MEDIA_CONTROL_CHANNEL.equals(channelId)) {\n-            handleMediaControlCommand(channelUID, command);\n-        } else if (START_PACKAGE_CHANNEL.equals(channelId)) {\n-            adbConnection.startPackage(command.toFullString());\n-            updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n-                    new StringType(command.toFullString()));\n-        } else if (STOP_PACKAGE_CHANNEL.equals(channelId)) {\n-            adbConnection.stopPackage(command.toFullString());\n-        } else if (STOP_CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n-            if (OnOffType.from(command.toFullString()).equals(OnOffType.OFF)) {\n-                adbConnection.stopPackage(adbConnection.getCurrentPackage());\n-            }\n-        } else if (CURRENT_PACKAGE_CHANNEL.equals(channelId)) {\n-            if (command instanceof RefreshType) {\n-                var packageName = adbConnection.getCurrentPackage();\n-                updateState(channelUID, new StringType(packageName));\n-            }\n-        } else if (WAKE_LOCK_CHANNEL.equals(channelId)) {\n-            if (command instanceof RefreshType) {\n-                int lock = adbConnection.getPowerWakeLock();\n-                updateState(channelUID, new DecimalType(lock));\n-            }\n-        } else if (SCREEN_STATE_CHANNEL.equals(channelId)) {\n-            if (command instanceof RefreshType) {\n-                boolean screenState = adbConnection.isScreenOn();\n-                updateState(channelUID, OnOffType.from(screenState));\n-            }\n+        switch (channelId) {\n+            case KEY_EVENT_CHANNEL:\n+                adbConnection.sendKeyEvent(command.toFullString());\n+                break;\n+            case TEXT_CHANNEL:\n+                adbConnection.sendText(command.toFullString());\n+                break;\n+            case MEDIA_VOLUME_CHANNEL:\n+                handleMediaVolume(channelUID, command);\n+                break;\n+            case MEDIA_CONTROL_CHANNEL:\n+                handleMediaControlCommand(channelUID, command);\n+                break;\n+            case START_PACKAGE_CHANNEL:\n+                adbConnection.startPackage(command.toFullString());\n+                updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                        new StringType(command.toFullString()));\n+                break;\n+            case STOP_PACKAGE_CHANNEL:\n+                adbConnection.stopPackage(command.toFullString());\n+                break;\n+            case STOP_CURRENT_PACKAGE_CHANNEL:\n+                if (OnOffType.from(command.toFullString()).equals(OnOffType.OFF)) {\n+                    adbConnection.stopPackage(adbConnection.getCurrentPackage());\n+                }\n+                break;\n+            case CURRENT_PACKAGE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    var packageName = adbConnection.getCurrentPackage();\n+                    updateState(channelUID, new StringType(packageName));\n+                }\n+                break;\n+            case WAKE_LOCK_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    int lock = adbConnection.getPowerWakeLock();\n+                    updateState(channelUID, new DecimalType(lock));\n+                }\n+                break;\n+            case SCREEN_STATE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    boolean screenState = adbConnection.isScreenOn();\n+                    updateState(channelUID, OnOffType.from(screenState));\n+                }\n+                break;\n         }\n     }\n \n"}}, {"oid": "770e2c4871110b709efd035278fd0922095179cc", "url": "https://github.com/openhab/openhab-addons/commit/770e2c4871110b709efd035278fd0922095179cc", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-19T13:49:10Z", "type": "commit"}, {"oid": "9674b9ab2953cb250954a6102baf08763faa6b3f", "url": "https://github.com/openhab/openhab-addons/commit/9674b9ab2953cb250954a6102baf08763faa6b3f", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-19T14:02:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4NzIxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561187219", "bodyText": "You should specify the Charset you are using here.", "author": "cpmeister", "createdAt": "2021-01-20T18:35:23Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;\n+            }\n+            return byteArrayOutputStream.toString(StandardCharsets.US_ASCII);\n+        });\n+        this.commandFuture = commandFuture;\n+        return commandFuture.get(timeoutSec, TimeUnit.SECONDS);\n+    }\n+\n+    private static AdbBase64 getBase64Impl() {\n+        return bytes -> new String(Base64.getEncoder().encode(bytes));", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 56d3fdaf3e..8778fcfbbe 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -16,6 +16,7 @@ import java.io.*;\n import java.net.InetSocketAddress;\n import java.net.Socket;\n import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.security.NoSuchAlgorithmException;\n import java.security.spec.InvalidKeySpecException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4ODYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561188605", "bodyText": "The use of var here makes it hard to understand what the type at a glance.", "author": "cpmeister", "createdAt": "2021-01-20T18:37:47Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 56d3fdaf3e..8778fcfbbe 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -16,6 +16,7 @@ import java.io.*;\n import java.net.InetSocketAddress;\n import java.net.Socket;\n import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.security.NoSuchAlgorithmException;\n import java.security.spec.InvalidKeySpecException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4OTExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561189111", "bodyText": "All if statements should have brackets.", "author": "cpmeister", "createdAt": "2021-01-20T18:38:34Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import java.io.*;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.concurrent.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.tananaev.adblib.AdbBase64;\n+import com.tananaev.adblib.AdbConnection;\n+import com.tananaev.adblib.AdbCrypto;\n+\n+/**\n+ * The {@link AndroidDebugBridgeConfiguration} class encapsulates adb device connection logic.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeDevice {\n+    public static final int ANDROID_MEDIA_STREAM = 3;\n+    private static final String ADB_FOLDER = OpenHAB.getUserDataFolder() + File.separator + \".adb\";\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+    private static final Pattern VOLUME_PATTERN = Pattern\n+            .compile(\"volume is (?<current>\\\\d.*) in range \\\\[(?<min>\\\\d.*)\\\\.\\\\.(?<max>\\\\d.*)]\");\n+\n+    private static @Nullable AdbCrypto adbCrypto;\n+\n+    static {\n+        var logger = LoggerFactory.getLogger(AndroidDebugBridgeDevice.class);\n+        try {\n+            File directory = new File(ADB_FOLDER);\n+            if (!directory.exists()) {\n+                directory.mkdir();\n+            }\n+            adbCrypto = loadKeyPair(ADB_FOLDER + File.separator + \"adb_pub.key\",\n+                    ADB_FOLDER + File.separator + \"adb.key\");\n+        } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException e) {\n+            logger.warn(\"Unable to setup adb keys: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private final ScheduledExecutorService scheduler;\n+\n+    private String ip = \"127.0.0.1\";\n+    private int port = 5555;\n+    private int timeoutSec = 5;\n+    private @Nullable Socket socket;\n+    private @Nullable AdbConnection connection;\n+    private @Nullable Future<String> commandFuture;\n+\n+    AndroidDebugBridgeDevice(ScheduledExecutorService scheduler) {\n+        this.scheduler = scheduler;\n+    }\n+\n+    public void configure(String ip, int port, int timeout) {\n+        this.ip = ip;\n+        this.port = port;\n+        this.timeoutSec = timeout;\n+    }\n+\n+    public void sendKeyEvent(String eventCode)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"keyevent\", eventCode);\n+    }\n+\n+    public void sendText(String text)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"input\", \"text\", URLEncoder.encode(text, StandardCharsets.UTF_8));\n+    }\n+\n+    public void startPackage(String packageName)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"monkey\", \"--pct-syskeys\", \"0\", \"-p\", packageName, \"-v\", \"1\");\n+        if (out.contains(\"monkey aborted\"))\n+            throw new AndroidDebugBridgeDeviceException(\"Unable to open package\");\n+    }\n+\n+    public void stopPackage(String packageName)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"am\", \"force-stop\", packageName);\n+    }\n+\n+    public String getCurrentPackage() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var out = runAdbShell(\"dumpsys\", \"window\", \"windows\", \"|\", \"grep\", \"mFocusedApp\");\n+        var targetLine = Arrays.stream(out.split(\"\\n\")).findFirst().orElse(\"\");\n+        var lineParts = targetLine.split(\" \");\n+        if (lineParts.length >= 2) {\n+            var packageActivityName = lineParts[lineParts.length - 2];\n+            if (packageActivityName.contains(\"/\"))\n+                return packageActivityName.split(\"/\")[0];\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read package name\");\n+    }\n+\n+    public boolean isScreenOn() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"'Display Power'\");\n+        if (devicesResp.contains(\"=\")) {\n+            try {\n+                return devicesResp.split(\"=\")[1].equals(\"ON\");\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read screen state\");\n+    }\n+\n+    public boolean isPlayingMedia(String currentApp)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String devicesResp = runAdbShell(\"dumpsys\", \"media_session\", \"|\", \"grep\", \"-A\", \"100\", \"'Sessions Stack'\", \"|\",\n+                \"grep\", \"-A\", \"50\", currentApp);\n+        String[] mediaSessions = devicesResp.split(\"\\n\\n\");\n+        if (mediaSessions.length == 0) {\n+            // no media session found for current app\n+            return false;\n+        }\n+        boolean isPlaying = mediaSessions[0].contains(\"PlaybackState {state=3\");\n+        logger.debug(\"device media state playing {}\", isPlaying);\n+        return isPlaying;\n+    }\n+\n+    public boolean isPlayingAudio()\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        String audioDump = runAdbShell(\"dumpsys\", \"audio\", \"|\", \"grep\", \"ID:\");\n+        return audioDump.contains(\"state:started\");\n+    }\n+\n+    public VolumeInfo getMediaVolume() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getVolume(ANDROID_MEDIA_STREAM);\n+    }\n+\n+    public void setMediaVolume(int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        setVolume(ANDROID_MEDIA_STREAM, volume);\n+    }\n+\n+    public int getPowerWakeLock() throws InterruptedException, AndroidDebugBridgeDeviceException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String lockResp = runAdbShell(\"dumpsys\", \"power\", \"|\", \"grep\", \"Locks\", \"|\", \"grep\", \"'size='\");\n+        if (lockResp.contains(\"=\")) {\n+            try {\n+                return Integer.parseInt(lockResp.replace(\"\\n\", \"\").split(\"=\")[1]);\n+            } catch (NumberFormatException e) {\n+                logger.debug(\"Unable to parse device wake lock: {}\", e.getMessage());\n+            }\n+        }\n+        throw new AndroidDebugBridgeDeviceReadException(\"can read wake lock\");\n+    }\n+\n+    private void setVolume(int stream, int volume)\n+            throws AndroidDebugBridgeDeviceException, InterruptedException, TimeoutException, ExecutionException {\n+        runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--set\", String.valueOf(volume));\n+    }\n+\n+    public String getModel() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.model\");\n+    }\n+\n+    public String getAndroidVersion() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.build.version.release\");\n+    }\n+\n+    public String getBrand() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.product.brand\");\n+    }\n+\n+    public String getSerialNo() throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        return getDeviceProp(\"ro.serialno\");\n+    }\n+\n+    private String getDeviceProp(String name) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        var propValue = runAdbShell(\"getprop\", name, \"&&\", \"sleep\", \"0.3\").replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n+        if (propValue.length() == 0) {\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get device property\");\n+        }\n+        return propValue;\n+    }\n+\n+    private VolumeInfo getVolume(int stream) throws AndroidDebugBridgeDeviceException, InterruptedException,\n+            AndroidDebugBridgeDeviceReadException, TimeoutException, ExecutionException {\n+        String volumeResp = runAdbShell(\"media\", \"volume\", \"--show\", \"--stream\", String.valueOf(stream), \"--get\", \"|\",\n+                \"grep\", \"volume\");\n+        Matcher matcher = VOLUME_PATTERN.matcher(volumeResp);\n+        if (!matcher.find())\n+            throw new AndroidDebugBridgeDeviceReadException(\"Unable to get volume info\");\n+        var volumeInfo = new VolumeInfo(Integer.parseInt(matcher.group(\"current\")),\n+                Integer.parseInt(matcher.group(\"min\")), Integer.parseInt(matcher.group(\"max\")));\n+        logger.debug(\"Device {}:{} VolumeInfo: current {}, min {}, max {}\", this.ip, this.port, volumeInfo.current,\n+                volumeInfo.min, volumeInfo.max);\n+        return volumeInfo;\n+    }\n+\n+    public boolean isConnected() {\n+        var currentSocket = socket;\n+        return currentSocket != null && currentSocket.isConnected();\n+    }\n+\n+    public void connect() throws AndroidDebugBridgeDeviceException, InterruptedException {\n+        this.disconnect();\n+        AdbConnection adbConnection;\n+        Socket sock;\n+        AdbCrypto crypto = adbCrypto;\n+        if (crypto == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        try {\n+            sock = new Socket();\n+            socket = sock;\n+            sock.connect(new InetSocketAddress(ip, port), (int) TimeUnit.SECONDS.toMillis(15));\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: [{}] {}\", ip, e.getClass().getName(), e.getMessage());\n+            if (e.getMessage().equals(\"Socket closed\")) {\n+                // Connection aborted by us\n+                throw new InterruptedException();\n+            }\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open socket \" + ip + \":\" + port);\n+        }\n+        try {\n+            adbConnection = AdbConnection.create(sock, crypto);\n+            connection = adbConnection;\n+            adbConnection.connect(15, TimeUnit.SECONDS, false);\n+        } catch (IOException e) {\n+            logger.debug(\"Error connecting to {}: {}\", ip, e.getMessage());\n+            throw new AndroidDebugBridgeDeviceException(\"Can not open adb connection \" + ip + \":\" + port);\n+        }\n+    }\n+\n+    private String runAdbShell(String... args)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, TimeoutException, ExecutionException {\n+        var adb = connection;\n+        if (adb == null) {\n+            throw new AndroidDebugBridgeDeviceException(\"Device not connected\");\n+        }\n+        var commandFuture = scheduler.submit(() -> {\n+            var byteArrayOutputStream = new ByteArrayOutputStream();\n+            var cmd = String.join(\" \", args);\n+            logger.debug(\"{} - shell:{}\", ip, cmd);\n+            try {\n+                var stream = adb.open(\"shell:\" + cmd);\n+                do {\n+                    byteArrayOutputStream.writeBytes(stream.read());\n+                } while (!stream.isClosed());\n+            } catch (IOException e) {\n+                var message = e.getMessage();\n+                if (message != null && !message.equals(\"Stream closed\"))\n+                    throw e;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\nindex 56d3fdaf3e..8778fcfbbe 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDevice.java\n\n@@ -16,6 +16,7 @@ import java.io.*;\n import java.net.InetSocketAddress;\n import java.net.Socket;\n import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.security.NoSuchAlgorithmException;\n import java.security.spec.InvalidKeySpecException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5MzkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561193929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (!(inetAddress instanceof Inet4Address))\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                if (!(inetAddress instanceof Inet4Address) || inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP)) {\n          \n          \n            \n                                    continue;\n          \n          \n            \n                                }", "author": "cpmeister", "createdAt": "2021-01-20T18:46:07Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        AndroidDebugBridgeBindingConfiguration configuration = getConfig();\n+        if (configuration == null) {\n+            return;\n+        }\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning) {\n+                        break;\n+                    }\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex 8c04a38645..d5aad994bb 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -53,8 +53,8 @@ public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService\n     public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n     public static final int MAX_RETRIES = 2;\n     private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private final ConfigurationAdmin admin;\n     private boolean discoveryRunning = false;\n-    private ConfigurationAdmin admin;\n \n     @Activate\n     public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NTY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561195669", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean discoveryRunning = false;\n          \n          \n            \n                private ConfigurationAdmin admin;\n          \n          \n            \n                private final ConfigurationAdmin admin;\n          \n          \n            \n                private boolean discoveryRunning = false;", "author": "cpmeister", "createdAt": "2021-01-20T18:48:54Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex 8c04a38645..d5aad994bb 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -53,8 +53,8 @@ public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService\n     public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n     public static final int MAX_RETRIES = 2;\n     private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private final ConfigurationAdmin admin;\n     private boolean discoveryRunning = false;\n-    private ConfigurationAdmin admin;\n \n     @Activate\n     public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NzQwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561197402", "bodyText": "Since you are trying against all the network interfaces, it is expected for most of them to fail. So I think logging warning here would unnecessarily fill the logs.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());\n          \n          \n            \n                                        logger.debug(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());", "author": "cpmeister", "createdAt": "2021-01-20T18:51:39Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.util.*;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.cm.Configuration;\n+import org.osgi.service.cm.ConfigurationAdmin;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AndroidDebugBridgeDiscoveryService} discover Android ADB Instances in the network.\n+ *\n+ * @author Miguel Alvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.androiddebugbridge\")\n+public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService {\n+    static final int TIMEOUT_MS = 60000;\n+    private static final long DISCOVERY_RESULT_TTL_SEC = 300;\n+    public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n+    public static final int MAX_RETRIES = 2;\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private boolean discoveryRunning = false;\n+    private ConfigurationAdmin admin;\n+\n+    @Activate\n+    public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n+        super(SUPPORTED_THING_TYPES, TIMEOUT_MS, false);\n+        this.admin = admin;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"scan started: searching android devices\");\n+        discoveryRunning = true;\n+        Enumeration<NetworkInterface> nets;\n+        AndroidDebugBridgeBindingConfiguration configuration = getConfig();\n+        if (configuration == null) {\n+            return;\n+        }\n+        try {\n+            nets = NetworkInterface.getNetworkInterfaces();\n+            for (NetworkInterface netint : Collections.list(nets)) {\n+                Enumeration<InetAddress> inetAddresses = netint.getInetAddresses();\n+                for (InetAddress inetAddress : Collections.list(inetAddresses)) {\n+                    if (!discoveryRunning) {\n+                        break;\n+                    }\n+                    if (!(inetAddress instanceof Inet4Address))\n+                        continue;\n+                    if (inetAddress.getHostAddress().equals(LOCAL_INTERFACE_IP))\n+                        continue;\n+                    String[] ipParts = inetAddress.getHostAddress().split(\"\\\\.\");\n+                    for (int i = configuration.discoveryIpRangeMin; i <= configuration.discoveryIpRangeMax; i++) {\n+                        if (!discoveryRunning) {\n+                            break;\n+                        }\n+                        ipParts[3] = Integer.toString(i);\n+                        String currentIp = String.join(\".\", ipParts);\n+                        try {\n+                            var currentAddress = InetAddress.getByName(currentIp);\n+                            logger.debug(\"address: {}\", currentIp);\n+                            if (currentAddress.isReachable(configuration.discoveryReachableMs)) {\n+                                logger.debug(\"Reachable ip: {}\", currentIp);\n+                                int retries = 0;\n+                                while (retries < MAX_RETRIES) {\n+                                    try {\n+                                        discoverWithADB(currentIp, configuration.discoveryPort);\n+                                    } catch (AndroidDebugBridgeDeviceReadException | TimeoutException e) {\n+                                        retries++;\n+                                        if (retries < MAX_RETRIES) {\n+                                            logger.debug(\"retrying - pending {}\", MAX_RETRIES - retries);\n+                                            continue;\n+                                        }\n+                                        throw e;\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                        } catch (IOException | AndroidDebugBridgeDeviceException | AndroidDebugBridgeDeviceReadException\n+                                | TimeoutException | ExecutionException e) {\n+                            logger.warn(\"Error connecting to device at {}: {}\", currentIp, e.getMessage());", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\nindex 8c04a38645..d5aad994bb 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeDiscoveryService.java\n\n@@ -53,8 +53,8 @@ public class AndroidDebugBridgeDiscoveryService extends AbstractDiscoveryService\n     public static final String LOCAL_INTERFACE_IP = \"127.0.0.1\";\n     public static final int MAX_RETRIES = 2;\n     private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeDiscoveryService.class);\n+    private final ConfigurationAdmin admin;\n     private boolean discoveryRunning = false;\n-    private ConfigurationAdmin admin;\n \n     @Activate\n     public AndroidDebugBridgeDiscoveryService(@Reference ConfigurationAdmin admin) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5OTgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561199839", "bodyText": "You should check the cause of the ExecutionException since if it was caused by a cancellation then that would mean that the handler is getting shut down, thus you shouldn't be changing statuses or disconnecting the connection since the dispose would already be handling that.", "author": "cpmeister", "createdAt": "2021-01-20T18:55:36Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private final Gson gson;\n+    private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+        super(thing);\n+        this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null){\n+            return;\n+        }\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (InterruptedException ignored) {\n+        } catch (AndroidDebugBridgeDeviceException | ExecutionException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDeviceReadException e) {", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex d75ab2784c..245e38b90c 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -52,26 +52,23 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n     public static final String KEY_EVENT_PREVIOUS = \"88\";\n     public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n     public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n-\n+    private static final Gson GSON = new Gson();\n     private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n     private final AndroidDebugBridgeDevice adbConnection;\n     private int maxMediaVolume = 0;\n-\n-    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private AndroidDebugBridgeConfiguration config = new AndroidDebugBridgeConfiguration();\n     private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n-    private final Gson gson;\n     private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n \n-    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+    public AndroidDebugBridgeHandler(Thing thing) {\n         super(thing);\n         this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n-        this.gson = gson;\n     }\n \n     @Override\n     public void handleCommand(ChannelUID channelUID, Command command) {\n         var currentConfig = config;\n-        if (currentConfig == null){\n+        if (currentConfig == null) {\n             return;\n         }\n         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMDk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561200982", "bodyText": "You should include the exception message in the log.", "author": "cpmeister", "createdAt": "2021-01-20T18:57:24Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n+    private final Gson gson;\n+    private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n+\n+    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+        super(thing);\n+        this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        var currentConfig = config;\n+        if (currentConfig == null){\n+            return;\n+        }\n+        try {\n+            if (!adbConnection.isConnected()) {\n+                // try reconnect\n+                adbConnection.connect();\n+            }\n+            handleCommandInternal(channelUID, command);\n+        } catch (InterruptedException ignored) {\n+        } catch (AndroidDebugBridgeDeviceException | ExecutionException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            adbConnection.disconnect();\n+        } catch (AndroidDebugBridgeDeviceReadException e) {\n+            logger.warn(\"{} - read error: {}\", currentConfig.ip, e.getMessage());\n+        } catch (TimeoutException e) {\n+            logger.warn(\"{} - timeout error\", currentConfig.ip);\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException,\n+            TimeoutException, ExecutionException {\n+        if (!isLinked(channelUID)){\n+            return;\n+        }\n+        String channelId = channelUID.getId();\n+        switch (channelId) {\n+            case KEY_EVENT_CHANNEL:\n+                adbConnection.sendKeyEvent(command.toFullString());\n+                break;\n+            case TEXT_CHANNEL:\n+                adbConnection.sendText(command.toFullString());\n+                break;\n+            case MEDIA_VOLUME_CHANNEL:\n+                handleMediaVolume(channelUID, command);\n+                break;\n+            case MEDIA_CONTROL_CHANNEL:\n+                handleMediaControlCommand(channelUID, command);\n+                break;\n+            case START_PACKAGE_CHANNEL:\n+                adbConnection.startPackage(command.toFullString());\n+                updateState(new ChannelUID(this.thing.getUID(), CURRENT_PACKAGE_CHANNEL),\n+                        new StringType(command.toFullString()));\n+                break;\n+            case STOP_PACKAGE_CHANNEL:\n+                adbConnection.stopPackage(command.toFullString());\n+                break;\n+            case STOP_CURRENT_PACKAGE_CHANNEL:\n+                if (OnOffType.from(command.toFullString()).equals(OnOffType.OFF)) {\n+                    adbConnection.stopPackage(adbConnection.getCurrentPackage());\n+                }\n+                break;\n+            case CURRENT_PACKAGE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    var packageName = adbConnection.getCurrentPackage();\n+                    updateState(channelUID, new StringType(packageName));\n+                }\n+                break;\n+            case WAKE_LOCK_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    int lock = adbConnection.getPowerWakeLock();\n+                    updateState(channelUID, new DecimalType(lock));\n+                }\n+                break;\n+            case SCREEN_STATE_CHANNEL:\n+                if (command instanceof RefreshType) {\n+                    boolean screenState = adbConnection.isScreenOn();\n+                    updateState(channelUID, OnOffType.from(screenState));\n+                }\n+                break;\n+        }\n+    }\n+\n+    private void handleMediaVolume(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceReadException, AndroidDebugBridgeDeviceException,\n+            TimeoutException, ExecutionException {\n+        if (command instanceof RefreshType) {\n+            var volumeInfo = adbConnection.getMediaVolume();\n+            maxMediaVolume = volumeInfo.max;\n+            updateState(channelUID, new PercentType((int) Math.round(toPercent(volumeInfo.current, volumeInfo.max))));\n+        } else {\n+            if (maxMediaVolume == 0){\n+                return; // We can not transform percentage\n+            }\n+            int targetVolume = Integer.parseInt(command.toFullString());\n+            adbConnection.setMediaVolume((int) Math.round(fromPercent(targetVolume, maxMediaVolume)));\n+            updateState(channelUID, new PercentType(targetVolume));\n+        }\n+    }\n+\n+    private double toPercent(double value, double maxValue) {\n+        return (value / maxValue) * 100;\n+    }\n+\n+    private double fromPercent(double value, double maxValue) {\n+        return (value / 100) * maxValue;\n+    }\n+\n+    private void handleMediaControlCommand(ChannelUID channelUID, Command command)\n+            throws InterruptedException, AndroidDebugBridgeDeviceException, AndroidDebugBridgeDeviceReadException,\n+            TimeoutException, ExecutionException {\n+        if (command instanceof RefreshType) {\n+            boolean playing;\n+            String currentPackage = adbConnection.getCurrentPackage();\n+            var currentPackageConfig = packageConfigs != null ? Arrays.stream(packageConfigs)\n+                    .filter(pc -> pc.name.equals(currentPackage)).findFirst().orElse(null) : null;\n+            if (currentPackageConfig != null) {\n+                logger.debug(\"media stream config found for {}, mode: {}\", currentPackage, currentPackageConfig.mode);\n+                switch (currentPackageConfig.mode) {\n+                    case \"idle\":\n+                        playing = false;\n+                        break;\n+                    case \"wake_lock\":\n+                        int wakeLockState = adbConnection.getPowerWakeLock();\n+                        playing = currentPackageConfig.wakeLockPlayStates.contains(wakeLockState);\n+                        break;\n+                    case \"media_state\":\n+                        playing = adbConnection.isPlayingMedia(currentPackage);\n+                        break;\n+                    case \"audio\":\n+                        playing = adbConnection.isPlayingAudio();\n+                        break;\n+                    default:\n+                        logger.warn(\"media state config: package {} unsupported mode\", currentPackage);\n+                        playing = false;\n+                }\n+            } else {\n+                logger.debug(\"media stream config not found for {}\", currentPackage);\n+                playing = adbConnection.isPlayingMedia(currentPackage);\n+            }\n+            updateState(channelUID, playing ? PlayPauseType.PLAY : PlayPauseType.PAUSE);\n+        } else if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PLAY);\n+                updateState(channelUID, PlayPauseType.PLAY);\n+            } else if (command == PlayPauseType.PAUSE) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PAUSE);\n+                updateState(channelUID, PlayPauseType.PAUSE);\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_NEXT);\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_PREVIOUS);\n+            }\n+        } else if (command instanceof RewindFastforwardType) {\n+            if (command == RewindFastforwardType.FASTFORWARD) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_FAST_FORWARD);\n+            } else if (command == RewindFastforwardType.REWIND) {\n+                adbConnection.sendKeyEvent(KEY_EVENT_MEDIA_REWIND);\n+            }\n+        } else {\n+            logger.warn(\"Unknown media control command: {}\", command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        var currentConfig = getConfigAs(AndroidDebugBridgeConfiguration.class);\n+        config = currentConfig;\n+        var mediaStateJSONConfig = currentConfig.mediaStateJSONConfig;\n+        if (mediaStateJSONConfig != null && !mediaStateJSONConfig.isEmpty()) {\n+            loadMediaStateConfig(mediaStateJSONConfig);\n+        }\n+        adbConnection.configure(currentConfig.ip, currentConfig.port, currentConfig.timeout);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connectionCheckerSchedule = scheduler.scheduleWithFixedDelay(this::checkConnection, 0,\n+                currentConfig.refreshTime, TimeUnit.SECONDS);\n+    }\n+\n+    private void loadMediaStateConfig(String mediaStateJSONConfig) {\n+        try {\n+            this.packageConfigs = gson.fromJson(mediaStateJSONConfig,\n+                    AndroidDebugBridgeMediaStatePackageConfig[].class);\n+        } catch (JsonSyntaxException e) {\n+            logger.warn(\"unable to parse media state config\");", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex d75ab2784c..245e38b90c 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -52,26 +52,23 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n     public static final String KEY_EVENT_PREVIOUS = \"88\";\n     public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n     public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n-\n+    private static final Gson GSON = new Gson();\n     private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n     private final AndroidDebugBridgeDevice adbConnection;\n     private int maxMediaVolume = 0;\n-\n-    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private AndroidDebugBridgeConfiguration config = new AndroidDebugBridgeConfiguration();\n     private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n-    private final Gson gson;\n     private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n \n-    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+    public AndroidDebugBridgeHandler(Thing thing) {\n         super(thing);\n         this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n-        this.gson = gson;\n     }\n \n     @Override\n     public void handleCommand(ChannelUID channelUID, Command command) {\n         var currentConfig = config;\n-        if (currentConfig == null){\n+        if (currentConfig == null) {\n             return;\n         }\n         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMTcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561201720", "bodyText": "You can avoid making your configuration nullable by setting it to the default config initially.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable AndroidDebugBridgeConfiguration config;\n          \n          \n            \n                private AndroidDebugBridgeConfiguration config = new AndroidDebugBridgeConfiguration();", "author": "cpmeister", "createdAt": "2021-01-20T18:58:32Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AndroidDebugBridgeHandler extends BaseThingHandler {\n+\n+    public static final String KEY_EVENT_PLAY = \"126\";\n+    public static final String KEY_EVENT_PAUSE = \"127\";\n+    public static final String KEY_EVENT_NEXT = \"87\";\n+    public static final String KEY_EVENT_PREVIOUS = \"88\";\n+    public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n+    public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n+    private final AndroidDebugBridgeDevice adbConnection;\n+    private int maxMediaVolume = 0;\n+\n+    private @Nullable AndroidDebugBridgeConfiguration config;", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\nindex d75ab2784c..245e38b90c 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandler.java\n\n@@ -52,26 +52,23 @@ public class AndroidDebugBridgeHandler extends BaseThingHandler {\n     public static final String KEY_EVENT_PREVIOUS = \"88\";\n     public static final String KEY_EVENT_MEDIA_REWIND = \"89\";\n     public static final String KEY_EVENT_MEDIA_FAST_FORWARD = \"90\";\n-\n+    private static final Gson GSON = new Gson();\n     private final Logger logger = LoggerFactory.getLogger(AndroidDebugBridgeHandler.class);\n     private final AndroidDebugBridgeDevice adbConnection;\n     private int maxMediaVolume = 0;\n-\n-    private @Nullable AndroidDebugBridgeConfiguration config;\n+    private AndroidDebugBridgeConfiguration config = new AndroidDebugBridgeConfiguration();\n     private @Nullable ScheduledFuture<?> connectionCheckerSchedule;\n-    private final Gson gson;\n     private AndroidDebugBridgeMediaStatePackageConfig @Nullable [] packageConfigs = null;\n \n-    public AndroidDebugBridgeHandler(Thing thing, Gson gson) {\n+    public AndroidDebugBridgeHandler(Thing thing) {\n         super(thing);\n         this.adbConnection = new AndroidDebugBridgeDevice(scheduler);\n-        this.gson = gson;\n     }\n \n     @Override\n     public void handleCommand(ChannelUID channelUID, Command command) {\n         var currentConfig = config;\n-        if (currentConfig == null){\n+        if (currentConfig == null) {\n             return;\n         }\n         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwNDQ3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9259#discussion_r561204475", "bodyText": "Instead of defining this here, define it in the AndroidDebugBridgeHandler as a static final constant.", "author": "cpmeister", "createdAt": "2021-01-20T19:03:28Z", "path": "bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.androiddebugbridge.internal;\n+\n+import static org.openhab.binding.androiddebugbridge.internal.AndroidDebugBridgeBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Miguel \u00c1lvarez - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = BINDING_CONFIGURATION_PID, service = ThingHandlerFactory.class)\n+public class AndroidDebugBridgeHandlerFactory extends BaseThingHandlerFactory {\n+    Gson gson = new Gson();", "originalCommit": "9674b9ab2953cb250954a6102baf08763faa6b3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "chunk": "diff --git a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\nindex d07cc9862e..761ab5a4b9 100644\n--- a/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\n+++ b/bundles/org.openhab.binding.androiddebugbridge/src/main/java/org/openhab/binding/androiddebugbridge/internal/AndroidDebugBridgeHandlerFactory.java\n\n@@ -23,8 +23,6 @@ import org.openhab.core.thing.binding.ThingHandler;\n import org.openhab.core.thing.binding.ThingHandlerFactory;\n import org.osgi.service.component.annotations.Component;\n \n-import com.google.gson.Gson;\n-\n /**\n  * The {@link AndroidDebugBridgeHandlerFactory} is responsible for creating things and thing\n  * handlers.\n"}}, {"oid": "d89cd4b00101df472b19eaaee4614ceb60ba5750", "url": "https://github.com/openhab/openhab-addons/commit/d89cd4b00101df472b19eaaee4614ceb60ba5750", "message": "apply pr review\n\nSigned-off-by: Miguel <miguelwork92@gmail.com>", "committedDate": "2021-01-20T21:11:31Z", "type": "commit"}]}