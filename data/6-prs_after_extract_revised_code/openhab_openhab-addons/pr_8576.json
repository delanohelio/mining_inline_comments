{"pr_number": 8576, "pr_title": "[BMW ConnectedDrive] initial contribution", "pr_createdAt": "2020-09-24T22:12:45Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8576", "timeline": [{"oid": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "url": "https://github.com/openhab/openhab-addons/commit/c45fde8fb30a91942ddfebf0880638d55634e9a6", "message": "Merge pull request #15 from ntruchsess/bmw-connected-drive-renameactions\n\nrename actions-scope as requested by @kaikreuzer", "committedDate": "2021-04-11T21:06:48Z", "type": "commit"}, {"oid": "afd5b16f5c0f474d9d0d10c15af80ab2b1954d8a", "url": "https://github.com/openhab/openhab-addons/commit/afd5b16f5c0f474d9d0d10c15af80ab2b1954d8a", "message": "correct Actions section in readme\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-04-11T21:26:49Z", "type": "commit"}, {"oid": "db78bab2051fc41a8411035b8bda8f4bd6dcb9a4", "url": "https://github.com/openhab/openhab-addons/commit/db78bab2051fc41a8411035b8bda8f4bd6dcb9a4", "message": "descriptions were swapped\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-04-12T07:33:49Z", "type": "commit"}, {"oid": "dd50d7ed5c3ab1aed876bc8eb1b303e87bc1a728", "url": "https://github.com/openhab/openhab-addons/commit/dd50d7ed5c3ab1aed876bc8eb1b303e87bc1a728", "message": "Merge pull request #16 from ntruchsess/bmw-connected-drive-readme\n\ndescriptions in readme were swapped", "committedDate": "2021-04-12T07:41:14Z", "type": "commit"}, {"oid": "ac539e837ce75a05cff7b07f152bf240893c0084", "url": "https://github.com/openhab/openhab-addons/commit/ac539e837ce75a05cff7b07f152bf240893c0084", "message": "remove logo and author from documentation\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-05-01T11:07:28Z", "type": "commit"}, {"oid": "972380ce05315945ac5b6404381333bb88ea1b20", "url": "https://github.com/openhab/openhab-addons/commit/972380ce05315945ac5b6404381333bb88ea1b20", "message": "update servers and constants due to changed authorization\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:28Z", "type": "commit"}, {"oid": "1f0954567c5f8482acb6ec8966055a8c82916ab5", "url": "https://github.com/openhab/openhab-addons/commit/1f0954567c5f8482acb6ec8966055a8c82916ab5", "message": "correct readme.md according to code changes\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:28Z", "type": "commit"}, {"oid": "43d4c34c03f2c699ef1c8218ee8b0fdab7c6221e", "url": "https://github.com/openhab/openhab-addons/commit/43d4c34c03f2c699ef1c8218ee8b0fdab7c6221e", "message": "solve checkstyle warnings\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:29Z", "type": "commit"}, {"oid": "b80c64046a765bfad892e5d2d6e7533a3660b89e", "url": "https://github.com/openhab/openhab-addons/commit/b80c64046a765bfad892e5d2d6e7533a3660b89e", "message": "shorten some channel ids\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:30Z", "type": "commit"}, {"oid": "de0db3706bb16a0db924ee3ca0f42b4b7230ed44", "url": "https://github.com/openhab/openhab-addons/commit/de0db3706bb16a0db924ee3ca0f42b4b7230ed44", "message": "remove fingerprint channel leftovers\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:31Z", "type": "commit"}, {"oid": "e67a72b9afcbf40a5bfba059296ec3df06f9c914", "url": "https://github.com/openhab/openhab-addons/commit/e67a72b9afcbf40a5bfba059296ec3df06f9c914", "message": "label bugfixes\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:31Z", "type": "commit"}, {"oid": "0bc45b2921f6bba6c3640f6fd0e9afc899abfcc1", "url": "https://github.com/openhab/openhab-addons/commit/0bc45b2921f6bba6c3640f6fd0e9afc899abfcc1", "message": "title case adaptions plus minor bugfixes\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:33Z", "type": "commit"}, {"oid": "292bb6809d2646b34415aabab4ff69ccdab6f973", "url": "https://github.com/openhab/openhab-addons/commit/292bb6809d2646b34415aabab4ff69ccdab6f973", "message": "harmonize readme.md and solved some compiler warnings\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:33Z", "type": "commit"}, {"oid": "7a8d4cdfd81b911712f9ec7b117b4c90dbc10686", "url": "https://github.com/openhab/openhab-addons/commit/7a8d4cdfd81b911712f9ec7b117b4c90dbc10686", "message": "introduce TimeZonePRovider\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:34Z", "type": "commit"}, {"oid": "6ed53d3172ea2406e9af10d6ec7ffcf9f7105071", "url": "https://github.com/openhab/openhab-addons/commit/6ed53d3172ea2406e9af10d6ec7ffcf9f7105071", "message": "readme corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:35Z", "type": "commit"}, {"oid": "f7241d8409eda6e0bc227b8e2436db120a977546", "url": "https://github.com/openhab/openhab-addons/commit/f7241d8409eda6e0bc227b8e2436db120a977546", "message": "correct review findings\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:36Z", "type": "commit"}, {"oid": "c183cf3a4880d9fef7d2f8d93c559610a2173c83", "url": "https://github.com/openhab/openhab-addons/commit/c183cf3a4880d9fef7d2f8d93c559610a2173c83", "message": "imperial handling for statistuc values\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:37Z", "type": "commit"}, {"oid": "85e828b8eec6d9f3341dd2de51bb1b7cd43a91b3", "url": "https://github.com/openhab/openhab-addons/commit/85e828b8eec6d9f3341dd2de51bb1b7cd43a91b3", "message": "ensure channel label & id <= 25 chars\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:38Z", "type": "commit"}, {"oid": "dce959b5fe08439d3bf97b2d9ea0b8a6392a00e9", "url": "https://github.com/openhab/openhab-addons/commit/dce959b5fe08439d3bf97b2d9ea0b8a6392a00e9", "message": "update readme refs to thing-configuration\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:39Z", "type": "commit"}, {"oid": "61acc7f909755b7bae592699723fc28f5368722d", "url": "https://github.com/openhab/openhab-addons/commit/61acc7f909755b7bae592699723fc28f5368722d", "message": "remove local gitignore\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:39Z", "type": "commit"}, {"oid": "fb398b1ea45fd143959c6e02cd034571a27a8f56", "url": "https://github.com/openhab/openhab-addons/commit/fb398b1ea45fd143959c6e02cd034571a27a8f56", "message": "Use QuantityType to convert km values into mi\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:40Z", "type": "commit"}, {"oid": "f026bb546a2bfa5775c7efef95b5288acbc2ba2d", "url": "https://github.com/openhab/openhab-addons/commit/f026bb546a2bfa5775c7efef95b5288acbc2ba2d", "message": "select int index instead of string value\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:41Z", "type": "commit"}, {"oid": "d09988b42c886d1cd3e1534edb7cb4e66215f725", "url": "https://github.com/openhab/openhab-addons/commit/d09988b42c886d1cd3e1534edb7cb4e66215f725", "message": "improve address conversion and undef values\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:41Z", "type": "commit"}, {"oid": "99b3a159c14cfec55f3a7194e743ce46e090927a", "url": "https://github.com/openhab/openhab-addons/commit/99b3a159c14cfec55f3a7194e743ce46e090927a", "message": "implement edit and send of ChargeProfile\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:42Z", "type": "commit"}, {"oid": "54e737a43ceea68cd850f4c94bc67232d906b321", "url": "https://github.com/openhab/openhab-addons/commit/54e737a43ceea68cd850f4c94bc67232d906b321", "message": "adapt ChargeProfileTest to latest changes\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:43Z", "type": "commit"}, {"oid": "125d3f6f9587f3deb9c91426fcc6ea1d133654b4", "url": "https://github.com/openhab/openhab-addons/commit/125d3f6f9587f3deb9c91426fcc6ea1d133654b4", "message": "update channel state when receiving commands (fixes UI not updating on change of hours/minutes)\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:44Z", "type": "commit"}, {"oid": "b30a9a0a9bdda6fc3990582f412d83156fb49801", "url": "https://github.com/openhab/openhab-addons/commit/b30a9a0a9bdda6fc3990582f412d83156fb49801", "message": "add pattern to channel-type states, revert last change\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:45Z", "type": "commit"}, {"oid": "4eef45af3775b674fde0cad7b3592fd7c837f712", "url": "https://github.com/openhab/openhab-addons/commit/4eef45af3775b674fde0cad7b3592fd7c837f712", "message": "refactoring charge-profile-handling into separate method\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:46Z", "type": "commit"}, {"oid": "659741d953414475c4d2fd78a49566aa7ac55cd0", "url": "https://github.com/openhab/openhab-addons/commit/659741d953414475c4d2fd78a49566aa7ac55cd0", "message": "some beautification\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:48Z", "type": "commit"}, {"oid": "c1108ee5f341b439e740f85b2d816941a4bc13ee", "url": "https://github.com/openhab/openhab-addons/commit/c1108ee5f341b439e740f85b2d816941a4bc13ee", "message": "use Map.of when declaring constant\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:50Z", "type": "commit"}, {"oid": "ab2841b342ea845f4650e426928a80bba7edbf03", "url": "https://github.com/openhab/openhab-addons/commit/ab2841b342ea845f4650e426928a80bba7edbf03", "message": "refactoring plus addition of ChargeProfile Action\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:54Z", "type": "commit"}, {"oid": "b1f68d812f9f514985f5f9a9d1135cf12a3584fb", "url": "https://github.com/openhab/openhab-addons/commit/b1f68d812f9f514985f5f9a9d1135cf12a3584fb", "message": "fix skip of charge-profile-command handling if no profile has been received yet\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:56Z", "type": "commit"}, {"oid": "bc96c4246f78568c44a980d7d2a5744aa34828b3", "url": "https://github.com/openhab/openhab-addons/commit/bc96c4246f78568c44a980d7d2a5744aa34828b3", "message": "codeowners\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:57Z", "type": "commit"}, {"oid": "230b981f6ede6fb876b9b17c2d7c52e7c7e18736", "url": "https://github.com/openhab/openhab-addons/commit/230b981f6ede6fb876b9b17c2d7c52e7c7e18736", "message": "some cleanup and logging\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:58Z", "type": "commit"}, {"oid": "47931e6e3b7e86f1ed1ddd0a245adbe34473518c", "url": "https://github.com/openhab/openhab-addons/commit/47931e6e3b7e86f1ed1ddd0a245adbe34473518c", "message": "add remaining charging time\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:58Z", "type": "commit"}, {"oid": "2b2ebe1beb9bfe1648284ad0f41cff4077a5d40c", "url": "https://github.com/openhab/openhab-addons/commit/2b2ebe1beb9bfe1648284ad0f41cff4077a5d40c", "message": "some cleanup of nullable, more functional use of Optional\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:59Z", "type": "commit"}, {"oid": "9a759fc93068fad01fe71482ed7611c9bb8d6348", "url": "https://github.com/openhab/openhab-addons/commit/9a759fc93068fad01fe71482ed7611c9bb8d6348", "message": "minor cleanup of leftovers\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:00Z", "type": "commit"}, {"oid": "f6eeb781e79ab18997dd4ae400456912d59f7f0d", "url": "https://github.com/openhab/openhab-addons/commit/f6eeb781e79ab18997dd4ae400456912d59f7f0d", "message": "fix Optional as parameter and use of Option.isPresent + get() antipattern\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:01Z", "type": "commit"}, {"oid": "742985162a157fceccb0c7143bd232b7608e82da", "url": "https://github.com/openhab/openhab-addons/commit/742985162a157fceccb0c7143bd232b7608e82da", "message": "fix more Optional as parameter antipattern\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:01Z", "type": "commit"}, {"oid": "243030067002ef53f9b2741d84a6e7c713a8f4ce", "url": "https://github.com/openhab/openhab-addons/commit/243030067002ef53f9b2741d84a6e7c713a8f4ce", "message": "fix byte[] cannot be @Nullable\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:02Z", "type": "commit"}, {"oid": "c6f48ca61ca50b2e075d96cfc7b25485409749b0", "url": "https://github.com/openhab/openhab-addons/commit/c6f48ca61ca50b2e075d96cfc7b25485409749b0", "message": "use java standard classes (DayOfWeek, Boolean, String) as paramters/retvalues in ChargeProfileActions\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:03Z", "type": "commit"}, {"oid": "edb650e3054c8fe86c8acb33458b182d9e41122d", "url": "https://github.com/openhab/openhab-addons/commit/edb650e3054c8fe86c8acb33458b182d9e41122d", "message": "cleanup\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:03Z", "type": "commit"}, {"oid": "bed6ecf7dead07fc85128ce945ec339be90517cf", "url": "https://github.com/openhab/openhab-addons/commit/bed6ecf7dead07fc85128ce945ec339be90517cf", "message": "Add missing example item\ni3OverrideEnabled was present in the example sitemap but missing in the example items\n\nSigned-off-by: Matt Cholawo <m.cholawo@gmail.com>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:04Z", "type": "commit"}, {"oid": "4e7d287223ce386662cc82c66b790ac9636aecde", "url": "https://github.com/openhab/openhab-addons/commit/4e7d287223ce386662cc82c66b790ac9636aecde", "message": "fixing review comments\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:05Z", "type": "commit"}, {"oid": "465f3663f6db0b8bb774598f060f2271b2ecc9b4", "url": "https://github.com/openhab/openhab-addons/commit/465f3663f6db0b8bb774598f060f2271b2ecc9b4", "message": "fixing review comments (channelUIDs are now dynamic)\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:05Z", "type": "commit"}, {"oid": "09e73dec528090e23b2a4ac60d21a0b1b53ab9e6", "url": "https://github.com/openhab/openhab-addons/commit/09e73dec528090e23b2a4ac60d21a0b1b53ab9e6", "message": "fix unnessary use of StringBuilder and Optional as parameter antipattern\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:06Z", "type": "commit"}, {"oid": "66a59c764d464df21d56d2e25b4440ce1954df05", "url": "https://github.com/openhab/openhab-addons/commit/66a59c764d464df21d56d2e25b4440ce1954df05", "message": "fix further missing JsonSyntaxException-handling\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:07Z", "type": "commit"}, {"oid": "af4d27b51a1597d4a7cee4e205ffb4307629de51", "url": "https://github.com/openhab/openhab-addons/commit/af4d27b51a1597d4a7cee4e205ffb4307629de51", "message": "fix NoSuchElementException\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:08Z", "type": "commit"}, {"oid": "d816b48da3ece6b3818d8a0f6cbba3f977e046a9", "url": "https://github.com/openhab/openhab-addons/commit/d816b48da3ece6b3818d8a0f6cbba3f977e046a9", "message": "fix potential Optional.of NullPointerException\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:08Z", "type": "commit"}, {"oid": "8f205dfaa8e244e73545e06e97ba63c926952cc8", "url": "https://github.com/openhab/openhab-addons/commit/8f205dfaa8e244e73545e06e97ba63c926952cc8", "message": "fix more Optional.ifPresent -> Optional.get antipattern\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:09Z", "type": "commit"}, {"oid": "93d5663102a6235ee7f3d0a7708ab8d578f2103b", "url": "https://github.com/openhab/openhab-addons/commit/93d5663102a6235ee7f3d0a7708ab8d578f2103b", "message": "use streaming api to join days\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:10Z", "type": "commit"}, {"oid": "2325d3d6bec49033ae002267a227a17aef9fd4a2", "url": "https://github.com/openhab/openhab-addons/commit/2325d3d6bec49033ae002267a227a17aef9fd4a2", "message": "move metadata-classes to ChargeProfileUtils\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:11Z", "type": "commit"}, {"oid": "8ded9287e1f5921038788deabb2c710d6610d0aa", "url": "https://github.com/openhab/openhab-addons/commit/8ded9287e1f5921038788deabb2c710d6610d0aa", "message": "fix racecondition resulting in 'NoSuchElementException: No value present'\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:11Z", "type": "commit"}, {"oid": "1d0ad87933789bcefbc30ca6aa8238f48f32bae2", "url": "https://github.com/openhab/openhab-addons/commit/1d0ad87933789bcefbc30ca6aa8238f48f32bae2", "message": "fix redundant refresh of GROUP_LASTTRIP, include GROUP_DESTINATION into refresh\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:12Z", "type": "commit"}, {"oid": "f0f0b207be188cd414143036542cb7d7a56fb4e5", "url": "https://github.com/openhab/openhab-addons/commit/f0f0b207be188cd414143036542cb7d7a56fb4e5", "message": "solve remaining checkstyle issues\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:13Z", "type": "commit"}, {"oid": "1a206dfef877ca6d8533e03fdada97db373f9785", "url": "https://github.com/openhab/openhab-addons/commit/1a206dfef877ca6d8533e03fdada97db373f9785", "message": "adapt readme, added service and checkcontrol details\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:14Z", "type": "commit"}, {"oid": "5ad27cf59869a63d8fd8c3054a703ff2969d1e3b", "url": "https://github.com/openhab/openhab-addons/commit/5ad27cf59869a63d8fd8c3054a703ff2969d1e3b", "message": "missing translations added\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:14Z", "type": "commit"}, {"oid": "838de39fa56608effe399070296e89d60ac071e8", "url": "https://github.com/openhab/openhab-addons/commit/838de39fa56608effe399070296e89d60ac071e8", "message": "Bugfix Service Details\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:15Z", "type": "commit"}, {"oid": "91e8264177256316e60ed3dca7124752b106a8b8", "url": "https://github.com/openhab/openhab-addons/commit/91e8264177256316e60ed3dca7124752b106a8b8", "message": "reduce info logging\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:16Z", "type": "commit"}, {"oid": "0a35f611038c2b63175bc5039010e51f9f55fb98", "url": "https://github.com/openhab/openhab-addons/commit/0a35f611038c2b63175bc5039010e51f9f55fb98", "message": "readme adaptions\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:16Z", "type": "commit"}, {"oid": "ef163d93767275c213eb73ed9382feb7bb088e7e", "url": "https://github.com/openhab/openhab-addons/commit/ef163d93767275c213eb73ed9382feb7bb088e7e", "message": "solve review comments\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:17Z", "type": "commit"}, {"oid": "a0e5315eb991a8026be943d7b014ec4a9ba7c12c", "url": "https://github.com/openhab/openhab-addons/commit/a0e5315eb991a8026be943d7b014ec4a9ba7c12c", "message": "correct pom.xml format\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:18Z", "type": "commit"}, {"oid": "ea0ddbe3e0eee3167cfb3629b03b3e200c41eb3b", "url": "https://github.com/openhab/openhab-addons/commit/ea0ddbe3e0eee3167cfb3629b03b3e200c41eb3b", "message": "dynamic RemoteService-command options\n\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:19Z", "type": "commit"}, {"oid": "cb33d0be617b2ede6256e01ff9045c089124696a", "url": "https://github.com/openhab/openhab-addons/commit/cb33d0be617b2ede6256e01ff9045c089124696a", "message": "review corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:20Z", "type": "commit"}, {"oid": "262f0bc5faa91690c7fcbdf5ae92b8a653da8592", "url": "https://github.com/openhab/openhab-addons/commit/262f0bc5faa91690c7fcbdf5ae92b8a653da8592", "message": "solve checkstyle issues of RemoteServiceUtils\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:20Z", "type": "commit"}, {"oid": "48ace3af1f1f3da5e91e4f43262827dfc6ff8ea1", "url": "https://github.com/openhab/openhab-addons/commit/48ace3af1f1f3da5e91e4f43262827dfc6ff8ea1", "message": "fixing handling of NonNull result of getConfigAs\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:21Z", "type": "commit"}, {"oid": "59d6403be7ba6a8a6e993f165797ac11e56facb1", "url": "https://github.com/openhab/openhab-addons/commit/59d6403be7ba6a8a6e993f165797ac11e56facb1", "message": "fix use of defaultCharset being platform-dependant\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:22Z", "type": "commit"}, {"oid": "ec67d8ef85c508a897adcdcef43fb71abffa3c2c", "url": "https://github.com/openhab/openhab-addons/commit/ec67d8ef85c508a897adcdcef43fb71abffa3c2c", "message": "fix import\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:23Z", "type": "commit"}, {"oid": "c7351f71289cb948047b771d110a59cf8c59dda9", "url": "https://github.com/openhab/openhab-addons/commit/c7351f71289cb948047b771d110a59cf8c59dda9", "message": "fix log of stacktrace\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:23Z", "type": "commit"}, {"oid": "2203c9b464eb0c90be257ba10356d1ebb75f19dc", "url": "https://github.com/openhab/openhab-addons/commit/2203c9b464eb0c90be257ba10356d1ebb75f19dc", "message": "fix reponse-type handling\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:24Z", "type": "commit"}, {"oid": "ecf35cf7b8492fc8067778ccc4dca250e2ce8a82", "url": "https://github.com/openhab/openhab-addons/commit/ecf35cf7b8492fc8067778ccc4dca250e2ce8a82", "message": "fix state-retrieval future not canceled on ThingHandler.dispose\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:25Z", "type": "commit"}, {"oid": "b91dbe05e136a5d29208dc79cf1f7109a334bde8", "url": "https://github.com/openhab/openhab-addons/commit/b91dbe05e136a5d29208dc79cf1f7109a334bde8", "message": "fix getConfigAs being not Nullable\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:26Z", "type": "commit"}, {"oid": "e51254aa3ca3995c1e80b84dd85f6e3bf8316593", "url": "https://github.com/openhab/openhab-addons/commit/e51254aa3ca3995c1e80b84dd85f6e3bf8316593", "message": "fix editTimeout not being canceled in dispose\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:26Z", "type": "commit"}, {"oid": "ca5afb04d9f3b710e145cbb564a87c93d8ab192d", "url": "https://github.com/openhab/openhab-addons/commit/ca5afb04d9f3b710e145cbb564a87c93d8ab192d", "message": "fix obsolete if (..) return true else return false\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:27Z", "type": "commit"}, {"oid": "2f150afe4ccf6d745f22ebeaa7e9751256b47cd7", "url": "https://github.com/openhab/openhab-addons/commit/2f150afe4ccf6d745f22ebeaa7e9751256b47cd7", "message": "fix use of Constant.SPACE and StringBuilder\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:28Z", "type": "commit"}, {"oid": "5ad8ba2218b6ca47c108f2783d6300fce2b3c4f9", "url": "https://github.com/openhab/openhab-addons/commit/5ad8ba2218b6ca47c108f2783d6300fce2b3c4f9", "message": "fix syntactical sugar in lambdas\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-03-29T01:49:28Z", "type": "commit"}, {"oid": "3632b78430708776a9cdadb4d946e45424bb0930", "url": "https://github.com/openhab/openhab-addons/commit/3632b78430708776a9cdadb4d946e45424bb0930", "message": "Merge pull request #7 from ntruchsess/bmw-connected-drive-finding1\n\nfixing handling of NonNull result of getConfigAs", "committedDate": "2021-03-29T01:49:29Z", "type": "commit"}, {"oid": "ef04a36f4221f3cdff59cf02ecaf78f5189e6e1d", "url": "https://github.com/openhab/openhab-addons/commit/ef04a36f4221f3cdff59cf02ecaf78f5189e6e1d", "message": "Merge pull request #8 from ntruchsess/bmw-connected-drive-finding2\n\nfix use of defaultCharset being platform-dependant", "committedDate": "2021-03-29T01:49:30Z", "type": "commit"}, {"oid": "950d7c14fb6aab26c8bc53af3c7684c9944b1a4a", "url": "https://github.com/openhab/openhab-addons/commit/950d7c14fb6aab26c8bc53af3c7684c9944b1a4a", "message": "Merge pull request #9 from ntruchsess/bmw-connected-drive-finding3\n\nfix state-retrieval future not canceled on ThingHandler.dispose", "committedDate": "2021-03-29T01:49:30Z", "type": "commit"}, {"oid": "82fb2ba4b56a2fac5c0f839df535b8ca44a24d29", "url": "https://github.com/openhab/openhab-addons/commit/82fb2ba4b56a2fac5c0f839df535b8ca44a24d29", "message": "Merge pull request #10 from ntruchsess/bmw-connected-drive-finding4\n\nfix getConfigAs being not Nullable", "committedDate": "2021-03-29T01:49:31Z", "type": "commit"}, {"oid": "950f07093300af3957efe24b7525f223254dd0a1", "url": "https://github.com/openhab/openhab-addons/commit/950f07093300af3957efe24b7525f223254dd0a1", "message": "Merge pull request #11 from ntruchsess/bmw-connected-drive-finding5\n\nfix syntactical sugar in lambdas", "committedDate": "2021-03-29T01:49:32Z", "type": "commit"}, {"oid": "d87929e50179aad20883d2e520b5ca399c15df69", "url": "https://github.com/openhab/openhab-addons/commit/d87929e50179aad20883d2e520b5ca399c15df69", "message": "solve review comments\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:32Z", "type": "commit"}, {"oid": "c794022caaca0870f223a993ca576f4618be01a6", "url": "https://github.com/openhab/openhab-addons/commit/c794022caaca0870f223a993ca576f4618be01a6", "message": "revert Action renaming until review comment is clarified\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:33Z", "type": "commit"}, {"oid": "95051e8e471f8279ab1c98fb66043e3bd24295b9", "url": "https://github.com/openhab/openhab-addons/commit/95051e8e471f8279ab1c98fb66043e3bd24295b9", "message": "solve further review findings\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:34Z", "type": "commit"}, {"oid": "24eb066979237f49b1225618f6acba4c4e7ea0ec", "url": "https://github.com/openhab/openhab-addons/commit/24eb066979237f49b1225618f6acba4c4e7ea0ec", "message": "solve further review comments\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:35Z", "type": "commit"}, {"oid": "f83b0ada9f5cd12620a5c247af257d94f8921910", "url": "https://github.com/openhab/openhab-addons/commit/f83b0ada9f5cd12620a5c247af257d94f8921910", "message": "Bugfix: legacy mode\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:36Z", "type": "commit"}, {"oid": "a3234a7929752fbd679e01dbe0553825a65d8b6f", "url": "https://github.com/openhab/openhab-addons/commit/a3234a7929752fbd679e01dbe0553825a65d8b6f", "message": "improve error handling\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:36Z", "type": "commit"}, {"oid": "570b80b817a52aad914f324996e58f694c868e29", "url": "https://github.com/openhab/openhab-addons/commit/570b80b817a52aad914f324996e58f694c868e29", "message": "review findings error logging\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:37Z", "type": "commit"}, {"oid": "d9aefdb20b4153e727f208daca9ad374739fac6b", "url": "https://github.com/openhab/openhab-addons/commit/d9aefdb20b4153e727f208daca9ad374739fac6b", "message": "correct undef handling\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:38Z", "type": "commit"}, {"oid": "a1a1650bc1870894fa4ba4d8f67eda5f132022a2", "url": "https://github.com/openhab/openhab-addons/commit/a1a1650bc1870894fa4ba4d8f67eda5f132022a2", "message": "fix translations\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:39Z", "type": "commit"}, {"oid": "91f7f261d40d626028ef8daf7027a76198424a40", "url": "https://github.com/openhab/openhab-addons/commit/91f7f261d40d626028ef8daf7027a76198424a40", "message": "xml review finding corrections\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:40Z", "type": "commit"}, {"oid": "bf1df0754bc0f53107886ef3f4e1945a251dd841", "url": "https://github.com/openhab/openhab-addons/commit/bf1df0754bc0f53107886ef3f4e1945a251dd841", "message": "move config declaration into separate files\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:41Z", "type": "commit"}, {"oid": "275dc932fbda0e22f8225bab466f2515edc1e3be", "url": "https://github.com/openhab/openhab-addons/commit/275dc932fbda0e22f8225bab466f2515edc1e3be", "message": "shorten labels for things and channels\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:42Z", "type": "commit"}, {"oid": "03f4787e5360aaa452c7edf81800a5521341fe02", "url": "https://github.com/openhab/openhab-addons/commit/03f4787e5360aaa452c7edf81800a5521341fe02", "message": "add state tags to channels\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:43Z", "type": "commit"}, {"oid": "03f4787e5360aaa452c7edf81800a5521341fe02", "url": "https://github.com/openhab/openhab-addons/commit/03f4787e5360aaa452c7edf81800a5521341fe02", "message": "add state tags to channels\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:49:43Z", "type": "forcePushed"}, {"oid": "59865cf56f626eaabf6bdbb10d3a9190fa43435a", "url": "https://github.com/openhab/openhab-addons/commit/59865cf56f626eaabf6bdbb10d3a9190fa43435a", "message": "writable datetime channels for charge profile\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-04-03T10:38:32Z", "type": "commit"}, {"oid": "64813ea3c24871b12f0b7fcca8cf8be80b89e88b", "url": "https://github.com/openhab/openhab-addons/commit/64813ea3c24871b12f0b7fcca8cf8be80b89e88b", "message": "editable DateTimeType-channels, removal of minute and hour-channels\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-04-03T12:40:58Z", "type": "commit"}, {"oid": "b53dd5f943811a2b00101c7c441011e24a31e354", "url": "https://github.com/openhab/openhab-addons/commit/b53dd5f943811a2b00101c7c441011e24a31e354", "message": "channel-type-definitions & documentation-update\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-04-03T14:08:12Z", "type": "commit"}, {"oid": "0801bead13de0e5777c9f07c4f18357c1023afa6", "url": "https://github.com/openhab/openhab-addons/commit/0801bead13de0e5777c9f07c4f18357c1023afa6", "message": "Merge pull request #13 from ntruchsess/bmw-connected-drive-datetime\n\neditable DateTimeType-channels, removal of minute and hour-channels", "committedDate": "2021-04-03T15:01:09Z", "type": "commit"}, {"oid": "c368dc0c012446d0090f25c84784198436ae68de", "url": "https://github.com/openhab/openhab-addons/commit/c368dc0c012446d0090f25c84784198436ae68de", "message": "rules for editing datetimes in sitemap\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-04-04T11:17:16Z", "type": "commit"}, {"oid": "094538b768fce3eb928c22df10de540bfadd3599", "url": "https://github.com/openhab/openhab-addons/commit/094538b768fce3eb928c22df10de540bfadd3599", "message": "Merge pull request #14 from ntruchsess/bmw-connected-drive-datetime-rules\n\nrules for editing datetimes in sitemap", "committedDate": "2021-04-05T15:34:34Z", "type": "commit"}, {"oid": "420dae39cafb44ef91fcae768214e983047903c8", "url": "https://github.com/openhab/openhab-addons/commit/420dae39cafb44ef91fcae768214e983047903c8", "message": "bugfix: set legacy mode only one time\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-04-09T15:44:05Z", "type": "commit"}, {"oid": "1156d891ed24218989a88e90519b827f8480a7be", "url": "https://github.com/openhab/openhab-addons/commit/1156d891ed24218989a88e90519b827f8480a7be", "message": "add missing translation\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-04-09T15:44:25Z", "type": "commit"}, {"oid": "5876481a43950f941b56d4995dfc699f074f734a", "url": "https://github.com/openhab/openhab-addons/commit/5876481a43950f941b56d4995dfc699f074f734a", "message": "rename actions-scope as requested by @kaikreuzer\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-04-11T12:51:00Z", "type": "commit"}, {"oid": "f2a23ec9b3a2b782df8eb5873986cfcaf249f9c0", "url": "https://github.com/openhab/openhab-addons/commit/f2a23ec9b3a2b782df8eb5873986cfcaf249f9c0", "message": "adjust README to renames of actions\nSigned-off-by: Norbert Truchsess <norbert.truchsess@t-online.de>", "committedDate": "2021-04-11T12:56:23Z", "type": "commit"}, {"oid": "d22be417458242c66b653206444573208bf97376", "url": "https://github.com/openhab/openhab-addons/commit/d22be417458242c66b653206444573208bf97376", "message": "Injector added to simulate different Vehicles\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2020-10-05T07:14:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528088145", "bodyText": "Please use Set.of instead. Apply elsewhere  where applicable.", "author": "cpmeister", "createdAt": "2020-11-21T06:43:25Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL = 5;\n+    public static final String DEFAULT_IMAGE_VIEWPORT = \"FRONT\";\n+\n+    // See constants from bimmer-connected\n+    // https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/vehicle.py\n+    public enum VehicleType {\n+        CONVENTIONAL(\"CONV\"),\n+        PLUGIN_HYBRID(\"PHEV\"),\n+        ELECTRIC_REX(\"BEV_REX\"),\n+        ELECTRIC(\"BEV\");\n+\n+        private final String type;\n+\n+        VehicleType(String s) {\n+            type = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type;\n+        }\n+    }\n+\n+    public static final Set<String> FUEL_VEHICLES = new HashSet<String>() {", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxMzg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529013880", "bodyText": "Corrected.", "author": "weymann", "createdAt": "2020-11-23T21:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4ODE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\nindex 45f1532331..31e22c4a09 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4OTc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528089785", "bodyText": "properties shouldn't have spaces in their names.", "author": "cpmeister", "createdAt": "2020-11-21T06:45:41Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+// @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.bmwconnecteddrive\")\n+public class VehicleDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+\n+    private ConnectedDriveBridgeHandler bridgeHandler;\n+\n+    public VehicleDiscovery(ConnectedDriveBridgeHandler bh) {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+        bridgeHandler = bh;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.requestVehicles();\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+            // the DriveTrain field in the delivered json is defining the Vehicle Type\n+            String vehicleType = vehicle.driveTrain;\n+            SUPPORTED_THING_SET.forEach(entry -> {\n+                if (entry.getId().equals(vehicleType)) {\n+                    ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                    Map<String, String> properties = new HashMap<>();\n+                    // Dealer\n+                    if (vehicle.dealer != null) {\n+                        properties.put(\"Dealer\", vehicle.dealer.name);\n+                        properties.put(\"Dealer Address\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                        properties.put(\"Dealer Phone\", vehicle.dealer.phone);\n+                    }\n+\n+                    // Services & Support\n+                    properties.put(\"Services Activated\", getObject(vehicle, Constants.ACTIVATED));\n+                    String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                    String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                    if (vehicle.statisticsAvailable) {\n+                        servicesSupported += Constants.STATISTICS;\n+                    } else {\n+                        servicesNotSupported += Constants.STATISTICS;\n+                    }\n+                    properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                    properties.put(\"Services Not Supported\", servicesNotSupported);\n+                    properties.put(\"Support Breakdown Number\", vehicle.breakdownNumber);\n+\n+                    // Vehicle Properties\n+                    if (vehicle.supportedChargingModes != null) {\n+                        StringBuffer chargingModes = new StringBuffer();\n+                        vehicle.supportedChargingModes.forEach(e -> {\n+                            chargingModes.append(e).append(Constants.SPACE);\n+                        });\n+                        properties.put(\"Vehicle Charge Modes\", chargingModes.toString());\n+                    }\n+                    if (vehicle.hasAlarmSystem) {\n+                        properties.put(\"Vehicle Alarm System\", \"Available\");\n+                    } else {\n+                        properties.put(\"Vehicle Alarm System\", \"Not Available\");\n+                    }\n+                    properties.put(\"Vehicle Brand\", vehicle.brand);\n+                    properties.put(\"Vehicle Bodytype\", vehicle.bodytype);\n+                    properties.put(\"Vehicle Color\", vehicle.color);\n+                    properties.put(\"Vehicle Construction Year\", Short.toString(vehicle.yearOfConstruction));\n+                    properties.put(\"Vehicle Drive Train\", vehicle.driveTrain);\n+                    properties.put(\"Vehicle Model\", vehicle.model);", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxNTkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529015906", "bodyText": "Removed the spaces so properties are CamelCase", "author": "weymann", "createdAt": "2020-11-23T21:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA4OTc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 32d8ba8a74..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDM5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528090392", "bodyText": "StringBuffer uses a lot of synchronization which makes it quite a bit slower than StringBuilder which does not. Since you aren't doing anything multithreading here, you should use StringBuilder instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();", "author": "cpmeister", "createdAt": "2020-11-21T06:46:26Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+// @Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.bmwconnecteddrive\")\n+public class VehicleDiscovery extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+\n+    private ConnectedDriveBridgeHandler bridgeHandler;\n+\n+    public VehicleDiscovery(ConnectedDriveBridgeHandler bh) {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+        bridgeHandler = bh;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.requestVehicles();\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            ThingUID bridgeUID = bridgeHandler.getThing().getUID();\n+            // the DriveTrain field in the delivered json is defining the Vehicle Type\n+            String vehicleType = vehicle.driveTrain;\n+            SUPPORTED_THING_SET.forEach(entry -> {\n+                if (entry.getId().equals(vehicleType)) {\n+                    ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                    Map<String, String> properties = new HashMap<>();\n+                    // Dealer\n+                    if (vehicle.dealer != null) {\n+                        properties.put(\"Dealer\", vehicle.dealer.name);\n+                        properties.put(\"Dealer Address\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                        properties.put(\"Dealer Phone\", vehicle.dealer.phone);\n+                    }\n+\n+                    // Services & Support\n+                    properties.put(\"Services Activated\", getObject(vehicle, Constants.ACTIVATED));\n+                    String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                    String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                    if (vehicle.statisticsAvailable) {\n+                        servicesSupported += Constants.STATISTICS;\n+                    } else {\n+                        servicesNotSupported += Constants.STATISTICS;\n+                    }\n+                    properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                    properties.put(\"Services Not Supported\", servicesNotSupported);\n+                    properties.put(\"Support Breakdown Number\", vehicle.breakdownNumber);\n+\n+                    // Vehicle Properties\n+                    if (vehicle.supportedChargingModes != null) {\n+                        StringBuffer chargingModes = new StringBuffer();\n+                        vehicle.supportedChargingModes.forEach(e -> {\n+                            chargingModes.append(e).append(Constants.SPACE);\n+                        });\n+                        properties.put(\"Vehicle Charge Modes\", chargingModes.toString());\n+                    }\n+                    if (vehicle.hasAlarmSystem) {\n+                        properties.put(\"Vehicle Alarm System\", \"Available\");\n+                    } else {\n+                        properties.put(\"Vehicle Alarm System\", \"Not Available\");\n+                    }\n+                    properties.put(\"Vehicle Brand\", vehicle.brand);\n+                    properties.put(\"Vehicle Bodytype\", vehicle.bodytype);\n+                    properties.put(\"Vehicle Color\", vehicle.color);\n+                    properties.put(\"Vehicle Construction Year\", Short.toString(vehicle.yearOfConstruction));\n+                    properties.put(\"Vehicle Drive Train\", vehicle.driveTrain);\n+                    properties.put(\"Vehicle Model\", vehicle.model);\n+                    if (vehicle.chargingControl != null) {\n+                        properties.put(\"Vehicle Charge Control\", Converter.toTitleCase(vehicle.model));\n+                    }\n+\n+                    // Check now if a thing with the same VIN exists\n+                    final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                    List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                    l.forEach(handler -> {\n+                        Thing vehicleThing = handler.getThing();\n+                        Configuration c = vehicleThing.getConfiguration();\n+                        if (c.containsKey(\"vin\")) {\n+                            String thingVIN = c.get(\"vin\").toString();\n+                            if (vehicle.vin.equals(thingVIN)) {\n+                                vehicleThing.setProperties(properties);\n+                                foundVehicle.set(true);\n+                            }\n+                        }\n+                    });\n+\n+                    // Vehicle not found -> trigger discovery\n+                    if (!foundVehicle.get()) {\n+                        // Properties needed for functional THing\n+                        properties.put(\"vin\", vehicle.vin);\n+                        properties.put(\"refreshInterval\",\n+                                Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                        properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                        properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                        properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                        String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                        Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                        thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                .withProperties(convertedProperties).build());\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuffer buf = new StringBuffer();", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTQ2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529021469", "bodyText": "Yes, checked other places too and they are also not multithreaded. StringBuffer is removed.", "author": "weymann", "createdAt": "2020-11-23T21:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 32d8ba8a74..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDk0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528090945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer buf = new StringBuffer();\n          \n          \n            \n                    StringBuilder buf = new StringBuilder();\n          \n      \n    \n    \n  \n\nPlease replace all other instances of StringBuffer with StringBuilder.", "author": "cpmeister", "createdAt": "2020-11-21T06:47:05Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    public String getAddress() {\n+        StringBuffer buf = new StringBuffer();", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTY4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529021689", "bodyText": "Done", "author": "weymann", "createdAt": "2020-11-23T21:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5MDk0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\nindex e8f4b5d4f6..e9d653a8e2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTYzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528099639", "bodyText": "You should avoid putting any heavy logic in the DTO classes. First, because it adds complexity to the DTO classes and second because you end up skirting around the null checker's static analysis. Either add @NonNullByDefault to the method or move all the code into another class that has @NonNullByDefault at the top of the class.", "author": "cpmeister", "createdAt": "2020-11-21T06:58:58Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link VehicleStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleStatus {\n+    public int mileage;// \": 17273,\n+    public double remainingFuel;// \": 4,\n+    public double remainingRangeElectric;// \": 148,\n+    public double remainingRangeElectricMls;// \": 91,\n+    public double remainingRangeFuel;// \": 70,\"\n+    public double remainingRangeFuelMls;// \":43,\"\n+    public double maxRangeElectric;// \":216,\"\n+    public double maxRangeElectricMls;// \":134,\"\n+    public double maxFuel;// \":8.5,\n+    public double chargingLevelHv;// \":71,\n+    public String vin;// : \"ANONYMOUS\",\n+    public String updateReason;// \": \"VEHICLE_SHUTDOWN_SECURED\",\n+    public String updateTime;// \": \"2020-08-24 T15:55:32+0000\",\n+    public String doorDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String sunroof = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String trunk = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String rearWindow = Constants.UNKNOWN;// \": \"INVALID\",\n+    public String hood = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorLockState;// \": \"SECURED\",\n+    public String parkingLight;// \": \"OFF\",\n+    public String positionLight;// \": \"ON\",\n+    public String connectionStatus;// \": \"DISCONNECTED\",\n+    public String chargingStatus;// \": \"INVALID\",\"\n+    public String lastChargingEndReason;// \": \"CHARGING_GOAL_REACHED\",\n+    public String lastChargingEndResult;// \": \"SUCCESS\",\"\n+    public Position position;\n+    public String internalDataTimeUTC;// \": \"2020-08-24 T15:55:32\",\n+    public boolean singleImmediateCharging;// \":false,\n+    public String chargingConnectionType;// \": \"CONDUCTIVE\",\n+    public String chargingInductivePositioning;// \": \"NOT_POSITIONED\",\n+    public String vehicleCountry;// \": \"DE\",\"+\"\n+    @SerializedName(\"DCS_CCH_Activation\")\n+    public String dcsCchActivation;// \": \"NA\",\n+    @SerializedName(\"DCS_CCH_Ongoing\")\n+    public boolean dcsCchOngoing;// \":false\n+    public List<CCMMessage> checkControlMessages = new ArrayList<CCMMessage>();// \":[],\n+    public List<CBSMessage> cbsData = new ArrayList<CBSMessage>();\n+\n+    /**\n+     * Get Next Service for Date and / or Mileage\n+     *\n+     * @param imperial\n+     * @return\n+     */\n+    public CBSMessage getNextService() {", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNTg1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529805851", "bodyText": "Right, these are some convenient functions to show the user the next service date or mileage. I introduced a small utils class to cover this.", "author": "weymann", "createdAt": "2020-11-24T18:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java\nindex 84adaa9be7..57119de591 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528099704", "bodyText": "same as above", "author": "cpmeister", "createdAt": "2020-11-21T06:59:05Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link VehicleStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleStatus {\n+    public int mileage;// \": 17273,\n+    public double remainingFuel;// \": 4,\n+    public double remainingRangeElectric;// \": 148,\n+    public double remainingRangeElectricMls;// \": 91,\n+    public double remainingRangeFuel;// \": 70,\"\n+    public double remainingRangeFuelMls;// \":43,\"\n+    public double maxRangeElectric;// \":216,\"\n+    public double maxRangeElectricMls;// \":134,\"\n+    public double maxFuel;// \":8.5,\n+    public double chargingLevelHv;// \":71,\n+    public String vin;// : \"ANONYMOUS\",\n+    public String updateReason;// \": \"VEHICLE_SHUTDOWN_SECURED\",\n+    public String updateTime;// \": \"2020-08-24 T15:55:32+0000\",\n+    public String doorDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowDriverRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerFront = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String windowPassengerRear = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String sunroof = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String trunk = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String rearWindow = Constants.UNKNOWN;// \": \"INVALID\",\n+    public String hood = Constants.UNKNOWN;// \": \"CLOSED\",\n+    public String doorLockState;// \": \"SECURED\",\n+    public String parkingLight;// \": \"OFF\",\n+    public String positionLight;// \": \"ON\",\n+    public String connectionStatus;// \": \"DISCONNECTED\",\n+    public String chargingStatus;// \": \"INVALID\",\"\n+    public String lastChargingEndReason;// \": \"CHARGING_GOAL_REACHED\",\n+    public String lastChargingEndResult;// \": \"SUCCESS\",\"\n+    public Position position;\n+    public String internalDataTimeUTC;// \": \"2020-08-24 T15:55:32\",\n+    public boolean singleImmediateCharging;// \":false,\n+    public String chargingConnectionType;// \": \"CONDUCTIVE\",\n+    public String chargingInductivePositioning;// \": \"NOT_POSITIONED\",\n+    public String vehicleCountry;// \": \"DE\",\"+\"\n+    @SerializedName(\"DCS_CCH_Activation\")\n+    public String dcsCchActivation;// \": \"NA\",\n+    @SerializedName(\"DCS_CCH_Ongoing\")\n+    public boolean dcsCchOngoing;// \":false\n+    public List<CCMMessage> checkControlMessages = new ArrayList<CCMMessage>();// \":[],\n+    public List<CBSMessage> cbsData = new ArrayList<CBSMessage>();\n+\n+    /**\n+     * Get Next Service for Date and / or Mileage\n+     *\n+     * @param imperial\n+     * @return\n+     */\n+    public CBSMessage getNextService() {\n+        CBSMessage cbs = new CBSMessage();\n+        if (cbsData == null) {\n+            return cbs;\n+        }\n+        if (cbsData.isEmpty()) {\n+            return cbs;\n+        } else {\n+            int serviceMileage = Integer.MAX_VALUE;\n+            LocalDateTime serviceDate = LocalDateTime.now().plusYears(100);\n+\n+            for (int i = 0; i < cbsData.size(); i++) {\n+                CBSMessage entry = cbsData.get(i);\n+                if (entry.cbsRemainingMileage != 0 && entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n+                    if ((entry.cbsRemainingMileage < serviceMileage) || (d.isBefore(serviceDate))) {\n+                        serviceDate = d;\n+                        serviceMileage = entry.cbsRemainingMileage;\n+                        cbs = entry;\n+                    }\n+                } else if (entry.cbsRemainingMileage != 0) {\n+                    if (entry.cbsRemainingMileage < serviceMileage) {\n+                        serviceMileage = entry.cbsRemainingMileage;\n+                        cbs = entry;\n+                    }\n+                } else if (entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n+                    if (d.isBefore(serviceDate)) {\n+                        serviceDate = d;\n+                        cbs = entry;\n+                    }\n+                }\n+            }\n+        }\n+        return cbs;\n+    }\n+\n+    public String getNextServiceDate() {", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwNjA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529806077", "bodyText": "as stated above", "author": "weymann", "createdAt": "2020-11-24T18:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA5OTcwNA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java\nindex 84adaa9be7..57119de591 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/VehicleStatus.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwMzkxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528103917", "bodyText": "I suggest that you change your discovery service into a ThingHandlerService so that you don't have to manage osgi registration of this class. It is a bit verbose to explain how to make the change but I've found another PR that shows exactly the changes that are required: https://github.com/openhab/openhab-addons/pull/6396/files", "author": "cpmeister", "createdAt": "2020-11-21T07:04:58Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Hashtable;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private BundleContext bundleContext;\n+    private VehicleDiscovery discoveryService;\n+    private ServiceRegistration<?> discoveryServiceRegstration;\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    private static final String DISCOVERY_FINGERPRINT = \"discovery-fingerprint\";\n+    private ChannelUID discoveryFingerprintChannel;\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf, BundleContext bc) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+        bundleContext = bc;\n+        discoveryService = new VehicleDiscovery(this);\n+        discoveryServiceRegstration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<>());", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MjU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r549052594", "bodyText": "I've done the changes and it works in the OH3 environment so BundleContext and service registration are completely removed.", "author": "weymann", "createdAt": "2020-12-27T01:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwMzkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex c38bb81bcd..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNDU2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528104562", "bodyText": "You should save the future returned here and make sure to cancel it during dispose()", "author": "cpmeister", "createdAt": "2020-11-21T07:05:51Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Hashtable;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceRegistration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private BundleContext bundleContext;\n+    private VehicleDiscovery discoveryService;\n+    private ServiceRegistration<?> discoveryServiceRegstration;\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    private static final String DISCOVERY_FINGERPRINT = \"discovery-fingerprint\";\n+    private ChannelUID discoveryFingerprintChannel;\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf, BundleContext bc) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+        bundleContext = bc;\n+        discoveryService = new VehicleDiscovery(this);\n+        discoveryServiceRegstration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<>());\n+        discoveryFingerprintChannel = new ChannelUID(bridge.getUID(), DISCOVERY_FINGERPRINT);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (DISCOVERY_FINGERPRINT.equals(channelUID.getIdWithoutGroup()) && command instanceof OnOffType) {\n+            if (command.equals(OnOffType.ON)) {\n+                logger.warn(\n+                        \"###### BMW ConnectedDrive Binding - Discovery Troubleshoot Fingerprint Data - BEGIN ######\");\n+                logger.warn(\"### Discovery Result ###\");\n+                logger.warn(\"{}\", getDiscoveryFingerprint());\n+                logger.warn(\"###### BMW ConnectedDrive Binding - Discovery Troubleshoot Fingerprint Data - END ######\");\n+                updateState(discoveryFingerprintChannel, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS);", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzNjgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529036801", "bodyText": "Done", "author": "weymann", "createdAt": "2020-11-23T22:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNDU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex c38bb81bcd..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNTc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528105789", "bodyText": "Use Set.of", "author": "cpmeister", "createdAt": "2020-11-21T07:07:30Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link BimmerConstants} This class holds the important constants for the BMW Connected Drive Authorization. They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@SuppressWarnings(\"serial\")\n+@NonNullByDefault\n+public class BimmerConstants {\n+\n+    public static final String SERVER_NORTH_AMERICA = \"b2vapi.bmwgroup.us\";\n+    public static final String SERVER_CHINA = \"b2vapi.bmwgroup.cn:859\";\n+    public static final String SERVER_ROW = \"b2vapi.bmwgroup.com\";\n+    public static final Map<String, String> SERVER_MAP = new HashMap<String, String>() {", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMDQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529030407", "bodyText": "Used Map.of", "author": "weymann", "createdAt": "2020-11-23T22:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNTc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java\nindex 69b5f55d76..5c0ed6438f 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/BimmerConstants.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528106079", "bodyText": "and here", "author": "cpmeister", "createdAt": "2020-11-21T07:07:55Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link Constants} General Constant Definitions\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Constants {\n+    // For Vehicle Status\n+    public static final String OK = \"Ok\";\n+    public static final String ACTIVE = \"ACTIVE\";\n+    public static final String NOT_ACTIVE = \"NOT ACTIVE\";\n+    public static final String OPEN = \"OPEN\";\n+    public static final String INVALID = \"INVALID\";\n+    public static final String CLOSED = \"CLOSED\";\n+    public static final String INTERMEDIATE = \"INTERMEDIATE\";\n+    public static final String UNKNOWN = \"UNKOWN\";\n+    public static final String NO_SERVICE_REQUEST = \"No Service Requests\";\n+    public static final String UTC_APPENDIX = \"-01T12:00:00\";\n+    public static final String NULL_DATE = \"1900-01-01T00:00:00\";\n+\n+    // Services to query\n+    public static final String SERVICES_SUPPORTED = \"Services Supported\";\n+    public static final String STATISTICS = \"Statistics\";\n+    public static final String LAST_DESTINATIONS = \"LastDestinations\";\n+\n+    // Services in Discovery\n+    public static final String ACTIVATED = \"ACTIVATED\";\n+    public static final String SUPPORTED = \"SUPPORTED\";\n+    public static final String NOT_SUPPORTED = \"NOT_SUPPORTED\";\n+\n+    // General Constants for String concatenation\n+    public static final String NULL = \"null\";\n+    public static final String SPACE = \" \";\n+    public static final String UNDERLINE = \"_\";\n+    public static final String HYPHEN = \" - \";\n+    public static final String PLUS = \"+\";\n+    public static final String EMPTY = \"\";\n+    public static final String COMMA = \",\";\n+    public static final String QUESTION = \"?\";\n+\n+    public static final String ANONYMOUS = \"ANONYMOUS\";\n+    public static final int MILES_TO_FEET_FACTOR = 5280;\n+    public static final String EMPTY_VEHICLES = \"{}\";\n+\n+    @SuppressWarnings(\"serial\")\n+    public static final Map<String, String> DAYS = new HashMap<String, String>() {", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzMDcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529030724", "bodyText": "used Map.of as above", "author": "weymann", "createdAt": "2020-11-23T22:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java\nindex 6c44779ff9..e5be2ebfde 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Constants.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r528106619", "bodyText": "10 to the power of 1? Why not just return 10.0?", "author": "cpmeister", "createdAt": "2020-11-21T07:08:49Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+\n+    public static double round(double value) {\n+        double scale = Math.pow(10, 1);", "originalCommit": "e0bfe93e13df4a3c5de5f8819b94ebf795664904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAzNDE2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r529034165", "bodyText": "Right. It's a leftover from previous round function which allowed configurable digits after comma. Default is now 1 digit so I put it as constant.", "author": "weymann", "createdAt": "2020-11-23T22:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\nindex cbebd39ae7..bc6e3fc75b 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"oid": "6a16378b08ecd8487b75d9673736770468ea516f", "url": "https://github.com/openhab/openhab-addons/commit/6a16378b08ecd8487b75d9673736770468ea516f", "message": "title case adaptions plus minor bugfixes\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2020-12-27T00:20:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDA5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571520097", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (bridgeHandler.isPresent()) {\n          \n          \n            \n                        bridgeHandler.get().requestVehicles();\n          \n          \n            \n                    }\n          \n          \n            \n                    bridgeHandler.ifPresent(ConnectedDriveBridgeHandler::requestVehicles);", "author": "cpmeister", "createdAt": "2021-02-07T02:42:47Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        if (bridgeHandler.isPresent()) {\n+            return bridgeHandler.get();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        if (bridgeHandler.isPresent()) {\n+            bridgeHandler.get().requestVehicles();\n+        }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjQxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216412", "bodyText": "all occurences of 'isPresent() + get()' that can reasonably be implemented using ifPresent/map/flatMap.... are fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDA5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDM0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571520347", "bodyText": "If the null checker throws a fit you can ignore this suggestion.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (bridgeHandler.isPresent()) {\n          \n          \n            \n                        return bridgeHandler.get();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }\n          \n          \n            \n                    return bridgeHandler.orElse(null);", "author": "cpmeister", "createdAt": "2021-02-07T02:45:45Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        if (bridgeHandler.isPresent()) {\n+            return bridgeHandler.get();\n+        } else {\n+            return null;\n+        }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216557", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDg4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571520884", "bodyText": "This should be checked before you go into the loop.", "author": "cpmeister", "createdAt": "2021-02-07T02:51:22Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjY1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216652", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMDg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571521122", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IllegalArgumentException e) {\n          \n          \n            \n                            logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n          \n          \n            \n                        } catch (IllegalAccessException e) {\n          \n          \n            \n                        } catch (IllegalArgumentException | IllegalAccessException e) {", "author": "cpmeister", "createdAt": "2021-02-07T02:54:21Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }\n+            } catch (IllegalArgumentException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            } catch (IllegalAccessException e) {", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjc0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216740", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571521169", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (value != null) {\n          \n          \n            \n                                if (value.equals(compare)) {\n          \n          \n            \n                                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                            if (compare.equals(value)) {\n          \n          \n            \n                                buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n          \n          \n            \n                            }", "author": "cpmeister", "createdAt": "2021-02-07T02:55:01Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(\"vin\").withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (value != null) {\n+                    if (value.equals(compare)) {\n+                        buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                    }\n+                }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIxNjkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588216919", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMTE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjI5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571522293", "bodyText": "Please make \"vin\" a static constant since you use it in several places.", "author": "cpmeister", "createdAt": "2021-02-07T02:59:20Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(\"vin\")) {\n+                                String thingVIN = c.get(\"vin\").toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(\"vin\", vehicle.vin);", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkwMzU0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588903540", "bodyText": "fixed", "author": "weymann", "createdAt": "2021-03-06T16:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjI5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjUzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571522534", "bodyText": "I assume that the extra space at the end isn't intentional.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        StringBuilder chargingModes = new StringBuilder();\n          \n          \n            \n                                        vehicle.supportedChargingModes.forEach(e -> {\n          \n          \n            \n                                            chargingModes.append(e).append(Constants.SPACE);\n          \n          \n            \n                                        });\n          \n          \n            \n                                        properties.put(\"vehicleChargeModes\", chargingModes.toString());\n          \n          \n            \n                                        properties.put(\"vehicleChargeModes\", String.join(Constants.SPACE, vehicle.supportedChargingModes));", "author": "cpmeister", "createdAt": "2021-02-07T03:02:53Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMyMTY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588321694", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T14:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyMjUzNA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571524755", "bodyText": "You can get all of the handlers by iterating through the handlers of the children of the bridge.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n          \n          \n            \n                                    l.forEach(handler -> {\n          \n          \n            \n                                        Thing vehicleThing = handler.getThing();\n          \n          \n            \n                                    bridgeHandler.get().getThing().getThings().forEach(vehicleThing ->", "author": "cpmeister", "createdAt": "2021-02-07T03:10:42Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveHandlerFactory;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Vehicle;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        List<Vehicle> vehicles = container.vehicles;\n+        vehicles.forEach(vehicle -> {\n+            if (bridgeHandler.isPresent()) {\n+                ThingUID bridgeUID = bridgeHandler.get().getThing().getUID();\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            StringBuilder chargingModes = new StringBuilder();\n+                            vehicle.supportedChargingModes.forEach(e -> {\n+                                chargingModes.append(e).append(Constants.SPACE);\n+                            });\n+                            properties.put(\"vehicleChargeModes\", chargingModes.toString());\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        List<VehicleHandler> l = ConnectedDriveHandlerFactory.getHandlerRegistry();\n+                        l.forEach(handler -> {\n+                            Thing vehicleThing = handler.getThing();", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyMTk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588221983", "bodyText": "fixed. Replaced by 'bridgeHandler.ifPresent(...' at begin of method. All other code in method is pointless without valid bridgeHandler", "author": "ntruchsess", "createdAt": "2021-03-05T11:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDc1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 480ba46c1f..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571524973", "bodyText": "I feel it should be up to the callers of getAddress() and getCoordinates() to cache these values, not this class. Is there any performance reason to cache these values in this class instead?", "author": "cpmeister", "createdAt": "2021-02-07T03:13:58Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    private String address = null;\n+    private String coordinates = null;", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkxMDQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588910448", "bodyText": "Not for performance reasons. The Handler is already quite packed and I want to provide easy calls which can be directly used to update the corresponding channles. An extra Wrapper for this small functionality isn't really needed from my point of view so I placed it here.\nI removed the cache variables because it doesn't provide a performance benefit.", "author": "weymann", "createdAt": "2021-03-06T17:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNDk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\nindex eb6f29705e..e9d653a8e2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571525284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (days.length() == 0) {\n          \n          \n            \n                            days.append(Constants.DAYS.get(entry));\n          \n          \n            \n                        } else {\n          \n          \n            \n                            days.append(Constants.COMMA).append(Constants.DAYS.get(entry));\n          \n          \n            \n                        }\n          \n          \n            \n                        if (days.length() != 0){\n          \n          \n            \n                            days.append(Constants.COMMA);\n          \n          \n            \n                        }\n          \n          \n            \n                        days.append(Constants.DAYS.get(entry));", "author": "cpmeister", "createdAt": "2021-02-07T03:15:52Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.charge;\n+\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+\n+/**\n+ * The {@link Timer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Timer {\n+    public String departureTime;// \": \"05:00\",\n+    public boolean timerEnabled;// \": false,\n+    public List<String> weekdays;\n+\n+    /**\n+     * \"MONDAY\",\n+     * \"TUESDAY\",\n+     * \"WEDNESDAY\",\n+     * \"THURSDAY\",\n+     * \"FRIDAY\"\n+     * ] '\n+     */\n+    public String getDays() {\n+        if (weekdays == null) {\n+            return Constants.UNDEF;\n+        }\n+        StringBuilder days = new StringBuilder();\n+        weekdays.forEach(entry -> {\n+            if (days.length() == 0) {\n+                days.append(Constants.DAYS.get(entry));\n+            } else {\n+                days.append(Constants.COMMA).append(Constants.DAYS.get(entry));\n+            }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyMzgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588223838", "bodyText": "refactored fixing this issue. See ChargeProfileUtils.formatDays().", "author": "ntruchsess", "createdAt": "2021-03-05T11:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java\nindex 6799e5d96d..65a3f23c8f 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/charge/Timer.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571525754", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();\n          \n          \n            \n                    return getCoordinates();", "author": "cpmeister", "createdAt": "2021-02-07T03:18:40Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.status;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+\n+/**\n+ * The {@link Position} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Position {\n+    public float lat;// \": 46.55605,\n+    public float lon;// \": 10.495669,\n+    public int heading;// \": 219,\n+    public String status;// \": \"OK\"\n+\n+    public String getCoordinates() {\n+        return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(Float.toString(lat)).append(Constants.COMMA).append(Float.toString(lon)).toString();", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkxMDgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588910806", "bodyText": "OMG, sure!", "author": "weymann", "createdAt": "2021-03-06T17:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java\nindex 83e4d44930..ee46dd372c 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/status/Position.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTk1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571525954", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (initializerJob.isPresent()) {\n          \n          \n            \n                        initializerJob.get().cancel(true);\n          \n          \n            \n                    }\n          \n          \n            \n                    initializerJob.ifPresent(job -> job.cancel(true));", "author": "cpmeister", "createdAt": "2021-02-07T03:20:48Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyNDQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588224479", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNTk1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex f331886408..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNjAwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571526000", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (proxy.isPresent()) {\n          \n          \n            \n                        proxy.get().requestVehicles(this);\n          \n          \n            \n                    }\n          \n          \n            \n                    proxy.ifPresent(prox -> prox.requestVehicles(this));", "author": "cpmeister", "createdAt": "2021-02-07T03:21:27Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }\n+    }\n+\n+    public void requestVehicles() {\n+        if (proxy.isPresent()) {\n+            proxy.get().requestVehicles(this);\n+        }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODIyNDYzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588224632", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T11:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyNjAwMA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex f331886408..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571529727", "bodyText": "You should catch the parsing exception that is thrown by gson.", "author": "cpmeister", "createdAt": "2021-02-07T03:44:27Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        if (configuration.isPresent()) {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, configuration.get()));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (initializerJob.isPresent()) {\n+            initializerJob.get().cancel(true);\n+        }\n+    }\n+\n+    public void requestVehicles() {\n+        if (proxy.isPresent()) {\n+            proxy.get().requestVehicles(this);\n+        }\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        if (troubleshootFingerprint.isPresent()) {\n+            VehiclesContainer container = Converter.getGson().fromJson(troubleshootFingerprint.get(),\n+                    VehiclesContainer.class);", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkyNDc0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588924746", "bodyText": "Done for all occurrences", "author": "weymann", "createdAt": "2021-03-06T20:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex f331886408..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571529991", "bodyText": "Why are you manually writing the trace when you can include the entire exception as part of the logged message?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage());\n          \n          \n            \n                        StackTraceElement[] trace = e.getStackTrace();\n          \n          \n            \n                        for (int i = 0; i < trace.length; i++) {\n          \n          \n            \n                            logger.info(\"{}\", trace[i]);\n          \n          \n            \n                        }\n          \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage(), e);", "author": "cpmeister", "createdAt": "2021-02-07T03:47:08Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private HttpClient httpClient;\n+    private HttpClient authHttpClient;\n+    private String legacyAuthUri;\n+    private ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    String baseUrl;\n+    String vehicleUrl;\n+    String legacyUrl;\n+    String vehicleStatusAPI = \"/status\";\n+    String lastTripAPI = \"/statistics/lastTrip\";\n+    String allTripsAPI = \"/statistics/allTrips\";\n+    String chargeAPI = \"/chargingprofile\";\n+    String destinationAPI = \"/destinations\";\n+    String imageAPI = \"/image\";\n+    String rangeMapAPI = \"/rangemap\";\n+    String serviceExecutionAPI = \"/executeService\";\n+    String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(String url, boolean post, Optional<MultiMap<String>> params,\n+            ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Optional.of(Injector.getDiscovery()));\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Optional.of(Injector.getStatus()));\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        Request req;\n+        final StringBuilder completeUrl = new StringBuilder(url);\n+        if (post) {\n+            req = httpClient.POST(completeUrl.toString());\n+            if (params.isPresent()) {\n+                String urlEncodedParameter = UrlEncoded.encode(params.get(), Charset.defaultCharset(), false);\n+                req.header(HttpHeader.CONTENT_TYPE, CONTENT_TYPE_URL_ENCODED);\n+                req.header(CONTENT_LENGTH, Integer.toString(urlEncodedParameter.length()));\n+                req.content(new StringContentProvider(urlEncodedParameter));\n+            }\n+        } else {\n+            if (params.isPresent()) {\n+                completeUrl.append(Constants.QUESTION)\n+                        .append(UrlEncoded.encode(params.get(), Charset.defaultCharset(), false)).toString();\n+            }\n+            req = httpClient.newRequest(completeUrl.toString());\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl.toString();\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(Optional.of(getContentAsString()));\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(Optional.of(getContent()));\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, Optional<MultiMap<String>> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, Optional<MultiMap<String>> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, Optional.empty(), callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(vehicleStatusAPI).toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(new StringBuilder(legacyUrl).append(config.vin).append(\"?offset=-60\").toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(lastTripAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(allTripsAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(chargeAPI).toString(), Optional.empty(), callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(destinationAPI).toString(), Optional.empty(),\n+                callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, Optional<MultiMap<String>> params,\n+            StringResponseCallback callback) {\n+        get(new StringBuilder(baseUrl).append(config.vin).append(rangeMapAPI).toString(), params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        String localImageUrl = new StringBuilder(baseUrl).append(config.vin).append(imageAPI).toString();\n+        MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, Optional.of(dataMap), callback);\n+    }\n+\n+    private String getRegionServer() {\n+        String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        if (retVal != null) {\n+            return retVal;\n+        } else {\n+            return Constants.INVALID;\n+        }\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONTENT_TYPE, CONTENT_TYPE_URL_ENCODED);\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        String urlEncodedData = UrlEncoded.encode(dataMap, Charset.defaultCharset(), false);\n+        req.header(CONTENT_LENGTH, Integer.toString(urlEncodedData.length()));\n+        req.content(new StringContentProvider(urlEncodedData));\n+        try {\n+            ContentResponse contentResponse = req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n+            // Status needs to be 302 - Response is stored in Header\n+            if (contentResponse.getStatus() == 302) {\n+                HttpFields fields = contentResponse.getHeaders();\n+                HttpField field = fields.getField(HttpHeader.LOCATION);\n+                tokenFromUrl(field.getValue());\n+            } else if (contentResponse.getStatus() == 200) {\n+                AuthResponse authResponse = Converter.getGson().fromJson(contentResponse.getContentAsString(),\n+                        AuthResponse.class);\n+                if (authResponse != null) {\n+                    token.setToken(authResponse.accessToken);\n+                    token.setType(authResponse.tokenType);\n+                    token.setExpiration(authResponse.expiresIn);\n+                }\n+            } else {\n+                logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage());\n+            StackTraceElement[] trace = e.getStackTrace();\n+            for (int i = 0; i < trace.length; i++) {\n+                logger.info(\"{}\", trace[i]);\n+            }", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMxMDI3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588310271", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T13:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUyOTk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 3e32ebe69e..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571530483", "bodyText": "The direct use of StringBuilder can get rather verbose. So try to avoid using it when only concatenating a small number of things.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new StringBuilder(viewport).append(Integer.toString(size)).toString();\n          \n          \n            \n                    return viewport + size;", "author": "cpmeister", "createdAt": "2021-02-07T03:52:15Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link ImageProperties} Properties of current Vehicle Image\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ImageProperties {\n+    public static final int RETRY_COUNTER = 5;\n+    public int failCounter = 0;\n+    public String viewport = Constants.EMPTY;\n+    public int size = -1;\n+\n+    public ImageProperties(String viewport, int size) {\n+        this.viewport = viewport;\n+        this.size = size;\n+    }\n+\n+    public ImageProperties() {\n+    }\n+\n+    public void failed() {\n+        failCounter++;\n+    }\n+\n+    public boolean failLimitReached() {\n+        return failCounter > RETRY_COUNTER;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(viewport).append(Integer.toString(size)).toString();", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMxMDk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588310940", "bodyText": "fixed. direct use of String replaced by '+'-operator in most places where this is equivalent to using the StringBuilder.", "author": "ntruchsess", "createdAt": "2021-03-05T13:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java\nindex dbab740c95..6b943a2fd2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ImageProperties.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r571530650", "bodyText": "You can easily create the ChannelUIDs on demand. So it seems pretty wasteful to make fields for each of them. Please remove these fields.", "author": "cpmeister", "createdAt": "2021-02-07T03:54:54Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Vehicle Status Channels\n+    protected ChannelUID doors;\n+    protected ChannelUID windows;\n+    protected ChannelUID lock;\n+    protected ChannelUID serviceNextDate;\n+    protected ChannelUID serviceNextMileage;\n+    protected ChannelUID checkControl;", "originalCommit": "d5c01cbf22b288e86546da29f08d62c4d59189e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODMxMTA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588311056", "bodyText": "fixed", "author": "ntruchsess", "createdAt": "2021-03-05T13:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkxMTY5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588911692", "bodyText": "Channel UID creation is taking for each update several String concatenations. So I found it pretty watseful to cerate these on demand. But fine for me.", "author": "weymann", "createdAt": "2021-03-06T18:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTUzMDY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\nindex c1a6136d12..6ff369b171 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n\n@@ -1,5 +1,5 @@\n /**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n  *\n  * See the NOTICE file(s) distributed with this work for additional\n  * information.\n"}}, {"oid": "25f868f4561737d7db30a6c1694ff475f25d66e4", "url": "https://github.com/openhab/openhab-addons/commit/25f868f4561737d7db30a6c1694ff475f25d66e4", "message": "readme adaptions", "committedDate": "2021-03-06T13:06:43Z", "type": "forcePushed"}, {"oid": "e79f3275955d143a081b41b9b1cc5996471f4035", "url": "https://github.com/openhab/openhab-addons/commit/e79f3275955d143a081b41b9b1cc5996471f4035", "message": "readme adaptions\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-06T13:18:59Z", "type": "forcePushed"}, {"oid": "4c76eb641062f634e1263c904fda85777b79be38", "url": "https://github.com/openhab/openhab-addons/commit/4c76eb641062f634e1263c904fda85777b79be38", "message": "readme adaptions\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-06T13:34:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588936157", "bodyText": "from what I can see toJson() does not throw JsonSyntaxException. (fromJson does)", "author": "ntruchsess", "createdAt": "2021-03-06T21:58:21Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -101,7 +103,11 @@ public String transform() {\n             }\n         }\n         vs.cbsData = cbsl;\n-\n-        return Converter.getGson().toJson(vsc);\n+        String returnVal = Constants.EMPTY_JSON;\n+        try {\n+            returnVal = Converter.getGson().toJson(vsc);", "originalCommit": "60d9ba89e05508de81acafb965b5a16e5c09fbf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1NDU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589054544", "bodyText": "True! Reverted this", "author": "weymann", "createdAt": "2021-03-07T16:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjE1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\nindex b5786b675f..3e8087f6e2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\n\n@@ -33,81 +20,4 @@ import com.google.gson.JsonSyntaxException;\n public class VehicleAttributesContainer {\n     public VehicleAttributes attributesMap;\n     public VehicleMessages vehicleMessages;\n-\n-    public String transform() {\n-        // create target objects\n-        VehicleStatusContainer vsc = new VehicleStatusContainer();\n-        VehicleStatus vs = new VehicleStatus();\n-        vsc.vehicleStatus = vs;\n-\n-        vs.mileage = attributesMap.mileage;\n-        vs.doorLockState = attributesMap.doorLockState;\n-\n-        vs.doorDriverFront = attributesMap.doorDriverFront;\n-        vs.doorDriverRear = attributesMap.doorDriverRear;\n-        vs.doorPassengerFront = attributesMap.doorPassengerFront;\n-        vs.doorPassengerRear = attributesMap.doorPassengerRear;\n-        vs.hood = attributesMap.hoodState;\n-        vs.trunk = attributesMap.trunkState;\n-\n-        vs.windowDriverFront = attributesMap.winDriverFront;\n-        vs.windowDriverRear = attributesMap.winDriverRear;\n-        vs.windowPassengerFront = attributesMap.winPassengerFront;\n-        vs.windowPassengerRear = attributesMap.winPassengerRear;\n-        vs.sunroof = attributesMap.sunroofState;\n-\n-        vs.remainingFuel = attributesMap.remainingFuel;\n-        vs.remainingRangeElectric = attributesMap.beRemainingRangeElectricKm;\n-        vs.remainingRangeElectricMls = attributesMap.beRemainingRangeElectricMile;\n-        vs.remainingRangeFuel = attributesMap.beRemainingRangeFuelKm;\n-        vs.remainingRangeFuelMls = attributesMap.beRemainingRangeFuelMile;\n-        vs.remainingFuel = attributesMap.remainingFuel;\n-        vs.chargingLevelHv = attributesMap.chargingLevelHv;\n-        vs.chargingStatus = attributesMap.chargingHVStatus;\n-        vs.lastChargingEndReason = attributesMap.lastChargingEndReason;\n-\n-        vs.updateTime = attributesMap.updateTimeConverted;\n-        // vs.internalDataTimeUTC = attributesMap.updateTime;\n-\n-        Position p = new Position();\n-        p.lat = attributesMap.gpsLat;\n-        p.lon = attributesMap.gpsLon;\n-        p.heading = attributesMap.heading;\n-        vs.position = p;\n-\n-        final List<CCMMessage> ccml = new ArrayList<CCMMessage>();\n-        if (vehicleMessages != null) {\n-            if (vehicleMessages.ccmMessages != null) {\n-                vehicleMessages.ccmMessages.forEach(entry -> {\n-                    CCMMessage ccmM = new CCMMessage();\n-                    ccmM.ccmDescriptionShort = entry.text;\n-                    ccmM.ccmDescriptionLong = Constants.HYPHEN;\n-                    ccmM.ccmMileage = entry.unitOfLengthRemaining;\n-                    ccml.add(ccmM);\n-                });\n-            }\n-        }\n-        vs.checkControlMessages = ccml;\n-\n-        final List<CBSMessage> cbsl = new ArrayList<CBSMessage>();\n-        if (vehicleMessages != null) {\n-            if (vehicleMessages.cbsMessages != null) {\n-                vehicleMessages.cbsMessages.forEach(entry -> {\n-                    CBSMessage cbsm = new CBSMessage();\n-                    cbsm.cbsType = entry.text;\n-                    cbsm.cbsDescription = entry.description;\n-                    cbsm.cbsDueDate = entry.date;\n-                    cbsm.cbsRemainingMileage = entry.unitOfLengthRemaining;\n-                    cbsl.add(cbsm);\n-                });\n-            }\n-        }\n-        vs.cbsData = cbsl;\n-        String returnVal = Constants.EMPTY_JSON;\n-        try {\n-            returnVal = Converter.getGson().toJson(vsc);\n-        } catch (JsonSyntaxException jse) {\n-        }\n-        return returnVal;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588936484", "bodyText": "catching JsonSyntaxException here is redundant to the catch in line 283", "author": "ntruchsess", "createdAt": "2021-03-06T22:01:48Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -290,7 +290,7 @@ private synchronized void updateToken() {\n                 logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n                         contentResponse.getReason());\n             }\n-        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+        } catch (InterruptedException | ExecutionException | TimeoutException | JsonSyntaxException e) {", "originalCommit": "60d9ba89e05508de81acafb965b5a16e5c09fbf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1MzU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589053557", "bodyText": "Reverted", "author": "weymann", "createdAt": "2021-03-07T16:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjQ4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2ff0992bdc..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -290,8 +300,8 @@ public class ConnectedDriveProxy {\n                 logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n                         contentResponse.getReason());\n             }\n-        } catch (InterruptedException | ExecutionException | TimeoutException | JsonSyntaxException e) {\n-            logger.debug(\"Authorization exception: {}\", e.getMessage(), e);\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage());\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjY3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r588936670", "bodyText": "ChargeProfileWrapper.fromJson does not throw any Exception. It will return empty Optional in case the Json is unparseable.", "author": "ntruchsess", "createdAt": "2021-03-06T22:03:54Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -334,7 +336,11 @@ protected void updateLastTrip(LastTrip trip) {\n     }\n \n     protected void updateChargeProfileFromContent(String content) {\n-        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+        try {\n+            ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);", "originalCommit": "60d9ba89e05508de81acafb965b5a16e5c09fbf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTA1NDE2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r589054163", "bodyText": "I see", "author": "weymann", "createdAt": "2021-03-07T16:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4ODkzNjY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\nindex 59c8341772..6ff369b171 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n\n@@ -336,11 +326,7 @@ public class VehicleChannelHandler extends BaseThingHandler {\n     }\n \n     protected void updateChargeProfileFromContent(String content) {\n-        try {\n-            ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n-        } catch (JsonSyntaxException jse) {\n-            logger.debug(\"Update charge profile parse exception {}\", jse.getMessage());\n-        }\n+        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n     }\n \n     protected void updateChargeProfile(ChargeProfileWrapper wrapper) {\n"}}, {"oid": "1b805197ad9a2ead121550d05a414ed485523909", "url": "https://github.com/openhab/openhab-addons/commit/1b805197ad9a2ead121550d05a414ed485523909", "message": "solve review comments\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-07T13:23:14Z", "type": "forcePushed"}, {"oid": "b19efbf215b23513e08847c9f83a84a23f0d43a5", "url": "https://github.com/openhab/openhab-addons/commit/b19efbf215b23513e08847c9f83a84a23f0d43a5", "message": "review corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-07T16:52:31Z", "type": "forcePushed"}, {"oid": "fc8566200cc6ffdfbeca29e8bd006b9104c751d3", "url": "https://github.com/openhab/openhab-addons/commit/fc8566200cc6ffdfbeca29e8bd006b9104c751d3", "message": "review corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-07T16:54:40Z", "type": "forcePushed"}, {"oid": "1ecc11163fd1b5bee09d2da3df35f0ee1c50b2d2", "url": "https://github.com/openhab/openhab-addons/commit/1ecc11163fd1b5bee09d2da3df35f0ee1c50b2d2", "message": "review corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-07T17:01:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjMyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597862320", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2021-03-19T17:36:55Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final String VIN = \"vin\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2NDA4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598264088", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-21T11:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\nindex 45e2f821c6..31e22c4a09 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\n\n@@ -36,8 +36,8 @@ public class ConnectedDriveConstants {\n \n     public static final String VIN = \"vin\";\n \n-    public static final int DEFAULT_IMAGE_SIZE = 1024;\n-    public static final int DEFAULT_REFRESH_INTERVAL = 5;\n+    public static final int DEFAULT_IMAGE_SIZE_PX = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL_MINUTES = 5;\n     public static final String DEFAULT_IMAGE_VIEWPORT = \"FRONT\";\n \n     // See constants from bimmer-connected\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjUzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597862530", "bodyText": "Same as above. Unit.", "author": "fwolter", "createdAt": "2021-03-19T17:37:11Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link ConnectedDriveConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveConstants {\n+\n+    private static final String BINDING_ID = \"bmwconnecteddrive\";\n+\n+    // Units\n+    public static final String UNITS_AUTODETECT = \"AUTODETECT\";\n+    public static final String UNITS_IMPERIAL = \"IMPERIAL\";\n+    public static final String UNITS_METRIC = \"METRIC\";\n+\n+    public static final String VIN = \"vin\";\n+\n+    public static final int DEFAULT_IMAGE_SIZE = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL = 5;", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2NDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598264103", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-21T11:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2MjUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\nindex 45e2f821c6..31e22c4a09 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveConstants.java\n\n@@ -36,8 +36,8 @@ public class ConnectedDriveConstants {\n \n     public static final String VIN = \"vin\";\n \n-    public static final int DEFAULT_IMAGE_SIZE = 1024;\n-    public static final int DEFAULT_REFRESH_INTERVAL = 5;\n+    public static final int DEFAULT_IMAGE_SIZE_PX = 1024;\n+    public static final int DEFAULT_REFRESH_INTERVAL_MINUTES = 5;\n     public static final String DEFAULT_IMAGE_VIEWPORT = \"FRONT\";\n \n     // See constants from bimmer-connected\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2NjUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597866517", "bodyText": "What is the purpose of this field?", "author": "fwolter", "createdAt": "2021-03-19T17:43:30Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.BMWConnectedDriveOptionProvider;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link ConnectedDriveHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.bmwconnecteddrive\", service = ThingHandlerFactory.class)\n+public class ConnectedDriveHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final HttpClientFactory httpClientFactory;\n+    private final BMWConnectedDriveOptionProvider optionProvider;\n+    private static final List<VehicleHandler> VEHICLE_HANDLER_REGISTRY = new ArrayList<VehicleHandler>();", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2NTAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598265017", "bodyText": "Leftover from intermediate implementation - removed", "author": "weymann", "createdAt": "2021-03-21T11:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2NjUxNw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java\nindex d57fead76f..11f2b01303 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/ConnectedDriveHandlerFactory.java\n\n@@ -14,9 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.handler.BMWConnectedDriveOptionProvider;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597866996", "bodyText": "The scope's name should match with the binding's name", "author": "fwolter", "createdAt": "2021-03-19T17:44:17Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3MzkzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598273931", "bodyText": "That implies you could have only a single action per binding. Is this the intention? Or is there a naming-scheme if you want to have multiple actions for the same binding?", "author": "ntruchsess", "createdAt": "2021-03-21T12:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NjA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598276057", "bodyText": "I'm not aware of a binding that has multiple Action classes for the same Thing. If I see correctly this binding has only one Action class. Is this a hypothetical question or is there maybe some misunderstanding?", "author": "fwolter", "createdAt": "2021-03-21T12:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMyMjE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598322141", "bodyText": "That is not a hypothetical question - from my point of view it makes sense to have multiple actions per thing but I don't know whether this is somehow forbidden by the OH3 design. Technically it doesn't seem to be. Is there some documentation that lists such conventions? By just looking into the examples this is not obvious.\nOf course I can easily change that if multiple actions per thing are not something anybody would ever want in OH.", "author": "ntruchsess", "createdAt": "2021-03-21T18:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg2MTY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601861693", "bodyText": "Just for clarification, there can be multiple Actions per Thing, but if I understand correctly, you want to add multiple Action classes per Thing?", "author": "fwolter", "createdAt": "2021-03-25T21:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4NDYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601884629", "bodyText": "sure - for what other reason does ThingHandler.getServices() return a collection if not to allow for multiple Action-classes per thing?\npublic Collection<Class<? extends ThingHandlerService>> getServices();\nWhat would the ThingActionsScope-(per-class)-annotation be good for if not to differentiate in between multiple implementations of ThingActions per Thing? If the scope would be a semantical synonym to the Thing-type then it would be just redundant to the ThingUID that is also passed to getActions in a script.\nThe implementation of class ScriptThingActions (how keys of THINGS_ACTION_MAP are being constructed and used) seems to be desinged exactly for that purpose.", "author": "ntruchsess", "createdAt": "2021-03-25T22:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjExMzM1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602113351", "bodyText": "The method signature should a strong evidence, that the framework supports multiple action classes per Thing! :)\nThe scope's name will be used to group the actions in the UI. So, if you call it \"chargeprofile\", it might be a bit lost in the UI.", "author": "fwolter", "createdAt": "2021-03-26T08:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjE1MDQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602150496", "bodyText": "I was not aware it shows in the ui and I don't think the approach you link works out well. It results in a long list of different scopes with a single method for most bindings. It should group per binding and then per scope. Or - if same scope would be used for equivalent actions in different things - optionally first per sope, then per thing-type.\nGiven it groups only per scope it would make sense to use a common prefix for all thing's actions. Like bmw-charging, bmw-navigation (to access recent destinations and send new destinations to the car). But if multiple car-related bindings would offer simmilar actions the prefix should rather be 'car-charging' + 'car-navigation'. But then there might be a binding for the garmin web-portal\nthat also allows to send destinations to so both might group as just 'navigation'.\nMaybe the best choice would be to use the most generic term it might group within? I think there should be a real concept for the grouping in the first place not just examples of existing use (that only shows the shortcomings of not having a concept).", "author": "ntruchsess", "createdAt": "2021-03-26T09:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ2NTgyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602465828", "bodyText": "ATM all actions are grouped by the binding (which is identical to the scope). Can you elaborate what's your concern about this approach?", "author": "fwolter", "createdAt": "2021-03-26T17:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjYyNzQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602627453", "bodyText": "if a binding has multiple ThingActions-classes and thus multiple scopes those are not grouped beneath each other unless their scopes share a common prefix, don't they?. But the information a common prefix for all ThingAction-classes belonging to the same Thing contains is redundant to the fact the actions belong to the same thing.\nAnd actually this is not just a hypothetical question. I'm planning to add a ThingActions-class to the bmwconnecteddrive-binding for creation and sending of messages containing navigation-destinations to the car. I do not want to prefix those names just for the UI, I'll use scope names without prefix and the UI might then be changed to accommodate this.", "author": "ntruchsess", "createdAt": "2021-03-26T23:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjY5MDE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602690145", "bodyText": "if a binding has multiple ThingActions-classes and thus multiple scopes those are not grouped beneath each other unless their scopes share a common prefix, don't they?\n\nI think so, too.\nYou could file an issue for the UI and core to group the actions by binding. I would check beforehand, if a grouping PR is accepted as we might not discussed the whole story here. I'm not familiar with the insights in core and UI at this place.", "author": "fwolter", "createdAt": "2021-03-27T08:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTc3NzI4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r605777281", "bodyText": "I'm a bit puzzeld here. I checked rules creation dialog but didn't find any actions from other bindings. I think just the core actions are in. Besides the BMW binding there's also mqtt active and I would expect the publishMQTTMessage here.", "author": "weymann", "createdAt": "2021-04-01T16:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc1ODMzNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608758337", "bodyText": "I agree with @ntruchsess that more actions will come. I've already sendPointOfInterest in mind which  can be sent to the vehicle and has nothing to do with the ChargeProfile.\nI searched through all present bindings and found only 2 with more than one Action\n\ncaddx - same naming but on different things - doesn't apply in this case\nmax - has 2 different actions max-cube and max-devices\n\nI think chargeprofile is too generic because it can apply to several upcoming car bindings in the future. Is it a valid approach to add the binding name as prefix like the MAX binding?\n@fwolter Can you give advice here?", "author": "weymann", "createdAt": "2021-04-07T15:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc2MTM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608761387", "bodyText": "I think so. But I would use a . to separate the binding name from the topic.", "author": "fwolter", "createdAt": "2021-04-07T15:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODc3NjA1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608776052", "bodyText": "the scope is valid only for the given thing. So even if multiple bindings use same scopes technically there will be no clash. (Of course any ui that groups 'by scope' should take this into account).\nFrom my point of view prepending the scope with the binding-name is redundant. Of course besides having to type more characters it will do no harm though;-)", "author": "ntruchsess", "createdAt": "2021-04-07T15:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODgwOTMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608809325", "bodyText": "the scope is valid only for the given thing.\n\nWhat's the source of this statement? Genuinely asking.", "author": "fwolter", "createdAt": "2021-04-07T16:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODk0NDk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r608944956", "bodyText": "it is in those lengthy specs only few people actually read ;-)", "author": "ntruchsess", "createdAt": "2021-04-07T19:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5MDc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611090749", "bodyText": "I cannot really understand the discussion here. \ud83e\udd14\nWhy isn't a single action class enough? As @fwolter pointed out, a single action class can hold any number of actions, so why should there be a need to split it?\nIt is indeed meant to have the scope be identical to the binding id - this makes it simplest for the user as any exception to this rule can easily lead to mistakes and misunderstandings.\nThe main reason why it is possible to define the scope at all (and not have the binding id applied by the framework automatically) is that there are bindings that consist out of multiple bundles (such as Bluetooth) - in these cases, it must be possible to let the binding extensions also register action classes.\nFor the BMW binding, I'd strongly suggest to go with a single action class, unless I am missing something here.", "author": "kaikreuzer", "createdAt": "2021-04-10T20:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5NjY3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611096672", "bodyText": "@kaikreuzer if you don't understand such discussion you should work on the docs. The main reason for this discussion is that there is no documentation regarding this topic (or if there is then it is well hidden) and the source-code doesn't suggest that it should be such either.\nOf course - technically there is no restrictions in number of methods in a single action-class. If there shall only be a single action-class per binding we have to rename the class and some of it's methods as e.g. a 'send' or 'cancel' will be ambigous as soon we add further remoting functionality (like sending points-of-interest)", "author": "ntruchsess", "createdAt": "2021-04-10T21:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5Njk2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611096969", "bodyText": "I'm glad that things are clear now.\nYou could file a PR to improve the docs.", "author": "fwolter", "createdAt": "2021-04-10T21:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTA5OTk4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611099985", "bodyText": "Looking at the telegram binding gives a good impression what happens if an unlimited number of thing actions are implemented in one ThingActions class. If everything that is requested in issues (and what is - in most cases - a good idea), we\u2018ll easily end up with 1k+ lines in a single class file (already 650 lines now). This will end up in unmanageable code (like the Connection class in the amazonechocontrol binding).", "author": "J-N-K", "createdAt": "2021-04-10T22:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTE3NjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611176543", "bodyText": "I'm glad that things are clear now.\nYou could file a PR to improve the docs.\n\nI don't see how I can improve the docs. If design-decisions and conventions cannot be derived from the code then it must be written by someone who knows the design-decisions. I can only read the code and I've just learned in openhab that is not a reliable source in terms of extracting wanted behaviour.", "author": "ntruchsess", "createdAt": "2021-04-11T11:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTE4NTM5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611185396", "bodyText": "@weymann please merge weymann#15 so we comply with @kaikreuzer s philosophy", "author": "ntruchsess", "createdAt": "2021-04-11T13:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTkxMDA3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r611910077", "bodyText": "That's a valid discusion! I raised the issue #10510", "author": "weymann", "createdAt": "2021-04-12T19:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Njk5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/BMWConnectedDriveActions.java\nsimilarity index 83%\nrename from bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java\nrename to bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/BMWConnectedDriveActions.java\nindex e51fcfbdec..10884ddaa8 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/BMWConnectedDriveActions.java\n\n@@ -32,13 +32,13 @@ import org.openhab.core.thing.binding.ThingActionsScope;\n import org.openhab.core.thing.binding.ThingHandler;\n \n /**\n- * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ * The {@link BMWConnectedDriveActions} provides actions for VehicleHandler\n  *\n  * @author Norbert Truchsess - Initial contribution\n  */\n-@ThingActionsScope(name = \"chargeprofile\")\n+@ThingActionsScope(name = \"bmwconnecteddrive\")\n @NonNullByDefault\n-public class ChargeProfileActions implements ThingActions {\n+public class BMWConnectedDriveActions implements ThingActions {\n \n     private Optional<VehicleHandler> handler = Optional.empty();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597867946", "bodyText": "Is there a reason why you don't add the timer number as an argument to a single common action?", "author": "fwolter", "createdAt": "2021-03-19T17:45:54Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.action;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.VehicleHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+\n+/**\n+ * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ *\n+ * @author Norbert Truchsess - Initial contribution\n+ */\n+@ThingActionsScope(name = \"chargeprofile\")\n+@NonNullByDefault\n+public class ChargeProfileActions implements ThingActions {\n+\n+    private Optional<VehicleHandler> handler = Optional.empty();\n+\n+    private Optional<ChargeProfileWrapper> profile = Optional.empty();\n+\n+    @RuleAction(label = \"getTimer1Departure\", description = \"returns the departure time of timer1\")", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3MzcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598273724", "bodyText": "The reason is that not all timers are the same - one has a special behaviour (the so called 'Override'-timer).\nOf course for timer 1 to 3 the number could be passed as a parameter but (besides there would be less methods) - is this really any better?", "author": "ntruchsess", "createdAt": "2021-03-21T12:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275353", "bodyText": "I think it would make the code cleaner, more concise and thus better maintainable.", "author": "fwolter", "createdAt": "2021-03-21T12:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMyMDQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598320454", "bodyText": "The properties of a charging-profile are being accessible by a few methods on the ChargeProfileWrapper-class (getTime/setTime, getEnabled/setEnabled, getDays/setDays). That Wrapper is being used both by the actions and by the command-handler. The actual Actions-class is just a dumb wrapper around the ChargeProfileWrapper. Besides hiding the typed keys that are used in ChargeProfileWrapper there is no logic in the Actions class. That also implies there is not much maintainability that one might gain here ;-)\nOf course the Actions-class might just wrap those getTime/setTime-methods of ChargeProfileWrapper, but that would imply exposing the ProfileKey-enum in the scripting-api which makes it harder to use for the script-developer (which is the main reason for the design-decission to offer more methods instead).", "author": "ntruchsess", "createdAt": "2021-03-21T18:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg1OTg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601859885", "bodyText": "OK", "author": "fwolter", "createdAt": "2021-03-25T21:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg2Nzk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/BMWConnectedDriveActions.java\nsimilarity index 83%\nrename from bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java\nrename to bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/BMWConnectedDriveActions.java\nindex e51fcfbdec..10884ddaa8 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/ChargeProfileActions.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/action/BMWConnectedDriveActions.java\n\n@@ -32,13 +32,13 @@ import org.openhab.core.thing.binding.ThingActionsScope;\n import org.openhab.core.thing.binding.ThingHandler;\n \n /**\n- * The {@link ChargeProfileActions} provides actions for VehicleHandler\n+ * The {@link BMWConnectedDriveActions} provides actions for VehicleHandler\n  *\n  * @author Norbert Truchsess - Initial contribution\n  */\n-@ThingActionsScope(name = \"chargeprofile\")\n+@ThingActionsScope(name = \"bmwconnecteddrive\")\n @NonNullByDefault\n-public class ChargeProfileActions implements ThingActions {\n+public class BMWConnectedDriveActions implements ThingActions {\n \n     private Optional<VehicleHandler> handler = Optional.empty();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3MjUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597872524", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2021-03-19T17:52:32Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2Njg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598266873", "bodyText": "fixed", "author": "weymann", "createdAt": "2021-03-21T11:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3MjUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 277fdc31a9..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -18,7 +18,6 @@ import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NDU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597874565", "bodyText": "Actually, the framework takes care that no Things with the same reprentation property are added to the inbox. What is the reason for checking it here?", "author": "fwolter", "createdAt": "2021-03-19T17:55:47Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEyODIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599128236", "bodyText": "Ok, removed", "author": "weymann", "createdAt": "2021-03-22T22:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NDU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 277fdc31a9..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -18,7 +18,6 @@ import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3Njg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597876880", "bodyText": "What is the purpose of overriding this?", "author": "fwolter", "createdAt": "2021-03-19T17:59:17Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2OTY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598269691", "bodyText": "No purpose! Was somehow added by Eclipse when adding ThingHandlerService.\nDeleted", "author": "weymann", "createdAt": "2021-03-21T12:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3Njg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 277fdc31a9..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -18,7 +18,6 @@ import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597877479", "bodyText": "Same as above. Purpose.", "author": "fwolter", "createdAt": "2021-03-19T18:00:10Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2OTc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598269761", "bodyText": "No purpose, same comment as above", "author": "weymann", "createdAt": "2021-03-21T12:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzQ3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 277fdc31a9..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -18,7 +18,6 @@ import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzU3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597877576", "bodyText": "Same as above. Purpose.", "author": "fwolter", "createdAt": "2021-03-19T18:00:18Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.discovery;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.SUPPORTED_THING_SET;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.ConnectedDriveBridgeHandler;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VehicleDiscovery} requests data from ConnectedDrive and is identifying the Vehicles after response\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleDiscovery extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VehicleDiscovery.class);\n+    private static final int DISCOVERY_TIMEOUT = 10;\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+\n+    public VehicleDiscovery() {\n+        super(SUPPORTED_THING_SET, DISCOVERY_TIMEOUT, false);\n+    }\n+\n+    public void onResponse(VehiclesContainer container) {\n+        bridgeHandler.ifPresent(bridge -> {\n+            final ThingUID bridgeUID = bridge.getThing().getUID();\n+            container.vehicles.forEach(vehicle -> {\n+                // the DriveTrain field in the delivered json is defining the Vehicle Type\n+                String vehicleType = vehicle.driveTrain.toLowerCase();\n+                SUPPORTED_THING_SET.forEach(entry -> {\n+                    if (entry.getId().equals(vehicleType)) {\n+                        ThingUID uid = new ThingUID(entry, vehicle.vin, bridgeUID.getId());\n+                        Map<String, String> properties = new HashMap<>();\n+                        // Dealer\n+                        if (vehicle.dealer != null) {\n+                            properties.put(\"dealer\", vehicle.dealer.name);\n+                            properties.put(\"dealerAddress\", vehicle.dealer.street + \" \" + vehicle.dealer.country + \" \"\n+                                    + vehicle.dealer.postalCode + \" \" + vehicle.dealer.city);\n+                            properties.put(\"dealerPhone\", vehicle.dealer.phone);\n+                        }\n+\n+                        // Services & Support\n+                        properties.put(\"servicesActivated\", getObject(vehicle, Constants.ACTIVATED));\n+                        String servicesSupported = getObject(vehicle, Constants.SUPPORTED);\n+                        String servicesNotSupported = getObject(vehicle, Constants.NOT_SUPPORTED);\n+                        if (vehicle.statisticsAvailable) {\n+                            servicesSupported += Constants.STATISTICS;\n+                        } else {\n+                            servicesNotSupported += Constants.STATISTICS;\n+                        }\n+                        properties.put(Constants.SERVICES_SUPPORTED, servicesSupported);\n+                        properties.put(\"servicesNotSupported\", servicesNotSupported);\n+                        properties.put(\"supportBreakdownNumber\", vehicle.breakdownNumber);\n+\n+                        // Vehicle Properties\n+                        if (vehicle.supportedChargingModes != null) {\n+                            properties.put(\"vehicleChargeModes\",\n+                                    String.join(Constants.SPACE, vehicle.supportedChargingModes));\n+                        }\n+                        if (vehicle.hasAlarmSystem) {\n+                            properties.put(\"vehicleAlarmSystem\", \"Available\");\n+                        } else {\n+                            properties.put(\"vehicleAlarmSystem\", \"Not Available\");\n+                        }\n+                        properties.put(\"vehicleBrand\", vehicle.brand);\n+                        properties.put(\"vehicleBodytype\", vehicle.bodytype);\n+                        properties.put(\"vehicleColor\", vehicle.color);\n+                        properties.put(\"vehicleConstructionYear\", Short.toString(vehicle.yearOfConstruction));\n+                        properties.put(\"vehicleDriveTrain\", vehicle.driveTrain);\n+                        properties.put(\"vehicleModel\", vehicle.model);\n+                        if (vehicle.chargingControl != null) {\n+                            properties.put(\"vehicleChargeControl\", Converter.toTitleCase(vehicle.model));\n+                        }\n+\n+                        // Check now if a thing with the same VIN exists\n+                        final AtomicBoolean foundVehicle = new AtomicBoolean(false);\n+                        bridge.getThing().getThings().forEach(vehicleThing -> {\n+                            Configuration c = vehicleThing.getConfiguration();\n+                            if (c.containsKey(ConnectedDriveConstants.VIN)) {\n+                                String thingVIN = c.get(ConnectedDriveConstants.VIN).toString();\n+                                if (vehicle.vin.equals(thingVIN)) {\n+                                    vehicleThing.setProperties(properties);\n+                                    foundVehicle.set(true);\n+                                }\n+                            }\n+                        });\n+\n+                        // Vehicle not found -> trigger discovery\n+                        if (!foundVehicle.get()) {\n+                            // Properties needed for functional THing\n+                            properties.put(ConnectedDriveConstants.VIN, vehicle.vin);\n+                            properties.put(\"refreshInterval\",\n+                                    Integer.toString(ConnectedDriveConstants.DEFAULT_REFRESH_INTERVAL));\n+                            properties.put(\"units\", ConnectedDriveConstants.UNITS_AUTODETECT);\n+                            properties.put(\"imageSize\", Integer.toString(ConnectedDriveConstants.DEFAULT_IMAGE_SIZE));\n+                            properties.put(\"imageViewport\", ConnectedDriveConstants.DEFAULT_IMAGE_VIEWPORT);\n+\n+                            String vehicleLabel = vehicle.brand + \" \" + vehicle.model;\n+                            Map<String, Object> convertedProperties = new HashMap<String, Object>(properties);\n+                            thingDiscovered(DiscoveryResultBuilder.create(uid).withBridge(bridgeUID)\n+                                    .withRepresentationProperty(ConnectedDriveConstants.VIN).withLabel(vehicleLabel)\n+                                    .withProperties(convertedProperties).build());\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    };\n+\n+    /**\n+     * Get all field names from a DTO with a specific value\n+     * Used to get e.g. all services which are \"ACTIVATED\"\n+     *\n+     * @param DTO Object\n+     * @param compare String which needs to map with the value\n+     * @return String with all field names matching this value separated with Spaces\n+     */\n+    public String getObject(Object dto, String compare) {\n+        StringBuilder buf = new StringBuilder();\n+        for (Field field : dto.getClass().getDeclaredFields()) {\n+            try {\n+                Object value = field.get(dto);\n+                if (compare.equals(value)) {\n+                    buf.append(Converter.capitalizeFirst(field.getName()) + Constants.SPACE);\n+                }\n+            } catch (IllegalArgumentException | IllegalAccessException e) {\n+                logger.debug(\"Field {} not found {}\", compare, e.getMessage());\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    @Override\n+    public void setThingHandler(ThingHandler handler) {\n+        if (handler instanceof ConnectedDriveBridgeHandler) {\n+            bridgeHandler = Optional.of((ConnectedDriveBridgeHandler) handler);\n+            bridgeHandler.get().setDiscoveryService(this);\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler.orElse(null);\n+    }\n+\n+    @Override\n+    public int getScanTimeout() {\n+        return DISCOVERY_TIMEOUT;\n+    }\n+\n+    @Override\n+    public boolean isBackgroundDiscoveryEnabled() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        bridgeHandler.ifPresent(ConnectedDriveBridgeHandler::requestVehicles);\n+    }\n+\n+    @Override\n+    public void abortScan() {\n+        // nothing to abort\n+    }\n+\n+    @Override\n+    public void activate() {\n+        super.activate(null);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI2OTc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598269788", "bodyText": "No purpose, but need to keep deactivate due to compiler error\n[ERROR] C:\\Users\\bernd\\openhab-master\\git\\openhab-addons\\bundles\\org.openhab.binding.bmwconnecteddrive\\src\\main\\java\\org\\openhab\\binding\\bmwconnecteddrive\\internal\\discovery\\VehicleDiscovery.java:[46,14] The inherited method org.openhab.core.config.discovery.AbstractDiscoveryService.deactivate() cannot hide the public abstract method in org.openhab.core.thing.binding.ThingHandlerService", "author": "weymann", "createdAt": "2021-03-21T12:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3NzU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\nindex 277fdc31a9..55c66b5b44 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/discovery/VehicleDiscovery.java\n\n@@ -18,7 +18,6 @@ import java.lang.reflect.Field;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597878891", "bodyText": "What is the reason for requesting all vehicles from the API? Can't you access the bridge's Things?", "author": "fwolter", "createdAt": "2021-03-19T18:02:38Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTE0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275144", "bodyText": "It's the only API to check for the bridge. Depending on the response either Bridge goes ONLINE / OFFLINE and debug entry is generated to identify problems.", "author": "weymann", "createdAt": "2021-03-21T12:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598276294", "bodyText": "Understood. You could add a comment, that this could by any API request and the purpose is only to check the connectitivity.", "author": "fwolter", "createdAt": "2021-03-21T13:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzMDI4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599130281", "bodyText": "ok", "author": "weymann", "createdAt": "2021-03-22T22:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg3ODg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex 81b7334885..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -27,6 +27,7 @@ import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.core.io.net.http.HttpClientFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MDA5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597880097", "bodyText": "StringBuilder has better performance when used in loops. In these use cases, you could simply use the plus operator.", "author": "fwolter", "createdAt": "2021-03-19T18:04:44Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link Destination} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class Destination {\n+    public float lat;\n+    public float lon;\n+    public String country;\n+    public String city;\n+    public String street;\n+    public String streetNumber;\n+    public String type;\n+    public String createdAt;\n+\n+    public String getAddress() {\n+        StringBuilder buf = new StringBuilder();\n+        if (street != null) {\n+            buf.append(street);\n+            if (streetNumber != null) {\n+                buf.append(SPACE).append(streetNumber);\n+            }\n+        }\n+        if (city != null) {\n+            if (buf.length() > 0) {\n+                buf.append(COMMA).append(SPACE).append(city);\n+            } else {\n+                buf.append(city);\n+            }\n+        }\n+        if (buf.length() == 0) {\n+            return UNDEF;\n+        } else {\n+            return Converter.toTitleCase(buf.toString());\n+        }\n+    }\n+\n+    public String getCoordinates() {\n+        return new StringBuilder().append(lat).append(Constants.COMMA).append(lon).toString();", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NTQyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598275421", "bodyText": "done", "author": "weymann", "createdAt": "2021-03-21T12:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MDA5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\nindex c365dfb294..e9d653a8e2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/Destination.java\n\n@@ -55,6 +55,6 @@ public class Destination {\n     }\n \n     public String getCoordinates() {\n-        return new StringBuilder().append(lat).append(Constants.COMMA).append(lon).toString();\n+        return lat + Constants.COMMA + lon;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MTI3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597881276", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2021-03-19T18:06:40Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link VehicleAttributesContainer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleAttributesContainer {\n+    public VehicleAttributes attributesMap;\n+    public VehicleMessages vehicleMessages;\n+\n+    public String transform() {\n+        // create target objects\n+        VehicleStatusContainer vsc = new VehicleStatusContainer();\n+        VehicleStatus vs = new VehicleStatus();\n+        vsc.vehicleStatus = vs;\n+\n+        vs.mileage = attributesMap.mileage;\n+        vs.doorLockState = attributesMap.doorLockState;\n+\n+        vs.doorDriverFront = attributesMap.doorDriverFront;\n+        vs.doorDriverRear = attributesMap.doorDriverRear;\n+        vs.doorPassengerFront = attributesMap.doorPassengerFront;\n+        vs.doorPassengerRear = attributesMap.doorPassengerRear;\n+        vs.hood = attributesMap.hoodState;\n+        vs.trunk = attributesMap.trunkState;\n+\n+        vs.windowDriverFront = attributesMap.winDriverFront;\n+        vs.windowDriverRear = attributesMap.winDriverRear;\n+        vs.windowPassengerFront = attributesMap.winPassengerFront;\n+        vs.windowPassengerRear = attributesMap.winPassengerRear;\n+        vs.sunroof = attributesMap.sunroofState;\n+\n+        vs.remainingFuel = attributesMap.remainingFuel;\n+        vs.remainingRangeElectric = attributesMap.beRemainingRangeElectricKm;\n+        vs.remainingRangeElectricMls = attributesMap.beRemainingRangeElectricMile;\n+        vs.remainingRangeFuel = attributesMap.beRemainingRangeFuelKm;\n+        vs.remainingRangeFuelMls = attributesMap.beRemainingRangeFuelMile;\n+        vs.remainingFuel = attributesMap.remainingFuel;\n+        vs.chargingLevelHv = attributesMap.chargingLevelHv;\n+        vs.chargingStatus = attributesMap.chargingHVStatus;\n+        vs.lastChargingEndReason = attributesMap.lastChargingEndReason;\n+\n+        vs.updateTime = attributesMap.updateTimeConverted;\n+        // vs.internalDataTimeUTC = attributesMap.updateTime;", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzMDU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599130570", "bodyText": "Sure", "author": "weymann", "createdAt": "2021-03-22T22:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MTI3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\nindex 3d24246d27..3e8087f6e2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\n\n@@ -12,17 +12,6 @@\n  */\n package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n-import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n-import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n-\n /**\n  * The {@link VehicleAttributesContainer} Data Transfer Object\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MjU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597882585", "bodyText": "DTOs shouldn't have logic. You could move it outside the DTO package.-", "author": "fwolter", "createdAt": "2021-03-19T18:08:51Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+\n+/**\n+ * The {@link VehicleAttributesContainer} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class VehicleAttributesContainer {\n+    public VehicleAttributes attributesMap;\n+    public VehicleMessages vehicleMessages;\n+\n+    public String transform() {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzODQ4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599138484", "bodyText": "Moved to Converter", "author": "weymann", "createdAt": "2021-03-22T23:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4MjU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\nindex 3d24246d27..3e8087f6e2 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/compat/VehicleAttributesContainer.java\n\n@@ -12,17 +12,6 @@\n  */\n package org.openhab.binding.bmwconnecteddrive.internal.dto.compat;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n-import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n-import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n-import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n-\n /**\n  * The {@link VehicleAttributesContainer} Data Transfer Object\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4Mjg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597882881", "bodyText": "Can these be removed?", "author": "fwolter", "createdAt": "2021-03-19T18:09:24Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.dto.remote;\n+\n+/**\n+ * The {@link ExecutionStatus} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+public class ExecutionStatus {\n+    public String serviceType;// \": \"DOOR_UNLOCK\",\n+    public String status;// \": \"EXECUTED\",\n+    public String eventId;// \": \"5639303536333926DA7B9400@bmw.de\",\n+    // public String extendedStatus;// \": {\n+    // public String newDoorStatus;// \": \"INVALID\",\n+    // public String oldDoorStatus;// \": \"INVALID\",\n+    // public String result;// \": \"STATUS_NOT_CHANGED\"", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTEzODk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599138979", "bodyText": "Yes, not used so far", "author": "weymann", "createdAt": "2021-03-22T23:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4Mjg4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java\nindex 71ff06627a..4f80ac78df 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/dto/remote/ExecutionStatus.java\n\n@@ -21,8 +21,4 @@ public class ExecutionStatus {\n     public String serviceType;// \": \"DOOR_UNLOCK\",\n     public String status;// \": \"EXECUTED\",\n     public String eventId;// \": \"5639303536333926DA7B9400@bmw.de\",\n-    // public String extendedStatus;// \": {\n-    // public String newDoorStatus;// \": \"INVALID\",\n-    // public String oldDoorStatus;// \": \"INVALID\",\n-    // public String result;// \": \"STATUS_NOT_CHANGED\"\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597884315", "bodyText": "If I see correctly the config is always present at this location. So, this will never be invoked.", "author": "fwolter", "createdAt": "2021-03-19T18:11:50Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NjM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598276369", "bodyText": "From what I can see deep inside BaseThingHandler.getConfigAs() ... there is a call to ConfigMapper.as returning Nullable which is not handled properly and would be returend by BaseThingHandler. But I agree: As formally BaseThingHandler.getConfigAs is declared as NonNullByDefault that should be fixed within BaseThingHandler. So I agree it can be removed.", "author": "ntruchsess", "createdAt": "2021-03-21T13:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3NzMzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598277334", "bodyText": "Good catch. You could file an issue in openhab-core.", "author": "fwolter", "createdAt": "2021-03-21T13:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI3ODg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598278898", "bodyText": "fixed in weymann#7", "author": "ntruchsess", "createdAt": "2021-03-21T13:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDMxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex 81b7334885..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -27,6 +27,7 @@ import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.core.io.net.http.HttpClientFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597884616", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-03-19T18:12:24Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        initializerJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void requestVehicles() {\n+        proxy.ifPresent(prox -> prox.requestVehicles(this));\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        return troubleshootFingerprint.map(fingerprint -> {\n+            VehiclesContainer container = null;\n+            try {\n+                container = Converter.getGson().fromJson(fingerprint, VehiclesContainer.class);\n+            } catch (JsonParseException jpe) {\n+                logger.info(\"Cannot parse fingerprint {}\", jpe.getMessage());", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE0ODA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599148053", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-22T23:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NDYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex 81b7334885..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -27,6 +27,7 @@ import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.core.io.net.http.HttpClientFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NTQxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597885418", "bodyText": "You could move this block into the try branch.", "author": "fwolter", "createdAt": "2021-03-19T18:13:40Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.ANONYMOUS;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link ConnectedDriveBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveBridgeHandler extends BaseBridgeHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveBridgeHandler.class);\n+    private HttpClientFactory httpClientFactory;\n+    private Optional<VehicleDiscovery> discoveryService = Optional.empty();\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<ConnectedDriveConfiguration> configuration = Optional.empty();\n+    private Optional<ScheduledFuture<?>> initializerJob = Optional.empty();\n+    private Optional<String> troubleshootFingerprint = Optional.empty();\n+\n+    public ConnectedDriveBridgeHandler(Bridge bridge, HttpClientFactory hcf) {\n+        super(bridge);\n+        httpClientFactory = hcf;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands available\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        troubleshootFingerprint = Optional.empty();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        configuration = Optional.of(getConfigAs(ConnectedDriveConfiguration.class));\n+        configuration.ifPresentOrElse(config -> {\n+            proxy = Optional.of(new ConnectedDriveProxy(httpClientFactory, config));\n+            // give the system some time to create all predefined Vehicles\n+            initializerJob = Optional.of(scheduler.schedule(this::requestVehicles, 5, TimeUnit.SECONDS));\n+        }, () -> {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        initializerJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void requestVehicles() {\n+        proxy.ifPresent(prox -> prox.requestVehicles(this));\n+    }\n+\n+    public String getDiscoveryFingerprint() {\n+        return troubleshootFingerprint.map(fingerprint -> {\n+            VehiclesContainer container = null;\n+            try {\n+                container = Converter.getGson().fromJson(fingerprint, VehiclesContainer.class);\n+            } catch (JsonParseException jpe) {\n+                logger.info(\"Cannot parse fingerprint {}\", jpe.getMessage());\n+            }\n+            if (container != null) {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE0ODY5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599148695", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-22T23:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NTQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\nindex 81b7334885..5c7ac485d5 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveBridgeHandler.java\n\n@@ -27,6 +27,7 @@ import org.openhab.binding.bmwconnecteddrive.internal.discovery.VehicleDiscovery\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.Dealer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.discovery.VehiclesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.core.io.net.http.HttpClientFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NjgwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597886807", "bodyText": "Is the Thing usable if this exception is rised? You could throw the exception and set the Thing offline with the exception's message.", "author": "fwolter", "createdAt": "2021-03-19T18:16:13Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc4OTU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602789592", "bodyText": "Right. After some thoughts I don't think it's the right place. I moved this into updateToken so if client isn't started it will be tried again for recovery. If updateToken fails correpsonding callback.onError is called and thing will be set to OFFLINE.", "author": "weymann", "createdAt": "2021-03-27T20:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NjgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NzcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597887701", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be warn.\nPlease check all.", "author": "fwolter", "createdAt": "2021-03-19T18:17:43Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1MTMyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599151323", "bodyText": "It's only used for Simulation purposes, so reduced to debug", "author": "weymann", "createdAt": "2021-03-22T23:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4NzcwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4ODY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597888654", "bodyText": "This applies the charset of the user's JVM. I would expect that the API expects a specific encoding.\nPlease check all.", "author": "fwolter", "createdAt": "2021-03-19T18:19:09Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDI4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280286", "bodyText": "fixed in weymann#8", "author": "ntruchsess", "createdAt": "2021-03-21T13:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4ODY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4OTQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597889481", "bodyText": "Please add the package to the imports.", "author": "fwolter", "createdAt": "2021-03-19T18:20:28Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280625", "bodyText": "also fixed in weymann#8", "author": "ntruchsess", "createdAt": "2021-03-21T13:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg4OTQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MDcwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597890707", "bodyText": "Are you sure this is always StringResponseCallback?", "author": "fwolter", "createdAt": "2021-03-19T18:22:37Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1MjE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599152155", "bodyText": "Yes, due to the URL check I'm sure", "author": "weymann", "createdAt": "2021-03-22T23:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MDcwNw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MTQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597891442", "bodyText": "Better check if it is ByteResponseCallback, in case in the future somebody adds another response callback type.", "author": "fwolter", "createdAt": "2021-03-19T18:23:50Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MTc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598281781", "bodyText": "fixed in weymann#8", "author": "ntruchsess", "createdAt": "2021-03-21T13:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MTQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MjIwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597892203", "bodyText": "Any reason not using getRegionServer() here?", "author": "fwolter", "createdAt": "2021-03-19T18:25:19Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1MzIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599153204", "bodyText": "No, fixed", "author": "weymann", "createdAt": "2021-03-22T23:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MjIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MzUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597893513", "bodyText": "You might want to do some validation on the user input. It can be empty if the user forgot to specify the parameter in textual configuration.", "author": "fwolter", "createdAt": "2021-03-19T18:27:32Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599155227", "bodyText": "Applied same handling as getRegionServer", "author": "weymann", "createdAt": "2021-03-23T00:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5MzUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Mzc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597893771", "bodyText": "See above. Encoding.", "author": "fwolter", "createdAt": "2021-03-19T18:28:01Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED,\n+                UrlEncoded.encode(dataMap, Charset.defaultCharset(), false), Charset.defaultCharset()));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280713", "bodyText": "fixed in weymann#8", "author": "ntruchsess", "createdAt": "2021-03-21T13:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Mzc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5NDQ3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597894474", "bodyText": "It seems unreasonable to log the stack trace if the network fails.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage(), e);\n          \n          \n            \n                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n          \n          \n            \n                        logger.debug(\"Authorization exception: {}\", e.getMessage());", "author": "fwolter", "createdAt": "2021-03-19T18:29:08Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpField;\n+import org.eclipse.jetty.http.HttpFields;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.auth.AuthResponse;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.simulation.Injector;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.BimmerConstants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ConnectedDriveProxy} This class holds the important constants for the BMW Connected Drive Authorization.\n+ * They\n+ * are taken from the Bimmercode from github {@link https://github.com/bimmerconnected/bimmer_connected}\n+ * File defining these constants\n+ * {@link https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/account.py}\n+ * https://customer.bmwgroup.com/one/app/oauth.js\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class ConnectedDriveProxy {\n+    private final Logger logger = LoggerFactory.getLogger(ConnectedDriveProxy.class);\n+    private final Token token = new Token();\n+    private final HttpClient httpClient;\n+    private final HttpClient authHttpClient;\n+    private final String legacyAuthUri;\n+    private final ConnectedDriveConfiguration configuration;\n+\n+    /**\n+     * URLs taken from https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/const.py\n+     */\n+    final String baseUrl;\n+    final String vehicleUrl;\n+    final String legacyUrl;\n+    final String vehicleStatusAPI = \"/status\";\n+    final String lastTripAPI = \"/statistics/lastTrip\";\n+    final String allTripsAPI = \"/statistics/allTrips\";\n+    final String chargeAPI = \"/chargingprofile\";\n+    final String destinationAPI = \"/destinations\";\n+    final String imageAPI = \"/image\";\n+    final String rangeMapAPI = \"/rangemap\";\n+    final String serviceExecutionAPI = \"/executeService\";\n+    final String serviceExecutionStateAPI = \"/serviceExecutionStatus\";\n+\n+    public ConnectedDriveProxy(HttpClientFactory httpClientFactory, ConnectedDriveConfiguration config) {\n+        httpClient = httpClientFactory.getCommonHttpClient();\n+        authHttpClient = httpClientFactory.createHttpClient(AUTH_HTTP_CLIENT_NAME);\n+        authHttpClient.setFollowRedirects(false);\n+        try {\n+            authHttpClient.start();\n+        } catch (Exception e) {\n+            logger.warn(\"Auth Http Client cannot be started\");\n+        }\n+        configuration = config;\n+\n+        final StringBuilder legacyAuth = new StringBuilder();\n+        legacyAuth.append(\"https://\");\n+        legacyAuth.append(BimmerConstants.AUTH_SERVER_MAP.get(configuration.region));\n+        legacyAuth.append(BimmerConstants.OAUTH_ENDPOINT);\n+        legacyAuthUri = legacyAuth.toString();\n+        vehicleUrl = \"https://\" + getRegionServer() + \"/webapi/v1/user/vehicles\";\n+        baseUrl = vehicleUrl + \"/\";\n+        legacyUrl = \"https://\" + getRegionServer() + \"/api/vehicle/dynamic/v1/\";\n+    }\n+\n+    private synchronized void call(final String url, final boolean post, final @Nullable MultiMap<String> params,\n+            final ResponseCallback callback) {\n+        // only executed in \"simulation mode\"\n+        // SimulationTest.testSimulationOff() assures Injector is off when releasing\n+        if (Injector.isActive()) {\n+            if (url.equals(baseUrl)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getDiscovery());\n+            } else if (url.endsWith(vehicleStatusAPI)) {\n+                ((StringResponseCallback) callback).onResponse(Injector.getStatus());\n+            } else {\n+                logger.info(\"Simulation of {} not supported\", url);\n+            }\n+            return;\n+        }\n+        final Request req;\n+        final String encoded = params == null || params.isEmpty() ? null\n+                : UrlEncoded.encode(params, Charset.defaultCharset(), false);\n+        final String completeUrl;\n+\n+        if (post) {\n+            completeUrl = url;\n+            req = httpClient.POST(url);\n+            if (encoded != null) {\n+                req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED, encoded, Charset.defaultCharset()));\n+            }\n+        } else {\n+            completeUrl = encoded == null ? url : url + Constants.QUESTION + encoded;\n+            req = httpClient.newRequest(completeUrl);\n+        }\n+        req.header(HttpHeader.AUTHORIZATION, getToken().getBearerToken());\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @NonNullByDefault({})\n+            @Override\n+            public void onComplete(org.eclipse.jetty.client.api.Result result) {\n+                if (result.getResponse().getStatus() != 200) {\n+                    NetworkError error = new NetworkError();\n+                    error.url = completeUrl;\n+                    error.status = result.getResponse().getStatus();\n+                    if (result.getResponse().getReason() != null) {\n+                        error.reason = result.getResponse().getReason();\n+                    } else {\n+                        error.reason = result.getFailure().getMessage();\n+                    }\n+                    error.params = result.getRequest().getParams().toString();\n+                    logger.debug(\"HTTP Error {}\", error.toString());\n+                    callback.onError(error);\n+                } else {\n+                    if (callback instanceof StringResponseCallback) {\n+                        ((StringResponseCallback) callback).onResponse(getContentAsString());\n+                    } else {\n+                        ((ByteResponseCallback) callback).onResponse(getContent());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    public void get(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, false, params, callback);\n+    }\n+\n+    public void post(String url, @Nullable MultiMap<String> params, ResponseCallback callback) {\n+        call(url, true, params, callback);\n+    }\n+\n+    public void requestVehicles(StringResponseCallback callback) {\n+        get(vehicleUrl, null, callback);\n+    }\n+\n+    public void requestVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + vehicleStatusAPI, null, callback);\n+    }\n+\n+    public void requestLegacyVehcileStatus(VehicleConfiguration config, StringResponseCallback callback) {\n+        // see https://github.com/jupe76/bmwcdapi/search?q=dynamic%2Fv1\n+        get(legacyUrl + config.vin + \"?offset=-60\", null, callback);\n+    }\n+\n+    public void requestLastTrip(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + lastTripAPI, null, callback);\n+    }\n+\n+    public void requestAllTrips(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + allTripsAPI, null, callback);\n+    }\n+\n+    public void requestChargingProfile(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + chargeAPI, null, callback);\n+    }\n+\n+    public void requestDestinations(VehicleConfiguration config, StringResponseCallback callback) {\n+        get(baseUrl + config.vin + destinationAPI, null, callback);\n+    }\n+\n+    public void requestRangeMap(VehicleConfiguration config, @Nullable MultiMap<String> params,\n+            StringResponseCallback callback) {\n+        get(baseUrl + config.vin + rangeMapAPI, params, callback);\n+    }\n+\n+    public void requestImage(VehicleConfiguration config, ImageProperties props, ByteResponseCallback callback) {\n+        final String localImageUrl = baseUrl + config.vin + imageAPI;\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"width\", Integer.toString(props.size));\n+        dataMap.add(\"height\", Integer.toString(props.size));\n+        dataMap.add(\"view\", props.viewport);\n+        get(localImageUrl, dataMap, callback);\n+    }\n+\n+    private String getRegionServer() {\n+        final String retVal = BimmerConstants.SERVER_MAP.get(configuration.region);\n+        return retVal == null ? Constants.INVALID : retVal;\n+    }\n+\n+    RemoteServiceHandler getRemoteServiceHandler(VehicleHandler vehicleHandler) {\n+        return new RemoteServiceHandler(vehicleHandler, this);\n+    }\n+\n+    // Token handling\n+\n+    /**\n+     * Gets new token if old one is expired or invalid. In case of error the token remains.\n+     * So if token refresh fails the corresponding requests will also fail and update the\n+     * Thing status accordingly.\n+     *\n+     * @return token\n+     */\n+    public Token getToken() {\n+        if (token.isExpired() || !token.isValid()) {\n+            updateToken();\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Authorize at BMW Connected Drive Portal and get Token\n+     *\n+     * @return\n+     */\n+    private synchronized void updateToken() {\n+        final Request req = authHttpClient.POST(legacyAuthUri);\n+\n+        req.header(HttpHeader.CONNECTION, KEEP_ALIVE);\n+        req.header(HttpHeader.HOST, BimmerConstants.SERVER_MAP.get(configuration.region));\n+        req.header(HttpHeader.AUTHORIZATION, BimmerConstants.AUTHORIZATION_VALUE_MAP.get(configuration.region));\n+        req.header(CREDENTIALS, BimmerConstants.CREDENTIAL_VALUES);\n+        req.header(HttpHeader.REFERER, BimmerConstants.REFERER_URL);\n+\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(\"grant_type\", \"password\");\n+        dataMap.add(SCOPE, BimmerConstants.SCOPE_VALUES);\n+        dataMap.add(USERNAME, configuration.userName);\n+        dataMap.add(PASSWORD, configuration.password);\n+        req.content(new StringContentProvider(CONTENT_TYPE_URL_ENCODED,\n+                UrlEncoded.encode(dataMap, Charset.defaultCharset(), false), Charset.defaultCharset()));\n+        try {\n+            ContentResponse contentResponse = req.timeout(HTTP_TIMEOUT_SEC, TimeUnit.SECONDS).send();\n+            // Status needs to be 302 - Response is stored in Header\n+            if (contentResponse.getStatus() == 302) {\n+                final HttpFields fields = contentResponse.getHeaders();\n+                final HttpField field = fields.getField(HttpHeader.LOCATION);\n+                tokenFromUrl(field.getValue());\n+            } else if (contentResponse.getStatus() == 200) {\n+                final String stringContent = contentResponse.getContentAsString();\n+                if (stringContent != null && !stringContent.isEmpty()) {\n+                    try {\n+                        final AuthResponse authResponse = Converter.getGson().fromJson(stringContent,\n+                                AuthResponse.class);\n+                        if (authResponse != null) {\n+                            token.setToken(authResponse.accessToken);\n+                            token.setType(authResponse.tokenType);\n+                            token.setExpiration(authResponse.expiresIn);\n+                        } else {\n+                            logger.debug(\"not an Authorization response: {}\", stringContent);\n+                        }\n+                    } catch (JsonSyntaxException jse) {\n+                        logger.debug(\"Authorization response unparsable: {}\", stringContent);\n+                    }\n+                } else {\n+                    logger.debug(\"Authorization response has no content\");\n+                }\n+            } else {\n+                logger.debug(\"Authorization status {} reason {}\", contentResponse.getStatus(),\n+                        contentResponse.getReason());\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Authorization exception: {}\", e.getMessage(), e);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI4MDkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598280932", "bodyText": "fixed in weymann#8", "author": "ntruchsess", "createdAt": "2021-03-21T13:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5NDQ3NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\nindex 2830331b70..af2164bf87 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/ConnectedDriveProxy.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n \n import static org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants.*;\n \n-import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Nzg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597897869", "bodyText": "Please move all fields to the top of the class.", "author": "fwolter", "createdAt": "2021-03-19T18:35:21Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NjEzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599156133", "bodyText": "done", "author": "weymann", "createdAt": "2021-03-23T00:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5Nzg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\nindex 5942e3fce5..fc1999d46a 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n \n import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5ODczNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597898734", "bodyText": "You could throw an exception to finish the program flow quickly and set the Thing offline.", "author": "fwolter", "createdAt": "2021-03-19T18:36:51Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc5NDIwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602794207", "bodyText": "Right, again after looking into this I'm not pleased with this error handling so late. I introduced now checkConfiguration in the BridgeHandler and set it to OFFLINE immediately if config doesn't fit. With this the check in RemoteServiceHandler isn't necessary anymore.", "author": "weymann", "createdAt": "2021-03-27T21:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5ODczNA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\nindex 5942e3fce5..fc1999d46a 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n \n import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5OTQyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597899426", "bodyText": "Can you fix the line break?", "author": "fwolter", "createdAt": "2021-03-19T18:38:01Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");\n+        }\n+    }\n+\n+    boolean execute(RemoteService service, String... data) {\n+        synchronized (this) {\n+            if (serviceExecuting.isPresent()) {\n+                // only one service executing\n+                return false;\n+            }\n+            serviceExecuting = Optional.of(service.name());\n+        }\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(SERVICE_TYPE, service.name());\n+        if (data.length > 0) {\n+            dataMap.add(DATA, data[0]);\n+        }\n+        proxy.post(serviceExecutionAPI, dataMap, this);\n+        return true;\n+    }\n+\n+    public void getState() {\n+        synchronized (this) {\n+            serviceExecuting.ifPresentOrElse(service -> {\n+                if (counter >= GIVEUP_COUNTER) {\n+                    logger.warn(\"Giving up updating state for {} after {} times\", service, GIVEUP_COUNTER);\n+                    reset();\n+                    // immediately refresh data\n+                    handler.getData();\n+                }\n+                counter++;\n+                final MultiMap<String> dataMap = new MultiMap<String>();\n+                dataMap.add(SERVICE_TYPE, service);\n+                proxy.get(serviceExecutionStateAPI, dataMap, this);\n+            }, () -> {\n+                logger.warn(\"No Service executed to get state\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void onResponse(@Nullable String result) {\n+        if (result != null) {\n+            try {\n+                ExecutionStatusContainer esc = Converter.getGson().fromJson(result, ExecutionStatusContainer.class);\n+                if (esc != null && esc.executionStatus != null) {\n+                    String status = esc.executionStatus.status;\n+                    synchronized (this) {\n+                        handler.updateRemoteExecutionStatus(serviceExecuting.orElse(null), status);\n+                        if (ExecutionState.EXECUTED.name().equals(status)) {\n+                            // refresh loop ends - update of status handled in the normal refreshInterval. Earlier\n+                            // update\n+                            // doesn't\n+                            // show better results!", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NjkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599156925", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-23T00:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzg5OTQyNg=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\nindex 5942e3fce5..fc1999d46a 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n \n import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMDA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597900079", "bodyText": "This should be cancelled if the handler is disposed.", "author": "fwolter", "createdAt": "2021-03-19T18:39:09Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.remote.ExecutionStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.HTTPConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RemoteServiceHandler} handles executions of remote services towards your Vehicle\n+ *\n+ * @see https://github.com/bimmerconnected/bimmer_connected/blob/master/bimmer_connected/remote_services.py\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class RemoteServiceHandler implements StringResponseCallback {\n+    private final Logger logger = LoggerFactory.getLogger(RemoteServiceHandler.class);\n+\n+    // after 60 retries the state update will give up\n+    private static final String SERVICE_TYPE = \"serviceType\";\n+    private static final String DATA = \"data\";\n+    private static final int GIVEUP_COUNTER = 6;\n+    private static final int STATE_UPDATE_SEC = HTTPConstants.HTTP_TIMEOUT_SEC + 1; // regular timeout + 1sec\n+    private int counter = 0;\n+\n+    public enum ExecutionState {\n+        READY,\n+        INITIATED,\n+        PENDING,\n+        DELIVERED,\n+        EXECUTED,\n+        ERROR,\n+    }\n+\n+    public enum RemoteService {\n+        LIGHT_FLASH(REMOTE_SERVICE_LIGHT_FLASH, \"Flash Lights\"),\n+        VEHICLE_FINDER(REMOTE_SERVICE_VEHICLE_FINDER, \"Vehicle Finder\"),\n+        DOOR_LOCK(REMOTE_SERVICE_DOOR_LOCK, \"Door Lock\"),\n+        DOOR_UNLOCK(REMOTE_SERVICE_DOOR_UNLOCK, \"Door Unlock\"),\n+        HORN_BLOW(REMOTE_SERVICE_HORN, \"Horn Blow\"),\n+        CLIMATE_NOW(REMOTE_SERVICE_AIR_CONDITIONING, \"Climate Control\"),\n+        CHARGE_NOW(REMOTE_SERVICE_CHARGE_NOW, \"Start Charging\"),\n+        CHARGING_CONTROL(REMOTE_SERVICE_CHARGING_CONTROL, \"Send Charging Profile\");\n+\n+        private final String command;\n+        private final String label;\n+\n+        RemoteService(final String command, final String label) {\n+            this.command = command;\n+            this.label = label;\n+        }\n+\n+        public String getCommand() {\n+            return command;\n+        }\n+\n+        public String getLabel() {\n+            return label;\n+        }\n+    }\n+\n+    private final ConnectedDriveProxy proxy;\n+    private final VehicleHandler handler;\n+    private Optional<String> serviceExecuting = Optional.empty();\n+\n+    private final String serviceExecutionAPI;\n+    private final String serviceExecutionStateAPI;\n+\n+    public RemoteServiceHandler(VehicleHandler vehicleHandler, ConnectedDriveProxy connectedDriveProxy) {\n+        handler = vehicleHandler;\n+        proxy = connectedDriveProxy;\n+        if (handler.getConfiguration().isPresent()) {\n+            final VehicleConfiguration config = handler.getConfiguration().get();\n+            serviceExecutionAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionAPI;\n+            serviceExecutionStateAPI = proxy.baseUrl + config.vin + proxy.serviceExecutionStateAPI;\n+        } else {\n+            serviceExecutionAPI = Constants.INVALID;\n+            serviceExecutionStateAPI = Constants.INVALID;\n+            logger.warn(\"No configuration for VehicleHandler available\");\n+        }\n+    }\n+\n+    boolean execute(RemoteService service, String... data) {\n+        synchronized (this) {\n+            if (serviceExecuting.isPresent()) {\n+                // only one service executing\n+                return false;\n+            }\n+            serviceExecuting = Optional.of(service.name());\n+        }\n+        final MultiMap<String> dataMap = new MultiMap<String>();\n+        dataMap.add(SERVICE_TYPE, service.name());\n+        if (data.length > 0) {\n+            dataMap.add(DATA, data[0]);\n+        }\n+        proxy.post(serviceExecutionAPI, dataMap, this);\n+        return true;\n+    }\n+\n+    public void getState() {\n+        synchronized (this) {\n+            serviceExecuting.ifPresentOrElse(service -> {\n+                if (counter >= GIVEUP_COUNTER) {\n+                    logger.warn(\"Giving up updating state for {} after {} times\", service, GIVEUP_COUNTER);\n+                    reset();\n+                    // immediately refresh data\n+                    handler.getData();\n+                }\n+                counter++;\n+                final MultiMap<String> dataMap = new MultiMap<String>();\n+                dataMap.add(SERVICE_TYPE, service);\n+                proxy.get(serviceExecutionStateAPI, dataMap, this);\n+            }, () -> {\n+                logger.warn(\"No Service executed to get state\");\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void onResponse(@Nullable String result) {\n+        if (result != null) {\n+            try {\n+                ExecutionStatusContainer esc = Converter.getGson().fromJson(result, ExecutionStatusContainer.class);\n+                if (esc != null && esc.executionStatus != null) {\n+                    String status = esc.executionStatus.status;\n+                    synchronized (this) {\n+                        handler.updateRemoteExecutionStatus(serviceExecuting.orElse(null), status);\n+                        if (ExecutionState.EXECUTED.name().equals(status)) {\n+                            // refresh loop ends - update of status handled in the normal refreshInterval. Earlier\n+                            // update\n+                            // doesn't\n+                            // show better results!\n+                            reset();\n+                            return;\n+                        }\n+                    }\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"RemoteService response is unparseable: {} {}\", result, jse.getMessage());\n+            }\n+        }\n+        // schedule even if no result is present until retries exceeded\n+        handler.getScheduler().schedule(this::getState, STATE_UPDATE_SEC, TimeUnit.SECONDS);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NDExNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598294117", "bodyText": "fixed in weymann#9", "author": "ntruchsess", "createdAt": "2021-03-21T15:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMDA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\nindex 5942e3fce5..fc1999d46a 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/RemoteServiceHandler.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bmwconnecteddrive.internal.handler;\n import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n \n import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMTkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597901907", "bodyText": "You could make this class abstract. Then, you don't need to implement them here.", "author": "fwolter", "createdAt": "2021-03-19T18:42:26Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTE1NzU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r599157566", "bodyText": "Sure, fixed", "author": "weymann", "createdAt": "2021-03-23T00:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwMTkwNw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\nindex b5ad52bd66..6ff369b171 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n\n@@ -46,19 +46,15 @@ import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n import org.openhab.core.library.types.DateTimeType;\n-import org.openhab.core.library.types.DecimalType;\n import org.openhab.core.library.types.OnOffType;\n import org.openhab.core.library.types.PointType;\n import org.openhab.core.library.types.QuantityType;\n import org.openhab.core.library.types.StringType;\n import org.openhab.core.library.unit.ImperialUnits;\n-import org.openhab.core.library.unit.MetricPrefix;\n-import org.openhab.core.library.unit.SIUnits;\n import org.openhab.core.library.unit.Units;\n import org.openhab.core.thing.ChannelUID;\n import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.binding.BaseThingHandler;\n-import org.openhab.core.types.Command;\n import org.openhab.core.types.State;\n import org.openhab.core.types.StateOption;\n import org.openhab.core.types.UnDefType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwNjQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597906457", "bodyText": "You could make MetricPrefix.KILO(SIUnits.METRE) a constant.", "author": "fwolter", "createdAt": "2021-03-19T18:50:38Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDAyNTk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600025979", "bodyText": "Changed for all occurrences", "author": "weymann", "createdAt": "2021-03-23T23:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkwNjQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\nindex b5ad52bd66..6ff369b171 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n\n@@ -46,19 +46,15 @@ import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n import org.openhab.core.library.types.DateTimeType;\n-import org.openhab.core.library.types.DecimalType;\n import org.openhab.core.library.types.OnOffType;\n import org.openhab.core.library.types.PointType;\n import org.openhab.core.library.types.QuantityType;\n import org.openhab.core.library.types.StringType;\n import org.openhab.core.library.unit.ImperialUnits;\n-import org.openhab.core.library.unit.MetricPrefix;\n-import org.openhab.core.library.unit.SIUnits;\n import org.openhab.core.library.unit.Units;\n import org.openhab.core.thing.ChannelUID;\n import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.binding.BaseThingHandler;\n-import org.openhab.core.types.Command;\n import org.openhab.core.types.State;\n import org.openhab.core.types.StateOption;\n import org.openhab.core.types.UnDefType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxMjYwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597912601", "bodyText": "Why not using your Converter method?", "author": "fwolter", "createdAt": "2021-03-19T19:01:46Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.VehicleType;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.Destination;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Doors;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Windows;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.TimedChannel;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PointType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.MetricPrefix;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleChannelHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send of charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleChannelHandler extends BaseThingHandler {\n+    protected final Logger logger = LoggerFactory.getLogger(VehicleChannelHandler.class);\n+    protected boolean imperial = false;\n+    protected boolean hasFuel = false;\n+    protected boolean isElectric = false;\n+    protected boolean isHybrid = false;\n+\n+    // List Interfaces\n+    protected List<CBSMessage> serviceList = new ArrayList<CBSMessage>();\n+    protected String selectedService = Constants.UNDEF;\n+    protected List<CCMMessage> checkControlList = new ArrayList<CCMMessage>();\n+    protected String selectedCC = Constants.UNDEF;\n+    protected List<Destination> destinationList = new ArrayList<Destination>();\n+    protected String selectedDestination = Constants.UNDEF;\n+\n+    protected BMWConnectedDriveOptionProvider optionProvider;\n+\n+    // Data Caches\n+    protected Optional<String> vehicleStatusCache = Optional.empty();\n+    protected Optional<String> lastTripCache = Optional.empty();\n+    protected Optional<String> allTripsCache = Optional.empty();\n+    protected Optional<String> chargeProfileCache = Optional.empty();\n+    protected Optional<String> rangeMapCache = Optional.empty();\n+    protected Optional<String> destinationCache = Optional.empty();\n+    protected Optional<byte[]> imageCache = Optional.empty();\n+\n+    public VehicleChannelHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing);\n+        optionProvider = op;\n+\n+        this.imperial = imperial;\n+        hasFuel = type.equals(VehicleType.CONVENTIONAL.toString()) || type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString());\n+        isElectric = type.equals(VehicleType.PLUGIN_HYBRID.toString())\n+                || type.equals(VehicleType.ELECTRIC_REX.toString()) || type.equals(VehicleType.ELECTRIC.toString());\n+        isHybrid = hasFuel && isElectric;\n+\n+        setOptions(CHANNEL_GROUP_REMOTE, REMOTE_SERVICE_COMMAND, RemoteServiceUtils.getOptions(isElectric));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+    }\n+\n+    private void setOptions(final String group, final String id, List<StateOption> options) {\n+        optionProvider.setStateOptions(new ChannelUID(thing.getUID(), group, id), options);\n+    }\n+\n+    protected void updateChannel(final String group, final String id, final State state) {\n+        updateState(new ChannelUID(thing.getUID(), group, id), state);\n+    }\n+\n+    protected void updateCheckControls(List<CCMMessage> ccl) {\n+        if (ccl.size() == 0) {\n+            // No Check Control available - show not active\n+            CCMMessage ccm = new CCMMessage();\n+            ccm.ccmDescriptionLong = Constants.NO_ENTRIES;\n+            ccm.ccmDescriptionShort = Constants.NO_ENTRIES;\n+            ccm.ccmId = -1;\n+            ccm.ccmMileage = -1;\n+            ccl.add(ccm);\n+        }\n+\n+        // add all elements to options\n+        checkControlList = ccl;\n+        List<StateOption> ccmDescriptionOptions = new ArrayList<>();\n+        List<StateOption> ccmDetailsOptions = new ArrayList<>();\n+        List<StateOption> ccmMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CCMMessage ccEntry : checkControlList) {\n+            ccmDescriptionOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionShort));\n+            ccmDetailsOptions.add(new StateOption(Integer.toString(index), ccEntry.ccmDescriptionLong));\n+            ccmMileageOptions.add(new StateOption(Integer.toString(index), Integer.toString(ccEntry.ccmMileage)));\n+            if (selectedCC.equals(ccEntry.ccmDescriptionShort)) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, NAME, ccmDescriptionOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, ccmDetailsOptions);\n+        setOptions(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE, ccmMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectCheckControl(0);\n+        }\n+    }\n+\n+    protected void selectCheckControl(int index) {\n+        if (index >= 0 && index < checkControlList.size()) {\n+            CCMMessage ccEntry = checkControlList.get(index);\n+            selectedCC = ccEntry.ccmDescriptionShort;\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, NAME, StringType.valueOf(ccEntry.ccmDescriptionShort));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, DETAILS, StringType.valueOf(ccEntry.ccmDescriptionLong));\n+            updateChannel(CHANNEL_GROUP_CHECK_CONTROL, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(ccEntry.ccmMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateServices(List<CBSMessage> sl) {\n+        // if list is empty add \"undefined\" element\n+        if (sl.size() == 0) {\n+            CBSMessage cbsm = new CBSMessage();\n+            cbsm.cbsType = Constants.NO_ENTRIES;\n+            cbsm.cbsDescription = Constants.NO_ENTRIES;\n+            sl.add(cbsm);\n+        }\n+\n+        // add all elements to options\n+        serviceList = sl;\n+        List<StateOption> serviceNameOptions = new ArrayList<>();\n+        List<StateOption> serviceDetailsOptions = new ArrayList<>();\n+        List<StateOption> serviceDateOptions = new ArrayList<>();\n+        List<StateOption> serviceMileageOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (CBSMessage serviceEntry : serviceList) {\n+            // create StateOption with \"value = list index\" and \"label = human readable string\"\n+            serviceNameOptions.add(new StateOption(Integer.toString(index), serviceEntry.getType()));\n+            serviceDetailsOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDescription()));\n+            serviceDateOptions.add(new StateOption(Integer.toString(index), serviceEntry.getDueDate()));\n+            serviceMileageOptions\n+                    .add(new StateOption(Integer.toString(index), Integer.toString(serviceEntry.cbsRemainingMileage)));\n+            if (selectedService.equals(serviceEntry.getType())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_SERVICE, NAME, serviceNameOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DETAILS, serviceDetailsOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, DATE, serviceDateOptions);\n+        setOptions(CHANNEL_GROUP_SERVICE, MILEAGE, serviceMileageOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectService(0);\n+        }\n+    }\n+\n+    protected void selectService(int index) {\n+        if (index >= 0 && index < serviceList.size()) {\n+            CBSMessage serviceEntry = serviceList.get(index);\n+            selectedService = serviceEntry.cbsType;\n+            updateChannel(CHANNEL_GROUP_SERVICE, NAME,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getType())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DETAILS,\n+                    StringType.valueOf(Converter.toTitleCase(serviceEntry.getDescription())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, DATE,\n+                    DateTimeType.valueOf(Converter.getLocalDateTime(serviceEntry.getDueDate())));\n+            updateChannel(CHANNEL_GROUP_SERVICE, MILEAGE,\n+                    QuantityType.valueOf(Converter.round(serviceEntry.cbsRemainingMileage),\n+                            imperial ? ImperialUnits.MILE : MetricPrefix.KILO(SIUnits.METRE)));\n+        }\n+    }\n+\n+    protected void updateDestinations(List<Destination> dl) {\n+        // if list is empty add \"undefined\" element\n+        if (dl.size() == 0) {\n+            Destination dest = new Destination();\n+            dest.city = Constants.NO_ENTRIES;\n+            dest.lat = -1;\n+            dest.lon = -1;\n+            dl.add(dest);\n+        }\n+\n+        // add all elements to options\n+        destinationList = dl;\n+        List<StateOption> destinationNameOptions = new ArrayList<>();\n+        List<StateOption> destinationGPSOptions = new ArrayList<>();\n+        boolean isSelectedElementIn = false;\n+        int index = 0;\n+        for (Destination destination : destinationList) {\n+            destinationNameOptions.add(new StateOption(Integer.toString(index), destination.getAddress()));\n+            destinationGPSOptions.add(new StateOption(Integer.toString(index), destination.getCoordinates()));\n+            if (selectedDestination.equals(destination.getAddress())) {\n+                isSelectedElementIn = true;\n+            }\n+            index++;\n+        }\n+        setOptions(CHANNEL_GROUP_DESTINATION, NAME, destinationNameOptions);\n+        setOptions(CHANNEL_GROUP_DESTINATION, GPS, destinationGPSOptions);\n+\n+        // if current selected item isn't anymore in the list select first entry\n+        if (!isSelectedElementIn) {\n+            selectDestination(0);\n+        }\n+    }\n+\n+    protected void selectDestination(int index) {\n+        if (index >= 0 && index < destinationList.size()) {\n+            Destination destinationEntry = destinationList.get(index);\n+            // update selected Item\n+            selectedDestination = destinationEntry.getAddress();\n+            // update coordinates according to new set location\n+            updateChannel(CHANNEL_GROUP_DESTINATION, NAME, StringType.valueOf(destinationEntry.getAddress()));\n+            updateChannel(CHANNEL_GROUP_DESTINATION, GPS, PointType.valueOf(destinationEntry.getCoordinates()));\n+        }\n+    }\n+\n+    protected void updateAllTrips(AllTrips allTrips) {\n+        QuantityType<Length> qtTotalElectric = QuantityType\n+                .valueOf(Converter.round(allTrips.totalElectricDistance.userTotal), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtLongestElectricRange = QuantityType\n+                .valueOf(Converter.round(allTrips.chargecycleRange.userHigh), MetricPrefix.KILO(SIUnits.METRE));\n+        QuantityType<Length> qtDistanceSinceCharge = QuantityType.valueOf(\n+                Converter.round(allTrips.chargecycleRange.userCurrentChargeCycle), MetricPrefix.KILO(SIUnits.METRE));\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, TOTAL_DRIVEN_DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalElectric) : qtTotalElectric);\n+        updateChannel(CHANNEL_GROUP_LIFETIME, SINGLE_LONGEST_DISTANCE,\n+                imperial ? Converter.getMiles(qtLongestElectricRange) : qtLongestElectricRange);\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE_SINCE_CHARGING,\n+                imperial ? Converter.getMiles(qtDistanceSinceCharge) : qtDistanceSinceCharge);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumotion = imperial ? allTrips.avgElectricConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgElectricConsumption.userAverage;\n+        double avgCombinedConsumption = imperial\n+                ? allTrips.avgCombinedConsumption.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgCombinedConsumption.userAverage;\n+        double avgRecuperation = imperial ? allTrips.avgRecuperation.userAverage * Converter.MILES_TO_KM_RATIO\n+                : allTrips.avgRecuperation.userAverage;\n+\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumotion), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LIFETIME, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateLastTrip(LastTrip trip) {\n+        // Whyever the Last Trip DateTime is delivered without offest - so LocalTime\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DATE,\n+                DateTimeType.valueOf(Converter.getLocalDateTimeWithoutOffest(trip.date)));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DURATION, QuantityType.valueOf(trip.duration, Units.MINUTE));\n+\n+        QuantityType<Length> qtTotalDistance = QuantityType.valueOf(Converter.round(trip.totalDistance),\n+                MetricPrefix.KILO(SIUnits.METRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, DISTANCE,\n+                imperial ? Converter.getMiles(qtTotalDistance) : qtTotalDistance);\n+\n+        // Conversion from kwh/100km to kwh/10mi has to be done manually\n+        double avgConsumtption = imperial ? trip.avgElectricConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgElectricConsumption;\n+        double avgCombinedConsumption = imperial ? trip.avgCombinedConsumption * Converter.MILES_TO_KM_RATIO\n+                : trip.avgCombinedConsumption;\n+        double avgRecuperation = imperial ? trip.avgRecuperation * Converter.MILES_TO_KM_RATIO : trip.avgRecuperation;\n+\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgConsumtption), Units.KILOWATT_HOUR));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_COMBINED_CONSUMPTION,\n+                QuantityType.valueOf(Converter.round(avgCombinedConsumption), Units.LITRE));\n+        updateChannel(CHANNEL_GROUP_LAST_TRIP, AVG_RECUPERATION,\n+                QuantityType.valueOf(Converter.round(avgRecuperation), Units.KILOWATT_HOUR));\n+    }\n+\n+    protected void updateChargeProfileFromContent(String content) {\n+        ChargeProfileWrapper.fromJson(content).ifPresent(this::updateChargeProfile);\n+    }\n+\n+    protected void updateChargeProfile(ChargeProfileWrapper wrapper) {\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getPreference())));\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                StringType.valueOf(Converter.toTitleCase(wrapper.getMode())));\n+        final Boolean climate = wrapper.isEnabled(ProfileKey.CLIMATE);\n+        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_CLIMATE,\n+                climate == null ? UnDefType.UNDEF : OnOffType.from(climate));\n+        updateTimedState(wrapper, ProfileKey.WINDOWSTART);\n+        updateTimedState(wrapper, ProfileKey.WINDOWEND);\n+        updateTimedState(wrapper, ProfileKey.TIMER1);\n+        updateTimedState(wrapper, ProfileKey.TIMER2);\n+        updateTimedState(wrapper, ProfileKey.TIMER3);\n+        updateTimedState(wrapper, ProfileKey.OVERRIDE);\n+    }\n+\n+    protected void updateTimedState(ChargeProfileWrapper profile, ProfileKey key) {\n+        final TimedChannel timed = ChargeProfileUtils.getTimedChannel(key);\n+        if (timed != null) {\n+            final LocalTime time = profile.getTime(key);\n+            updateChannel(CHANNEL_GROUP_CHARGE, timed.time, time == null ? UnDefType.UNDEF\n+                    : new DateTimeType(ZonedDateTime.of(Constants.EPOCH_DAY, time, ZoneId.systemDefault())));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDAzNzA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600037093", "bodyText": "Checked the code and there's only this occurrence of DateTime creation. Do you think it's benefical to provide a helper function?", "author": "weymann", "createdAt": "2021-03-23T23:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxMjYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg2MzI5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601863292", "bodyText": "I thought there was already a suiting method in the Converter class. Never mind.", "author": "fwolter", "createdAt": "2021-03-25T21:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxMjYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\nindex b5ad52bd66..6ff369b171 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleChannelHandler.java\n\n@@ -46,19 +46,15 @@ import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n import org.openhab.binding.bmwconnecteddrive.internal.utils.VehicleStatusUtils;\n import org.openhab.core.library.types.DateTimeType;\n-import org.openhab.core.library.types.DecimalType;\n import org.openhab.core.library.types.OnOffType;\n import org.openhab.core.library.types.PointType;\n import org.openhab.core.library.types.QuantityType;\n import org.openhab.core.library.types.StringType;\n import org.openhab.core.library.unit.ImperialUnits;\n-import org.openhab.core.library.unit.MetricPrefix;\n-import org.openhab.core.library.unit.SIUnits;\n import org.openhab.core.library.unit.Units;\n import org.openhab.core.thing.ChannelUID;\n import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.binding.BaseThingHandler;\n-import org.openhab.core.types.Command;\n import org.openhab.core.types.State;\n import org.openhab.core.types.StateOption;\n import org.openhab.core.types.UnDefType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNDgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597914810", "bodyText": "config cannot be null at this point. But the parameters within the config object can be empty.", "author": "fwolter", "createdAt": "2021-03-19T19:06:09Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NjY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598296649", "bodyText": "fixed in weymann#10", "author": "ntruchsess", "createdAt": "2021-03-21T15:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNDgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597916035", "bodyText": "Is there any blocking method in the following code, or what is the reason for executing this asynchronously?", "author": "fwolter", "createdAt": "2021-03-19T19:08:15Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA0MDc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600040757", "bodyText": "Not really blocking but quite some code with constructors and initialization is executed and also one critical section inside. Wanted to be sure to execute this asynchronous. But no problem to make it synchronous. Do you have an advice?", "author": "weymann", "createdAt": "2021-03-23T23:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg2NDI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601864267", "bodyText": "Constructors and initialization can be executed synchronously. Critical sections cannot be guarded by executing them asynchronously. These should be synchronized.", "author": "fwolter", "createdAt": "2021-03-25T21:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjc5NTY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602795641", "bodyText": "Ok, critical section is already synchronized - asnyc execution just in case if it's blocked so I don't want to delay other initializations. But seems acceptable so I'll remoce async init.", "author": "weymann", "createdAt": "2021-03-27T21:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNjAzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNzk2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597917965", "bodyText": "You could remove the binding name from the log message as the package name is already logged.", "author": "fwolter", "createdAt": "2021-03-19T19:12:08Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA0MzI1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600043256", "bodyText": "Removed", "author": "weymann", "createdAt": "2021-03-24T00:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxNzk2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597918465", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n          \n          \n            \n                        return true;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }\n          \n          \n            \n                    return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();", "author": "fwolter", "createdAt": "2021-03-19T19:13:09Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NzAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598297038", "bodyText": "fixed in weymann#10", "author": "ntruchsess", "createdAt": "2021-03-21T15:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODQ2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597918805", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n          \n          \n            \n                            new StringBuilder(service == null ? \"-\" : service).append(Converter.SPACE).append(status).toString())));", "author": "fwolter", "createdAt": "2021-03-19T19:13:47Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5NzkwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598297901", "bodyText": "fixed in weymann#10", "author": "ntruchsess", "createdAt": "2021-03-21T15:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxODgwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597919328", "bodyText": "This could be removed.", "author": "fwolter", "createdAt": "2021-03-19T19:14:54Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA1MDkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600050911", "bodyText": "Removed", "author": "weymann", "createdAt": "2021-03-24T00:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTY2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597919660", "bodyText": "See above. Remove. Same for below.", "author": "fwolter", "createdAt": "2021-03-19T19:15:26Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA1MTA4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600051084", "bodyText": "removed for all inner classes", "author": "weymann", "createdAt": "2021-03-24T00:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkxOTY2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTI3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597921275", "bodyText": "The ONLINE state shouldn't contain any detail arguments.", "author": "fwolter", "createdAt": "2021-03-19T19:18:22Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA3ODc2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600078766", "bodyText": "fixed", "author": "weymann", "createdAt": "2021-03-24T01:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597921654", "bodyText": "Is there any case where status can be null?", "author": "fwolter", "createdAt": "2021-03-19T19:19:00Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA1NzIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r600057234", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-24T00:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMTY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMjk5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597922995", "bodyText": "This needs to be cancelled in dispose().", "author": "fwolter", "createdAt": "2021-03-19T19:21:26Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODI5OTI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598299266", "bodyText": "fixed in weymann#9", "author": "ntruchsess", "createdAt": "2021-03-21T15:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMjk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597923367", "bodyText": "Syntactical sugar. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n          \n          \n            \n                                chargeProfileCache.ifPresent(this::updateChargeProfileFromContent);", "author": "fwolter", "createdAt": "2021-03-19T19:22:08Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {\n+                    editTimeout = Optional.empty();\n+                    chargeProfileEdit = Optional.empty();\n+                    chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODMwMDAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r598300009", "bodyText": "fixed in weymann#11", "author": "ntruchsess", "createdAt": "2021-03-21T15:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzM2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597923644", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-03-19T19:22:43Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,826 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.info(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        if (config != null) {\n+            configuration = Optional.of(config);\n+            scheduler.execute(() -> {\n+                Bridge bridge = getBridge();\n+                if (bridge != null) {\n+                    BridgeHandler handler = bridge.getHandler();\n+                    if (handler != null) {\n+                        bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                        proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                        remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                    } else {\n+                        logger.debug(\"Bridge Handler null\");\n+                    }\n+                } else {\n+                    logger.debug(\"Bridge null\");\n+                }\n+\n+                // get Image after init with config values\n+                synchronized (imageProperties) {\n+                    imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+                }\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+                // check imperial setting is different to AutoDetect\n+                if (!UNITS_AUTODETECT.equals(config.units)) {\n+                    imperial = UNITS_IMPERIAL.equals(config.units);\n+                }\n+\n+                // start update schedule\n+                startSchedule(config.refreshInterval);\n+            });\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### BMW ConnectedDrive Binding - Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        if (lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty()) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType.valueOf(Converter.toTitleCase(\n+                new StringBuilder(service == null ? \"-\" : service).append(\" \").append(status).toString())));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    @NonNullByDefault({})\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    @NonNullByDefault({})\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    @NonNullByDefault({})\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        /**\n+         * Vehicle Status is supported by all Vehicles so callback result is used to report Thing Status.\n+         * If valid content is delivered in onResponse Thing goes online while onError Thing goes offline\n+         *\n+         * @param status\n+         * @param detail\n+         * @param reason\n+         */\n+        private void setThingStatus(ThingStatus status, ThingStatusDetail detail, String reason) {\n+            if (thingStatus != status) {\n+                updateStatus(status, detail, reason);\n+            }\n+        }\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                setThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, Constants.EMPTY);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * Fallback API if origin isn't supported.\n+     * This comes from the Community Discussion where a Vehicle from 2015 answered with \"404\"\n+     * https://community.openhab.org/t/bmw-connecteddrive-binding/105124\n+     *\n+     * Selection of API was discussed here\n+     * https://community.openhab.org/t/bmw-connecteddrive-bmw-i3/103876\n+     *\n+     * I figured out that only one API was working for this Vehicle. So this backward compatible Callback is introduced.\n+     * The delivered data is converted into the origin dto object so no changes in previous functional code needed\n+     */\n+    @NonNullByDefault({})\n+    public class LegacyVehicleStatusCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                try {\n+                    VehicleAttributesContainer vac = Converter.getGson().fromJson(content,\n+                            VehicleAttributesContainer.class);\n+                    if (vac != null) {\n+                        vehicleStatusCallback.onResponse(vac.transform());\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            vehicleStatusCallback.onError(error);\n+        }\n+    }\n+\n+    private void handleChargeProfileCommand(ChannelUID channelUID, Command command) {\n+        if (chargeProfileEdit.isEmpty()) {\n+            chargeProfileEdit = getChargeProfileWrapper();\n+        }\n+\n+        chargeProfileEdit.ifPresent(profile -> {\n+\n+            boolean processed = false;\n+\n+            final String id = channelUID.getIdWithoutGroup();\n+\n+            if (command instanceof StringType) {\n+                final String stringCommand = ((StringType) command).toFullString();\n+                switch (id) {\n+                    case CHARGE_PROFILE_PREFERENCE:\n+                        profile.setPreference(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_PREFERENCE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getPreference())));\n+                        processed = true;\n+                        break;\n+                    case CHARGE_PROFILE_MODE:\n+                        profile.setMode(stringCommand);\n+                        updateChannel(CHANNEL_GROUP_CHARGE, CHARGE_PROFILE_MODE,\n+                                StringType.valueOf(Converter.toTitleCase(profile.getMode())));\n+                        processed = true;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                final ProfileKey enableKey = ChargeProfileUtils.getEnableKey(id);\n+                if (enableKey != null) {\n+                    profile.setEnabled(enableKey, OnOffType.ON.equals(command));\n+                    updateTimedState(profile, enableKey);\n+                    processed = true;\n+                } else {\n+                    final ChargeKeyDay chargeKeyDay = ChargeProfileUtils.getKeyDay(id);\n+                    if (chargeKeyDay != null) {\n+                        profile.setDayEnabled(chargeKeyDay.key, chargeKeyDay.day, OnOffType.ON.equals(command));\n+                        updateTimedState(profile, chargeKeyDay.key);\n+                        processed = true;\n+                    }\n+                }\n+            } else if (command instanceof DecimalType) {\n+                final ChargeKeyHour keyHour = ChargeProfileUtils.getKeyHour(id);\n+                if (keyHour != null) {\n+                    if (keyHour.isHour) {\n+                        profile.setHour(keyHour.key, ((DecimalType) command).intValue());\n+                    } else {\n+                        profile.setMinute(keyHour.key, ((DecimalType) command).intValue());\n+                    }\n+                    updateTimedState(profile, keyHour.key);\n+                    processed = true;\n+                }\n+            }\n+\n+            if (processed) {\n+                // cancel current timer and add another 5 mins - valid for each edit\n+                editTimeout.ifPresent(timeout -> timeout.cancel(true));\n+                // start edit timer with 5 min timeout\n+                editTimeout = Optional.of(scheduler.schedule(() -> {\n+                    editTimeout = Optional.empty();\n+                    chargeProfileEdit = Optional.empty();\n+                    chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n+                }, 5, TimeUnit.MINUTES));\n+            } else {\n+                logger.info(\"unexpected command {} not processed\", command.toFullString());\n+            }\n+        });\n+    }\n+\n+    private void saveChargeProfileSent() {\n+        editTimeout.ifPresent(timeout -> {\n+            timeout.cancel(true);\n+            editTimeout = Optional.empty();\n+        });\n+        chargeProfileSent.ifPresent(sent -> {\n+            chargeProfileCache = Optional.of(sent);\n+            chargeProfileSent = Optional.empty();\n+            chargeProfileEdit = Optional.empty();\n+            chargeProfileCache.ifPresent(content -> updateChargeProfileFromContent(content));\n+        });\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Set.of(ChargeProfileActions.class);\n+    }\n+\n+    public Optional<ChargeProfileWrapper> getChargeProfileWrapper() {\n+        return chargeProfileCache.flatMap(cache -> {\n+            return ChargeProfileWrapper.fromJson(cache).map(wrapper -> {\n+                logger.debug(\"Charge Profile editing - start\");\n+                logger.debug(\"{}\", wrapper.getJson());", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwMjEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602802125", "bodyText": "Right, this is the good case and shall not be logged - deleted", "author": "weymann", "createdAt": "2021-03-27T22:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyMzY0NA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex 1e699e9154..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNDYwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597924604", "bodyText": "Fields should be at the top of the class. Please check all.", "author": "fwolter", "createdAt": "2021-03-19T19:24:35Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.time.DayOfWeek;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+\n+/**\n+ * The {@link ChargeProfileUtils} utility functions for charging profiles\n+ *\n+ * @author Norbert Truchsess - initial contribution\n+ */\n+@NonNullByDefault\n+public class ChargeProfileUtils {\n+\n+    // Charging\n+    public static class TimedChannel {\n+        TimedChannel(final String time, @Nullable final String timer, final boolean hasDays) {\n+            this.time = time;\n+            this.timer = timer;\n+            this.hasDays = hasDays;\n+        }\n+\n+        public final String time;\n+        public final @Nullable String timer;\n+        public final boolean hasDays;", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwMjUzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602802534", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-27T23:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNDYwNA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java\nindex a6b3c50c17..67da7ae94e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileUtils.java\n\n@@ -34,15 +34,15 @@ public class ChargeProfileUtils {\n \n     // Charging\n     public static class TimedChannel {\n+        public final String time;\n+        public final @Nullable String timer;\n+        public final boolean hasDays;\n+\n         TimedChannel(final String time, @Nullable final String timer, final boolean hasDays) {\n             this.time = time;\n             this.timer = timer;\n             this.hasDays = hasDays;\n         }\n-\n-        public final String time;\n-        public final @Nullable String timer;\n-        public final boolean hasDays;\n     }\n \n     @SuppressWarnings(\"serial\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597925285", "bodyText": "Should this be logged?", "author": "fwolter", "createdAt": "2021-03-19T19:25:50Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey.*;\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingMode;\n+import org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.ChargingPreference;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargeProfile;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.ChargingWindow;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.Timer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.charge.WeeklyPlanner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ChargeProfileWrapper} Wrapper for ChargeProfiles\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - add ChargeProfileActions\n+ */\n+@NonNullByDefault\n+public class ChargeProfileWrapper {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n+\n+    public enum ProfileType {\n+        WEEKLY,\n+        TWO_TIMES,\n+        EMPTY\n+    }\n+\n+    public enum ProfileKey {\n+        CLIMATE,\n+        TIMER1,\n+        TIMER2,\n+        TIMER3,\n+        TIMER4,\n+        OVERRIDE,\n+        WINDOWSTART,\n+        WINDOWEND\n+    }\n+\n+    protected final ProfileType type;\n+\n+    private Optional<ChargingMode> mode = Optional.empty();\n+    private Optional<ChargingPreference> preference = Optional.empty();\n+\n+    private final Map<ProfileKey, Boolean> enabled = new HashMap<>();\n+    private final Map<ProfileKey, LocalTime> times = new HashMap<>();\n+    private final Map<ProfileKey, Set<DayOfWeek>> daysOfWeek = new HashMap<>();\n+\n+    public static Optional<ChargeProfileWrapper> fromJson(final String content) {\n+        try {\n+            final ChargeProfile cp = Converter.getGson().fromJson(content, ChargeProfile.class);\n+            if (cp != null) {\n+                return Optional.of(new ChargeProfileWrapper(cp));\n+            }\n+        } catch (JsonSyntaxException jse) {\n+        }", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNDA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602804070", "bodyText": "Yes, maybe this wasn't done due to static function declaration where logger cannot be used. But I think static logger isn't a problem anymore, right?", "author": "weymann", "createdAt": "2021-03-27T23:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg1NTY0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602855646", "bodyText": "If you need to access the logger in a static way, it can be static.", "author": "fwolter", "createdAt": "2021-03-28T09:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0MTk3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602941979", "bodyText": "ok, this is already in", "author": "weymann", "createdAt": "2021-03-28T22:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNTI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java\nindex 4b67645a4c..83a7276580 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/ChargeProfileWrapper.java\n\n@@ -46,8 +46,7 @@ import com.google.gson.JsonSyntaxException;\n  */\n @NonNullByDefault\n public class ChargeProfileWrapper {\n-\n-    private final Logger logger = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ChargeProfileWrapper.class);\n \n     public enum ProfileType {\n         WEEKLY,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNzgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597927830", "bodyText": "You could return UnDefType.UNDEF instead of -1", "author": "fwolter", "createdAt": "2021-03-19T19:30:40Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNTg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602805882", "bodyText": "Done", "author": "weymann", "createdAt": "2021-03-27T23:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyNzgzMA=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\nindex 0351c28db0..bc6e3fc75b 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n\n@@ -17,15 +17,29 @@ import java.time.ZoneId;\n import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Optional;\n \n import javax.measure.quantity.Length;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributes;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleMessages;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n import org.openhab.core.i18n.TimeZoneProvider;\n import org.openhab.core.library.types.QuantityType;\n import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyOTY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597929649", "bodyText": "To be able to return UnDefType.UNDEF.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {\n          \n          \n            \n                public static State getMiles(QuantityType<Length> qtLength) {", "author": "fwolter", "createdAt": "2021-03-19T19:34:15Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);\n+    private static final String SPLIT_HYPHEN = \"-\";\n+    private static final String SPLIT_BRACKET = \"\\\\(\";\n+\n+    public static Optional<TimeZoneProvider> timeZoneProvider = Optional.empty();\n+\n+    public static double round(double value) {\n+        return Math.round(value * SCALE) / SCALE;\n+    }\n+\n+    public static String getLocalDateTimeWithoutOffest(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+        }\n+        return ldt.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static String getLocalDateTime(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            try {\n+                ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+            } catch (DateTimeParseException dtpe) {\n+                ldt = LocalDateTime.parse(input, Converter.LOCAL_DATE_INPUT_PATTERN);\n+            }\n+        }\n+        ZonedDateTime zdtUTC = ldt.atZone(ZoneId.of(\"UTC\"));\n+        ZonedDateTime zdtLZ;\n+        zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        if (timeZoneProvider.isPresent()) {\n+            zdtLZ = zdtUTC.withZoneSameInstant(timeZoneProvider.get().getTimeZone());\n+        } else {\n+            zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        }\n+        return zdtLZ.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static void setTimeZoneProvider(TimeZoneProvider tzp) {\n+        timeZoneProvider = Optional.of(tzp);\n+    }\n+\n+    public static String toTitleCase(@Nullable String input) {\n+        if (input == null) {\n+            return toTitleCase(Constants.UNDEF);\n+        } else {\n+            String lower = input.replaceAll(Constants.UNDERLINE, Constants.SPACE).toLowerCase();\n+            String converted = toTitleCase(lower, Constants.SPACE);\n+            converted = toTitleCase(converted, SPLIT_HYPHEN);\n+            converted = toTitleCase(converted, SPLIT_BRACKET);\n+            return converted;\n+        }\n+    }\n+\n+    private static String toTitleCase(String input, String splitter) {\n+        String[] arr = input.split(splitter);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < arr.length; i++) {\n+            if (i > 0) {\n+                sb.append(splitter.replaceAll(\"\\\\\\\\\", Constants.EMPTY));\n+            }\n+            sb.append(Character.toUpperCase(arr[i].charAt(0))).append(arr[i].substring(1));\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    public static String capitalizeFirst(String str) {\n+        return str.substring(0, 1).toUpperCase() + str.substring(1);\n+    }\n+\n+    public static Gson getGson() {\n+        return GSON;\n+    }\n+\n+    /**\n+     * Measure distance between 2 coordinates\n+     *\n+     * @param sourceLatitude\n+     * @param sourceLongitude\n+     * @param destinationLatitude\n+     * @param destinationLongitude\n+     * @return distance\n+     */\n+    public static double measureDistance(double sourceLatitude, double sourceLongitude, double destinationLatitude,\n+            double destinationLongitude) {\n+        double earthRadius = 6378.137; // Radius of earth in KM\n+        double dLat = destinationLatitude * Math.PI / 180 - sourceLatitude * Math.PI / 180;\n+        double dLon = destinationLongitude * Math.PI / 180 - sourceLongitude * Math.PI / 180;\n+        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(sourceLatitude * Math.PI / 180)\n+                * Math.cos(destinationLatitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n+        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n+        return earthRadius * c;\n+    }\n+\n+    /**\n+     * Easy function but there's some measures behind:\n+     * Guessing the range of the Vehicle on Map. If you can drive x kilometers with your Vehicle it's not feasible to\n+     * project this x km Radius on Map. The roads to be taken are causing some overhead because they are not a straight\n+     * line from Location A to B.\n+     * I've taken some measurements to calculate the overhead factor based on Google Maps\n+     * Berlin - Dresden: Road Distance: 193 air-line Distance 167 = Factor 87%\n+     * Kassel - Frankfurt: Road Distance: 199 air-line Distance 143 = Factor 72%\n+     * After measuring more distances you'll find out that the outcome is between 70% and 90%. So\n+     *\n+     * This depends also on the roads of a concrete route but this is only a guess without any Route Navigation behind\n+     *\n+     * In future it's foreseen to replace this with BMW RangeMap Service which isn't running at the moment.\n+     *\n+     * @param range\n+     * @return mapping from air-line distance to \"real road\" distance\n+     */\n+    public static double guessRangeRadius(double range) {\n+        return range * 0.8;\n+    }\n+\n+    public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNTg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602805889", "bodyText": "Done", "author": "weymann", "createdAt": "2021-03-27T23:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkyOTY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\nindex 0351c28db0..bc6e3fc75b 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n\n@@ -17,15 +17,29 @@ import java.time.ZoneId;\n import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Optional;\n \n import javax.measure.quantity.Length;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributes;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleMessages;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n import org.openhab.core.i18n.TimeZoneProvider;\n import org.openhab.core.library.types.QuantityType;\n import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMDQyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597930429", "bodyText": "If it can't be converted, there's something fishy about it. You could log it and return UNDEF.", "author": "fwolter", "createdAt": "2021-03-19T19:35:47Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Length;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link Converter} Conversion Helpers\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Converter {\n+    public static final DateTimeFormatter SERVICE_DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    public static final DateTimeFormatter SERVICE_DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"MMM yyyy\");\n+\n+    public static final String LOCAL_DATE_INPUT_PATTERN_STRING = \"dd.MM.yyyy HH:mm\";\n+    public static final DateTimeFormatter LOCAL_DATE_INPUT_PATTERN = DateTimeFormatter\n+            .ofPattern(LOCAL_DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ss\";\n+    public static final DateTimeFormatter DATE_INPUT_PATTERN = DateTimeFormatter.ofPattern(DATE_INPUT_PATTERN_STRING);\n+\n+    public static final String DATE_INPUT_ZONE_PATTERN_STRING = \"yyyy-MM-dd'T'HH:mm:ssZ\";\n+    public static final DateTimeFormatter DATE_INPUT_ZONE_PATTERN = DateTimeFormatter\n+            .ofPattern(DATE_INPUT_ZONE_PATTERN_STRING);\n+\n+    public static final DateTimeFormatter DATE_OUTPUT_PATTERN = DateTimeFormatter.ofPattern(\"dd.MM.yyyy HH:mm\");\n+\n+    private static final Gson GSON = new Gson();\n+    private static final double SCALE = 10;\n+    public static final double MILES_TO_KM_RATIO = 1.60934;\n+    private static final QuantityType<Length> UNDEF_MILES = QuantityType.valueOf(-1, ImperialUnits.MILE);\n+    private static final String SPLIT_HYPHEN = \"-\";\n+    private static final String SPLIT_BRACKET = \"\\\\(\";\n+\n+    public static Optional<TimeZoneProvider> timeZoneProvider = Optional.empty();\n+\n+    public static double round(double value) {\n+        return Math.round(value * SCALE) / SCALE;\n+    }\n+\n+    public static String getLocalDateTimeWithoutOffest(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+        }\n+        return ldt.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static String getLocalDateTime(@Nullable String input) {\n+        if (input == null) {\n+            return Constants.NULL_DATE;\n+        }\n+\n+        LocalDateTime ldt;\n+        if (input.contains(Constants.PLUS)) {\n+            ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_ZONE_PATTERN);\n+        } else {\n+            try {\n+                ldt = LocalDateTime.parse(input, Converter.DATE_INPUT_PATTERN);\n+            } catch (DateTimeParseException dtpe) {\n+                ldt = LocalDateTime.parse(input, Converter.LOCAL_DATE_INPUT_PATTERN);\n+            }\n+        }\n+        ZonedDateTime zdtUTC = ldt.atZone(ZoneId.of(\"UTC\"));\n+        ZonedDateTime zdtLZ;\n+        zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        if (timeZoneProvider.isPresent()) {\n+            zdtLZ = zdtUTC.withZoneSameInstant(timeZoneProvider.get().getTimeZone());\n+        } else {\n+            zdtLZ = zdtUTC.withZoneSameInstant(ZoneId.systemDefault());\n+        }\n+        return zdtLZ.format(Converter.DATE_INPUT_PATTERN);\n+    }\n+\n+    public static void setTimeZoneProvider(TimeZoneProvider tzp) {\n+        timeZoneProvider = Optional.of(tzp);\n+    }\n+\n+    public static String toTitleCase(@Nullable String input) {\n+        if (input == null) {\n+            return toTitleCase(Constants.UNDEF);\n+        } else {\n+            String lower = input.replaceAll(Constants.UNDERLINE, Constants.SPACE).toLowerCase();\n+            String converted = toTitleCase(lower, Constants.SPACE);\n+            converted = toTitleCase(converted, SPLIT_HYPHEN);\n+            converted = toTitleCase(converted, SPLIT_BRACKET);\n+            return converted;\n+        }\n+    }\n+\n+    private static String toTitleCase(String input, String splitter) {\n+        String[] arr = input.split(splitter);\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < arr.length; i++) {\n+            if (i > 0) {\n+                sb.append(splitter.replaceAll(\"\\\\\\\\\", Constants.EMPTY));\n+            }\n+            sb.append(Character.toUpperCase(arr[i].charAt(0))).append(arr[i].substring(1));\n+        }\n+        return sb.toString().trim();\n+    }\n+\n+    public static String capitalizeFirst(String str) {\n+        return str.substring(0, 1).toUpperCase() + str.substring(1);\n+    }\n+\n+    public static Gson getGson() {\n+        return GSON;\n+    }\n+\n+    /**\n+     * Measure distance between 2 coordinates\n+     *\n+     * @param sourceLatitude\n+     * @param sourceLongitude\n+     * @param destinationLatitude\n+     * @param destinationLongitude\n+     * @return distance\n+     */\n+    public static double measureDistance(double sourceLatitude, double sourceLongitude, double destinationLatitude,\n+            double destinationLongitude) {\n+        double earthRadius = 6378.137; // Radius of earth in KM\n+        double dLat = destinationLatitude * Math.PI / 180 - sourceLatitude * Math.PI / 180;\n+        double dLon = destinationLongitude * Math.PI / 180 - sourceLongitude * Math.PI / 180;\n+        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(sourceLatitude * Math.PI / 180)\n+                * Math.cos(destinationLatitude * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n+        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n+        return earthRadius * c;\n+    }\n+\n+    /**\n+     * Easy function but there's some measures behind:\n+     * Guessing the range of the Vehicle on Map. If you can drive x kilometers with your Vehicle it's not feasible to\n+     * project this x km Radius on Map. The roads to be taken are causing some overhead because they are not a straight\n+     * line from Location A to B.\n+     * I've taken some measurements to calculate the overhead factor based on Google Maps\n+     * Berlin - Dresden: Road Distance: 193 air-line Distance 167 = Factor 87%\n+     * Kassel - Frankfurt: Road Distance: 199 air-line Distance 143 = Factor 72%\n+     * After measuring more distances you'll find out that the outcome is between 70% and 90%. So\n+     *\n+     * This depends also on the roads of a concrete route but this is only a guess without any Route Navigation behind\n+     *\n+     * In future it's foreseen to replace this with BMW RangeMap Service which isn't running at the moment.\n+     *\n+     * @param range\n+     * @return mapping from air-line distance to \"real road\" distance\n+     */\n+    public static double guessRangeRadius(double range) {\n+        return range * 0.8;\n+    }\n+\n+    public static QuantityType<Length> getMiles(QuantityType<Length> qtLength) {\n+        if (qtLength.intValue() == -1) {\n+            return UNDEF_MILES;\n+        }\n+        QuantityType<Length> qt = qtLength.toUnit(ImperialUnits.MILE);\n+        if (qt != null) {\n+            return qt;\n+        } else {\n+            return QuantityType.valueOf(qtLength.doubleValue() / MILES_TO_KM_RATIO, ImperialUnits.MILE);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNzY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602807694", "bodyText": "done", "author": "weymann", "createdAt": "2021-03-28T00:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMDQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\nindex 0351c28db0..bc6e3fc75b 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/Converter.java\n\n@@ -17,15 +17,29 @@ import java.time.ZoneId;\n import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Optional;\n \n import javax.measure.quantity.Length;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributes;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleMessages;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CCMMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.Position;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n import org.openhab.core.i18n.TimeZoneProvider;\n import org.openhab.core.library.types.QuantityType;\n import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMTE3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r597931177", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2021-03-19T19:37:15Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.utils;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.utils.Constants.*;\n+\n+import java.lang.reflect.Field;\n+import java.time.LocalDateTime;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.CBSMessage;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+\n+/**\n+ * The {@link VehicleStatusUtils} Data Transfer Object\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VehicleStatusUtils {\n+\n+    public static String getNextServiceDate(VehicleStatus vStatus) {\n+        if (vStatus.cbsData == null) {\n+            return Constants.NULL_DATE;\n+        }\n+        if (vStatus.cbsData.isEmpty()) {\n+            return Constants.NULL_DATE;\n+        } else {\n+            LocalDateTime farFuture = LocalDateTime.now().plusYears(100);\n+            LocalDateTime serviceDate = farFuture;\n+            for (int i = 0; i < vStatus.cbsData.size(); i++) {\n+                CBSMessage entry = vStatus.cbsData.get(i);\n+                if (entry.cbsDueDate != null) {\n+                    LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n+                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n+                    // Converter.SERVICE_DATE_INPUT_PATTERN);", "originalCommit": "48af48c82562d006b6f2aa35922270f181c885ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwNzk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602807957", "bodyText": "Fixed", "author": "weymann", "createdAt": "2021-03-28T00:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzkzMTE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java\nindex 03f1b4e314..1a11ee6964 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/utils/VehicleStatusUtils.java\n\n@@ -42,8 +42,6 @@ public class VehicleStatusUtils {\n                 CBSMessage entry = vStatus.cbsData.get(i);\n                 if (entry.cbsDueDate != null) {\n                     LocalDateTime d = LocalDateTime.parse(entry.cbsDueDate + Constants.UTC_APPENDIX);\n-                    // LocalDate d = LocalDate.parse(entry.cbsDueDate + APPENDIX_DAY,\n-                    // Converter.SERVICE_DATE_INPUT_PATTERN);\n                     if (d.isBefore(serviceDate)) {\n                         serviceDate = d;\n                     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r601880315", "bodyText": "I get a compile-error here - method 'setThingStatus' being unknown.\nfixed in weymann#12", "author": "ntruchsess", "createdAt": "2021-03-25T22:30:14Z", "path": "bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bmwconnecteddrive.internal.handler;\n+\n+import static org.openhab.binding.bmwconnecteddrive.internal.ConnectedDriveConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTrips;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.AllTripsContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTrip;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.statistics.LastTripContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatus;\n+import org.openhab.binding.bmwconnecteddrive.internal.dto.status.VehicleStatusContainer;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.ExecutionState;\n+import org.openhab.binding.bmwconnecteddrive.internal.handler.RemoteServiceHandler.RemoteService;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyDay;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileUtils.ChargeKeyHour;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ChargeProfileWrapper.ProfileKey;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Constants;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.Converter;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.ImageProperties;\n+import org.openhab.binding.bmwconnecteddrive.internal.utils.RemoteServiceUtils;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VehicleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernd Weymann - Initial contribution\n+ * @author Norbert Truchsess - edit & send charge profile\n+ */\n+@NonNullByDefault\n+public class VehicleHandler extends VehicleChannelHandler {\n+    private boolean legacyMode = false; // switch to legacy API in case of 404 Errors\n+\n+    private Optional<ConnectedDriveProxy> proxy = Optional.empty();\n+    private Optional<RemoteServiceHandler> remote = Optional.empty();\n+    private Optional<VehicleConfiguration> configuration = Optional.empty();\n+    private Optional<ConnectedDriveBridgeHandler> bridgeHandler = Optional.empty();\n+    private Optional<ScheduledFuture<?>> refreshJob = Optional.empty();\n+    private Optional<ScheduledFuture<?>> editTimeout = Optional.empty();\n+    private Optional<List<ResponseCallback>> callbackCounter = Optional.empty();\n+\n+    private ImageProperties imageProperties = new ImageProperties();\n+    VehicleStatusCallback vehicleStatusCallback = new VehicleStatusCallback();\n+    StringResponseCallback oldVehicleStatusCallback = new LegacyVehicleStatusCallback();\n+    StringResponseCallback lastTripCallback = new LastTripCallback();\n+    StringResponseCallback allTripsCallback = new AllTripsCallback();\n+    StringResponseCallback chargeProfileCallback = new ChargeProfilesCallback();\n+    StringResponseCallback rangeMapCallback = new RangeMapCallback();\n+    DestinationsCallback destinationCallback = new DestinationsCallback();\n+    ByteResponseCallback imageCallback = new ImageCallback();\n+\n+    private Optional<ChargeProfileWrapper> chargeProfileEdit = Optional.empty();\n+    private Optional<String> chargeProfileSent = Optional.empty();\n+\n+    public VehicleHandler(Thing thing, BMWConnectedDriveOptionProvider op, String type, boolean imperial) {\n+        super(thing, op, type, imperial);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String group = channelUID.getGroupId();\n+\n+        // Refresh of Channels with cached values\n+        if (command instanceof RefreshType) {\n+            if (CHANNEL_GROUP_LAST_TRIP.equals(group)) {\n+                lastTripCache.ifPresent(lastTrip -> lastTripCallback.onResponse(lastTrip));\n+            } else if (CHANNEL_GROUP_LIFETIME.equals(group)) {\n+                allTripsCache.ifPresent(allTrips -> allTripsCallback.onResponse(allTrips));\n+            } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+                destinationCache.ifPresent(destination -> destinationCallback.onResponse(destination));\n+            } else if (CHANNEL_GROUP_STATUS.equals(group)) {\n+                vehicleStatusCache.ifPresent(vehicleStatus -> vehicleStatusCallback.onResponse(vehicleStatus));\n+            } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+                chargeProfileEdit.ifPresentOrElse(this::updateChargeProfile,\n+                        () -> chargeProfileCache.ifPresent(this::updateChargeProfileFromContent));\n+            } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+                imageCache.ifPresent(image -> imageCallback.onResponse(image));\n+            }\n+            // Check for Channel Group and corresponding Actions\n+        } else if (CHANNEL_GROUP_REMOTE.equals(group)) {\n+            // Executing Remote Services\n+            if (command instanceof StringType) {\n+                String serviceCommand = ((StringType) command).toFullString();\n+                remote.ifPresent(remot -> {\n+                    switch (serviceCommand) {\n+                        case REMOTE_SERVICE_LIGHT_FLASH:\n+                        case REMOTE_SERVICE_AIR_CONDITIONING:\n+                        case REMOTE_SERVICE_DOOR_LOCK:\n+                        case REMOTE_SERVICE_DOOR_UNLOCK:\n+                        case REMOTE_SERVICE_HORN:\n+                        case REMOTE_SERVICE_VEHICLE_FINDER:\n+                        case REMOTE_SERVICE_CHARGE_NOW:\n+                            RemoteServiceUtils.getRemoteService(serviceCommand)\n+                                    .ifPresentOrElse(service -> remot.execute(service), () -> {\n+                                        logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                                    });\n+                            break;\n+                        case REMOTE_SERVICE_CHARGING_CONTROL:\n+                            sendChargeProfile(chargeProfileEdit);\n+                            break;\n+                        default:\n+                            logger.debug(\"Remote service execution {} unknown\", serviceCommand);\n+                            break;\n+                    }\n+                });\n+            }\n+        } else if (CHANNEL_GROUP_VEHICLE_IMAGE.equals(group)) {\n+            // Image Change\n+            configuration.ifPresent(config -> {\n+                if (command instanceof StringType) {\n+                    if (channelUID.getIdWithoutGroup().equals(IMAGE_VIEWPORT)) {\n+                        String newViewport = command.toString();\n+                        synchronized (imageProperties) {\n+                            if (!imageProperties.viewport.equals(newViewport)) {\n+                                imageProperties = new ImageProperties(newViewport, imageProperties.size);\n+                                imageCache = Optional.empty();\n+                                proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf(newViewport));\n+                    }\n+                }\n+                if (command instanceof DecimalType) {\n+                    if (command instanceof DecimalType) {\n+                        int newImageSize = ((DecimalType) command).intValue();\n+                        if (channelUID.getIdWithoutGroup().equals(IMAGE_SIZE)) {\n+                            synchronized (imageProperties) {\n+                                if (imageProperties.size != newImageSize) {\n+                                    imageProperties = new ImageProperties(imageProperties.viewport, newImageSize);\n+                                    imageCache = Optional.empty();\n+                                    proxy.ifPresent(prox -> prox.requestImage(config, imageProperties, imageCallback));\n+                                }\n+                            }\n+                        }\n+                        updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType(newImageSize));\n+                    }\n+                }\n+            });\n+        } else if (CHANNEL_GROUP_DESTINATION.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectDestination(index);\n+                } else {\n+                    logger.debug(\"Cannot select Destination index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_SERVICE.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectService(index);\n+                } else {\n+                    logger.debug(\"Cannot select Service index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHECK_CONTROL.equals(group)) {\n+            if (command instanceof StringType) {\n+                int index = Converter.getIndex(command.toFullString());\n+                if (index != -1) {\n+                    selectCheckControl(index);\n+                } else {\n+                    logger.debug(\"Cannot select CheckControl index {}\", command.toFullString());\n+                }\n+            }\n+        } else if (CHANNEL_GROUP_CHARGE.equals(group)) {\n+            handleChargeProfileCommand(channelUID, command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        callbackCounter = Optional.of(new ArrayList<ResponseCallback>());\n+        updateStatus(ThingStatus.UNKNOWN);\n+        final VehicleConfiguration config = getConfigAs(VehicleConfiguration.class);\n+        configuration = Optional.of(config);\n+        scheduler.execute(() -> {\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                BridgeHandler handler = bridge.getHandler();\n+                if (handler != null) {\n+                    bridgeHandler = Optional.of(((ConnectedDriveBridgeHandler) handler));\n+                    proxy = ((ConnectedDriveBridgeHandler) handler).getProxy();\n+                    remote = proxy.map(prox -> prox.getRemoteServiceHandler(this));\n+                } else {\n+                    logger.debug(\"Bridge Handler null\");\n+                }\n+            } else {\n+                logger.debug(\"Bridge null\");\n+            }\n+\n+            // get Image after init with config values\n+            synchronized (imageProperties) {\n+                imageProperties = new ImageProperties(config.imageViewport, config.imageSize);\n+            }\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_VIEWPORT, StringType.valueOf((config.imageViewport)));\n+            updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_SIZE, new DecimalType((config.imageSize)));\n+\n+            // check imperial setting is different to AutoDetect\n+            if (!UNITS_AUTODETECT.equals(config.units)) {\n+                imperial = UNITS_IMPERIAL.equals(config.units);\n+            }\n+\n+            // start update schedule\n+            startSchedule(config.refreshInterval);\n+        });\n+    }\n+\n+    private void startSchedule(int interval) {\n+        refreshJob.ifPresentOrElse(job -> {\n+            if (job.isCancelled()) {\n+                refreshJob = Optional\n+                        .of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+            } // else - scheduler is already running!\n+        }, () -> {\n+            refreshJob = Optional.of(scheduler.scheduleWithFixedDelay(this::getData, 0, interval, TimeUnit.MINUTES));\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        refreshJob.ifPresent(job -> job.cancel(true));\n+        editTimeout.ifPresent(job -> job.cancel(true));\n+        remote.ifPresent(RemoteServiceHandler::cancel);\n+    }\n+\n+    public void getData() {\n+        proxy.ifPresentOrElse(prox -> {\n+            configuration.ifPresentOrElse(config -> {\n+                if (!legacyMode) {\n+                    prox.requestVehcileStatus(config, vehicleStatusCallback);\n+                } else {\n+                    prox.requestLegacyVehcileStatus(config, oldVehicleStatusCallback);\n+                }\n+                addCallback(vehicleStatusCallback);\n+                if (isSupported(Constants.STATISTICS)) {\n+                    prox.requestLastTrip(config, lastTripCallback);\n+                    prox.requestAllTrips(config, allTripsCallback);\n+                    addCallback(lastTripCallback);\n+                    addCallback(allTripsCallback);\n+                }\n+                if (isSupported(Constants.LAST_DESTINATIONS)) {\n+                    prox.requestDestinations(config, destinationCallback);\n+                    addCallback(destinationCallback);\n+                }\n+                if (isElectric) {\n+                    prox.requestChargingProfile(config, chargeProfileCallback);\n+                    addCallback(chargeProfileCallback);\n+                }\n+                synchronized (imageProperties) {\n+                    if (!imageCache.isPresent() && !imageProperties.failLimitReached()) {\n+                        prox.requestImage(config, imageProperties, imageCallback);\n+                        addCallback(imageCallback);\n+                    }\n+                }\n+            }, () -> {\n+                logger.warn(\"ConnectedDrive Configuration isn't present\");\n+            });\n+        }, () -> {\n+            logger.warn(\"ConnectedDrive Proxy isn't present\");\n+        });\n+    }\n+\n+    private synchronized void addCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> counter.add(rc));\n+    }\n+\n+    private synchronized void removeCallback(ResponseCallback rc) {\n+        callbackCounter.ifPresent(counter -> {\n+            counter.remove(rc);\n+            // all necessary callbacks received => print and set to empty\n+            if (counter.isEmpty()) {\n+                logFingerPrint();\n+                callbackCounter = Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private void logFingerPrint() {\n+        final String vin = configuration.map(config -> config.vin).orElse(\"\");\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - BEGIN ######\");\n+        logger.debug(\"### Discovery Result ###\");\n+        bridgeHandler.ifPresent(handler -> {\n+            logger.debug(\"{}\", handler.getDiscoveryFingerprint());\n+        });\n+        vehicleStatusCache.ifPresentOrElse(vehicleStatus -> {\n+            logger.debug(\"### Vehicle Status ###\");\n+\n+            // Anonymous data for VIN and Position\n+            try {\n+                VehicleStatusContainer container = Converter.getGson().fromJson(vehicleStatus,\n+                        VehicleStatusContainer.class);\n+                if (container != null) {\n+                    VehicleStatus status = container.vehicleStatus;\n+                    if (status != null) {\n+                        status.vin = Constants.ANONYMOUS;\n+                        if (status.position != null) {\n+                            status.position.lat = -1;\n+                            status.position.lon = -1;\n+                            status.position.heading = -1;\n+                        }\n+                    }\n+                }\n+                logger.debug(\"{}\", Converter.getGson().toJson(container));\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Vehicle Status Empty ###\");\n+        });\n+        lastTripCache.ifPresentOrElse(lastTrip -> {\n+            logger.debug(\"### Last Trip ###\");\n+            logger.debug(\"{}\", lastTrip.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Last Trip Empty ###\");\n+        });\n+        allTripsCache.ifPresentOrElse(allTrips -> {\n+            logger.debug(\"### All Trips ###\");\n+            logger.debug(\"{}\", allTrips.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### All Trips Empty ###\");\n+        });\n+        if (isElectric) {\n+            chargeProfileCache.ifPresentOrElse(chargeProfile -> {\n+                logger.debug(\"### Charge Profile ###\");\n+                logger.debug(\"{}\", chargeProfile.replaceAll(vin, Constants.ANONYMOUS));\n+            }, () -> {\n+                logger.debug(\"### Charge Profile Empty ###\");\n+            });\n+        }\n+        destinationCache.ifPresentOrElse(destination -> {\n+            logger.debug(\"### Charge Profile ###\");\n+            try {\n+                DestinationContainer container = Converter.getGson().fromJson(destination, DestinationContainer.class);\n+                if (container != null) {\n+                    if (container.destinations != null) {\n+                        container.destinations.forEach(entry -> {\n+                            entry.lat = 0;\n+                            entry.lon = 0;\n+                            entry.city = Constants.ANONYMOUS;\n+                            entry.street = Constants.ANONYMOUS;\n+                            entry.streetNumber = Constants.ANONYMOUS;\n+                            entry.country = Constants.ANONYMOUS;\n+                        });\n+                        logger.debug(\"{}\", Converter.getGson().toJson(container));\n+                    }\n+                } else {\n+                    logger.debug(\"### Destinations Empty ###\");\n+                }\n+            } catch (JsonSyntaxException jse) {\n+                logger.debug(\"{}\", jse.getMessage());\n+            }\n+        }, () -> {\n+            logger.debug(\"### Charge Profile Empty ###\");\n+        });\n+        rangeMapCache.ifPresentOrElse(rangeMap -> {\n+            logger.debug(\"### Range Map ###\");\n+            logger.debug(\"{}\", rangeMap.replaceAll(vin, Constants.ANONYMOUS));\n+        }, () -> {\n+            logger.debug(\"### Range Map Empty ###\");\n+        });\n+        logger.debug(\"###### Vehicle Troubleshoot Fingerprint Data - END ######\");\n+    }\n+\n+    /**\n+     * Don't stress ConnectedDrive with unnecessary requests. One call at the beginning is done to check the response.\n+     * After cache has e.g. a proper error response it will be shown in the fingerprint\n+     *\n+     * @return\n+     */\n+    private boolean isSupported(String service) {\n+        final String services = thing.getProperties().get(Constants.SERVICES_SUPPORTED);\n+        if (services != null) {\n+            if (services.contains(service)) {\n+                return true;\n+            }\n+        }\n+        // if cache is empty give it a try one time to collected Troubleshoot data\n+        return lastTripCache.isEmpty() || allTripsCache.isEmpty() || destinationCache.isEmpty();\n+    }\n+\n+    public void updateRemoteExecutionStatus(@Nullable String service, @Nullable String status) {\n+        if (RemoteService.CHARGING_CONTROL.toString().equals(service)\n+                && ExecutionState.EXECUTED.name().equals(status)) {\n+            saveChargeProfileSent();\n+        }\n+        updateChannel(CHANNEL_GROUP_REMOTE, REMOTE_STATE, StringType\n+                .valueOf(Converter.toTitleCase((service == null ? \"-\" : service) + Constants.SPACE + status)));\n+    }\n+\n+    public Optional<VehicleConfiguration> getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public ScheduledExecutorService getScheduler() {\n+        return scheduler;\n+    }\n+\n+    /**\n+     * Callbacks for ConnectedDrive Portal\n+     *\n+     * @author Bernd Weymann\n+     *\n+     */\n+    public class ChargeProfilesCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                chargeProfileCache = Optional.of(content);\n+                if (chargeProfileEdit.isEmpty()) {\n+                    updateChargeProfileFromContent(content);\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            chargeProfileCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class RangeMapCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            rangeMapCache = Optional.ofNullable(content);\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            rangeMapCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class DestinationsCallback implements StringResponseCallback {\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            destinationCache = Optional.ofNullable(content);\n+            if (content != null) {\n+                try {\n+                    DestinationContainer dc = Converter.getGson().fromJson(content, DestinationContainer.class);\n+                    if (dc != null && dc.destinations != null) {\n+                        updateDestinations(dc.destinations);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            destinationCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class ImageCallback implements ByteResponseCallback {\n+        @Override\n+        public void onResponse(byte[] content) {\n+            if (content.length > 0) {\n+                imageCache = Optional.of(content);\n+                String contentType = HttpUtil.guessContentTypeFromData(content);\n+                updateChannel(CHANNEL_GROUP_VEHICLE_IMAGE, IMAGE_FORMAT, new RawType(content, contentType));\n+            } else {\n+                synchronized (imageProperties) {\n+                    imageProperties.failed();\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            synchronized (imageProperties) {\n+                imageProperties.failed();\n+            }\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class AllTripsCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                allTripsCache = Optional.of(content);\n+                try {\n+                    AllTripsContainer atc = Converter.getGson().fromJson(content, AllTripsContainer.class);\n+                    if (atc != null) {\n+                        AllTrips at = atc.allTrips;\n+                        if (at != null) {\n+                            updateAllTrips(at);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            allTripsCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    public class LastTripCallback implements StringResponseCallback {\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                lastTripCache = Optional.of(content);\n+                try {\n+                    LastTripContainer lt = Converter.getGson().fromJson(content, LastTripContainer.class);\n+                    if (lt != null) {\n+                        LastTrip trip = lt.lastTrip;\n+                        if (trip != null) {\n+                            updateLastTrip(trip);\n+                        }\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        /**\n+         * Store Error Report in cache variable. Via Fingerprint Channel error is logged and Issue can be raised\n+         */\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            lastTripCache = Optional.of(Converter.getGson().toJson(error));\n+            removeCallback(this);\n+        }\n+    }\n+\n+    /**\n+     * The VehicleStatus is supported by all Vehicle Types so it's used to reflect the Thing Status\n+     */\n+    public class VehicleStatusCallback implements StringResponseCallback {\n+        private ThingStatus thingStatus = ThingStatus.UNKNOWN;\n+\n+        @Override\n+        public void onResponse(@Nullable String content) {\n+            if (content != null) {\n+                updateStatus(ThingStatus.ONLINE);\n+                vehicleStatusCache = Optional.of(content);\n+                try {\n+                    VehicleStatusContainer status = Converter.getGson().fromJson(content, VehicleStatusContainer.class);\n+                    if (status != null) {\n+                        VehicleStatus vStatus = status.vehicleStatus;\n+                        if (vStatus == null) {\n+                            return;\n+                        }\n+                        updateVehicleStatus(vStatus);\n+                        updateCheckControls(vStatus.checkControlMessages);\n+                        updateServices(vStatus.cbsData);\n+                        updatePosition(vStatus.position);\n+                    }\n+                } catch (JsonSyntaxException jse) {\n+                    logger.debug(\"{}\", jse.getMessage());\n+                }\n+            }\n+            removeCallback(this);\n+        }\n+\n+        @Override\n+        public void onError(NetworkError error) {\n+            logger.debug(\"{}\", error.toString());\n+            if (error.status == 404) {\n+                legacyMode = true;\n+                logger.debug(\"VehicleStatus not found - switch to legacy API\");\n+                proxy.get().requestLegacyVehcileStatus(configuration.get(), oldVehicleStatusCallback);\n+            }\n+            vehicleStatusCache = Optional.of(Converter.getGson().toJson(error));\n+            setThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error.reason);", "originalCommit": "5a568b041a01f7b8cd6e1290a8d969c40369480a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMjYyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602812624", "bodyText": "Last 3 builds are working fine - perhaps rebase with the newest baseline missing with the latest review changes?", "author": "weymann", "createdAt": "2021-03-28T01:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjg2MTQxNg==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602861416", "bodyText": "in weymann@5a568b0 you did delete method 'setThingStatus' which caused the compile-error (being resoleved in weymann@3eb30f7).\nI just tried to compile in between.", "author": "ntruchsess", "createdAt": "2021-03-28T10:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8576#discussion_r602902558", "bodyText": "ok, so resolved", "author": "weymann", "createdAt": "2021-03-28T16:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MDMxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c45fde8fb30a91942ddfebf0880638d55634e9a6", "chunk": "diff --git a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\nindex bb21c39678..035f0c1b6e 100644\n--- a/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n+++ b/bundles/org.openhab.binding.bmwconnecteddrive/src/main/java/org/openhab/binding/bmwconnecteddrive/internal/handler/VehicleHandler.java\n\n@@ -26,7 +26,7 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bmwconnecteddrive.internal.VehicleConfiguration;\n-import org.openhab.binding.bmwconnecteddrive.internal.action.ChargeProfileActions;\n+import org.openhab.binding.bmwconnecteddrive.internal.action.BMWConnectedDriveActions;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.DestinationContainer;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.NetworkError;\n import org.openhab.binding.bmwconnecteddrive.internal.dto.compat.VehicleAttributesContainer;\n"}}, {"oid": "0af1f3d5d456abdb3b7e1e42bd52954afec54f1a", "url": "https://github.com/openhab/openhab-addons/commit/0af1f3d5d456abdb3b7e1e42bd52954afec54f1a", "message": "review findings error logging\n\nSigned-off-by: Bernd Weymann <bernd.weymann@gmail.com>", "committedDate": "2021-03-27T23:22:33Z", "type": "forcePushed"}, {"oid": "50526d8a6a586cbc547a880f0489cd30f551faef", "url": "https://github.com/openhab/openhab-addons/commit/50526d8a6a586cbc547a880f0489cd30f551faef", "message": "initial commit\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit ccc2b2ca32b7981b0a4a056dd80dbb7beeb23ac2)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:26Z", "type": "commit"}, {"oid": "30f56475c67397ea59efbb415b98cc4b9bfe5c74", "url": "https://github.com/openhab/openhab-addons/commit/30f56475c67397ea59efbb415b98cc4b9bfe5c74", "message": "initial commit\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit a1ecf762e6d1f633f3396209b1aa80b50022cc14)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:26Z", "type": "commit"}, {"oid": "15f4aed3fd0928beb151ecc6933db352d73ab7c6", "url": "https://github.com/openhab/openhab-addons/commit/15f4aed3fd0928beb151ecc6933db352d73ab7c6", "message": "Range feature added\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 1b7e4da6b8df82771215469e029175098768f50e)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:27Z", "type": "commit"}, {"oid": "e4f68c4b03559f70200c592a9033f270f6ac7e47", "url": "https://github.com/openhab/openhab-addons/commit/e4f68c4b03559f70200c592a9033f270f6ac7e47", "message": "last-trip and lifetime values\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 35ac78874620aafee52355cfd2512736517a9990)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:28Z", "type": "commit"}, {"oid": "caf85308b68fda57fdefe601e25324e2f4c8ce7f", "url": "https://github.com/openhab/openhab-addons/commit/caf85308b68fda57fdefe601e25324e2f4c8ce7f", "message": "add location group\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 33b7983c129d5c58513ce364a88733788348dd97)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:29Z", "type": "commit"}, {"oid": "3f0a812458b87fb0963c3e201c9e83aacabbd1ea", "url": "https://github.com/openhab/openhab-addons/commit/3f0a812458b87fb0963c3e201c9e83aacabbd1ea", "message": "add location group\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 2658091445223a8fb9998ee0be3b66da4ec5363a)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:30Z", "type": "commit"}, {"oid": "fac2914535257c9167e96c8b5a20707bcad60da6", "url": "https://github.com/openhab/openhab-addons/commit/fac2914535257c9167e96c8b5a20707bcad60da6", "message": "switch to webapi\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 68bc41ba36a28e6d1f3484427b2aada6f373c1c7)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:31Z", "type": "commit"}, {"oid": "1de2bb567d43de7362a4fd1c9974fac5120827e2", "url": "https://github.com/openhab/openhab-addons/commit/1de2bb567d43de7362a4fd1c9974fac5120827e2", "message": "local date time conversion\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 9294e53c5be20c8c69cd4cd8139bd6f616664a42)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:32Z", "type": "commit"}, {"oid": "abf426524edcdffedc2c5aa909a593d39bc46ed9", "url": "https://github.com/openhab/openhab-addons/commit/abf426524edcdffedc2c5aa909a593d39bc46ed9", "message": "added vehicle status\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 5358e666065610f539081c4097cb79edf3af8c16)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:33Z", "type": "commit"}, {"oid": "e43651bb92a5d3e1cd836a6031c3ba09c0e97e4a", "url": "https://github.com/openhab/openhab-addons/commit/e43651bb92a5d3e1cd836a6031c3ba09c0e97e4a", "message": "added vehicle status\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 059edbcc1d75331d0262df9b235e7fd659e43e95)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:33Z", "type": "commit"}, {"oid": "2b019228836ffb7a8e63d64bc8b3de278fcc5311", "url": "https://github.com/openhab/openhab-addons/commit/2b019228836ffb7a8e63d64bc8b3de278fcc5311", "message": "add remote services\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 93803e3565e573765631cbee7b01dea7e8b18989)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:34Z", "type": "commit"}, {"oid": "f509bc40c8056dbba4013e5b9c5741cb460d0a9c", "url": "https://github.com/openhab/openhab-addons/commit/f509bc40c8056dbba4013e5b9c5741cb460d0a9c", "message": "reduce logging\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 9d3bd24bb893363a0c2b81149322228e7b6d35ce)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:35Z", "type": "commit"}, {"oid": "00e0239ccc85a976e3364fd31faba7004b358f6f", "url": "https://github.com/openhab/openhab-addons/commit/00e0239ccc85a976e3364fd31faba7004b358f6f", "message": "Asnyc Jetty Client API\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit ea6a7e759907e9e7dc92375f53eb0d176a5638b7)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:36Z", "type": "commit"}, {"oid": "8a4c05e7c38a91aa2a01ef1eef50afd7450bd653", "url": "https://github.com/openhab/openhab-addons/commit/8a4c05e7c38a91aa2a01ef1eef50afd7450bd653", "message": "Constant cleanup, Network error handling and logging cleanup\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit a3b8723d5f262dd4e4c0b62b18f6751db688937b)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:38Z", "type": "commit"}, {"oid": "1cfba137c5275811276b380a1be9bb272fab4e84", "url": "https://github.com/openhab/openhab-addons/commit/1cfba137c5275811276b380a1be9bb272fab4e84", "message": "discovery optimization\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 000f413bdef80b792cb26ae209c41bfe07d22343)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:38Z", "type": "commit"}, {"oid": "0d76c7c868faeedc19276bfd7a33d170c52e64be", "url": "https://github.com/openhab/openhab-addons/commit/0d76c7c868faeedc19276bfd7a33d170c52e64be", "message": "readme.md plus organizational changes\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit e1398cb5390c12b8220cdffba2777b9de19748b0)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:39Z", "type": "commit"}, {"oid": "50b196e135d037a91da1be21096e474ff9942829", "url": "https://github.com/openhab/openhab-addons/commit/50b196e135d037a91da1be21096e474ff9942829", "message": "add group destinations\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 2885dea745fd81c47d744bffcfa4113e94ea6b51)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:41Z", "type": "commit"}, {"oid": "dd6e5f9aea3fcbd366aa6f2b7d5b5e8340265677", "url": "https://github.com/openhab/openhab-addons/commit/dd6e5f9aea3fcbd366aa6f2b7d5b5e8340265677", "message": "de translations\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 221ef95c20368a47b06307f17b9075657ec78865)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:42Z", "type": "commit"}, {"oid": "1123aefe9c2ca2dedd14facc01092e2243fb0234", "url": "https://github.com/openhab/openhab-addons/commit/1123aefe9c2ca2dedd14facc01092e2243fb0234", "message": "added all account variables to dto\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit b014d5f838a70c1862af16b82d83cfa5c9e4eae2)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:42Z", "type": "commit"}, {"oid": "22a665605fdf88f3d586494454eb0fcf401ec949", "url": "https://github.com/openhab/openhab-addons/commit/22a665605fdf88f3d586494454eb0fcf401ec949", "message": "consistent Vehicle naming\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 6999d70c65f4834d6c068068991d8ac4f1f77e5a)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:43Z", "type": "commit"}, {"oid": "37739919eeb9c14911adad231a8b3319196b2403", "url": "https://github.com/openhab/openhab-addons/commit/37739919eeb9c14911adad231a8b3319196b2403", "message": "HttpClient reorg\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit fefd653b14021e33b8ba48aa532059e66be21c4e)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:44Z", "type": "commit"}, {"oid": "6231032f1fed667f00cfd53ffe2f28f93b18c813", "url": "https://github.com/openhab/openhab-addons/commit/6231032f1fed667f00cfd53ffe2f28f93b18c813", "message": "extended Service Message\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit c71ef1b4970ceec3274d4eae800f8ffc4bae4e79)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:45Z", "type": "commit"}, {"oid": "1c610e018e67d85d9764e7707e4b68fa2f9e1e8f", "url": "https://github.com/openhab/openhab-addons/commit/1c610e018e67d85d9764e7707e4b68fa2f9e1e8f", "message": "hard-coded checks for StatusWrapper\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 975064fa6a6021ba5593e1eed37e4e99fe803a65)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:46Z", "type": "commit"}, {"oid": "3f0bd53d7eadf5d8e43fa877d6312167b7556455", "url": "https://github.com/openhab/openhab-addons/commit/3f0bd53d7eadf5d8e43fa877d6312167b7556455", "message": "date time corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit d983c7989465e85188a30f019c9ead6dba20e973)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:47Z", "type": "commit"}, {"oid": "cc04aa110c903af1b2c19b4f2169144fc1d5b6ba", "url": "https://github.com/openhab/openhab-addons/commit/cc04aa110c903af1b2c19b4f2169144fc1d5b6ba", "message": "more descriptions\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit f98b00f57caa34bb56956f4ff654299a9cfbdd63)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:48Z", "type": "commit"}, {"oid": "90da4a35c982daa9b80afab9c0bc5866d57d3ec3", "url": "https://github.com/openhab/openhab-addons/commit/90da4a35c982daa9b80afab9c0bc5866d57d3ec3", "message": "add service rule\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 640b9c659c9b549596fec910092b88da87b454c3)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:48Z", "type": "commit"}, {"oid": "e8f87464371b135ff3d39b9c73772917334c5532", "url": "https://github.com/openhab/openhab-addons/commit/e8f87464371b135ff3d39b9c73772917334c5532", "message": "charge status\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 2683748a88c682fa0f6541f859839224317d24b4)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:49Z", "type": "commit"}, {"oid": "68986ef15a040dcf2ee632811764d6a43970ced7", "url": "https://github.com/openhab/openhab-addons/commit/68986ef15a040dcf2ee632811764d6a43970ced7", "message": "image channels added\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit b922b8fb3b1ca24c02e3855f80f63b8119155161)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:50Z", "type": "commit"}, {"oid": "581ac0f39ef680723b4ef4971b63e64e14a27c8c", "url": "https://github.com/openhab/openhab-addons/commit/581ac0f39ef680723b4ef4971b63e64e14a27c8c", "message": "token handling optimization\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 84591625fbfe6740f76ebb32ff30ac7ff560f34f)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:51Z", "type": "commit"}, {"oid": "cc86095dd3acc2b4e9192404df116614ee044cbc", "url": "https://github.com/openhab/openhab-addons/commit/cc86095dd3acc2b4e9192404df116614ee044cbc", "message": "http request optimization\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 054099758657c5fbd97998215a601699e22ebb5d)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:52Z", "type": "commit"}, {"oid": "7ef14bb5977333f3bdb4a569e735d85ecbcbf601", "url": "https://github.com/openhab/openhab-addons/commit/7ef14bb5977333f3bdb4a569e735d85ecbcbf601", "message": "translation corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 87a6a74964b14cf9178260a64e397b07981e1095)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:53Z", "type": "commit"}, {"oid": "caeada3c95f5b0bf85280293ced1f11426c99429", "url": "https://github.com/openhab/openhab-addons/commit/caeada3c95f5b0bf85280293ced1f11426c99429", "message": "readme corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 82c7d3adcb3ee0d0f2bc9486fe851abc1ebfa2b2)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:54Z", "type": "commit"}, {"oid": "f82a77b24080c57a08fb27dc02c93a8e308149e8", "url": "https://github.com/openhab/openhab-addons/commit/f82a77b24080c57a08fb27dc02c93a8e308149e8", "message": "readme corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 03878a3b3965159a491857922b43c7cc1989421f)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:54Z", "type": "commit"}, {"oid": "6b6e44190af69e234dd1d919e0cb646fbd64b06b", "url": "https://github.com/openhab/openhab-addons/commit/6b6e44190af69e234dd1d919e0cb646fbd64b06b", "message": "readme corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit cb9cd2da5080a7e52d29e5ef117e72dd3a8eb1ef)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:55Z", "type": "commit"}, {"oid": "e25f7247ba2a282d4cb3992e7d79ccd8408e302c", "url": "https://github.com/openhab/openhab-addons/commit/e25f7247ba2a282d4cb3992e7d79ccd8408e302c", "message": "readme corrections\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 9ef83e02ffe30be289d0ec5e2b19a832ef721feb)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:56Z", "type": "commit"}, {"oid": "112f7bcb08a330c48eb1ea203ca2403fec8e54fd", "url": "https://github.com/openhab/openhab-addons/commit/112f7bcb08a330c48eb1ea203ca2403fec8e54fd", "message": "remove readme.md previews\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit b1c71549496c1d9c3e2f9c09fe78fc117a7c563d)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:56Z", "type": "commit"}, {"oid": "8f560ec33847824966a0d02001a3942b7d60ac11", "url": "https://github.com/openhab/openhab-addons/commit/8f560ec33847824966a0d02001a3942b7d60ac11", "message": "change unit test from hard coded date to service name\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit ffa97aca83a44227f51984abeef9d4cfa382113e)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:57Z", "type": "commit"}, {"oid": "0088cfbfad0fbcea4af61aaad74da4089c5cc27f", "url": "https://github.com/openhab/openhab-addons/commit/0088cfbfad0fbcea4af61aaad74da4089c5cc27f", "message": "remove locale time test\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit fcdd3c0057d7ca6eb15854de004f088a26371190)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:57Z", "type": "commit"}, {"oid": "87520d24e912bf8d5b1728c1cf3c870586902697", "url": "https://github.com/openhab/openhab-addons/commit/87520d24e912bf8d5b1728c1cf3c870586902697", "message": "remote state execution status update increase\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 43bd1613dad22adb1b36fe4d10b7c2b0823dccec)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:58Z", "type": "commit"}, {"oid": "557a2ff649fccf803fcaad6e1598314c479d8b91", "url": "https://github.com/openhab/openhab-addons/commit/557a2ff649fccf803fcaad6e1598314c479d8b91", "message": "update after remote service call\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 72b324dfce9938e7ab3311df48e54d870d8c3ef1)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:59Z", "type": "commit"}, {"oid": "50e96c51d5d52c07cbba42915790c62a44bbce46", "url": "https://github.com/openhab/openhab-addons/commit/50e96c51d5d52c07cbba42915790c62a44bbce46", "message": "fix window intermediate state handling\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 0424c871ebd16db40e01b423f8c90fb0fbbca5a1)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:47:59Z", "type": "commit"}, {"oid": "02bfae2415ccdd4ab1feec20f716ff6cb0d35e27", "url": "https://github.com/openhab/openhab-addons/commit/02bfae2415ccdd4ab1feec20f716ff6cb0d35e27", "message": "add service list interface\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit f6933f95eadafac4e578cb8aff2a3af0ed4d4a32)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:00Z", "type": "commit"}, {"oid": "6afcc53d4e10d31d01a69002823fa032ce353763", "url": "https://github.com/openhab/openhab-addons/commit/6afcc53d4e10d31d01a69002823fa032ce353763", "message": "final service data list interface adaptions\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit caffeb9539ebdb588555a165f21d2b7193ec3e70)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:01Z", "type": "commit"}, {"oid": "1282f077b77a46c20568cc6797b498fb3d1ffca2", "url": "https://github.com/openhab/openhab-addons/commit/1282f077b77a46c20568cc6797b498fb3d1ffca2", "message": "destinations list interface\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit ddf493c16c147b70f26f83879b436872ba5ce56b)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:02Z", "type": "commit"}, {"oid": "a0121891ee5b93da4301161d09f55f5af7ddad62", "url": "https://github.com/openhab/openhab-addons/commit/a0121891ee5b93da4301161d09f55f5af7ddad62", "message": "add check control list\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 63e262d24e66011964f98315c8c389fe1d331a21)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:02Z", "type": "commit"}, {"oid": "612a8e0271b48d322fb54eba4c9353be7a0d3589", "url": "https://github.com/openhab/openhab-addons/commit/612a8e0271b48d322fb54eba4c9353be7a0d3589", "message": "correct Doors and Windows default values\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 60158881f7c6730a4960bde43f2dd1c782f5d808)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:03Z", "type": "commit"}, {"oid": "e388a0b2795f3883172783f7f183cb28d9825100", "url": "https://github.com/openhab/openhab-addons/commit/e388a0b2795f3883172783f7f183cb28d9825100", "message": "remove service-name from status\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 75e7116edbacfdf13d06523382293a4d2a7bc79f)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:04Z", "type": "commit"}, {"oid": "9bcb67cd4a533d928c3eb4d56b75822016b9dcf1", "url": "https://github.com/openhab/openhab-addons/commit/9bcb67cd4a533d928c3eb4d56b75822016b9dcf1", "message": "adapt translation to new lists\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 7160d0beecb34381408bd019e84545ce1bf9b654)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:04Z", "type": "commit"}, {"oid": "3e6315c20e48a71b922755ac1a329ee9c653755e", "url": "https://github.com/openhab/openhab-addons/commit/3e6315c20e48a71b922755ac1a329ee9c653755e", "message": "adapt translation to new lists\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>\n(cherry picked from commit 5ffbc3fb79bca290677a6e85ec9413e1cf282bb0)\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:05Z", "type": "commit"}, {"oid": "d74e1c2611c7443f94d4930c83e7906d6b9cb7ee", "url": "https://github.com/openhab/openhab-addons/commit/d74e1c2611c7443f94d4930c83e7906d6b9cb7ee", "message": "move to oh3\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:06Z", "type": "commit"}, {"oid": "f40f103afd23726b16a7e04abfef7623a0b22373", "url": "https://github.com/openhab/openhab-addons/commit/f40f103afd23726b16a7e04abfef7623a0b22373", "message": "fix discovery\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:07Z", "type": "commit"}, {"oid": "eaa60ceb9b4f9bd19fb434c9a4c9c09eb4ba8c9c", "url": "https://github.com/openhab/openhab-addons/commit/eaa60ceb9b4f9bd19fb434c9a4c9c09eb4ba8c9c", "message": "introduce backward compatibility mode\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:07Z", "type": "commit"}, {"oid": "04cc16243aaabb02b65ca60dc5c57f72f212247a", "url": "https://github.com/openhab/openhab-addons/commit/04cc16243aaabb02b65ca60dc5c57f72f212247a", "message": "introduce backward compatibility mode\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:08Z", "type": "commit"}, {"oid": "e062e37787ba69849f2fc374015f768c7a0adb55", "url": "https://github.com/openhab/openhab-addons/commit/e062e37787ba69849f2fc374015f768c7a0adb55", "message": "add backward compatibility unit tests\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:09Z", "type": "commit"}, {"oid": "e29641239f9e21daf4da2fcc3140ceca15a2b4d8", "url": "https://github.com/openhab/openhab-addons/commit/e29641239f9e21daf4da2fcc3140ceca15a2b4d8", "message": "add backward compatibility unit tests\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:09Z", "type": "commit"}, {"oid": "adb5a0a8873afc2b2d2accb328f7264b86546a5e", "url": "https://github.com/openhab/openhab-addons/commit/adb5a0a8873afc2b2d2accb328f7264b86546a5e", "message": "bugfix status channel types\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:10Z", "type": "commit"}, {"oid": "2e4dc4206e6d9b503f44dd23ea58b475d0187621", "url": "https://github.com/openhab/openhab-addons/commit/2e4dc4206e6d9b503f44dd23ea58b475d0187621", "message": "enable compatibility mode\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:10Z", "type": "commit"}, {"oid": "8e1331863718bdfdcc04bcca7d8673371ae13ad0", "url": "https://github.com/openhab/openhab-addons/commit/8e1331863718bdfdcc04bcca7d8673371ae13ad0", "message": "clear list content after receiving empty list\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:11Z", "type": "commit"}, {"oid": "6e3cd761353673ab3ee68960da0dafa484ca1072", "url": "https://github.com/openhab/openhab-addons/commit/6e3cd761353673ab3ee68960da0dafa484ca1072", "message": "bugfix refresh job cancel\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:12Z", "type": "commit"}, {"oid": "fe3853a8a6a5e6068a109139c9aa2291681bf5f2", "url": "https://github.com/openhab/openhab-addons/commit/fe3853a8a6a5e6068a109139c9aa2291681bf5f2", "message": "Injector added to simulate different Vehicles\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:12Z", "type": "commit"}, {"oid": "a38ad21bcd14b5914c771e4c781b1343353d73eb", "url": "https://github.com/openhab/openhab-addons/commit/a38ad21bcd14b5914c771e4c781b1343353d73eb", "message": "Injector added to simulate different Vehicles\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:13Z", "type": "commit"}, {"oid": "8d61d7ae93063dca81447dce3e837137fbc94b05", "url": "https://github.com/openhab/openhab-addons/commit/8d61d7ae93063dca81447dce3e837137fbc94b05", "message": "correct legacy mode\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:14Z", "type": "commit"}, {"oid": "5e74c52a5f6aa4a6f20559c027b3fb41c0c37f15", "url": "https://github.com/openhab/openhab-addons/commit/5e74c52a5f6aa4a6f20559c027b3fb41c0c37f15", "message": "bugfix fingerprint logging\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:14Z", "type": "commit"}, {"oid": "2dcb7533a7ee7c5d4d3bf3040066fd9440bd694c", "url": "https://github.com/openhab/openhab-addons/commit/2dcb7533a7ee7c5d4d3bf3040066fd9440bd694c", "message": "add region constants\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:15Z", "type": "commit"}, {"oid": "44f19e1e29c11591c38e03432678c4b638b0cdc2", "url": "https://github.com/openhab/openhab-addons/commit/44f19e1e29c11591c38e03432678c4b638b0cdc2", "message": "Switch to legacy auth like BimmerConnected project\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:15Z", "type": "commit"}, {"oid": "45b29dd746b8a019b97558db638c1f7b0a3902ec", "url": "https://github.com/openhab/openhab-addons/commit/45b29dd746b8a019b97558db638c1f7b0a3902ec", "message": "remove auto generated files\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:16Z", "type": "commit"}, {"oid": "0b5962a65cd6055acd0f9b7e833bb5e8640470b7", "url": "https://github.com/openhab/openhab-addons/commit/0b5962a65cd6055acd0f9b7e833bb5e8640470b7", "message": "correct structural review comments\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:17Z", "type": "commit"}, {"oid": "3c0e233f07254d0f996fe95b9e0745155494d1a2", "url": "https://github.com/openhab/openhab-addons/commit/3c0e233f07254d0f996fe95b9e0745155494d1a2", "message": "lower case thing type ids\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:17Z", "type": "commit"}, {"oid": "b2444d8060c648106aa3b43345aab77fa0114e1d", "url": "https://github.com/openhab/openhab-addons/commit/b2444d8060c648106aa3b43345aab77fa0114e1d", "message": "introduce Location type for GPS coordinates\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:18Z", "type": "commit"}, {"oid": "80001e89d8b03ea633b2279dcff81f322a5ad6aa", "url": "https://github.com/openhab/openhab-addons/commit/80001e89d8b03ea633b2279dcff81f322a5ad6aa", "message": "satisfy null checker\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:19Z", "type": "commit"}, {"oid": "974e914074a4296e13f26888e1a8b3adbead5019", "url": "https://github.com/openhab/openhab-addons/commit/974e914074a4296e13f26888e1a8b3adbead5019", "message": "introduce VehicleStatusUtils\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:19Z", "type": "commit"}, {"oid": "c483c85a6694858cd7e8f495bc6032f36c8cf628", "url": "https://github.com/openhab/openhab-addons/commit/c483c85a6694858cd7e8f495bc6032f36c8cf628", "message": "introduce ThingHandlerService\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:20Z", "type": "commit"}, {"oid": "bb64ada314e3bf8f4b29426337c717af3431e334", "url": "https://github.com/openhab/openhab-addons/commit/bb64ada314e3bf8f4b29426337c717af3431e334", "message": "update Units import\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:21Z", "type": "commit"}, {"oid": "d523ec52b34c854e519e72345e0bdab4e0ee585d", "url": "https://github.com/openhab/openhab-addons/commit/d523ec52b34c854e519e72345e0bdab4e0ee585d", "message": "update Units import\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:21Z", "type": "commit"}, {"oid": "8870834f2c0f595272fa6d8784e10dc49b398b33", "url": "https://github.com/openhab/openhab-addons/commit/8870834f2c0f595272fa6d8784e10dc49b398b33", "message": "introduce command description for remote services\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:22Z", "type": "commit"}, {"oid": "9d9ba93361c70955d3f112f328d6dda7154b9380", "url": "https://github.com/openhab/openhab-addons/commit/9d9ba93361c70955d3f112f328d6dda7154b9380", "message": "handle destination list as option list\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:22Z", "type": "commit"}, {"oid": "257dfee502ed36179b17512ae4f3c7d708e3a44d", "url": "https://github.com/openhab/openhab-addons/commit/257dfee502ed36179b17512ae4f3c7d708e3a44d", "message": "update list item after first call\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:23Z", "type": "commit"}, {"oid": "987f6a6caea3b5836aff0f2a8af22641a92d02de", "url": "https://github.com/openhab/openhab-addons/commit/987f6a6caea3b5836aff0f2a8af22641a92d02de", "message": "check if selected item is in updated list\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:24Z", "type": "commit"}, {"oid": "13ccfd5e4d9b48c040fb2e8f856b9e94a7c9b4b3", "url": "https://github.com/openhab/openhab-addons/commit/13ccfd5e4d9b48c040fb2e8f856b9e94a7c9b4b3", "message": "switch serviceList to options\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:25Z", "type": "commit"}, {"oid": "2e07630fb130828ef3f88ea588a55c6f4d6c28bc", "url": "https://github.com/openhab/openhab-addons/commit/2e07630fb130828ef3f88ea588a55c6f4d6c28bc", "message": "switch check control list to options\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:26Z", "type": "commit"}, {"oid": "511b172ec150f41517d21feab05b03b58fed4a14", "url": "https://github.com/openhab/openhab-addons/commit/511b172ec150f41517d21feab05b03b58fed4a14", "message": "rework troubleshoot fingerprint output\n\nSigned-off-by: Bernd <bernd.weymann@gmail.com>", "committedDate": "2021-03-29T01:48:26Z", "type": "commit"}]}