{"pr_number": 7434, "pr_title": "[bluetooth.daikinmadoka] Daikinmadoka binding initial contribution", "pr_createdAt": "2020-04-20T21:25:45Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7434", "timeline": [{"oid": "1b510f0d5787d397cd438e8e7c65081f008d4e70", "url": "https://github.com/openhab/openhab-addons/commit/1b510f0d5787d397cd438e8e7c65081f008d4e70", "message": "Add Daikin Madoka BLE binding\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-13T10:11:59Z", "type": "commit"}, {"oid": "e967483c94412b42db40b5fc032c9e0dde508e5d", "url": "https://github.com/openhab/openhab-addons/commit/e967483c94412b42db40b5fc032c9e0dde508e5d", "message": "updated doc\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-13T12:34:32Z", "type": "commit"}, {"oid": "06386ead59999fa0e2d23c6b3fe45c00be79a3c1", "url": "https://github.com/openhab/openhab-addons/commit/06386ead59999fa0e2d23c6b3fe45c00be79a3c1", "message": "fixed PR comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-19T15:00:58Z", "type": "commit"}, {"oid": "4efef432272ce52b549067c3aef0fa30b5b26213", "url": "https://github.com/openhab/openhab-addons/commit/4efef432272ce52b549067c3aef0fa30b5b26213", "message": "Fixed everything according to PR comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-19T15:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411709420", "bodyText": "Please remove this unneeded wrapping statement block.", "author": "cpmeister", "createdAt": "2020-04-20T21:37:27Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n+        if (expectedChunks != this.uartMessages.size()) {\n+            return false;\n+        }\n+        {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex bd468b51fd..23277ee519 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -58,33 +58,28 @@ public class BRC1HUartProcessor {\n         }\n \n         byte[] firstMessageInQueue = uartMessages.first();\n-        if (firstMessageInQueue[0] != 0) {\n-            return false;\n-        }\n \n         if (firstMessageInQueue.length < 2) {\n             return false;\n         }\n \n-        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n-        if (expectedChunks != this.uartMessages.size()) {\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n             return false;\n         }\n-        {\n-            // Check that we have every single ID\n-            int expected = 0;\n-            for (byte[] m : this.uartMessages) {\n-                if (m.length < 2) {\n-                    return false;\n-                }\n \n-                if (m[0] != expected++) {\n-                    return false;\n-                }\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n             }\n-            return true;\n-        }\n \n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     public void chunkReceived(byte[] byteValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411709826", "bodyText": "Please change this to an appropriate log level.", "author": "cpmeister", "createdAt": "2020-04-20T21:38:09Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n+        if (expectedChunks != this.uartMessages.size()) {\n+            return false;\n+        }\n+        {\n+            // Check that we have every single ID\n+            int expected = 0;\n+            for (byte[] m : this.uartMessages) {\n+                if (m.length < 2) {\n+                    return false;\n+                }\n+\n+                if (m[0] != expected++) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+\n+        this.uartMessages.add(byteValue);\n+        if (isMessageComplete()) {\n+\n+            // Beyond this point, full message received\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+            for (byte[] msg : uartMessages) {\n+                try {\n+                    bos.write(Arrays.copyOfRange(msg, 1, msg.length));\n+                } catch (Exception e) {\n+                    // should never happen.\n+                    logger.error(\"Unexpected error\", e);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex bd468b51fd..23277ee519 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -58,33 +58,28 @@ public class BRC1HUartProcessor {\n         }\n \n         byte[] firstMessageInQueue = uartMessages.first();\n-        if (firstMessageInQueue[0] != 0) {\n-            return false;\n-        }\n \n         if (firstMessageInQueue.length < 2) {\n             return false;\n         }\n \n-        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n-        if (expectedChunks != this.uartMessages.size()) {\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n             return false;\n         }\n-        {\n-            // Check that we have every single ID\n-            int expected = 0;\n-            for (byte[] m : this.uartMessages) {\n-                if (m.length < 2) {\n-                    return false;\n-                }\n \n-                if (m[0] != expected++) {\n-                    return false;\n-                }\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n             }\n-            return true;\n-        }\n \n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     public void chunkReceived(byte[] byteValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMTE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411711171", "bodyText": "This is already checked for you in the loop at the end of the method.", "author": "cpmeister", "createdAt": "2020-04-20T21:40:41Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex bd468b51fd..23277ee519 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -58,33 +58,28 @@ public class BRC1HUartProcessor {\n         }\n \n         byte[] firstMessageInQueue = uartMessages.first();\n-        if (firstMessageInQueue[0] != 0) {\n-            return false;\n-        }\n \n         if (firstMessageInQueue.length < 2) {\n             return false;\n         }\n \n-        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n-        if (expectedChunks != this.uartMessages.size()) {\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n             return false;\n         }\n-        {\n-            // Check that we have every single ID\n-            int expected = 0;\n-            for (byte[] m : this.uartMessages) {\n-                if (m.length < 2) {\n-                    return false;\n-                }\n \n-                if (m[0] != expected++) {\n-                    return false;\n-                }\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n             }\n-            return true;\n-        }\n \n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     public void chunkReceived(byte[] byteValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMTYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411711619", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (expectedChunks != this.uartMessages.size()) {\n          \n          \n            \n                    if (expectedChunks != messagesInQueue) {", "author": "cpmeister", "createdAt": "2020-04-20T21:41:31Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n+        if (expectedChunks != this.uartMessages.size()) {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex bd468b51fd..23277ee519 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -58,33 +58,28 @@ public class BRC1HUartProcessor {\n         }\n \n         byte[] firstMessageInQueue = uartMessages.first();\n-        if (firstMessageInQueue[0] != 0) {\n-            return false;\n-        }\n \n         if (firstMessageInQueue.length < 2) {\n             return false;\n         }\n \n-        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n-        if (expectedChunks != this.uartMessages.size()) {\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n             return false;\n         }\n-        {\n-            // Check that we have every single ID\n-            int expected = 0;\n-            for (byte[] m : this.uartMessages) {\n-                if (m.length < 2) {\n-                    return false;\n-                }\n \n-                if (m[0] != expected++) {\n-                    return false;\n-                }\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n             }\n-            return true;\n-        }\n \n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     public void chunkReceived(byte[] byteValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNTc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411715747", "bodyText": "I think using Math.ceil makes what you are doing a bit more clear.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n          \n          \n            \n                    int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);", "author": "cpmeister", "createdAt": "2020-04-20T21:49:37Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex bd468b51fd..23277ee519 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -58,33 +58,28 @@ public class BRC1HUartProcessor {\n         }\n \n         byte[] firstMessageInQueue = uartMessages.first();\n-        if (firstMessageInQueue[0] != 0) {\n-            return false;\n-        }\n \n         if (firstMessageInQueue.length < 2) {\n             return false;\n         }\n \n-        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n-        if (expectedChunks != this.uartMessages.size()) {\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n             return false;\n         }\n-        {\n-            // Check that we have every single ID\n-            int expected = 0;\n-            for (byte[] m : this.uartMessages) {\n-                if (m.length < 2) {\n-                    return false;\n-                }\n \n-                if (m[0] != expected++) {\n-                    return false;\n-                }\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n             }\n-            return true;\n-        }\n \n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     public void chunkReceived(byte[] byteValue) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNjQ1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411716458", "bodyText": "remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T21:50:54Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNjUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411716531", "bodyText": "remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T21:51:00Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411717108", "bodyText": "Please catch specific exceptions.", "author": "cpmeister", "createdAt": "2020-04-20T21:52:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411717776", "bodyText": "If there is no way you could anticipate createRequest throwing an error, then I would suggest that instead of logging it you just throw some RuntimeException here instead.", "author": "cpmeister", "createdAt": "2020-04-20T21:53:28Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411717864", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T21:53:40Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxODcxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411718714", "bodyText": "If you expect size to be an unsigned int then you could do this instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        mv.setSize(msg[i + 1]);\n          \n          \n            \n                        mv.setSize(Byte.toUnsignedInt(msg[i + 1]));", "author": "cpmeister", "createdAt": "2020-04-20T21:55:24Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(msg[i + 1]);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxOTc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411719787", "bodyText": "Shouldn't you be calling this method in BRC1HUartProcessor.isMessageComplete()?", "author": "cpmeister", "createdAt": "2020-04-20T21:57:28Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(msg[i + 1]);\n+\n+            if (mv.getSize() < 0) {\n+                logger.info(\"*** TO BE TRACKED *** NEGATIVE VALUE ***\");\n+                mv.setSize(mv.getSize() + 128);\n+            }\n+\n+            mv.setRawValue(Arrays.copyOfRange(msg, i + 2, i + 2 + mv.getSize()));\n+\n+            i += 2 + mv.getSize();\n+\n+            m.values.put(mv.getId(), mv);\n+        }\n+\n+        return m;\n+    }\n+\n+    public int getMessageId() {\n+        return messageId;\n+    }\n+\n+    public Map<Integer, MadokaValue> getValues() {\n+        return values;\n+    }\n+\n+    public static int expectedMessageChunks(byte[] firstMessage) {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk5ODg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411998845", "bodyText": "Actually this method was not needed anymore - have removed it.", "author": "blafois", "createdAt": "2020-04-21T08:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxOTc4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411720626", "bodyText": "You should apply my earlier suggestion here as well.", "author": "cpmeister", "createdAt": "2020-04-20T21:59:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(msg[i + 1]);\n+\n+            if (mv.getSize() < 0) {\n+                logger.info(\"*** TO BE TRACKED *** NEGATIVE VALUE ***\");\n+                mv.setSize(mv.getSize() + 128);\n+            }\n+\n+            mv.setRawValue(Arrays.copyOfRange(msg, i + 2, i + 2 + mv.getSize()));\n+\n+            i += 2 + mv.getSize();\n+\n+            m.values.put(mv.getId(), mv);\n+        }\n+\n+        return m;\n+    }\n+\n+    public int getMessageId() {\n+        return messageId;\n+    }\n+\n+    public Map<Integer, MadokaValue> getValues() {\n+        return values;\n+    }\n+\n+    public static int expectedMessageChunks(byte[] firstMessage) {\n+        if (firstMessage.length < 2) {\n+            return -1;\n+        }\n+\n+        if (firstMessage[0] != 0) {\n+            // This is not the first message so cannot be used\n+            return -1;\n+        }\n+\n+        int expectedTotalBytes = firstMessage[1];\n+\n+        return ((expectedTotalBytes / (MAX_CHUNK_SIZE - 1))\n+                + ((expectedTotalBytes % (MAX_CHUNK_SIZE - 1)) > 0 ? 1 : 0));", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 6e42a8be1f..541b10f700 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -14,11 +14,13 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n \n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMTkzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411721930", "bodyText": "Please make sure your enum names are camelcase.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public enum FAN_SPEED {\n          \n          \n            \n                public enum FanSpeed {", "author": "cpmeister", "createdAt": "2020-04-20T22:01:57Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaProperties {\n+\n+    public enum FAN_SPEED {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\nindex af23691b3f..287e21b89b 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\n\n@@ -22,18 +22,18 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n @NonNullByDefault\n public class MadokaProperties {\n \n-    public enum FAN_SPEED {\n+    public enum FanSpeed {\n         MAX(5),\n         MEDIUM(3),\n         LOW(1);\n \n         private int v;\n \n-        FAN_SPEED(int v) {\n+        FanSpeed(int v) {\n             this.v = v;\n         }\n \n-        public static FAN_SPEED valueOf(int v) {\n+        public static FanSpeed valueOf(int v) {\n             if (v == 5) {\n                 return MAX;\n             } else if (v >= 2 && v <= 4) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjAwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411722006", "bodyText": "please make this camelcase as well.", "author": "cpmeister", "createdAt": "2020-04-20T22:02:09Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaProperties {\n+\n+    public enum FAN_SPEED {\n+        MAX(5),\n+        MEDIUM(3),\n+        LOW(1);\n+\n+        private int v;\n+\n+        FAN_SPEED(int v) {\n+            this.v = v;\n+        }\n+\n+        public static FAN_SPEED valueOf(int v) {\n+            if (v == 5) {\n+                return MAX;\n+            } else if (v >= 2 && v <= 4) {\n+                return MEDIUM;\n+            } else {\n+                return LOW;\n+            }\n+        }\n+\n+        public int value() {\n+            return v;\n+        }\n+    }\n+\n+    public enum OPERATION_MODE {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\nindex af23691b3f..287e21b89b 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\n\n@@ -22,18 +22,18 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n @NonNullByDefault\n public class MadokaProperties {\n \n-    public enum FAN_SPEED {\n+    public enum FanSpeed {\n         MAX(5),\n         MEDIUM(3),\n         LOW(1);\n \n         private int v;\n \n-        FAN_SPEED(int v) {\n+        FanSpeed(int v) {\n             this.v = v;\n         }\n \n-        public static FAN_SPEED valueOf(int v) {\n+        public static FanSpeed valueOf(int v) {\n             if (v == 5) {\n                 return MAX;\n             } else if (v >= 2 && v <= 4) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411722921", "bodyText": "The state shouldn't be nullable since the initial state should be NEW.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private volatile @Nullable State state;\n          \n          \n            \n                private volatile State state = State.NEW;", "author": "cpmeister", "createdAt": "2020-04-20T22:04:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile @Nullable State state;", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\nindex 2926a1049d..62e0164604 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n\n@@ -19,7 +19,7 @@ import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n \n /**\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMzEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411723134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable State getState() {\n          \n          \n            \n                public State getState() {", "author": "cpmeister", "createdAt": "2020-04-20T22:04:36Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile @Nullable State state;\n+\n+    private final Lock stateLock = new ReentrantLock();\n+\n+    private final Condition stateCondition = stateLock.newCondition();\n+\n+    public abstract boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response);\n+\n+    /**\n+     * THis command returns the message to be sent\n+     *\n+     * @return\n+     */\n+    public abstract byte[] getRequest();\n+\n+    /**\n+     * This is the command number, in the protocol\n+     *\n+     * @return\n+     */\n+    public abstract int getCommandId();\n+\n+    /**\n+     * Returns current state of the command.\n+     *\n+     * @return current state\n+     */\n+    public @Nullable State getState() {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\nindex 2926a1049d..62e0164604 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n\n@@ -19,7 +19,7 @@ import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n \n /**\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMzM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411723367", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T22:05:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetFanspeedCommand.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FAN_SPEED;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class GetFanspeedCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetFanspeedCommand.class);\n+\n+    private @Nullable FAN_SPEED coolingFanSpeed;\n+    private @Nullable FAN_SPEED heatingFanSpeed;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetFanspeedCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetFanspeedCommand.java\nindex c8d66226aa..dc18df2542 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetFanspeedCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetFanspeedCommand.java\n\n@@ -17,7 +17,7 @@ import java.util.concurrent.Executor;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n-import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FAN_SPEED;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNDM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411724362", "bodyText": "Did you see my other comment about this: #7372 (comment)", "author": "cpmeister", "createdAt": "2020-04-20T22:07:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OPERATION_MODE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetOperationmodeCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetOperationmodeCommand.class);\n+\n+    private OPERATION_MODE operationMode;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+        if (response == null) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            MadokaMessage mm = MadokaMessage.parse(response);\n+\n+            operationMode = OPERATION_MODE.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n+\n+            logger.debug(\"operationMode: {}\", operationMode);\n+\n+            listener.receivedResponse(this);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java\nindex 68720ce20e..39dd636f6a 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java\n\n@@ -14,9 +14,8 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n-import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OPERATION_MODE;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNjEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411726128", "bodyText": "Please remove all of these autogenerated comments", "author": "cpmeister", "createdAt": "2020-04-20T22:10:50Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DummyThing.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class DummyThing implements Thing {\n+\n+    @Override\n+    public @Nullable String getLabel() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void setLabel(@Nullable String label) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public List<@NonNull Channel> getChannels() {\n+        // TODO Auto-generated method stub\n+        return new ArrayList<Channel>();\n+    }\n+\n+    @Override\n+    public List<@NonNull Channel> getChannelsOfGroup(String channelGroupId) {\n+        // TODO Auto-generated method stub\n+        return new ArrayList<Channel>();\n+    }\n+\n+    @Override\n+    public @Nullable Channel getChannel(String channelId) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable Channel getChannel(ChannelUID channelUID) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public ThingStatus getStatus() {\n+        // TODO Auto-generated method stub\n+        return ThingStatus.ONLINE;\n+    }\n+\n+    @Override\n+    public ThingStatusInfo getStatusInfo() {\n+        // TODO Auto-generated method stub\n+        return new ThingStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, \"Dummy\");\n+    }\n+\n+    @Override\n+    public void setStatusInfo(ThingStatusInfo status) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public void setHandler(@Nullable ThingHandler thingHandler) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getHandler() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getBridgeUID() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void setBridgeUID(@Nullable ThingUID bridgeUID) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration() {\n+        // TODO Auto-generated method stub\n+        return new Configuration();\n+    }\n+\n+    @Override\n+    public ThingUID getUID() {\n+        // TODO Auto-generated method stub\n+        return new ThingUID(\"dummy\");\n+    }\n+\n+    @Override\n+    public ThingTypeUID getThingTypeUID() {\n+        // TODO Auto-generated method stub\n+        return new ThingTypeUID(\"dummy\");\n+    }\n+\n+    @Override\n+    public Map<@NonNull String, @NonNull String> getProperties() {\n+        // TODO Auto-generated method stub\n+        return new HashMap<String, String>();\n+    }\n+\n+    @Override\n+    public @Nullable String setProperty(String name, @Nullable String value) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void setProperties(Map<@NonNull String, @NonNull String> properties) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public @Nullable String getLocation() {\n+        // TODO Auto-generated method stub", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DummyThing.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DummyThing.java\nindex 5d4feba307..6b10287651 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DummyThing.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DummyThing.java\n\n@@ -33,7 +33,7 @@ import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n @NonNullByDefault\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNjM4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411726388", "bodyText": "Please remove the excess blank lines in all the methods in this file.", "author": "cpmeister", "createdAt": "2020-04-20T22:11:21Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/internal/MadokaMessageTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.junit.Test;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class MadokaMessageTest {\n+\n+    @Test\n+    public void testExpectedMessageChunks0() {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/internal/MadokaMessageTest.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/internal/MadokaMessageTest.java\nindex a313007458..9309807fda 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/internal/MadokaMessageTest.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/internal/MadokaMessageTest.java\n\n@@ -12,7 +12,7 @@\n  */\n package org.openhab.binding.bluetooth.daikinmadoka.internal;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertArrayEquals;\n \n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411727605", "bodyText": "The error logging level should be reserved for issues catastrophic enough to threaten the operation of openHab itself. An error in a binding shouldn't qualify for this. Please read the openHab coding guidelines for expected use of logging in bindings.\nMy general rule for logging levels is:\n\ntrace - used for normal expected execution paths\ndebug - used for unexepected execution paths, but well within normal operation\ninfo - used for notable points in an execution path, like a milestone. (in openhab we try reserve this logging level for the core, so bindings should rarely ever call this.)\nwarn - used for notable unexpected execution paths that a regular user (not just a developer) should be notified of. Warnings should be used to indicate that something not-normal occurred and user intervention is required to resolve. Warnings do not indicate a failure to operate merely an abnormal condition of operation that can still be handled by the binding. Failures in binding operation should be indicated by changing the thing status to offline.\nerror - used to indicate catastrophic program failure. This should be used to indicate a catastrophic failure in openhab's ability to operate. A failure in a binding would never cause openhab as a whole to fail so a failure in a bindings should never log an error. Instead that failure should be indicated by changing the thing status.\n\nPlease make changes elsewhere as appropriate.", "author": "cpmeister", "createdAt": "2020-04-20T22:14:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetVersionCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n+    private String remoteControllerVersion;\n+    private String communicationControllerVersion;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+        if (response == null) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            MadokaMessage mm = MadokaMessage.parse(response);\n+\n+            int remoteControllerMajor = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[0]);\n+            int remoteControllerMinor = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[1]);\n+            int remoteControllerRevision = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[2]);\n+\n+            this.remoteControllerVersion = remoteControllerMajor + \".\" + remoteControllerMinor + \".\"\n+                    + remoteControllerRevision;\n+\n+            int commControllerMajor = Integer.valueOf(mm.getValues().get(0x46).getRawValue()[0]);\n+            int commControllerMinor = Integer.valueOf(mm.getValues().get(0x46).getRawValue()[1]);\n+\n+            this.communicationControllerVersion = commControllerMajor + \".\" + commControllerMinor;\n+\n+            listener.receivedResponse(this);\n+            setState(State.SUCCEEDED);\n+            return true;\n+        } catch (Exception e) {\n+            logger.error(\"Error while parsing response\", e);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\nindex 4300cebbf0..4bb01e9089 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411727975", "bodyText": "Please cache mm.getValues().get(0x45).getRawValue() and mm.getValues().get(0x46).getRawValue() in local variables so you can reuse them.", "author": "cpmeister", "createdAt": "2020-04-20T22:15:01Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetVersionCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n+    private String remoteControllerVersion;\n+    private String communicationControllerVersion;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+        if (response == null) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            MadokaMessage mm = MadokaMessage.parse(response);\n+\n+            int remoteControllerMajor = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[0]);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\nindex 4300cebbf0..4bb01e9089 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczMDU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411730585", "bodyText": "To reduce the amount of redundant logic that subclasses must implement I suggest changing this method signature so that all the redundant logic is handled in by the method caller instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response);\n          \n          \n            \n                public abstract void handleResponse(ResponseListener listener, MadokaMessage mm);", "author": "cpmeister", "createdAt": "2020-04-20T22:20:34Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile @Nullable State state;\n+\n+    private final Lock stateLock = new ReentrantLock();\n+\n+    private final Condition stateCondition = stateLock.newCondition();\n+\n+    public abstract boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\nindex 2926a1049d..62e0164604 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n\n@@ -19,7 +19,7 @@ import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n \n /**\n  *\n"}}, {"oid": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "url": "https://github.com/openhab/openhab-addons/commit/4023fa4afda298d1796ec0cf4b28ce44f36dff73", "message": "Fixed all remarks in PR.\nAdded chapter on Bluetooth pairing in README.md\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-21T09:45:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMzM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412423393", "bodyText": "Can you please add @NonNullByDefault to all of your command classes", "author": "cpmeister", "createdAt": "2020-04-21T19:14:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetPowerstateCommand extends BRC1HCommand {", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\nindex cc997d3d1c..e2f688f241 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\n\n@@ -14,20 +14,24 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n+@NonNullByDefault\n public class GetPowerstateCommand extends BRC1HCommand {\n \n     private final Logger logger = LoggerFactory.getLogger(GetPowerstateCommand.class);\n \n-    private Boolean powerState;\n+    private @Nullable Boolean powerState;\n \n     @Override\n     public byte[] getRequest() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMTUyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412431527", "bodyText": "Is this one of those unsigned byte issues again? Can you just use Byte.toUnsignedInt when parsing it instead?", "author": "cpmeister", "createdAt": "2020-04-21T19:27:17Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetIndoorOutoorTemperatures extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetIndoorOutoorTemperatures.class);\n+\n+    private DecimalType indoorTemperature;\n+    private DecimalType outdoorTemperature;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        try {\n+            Integer iIndoorTemperature = Integer.valueOf(mm.getValues().get(0x40).getRawValue()[0]);\n+            Integer iOutdoorTemperature = Integer.valueOf(mm.getValues().get(0x41).getRawValue()[0]);\n+\n+            if (iOutdoorTemperature == -1) {\n+                iOutdoorTemperature = null;\n+            } else {\n+                if (iOutdoorTemperature < 0) {\n+                    iOutdoorTemperature = ((iOutdoorTemperature + 256) - 128) * -1;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NDA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412794045", "bodyText": "No this one is different - it is the encoding of the temperature from the thermostat. It must supports negative values from outdoor temperature.", "author": "blafois", "createdAt": "2020-04-22T08:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMTUyNw=="}], "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java\nindex 9f53c657a6..8310d46060 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java\n\n@@ -14,22 +14,26 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n+@NonNullByDefault\n public class GetIndoorOutoorTemperatures extends BRC1HCommand {\n \n     private final Logger logger = LoggerFactory.getLogger(GetIndoorOutoorTemperatures.class);\n \n-    private DecimalType indoorTemperature;\n-    private DecimalType outdoorTemperature;\n+    private @Nullable DecimalType indoorTemperature;\n+    private @Nullable DecimalType outdoorTemperature;\n \n     @Override\n     public byte[] getRequest() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412435747", "bodyText": "Integer.valueOf isn't needed to convert a byte to an int.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int remoteControllerMajor = Integer.valueOf(mv45[0]);\n          \n          \n            \n                        int remoteControllerMajor = mv45[0];", "author": "cpmeister", "createdAt": "2020-04-21T19:34:18Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetVersionCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n+    private String remoteControllerVersion;\n+    private String communicationControllerVersion;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        try {\n+            byte[] mv45 = mm.getValues().get(0x45).getRawValue();\n+\n+            int remoteControllerMajor = Integer.valueOf(mv45[0]);", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\nindex 4bb01e9089..8e513bad30 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java\n\n@@ -14,20 +14,24 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n+@NonNullByDefault\n public class GetVersionCommand extends BRC1HCommand {\n \n     private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n-    private String remoteControllerVersion;\n-    private String communicationControllerVersion;\n+    private @Nullable String remoteControllerVersion;\n+    private @Nullable String communicationControllerVersion;\n \n     @Override\n     public byte[] getRequest() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNzY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412437683", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-21T19:37:30Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n+            return false;\n+        }\n+\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n+            }\n+\n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 23277ee519..7666aa2273 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -24,12 +24,17 @@ import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n @NonNullByDefault\n public class BRC1HUartProcessor {\n \n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n     /**\n      * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNzc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412437755", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-21T19:37:38Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 23277ee519..7666aa2273 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -24,12 +24,17 @@ import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n @NonNullByDefault\n public class BRC1HUartProcessor {\n \n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n     /**\n      * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzOTIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412439233", "bodyText": "You should add another constructor allowing you to provide a cause throwable.", "author": "cpmeister", "createdAt": "2020-04-21T19:40:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaParsingException extends Exception {\n+\n+    private String message;\n+\n+    public MadokaParsingException(String message) {\n+        this.message = message;\n+    }\n+", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java\nindex 77168feb06..1d98ac33b3 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java\n\n@@ -16,20 +16,18 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n @NonNullByDefault\n public class MadokaParsingException extends Exception {\n \n-    private String message;\n-\n     public MadokaParsingException(String message) {\n-        this.message = message;\n+        super(message);\n     }\n \n-    @Override\n-    public String getMessage() {\n-        return message;\n+    public MadokaParsingException(Throwable t) {\n+        super(t);\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1Mjg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412452866", "bodyText": "It seems that your handler will log any failures when calling handleResponse already. So I think you would end up having duplicate logs in the event of exceptions in your commands.\nSince the handler already handles any MadokaParsingException thrown, and since it appears that any exception here could be classified as a parsing exception, I suggest wrapping any exceptions that occur in a MadokaParsingException and passing the exception up the line.\nDoing that would eliminate the double logging issue and would also eliminate the need to return a boolean since any failures would be thrown as an exception instead.\nThis should cleanup a bit of code in both the commands and the handler.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        operationMode = OperationMode.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n          \n          \n            \n            \n          \n          \n            \n                        logger.debug(\"operationMode: {}\", operationMode);\n          \n          \n            \n            \n          \n          \n            \n                        setState(State.SUCCEEDED);\n          \n          \n            \n                        executor.execute(() -> listener.receivedResponse(this));\n          \n          \n            \n            \n          \n          \n            \n                        return true;\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        logger.debug(\"Error while parsing response\", e);\n          \n          \n            \n                        setState(State.FAILED);\n          \n          \n            \n                    }\n          \n          \n            \n                    return false;\n          \n          \n            \n                public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        operationMode = OperationMode.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n          \n          \n            \n            \n          \n          \n            \n                        logger.debug(\"operationMode: {}\", operationMode);\n          \n          \n            \n            \n          \n          \n            \n                        setState(State.SUCCEEDED);\n          \n          \n            \n                        executor.execute(() -> listener.receivedResponse(this));\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        setState(State.FAILED);\n          \n          \n            \n                        throw new MadokaParsingException(e);\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-04-21T20:01:52Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetOperationmodeCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetOperationmodeCommand.class);\n+\n+    private OperationMode operationMode;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        try {\n+            operationMode = OperationMode.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n+\n+            logger.debug(\"operationMode: {}\", operationMode);\n+\n+            setState(State.SUCCEEDED);\n+            executor.execute(() -> listener.receivedResponse(this));\n+\n+            return true;\n+        } catch (Exception e) {\n+            logger.debug(\"Error while parsing response\", e);\n+            setState(State.FAILED);\n+        }\n+        return false;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java\nindex 39dd636f6a..3fe5e60c13 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java\n\n@@ -14,21 +14,25 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n+@NonNullByDefault\n public class GetOperationmodeCommand extends BRC1HCommand {\n \n     private final Logger logger = LoggerFactory.getLogger(GetOperationmodeCommand.class);\n \n-    private OperationMode operationMode;\n+    private @Nullable OperationMode operationMode;\n \n     @Override\n     public byte[] getRequest() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NDI0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412454245", "bodyText": "Why is this returning long if the largest value it would return is an int?", "author": "cpmeister", "createdAt": "2020-04-21T20:04:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ */\n+@NonNullByDefault\n+public class MadokaValue {\n+\n+    private int id;\n+    private int size;\n+    private byte @Nullable [] rawValue;\n+\n+    public MadokaValue(int id, int size, byte[] rawValue) {\n+        this.id = id;\n+        this.size = size;\n+        this.rawValue = rawValue;\n+    }\n+\n+    public MadokaValue() {\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    public byte @Nullable [] getRawValue() {\n+        return rawValue;\n+    }\n+\n+    public void setRawValue(byte[] rawValue) {\n+        this.rawValue = rawValue;\n+    }\n+\n+    public long getComputedValue() {", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java\nindex fae465b7e5..f19a3423d6 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java\n\n@@ -19,7 +19,7 @@ import org.eclipse.jdt.annotation.Nullable;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  */\n @NonNullByDefault\n public class MadokaValue {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NjkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412456919", "bodyText": "Since a lot of the commands that use this as their implementation perhaps you should make this the default implementation in BRC1HCommand.", "author": "cpmeister", "createdAt": "2020-04-21T20:08:32Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetIndoorOutoorTemperatures extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetIndoorOutoorTemperatures.class);\n+\n+    private DecimalType indoorTemperature;\n+    private DecimalType outdoorTemperature;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java\nindex 9f53c657a6..8310d46060 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java\n\n@@ -14,22 +14,26 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n+@NonNullByDefault\n public class GetIndoorOutoorTemperatures extends BRC1HCommand {\n \n     private final Logger logger = LoggerFactory.getLogger(GetIndoorOutoorTemperatures.class);\n \n-    private DecimalType indoorTemperature;\n-    private DecimalType outdoorTemperature;\n+    private @Nullable DecimalType indoorTemperature;\n+    private @Nullable DecimalType outdoorTemperature;\n \n     @Override\n     public byte[] getRequest() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NzI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412457260", "bodyText": "Please make sure all of your authoring tags use your real name.", "author": "cpmeister", "createdAt": "2020-04-21T20:09:05Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\nindex cc997d3d1c..e2f688f241 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\n\n@@ -14,20 +14,24 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n  *\n- * @author blafois\n+ * @author Benjamin Lafois\n  *\n  */\n+@NonNullByDefault\n public class GetPowerstateCommand extends BRC1HCommand {\n \n     private final Logger logger = LoggerFactory.getLogger(GetPowerstateCommand.class);\n \n-    private Boolean powerState;\n+    private @Nullable Boolean powerState;\n \n     @Override\n     public byte[] getRequest() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1OTk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412459940", "bodyText": "After a bit of research and a change of heart, I changed my mind and feel that the readability of using ByteBuffer outweighs the performance loss. So you can use ByteBuffer as you originally did.", "author": "cpmeister", "createdAt": "2020-04-21T20:13:36Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private byte @Nullable [] rawMessage;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (IOException e) {\n+            logger.info(\"Error while building request\", e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        m.setRawMessage(msg);\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMDU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412810552", "bodyText": "lol. ok.", "author": "blafois", "createdAt": "2020-04-22T09:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1OTk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 541b10f700..c211ccce81 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NTEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412465103", "bodyText": "This loop seems generally unsafe since you are not checking if msg is large enough before trying to access values in it.", "author": "cpmeister", "createdAt": "2020-04-21T20:22:09Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private byte @Nullable [] rawMessage;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (IOException e) {\n+            logger.info(\"Error while building request\", e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        m.setRawMessage(msg);\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(Byte.toUnsignedInt(msg[i + 1]));\n+            mv.setRawValue(Arrays.copyOfRange(msg, i + 2, i + 2 + mv.getSize()));\n+\n+            i += 2 + mv.getSize();\n+\n+            m.values.put(mv.getId(), mv);\n+        }", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 541b10f700..c211ccce81 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2ODA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412468059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<Integer, MadokaValue> values;\n          \n          \n            \n                private final Map<Integer, MadokaValue> values;", "author": "cpmeister", "createdAt": "2020-04-21T20:27:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 541b10f700..c211ccce81 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NDI1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412474253", "bodyText": "Since you start at index 4, does that mean that you skip the command id of the returned message? Wouldn't that be important to know in order to make sure that a particular response corresponds to a particular request?", "author": "cpmeister", "createdAt": "2020-04-21T20:37:25Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private byte @Nullable [] rawMessage;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (IOException e) {\n+            logger.info(\"Error while building request\", e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        m.setRawMessage(msg);\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412821372", "bodyText": "No I don't, the message ID is parsed and saved 2 lines before. At 4, only parameter values start.", "author": "blafois", "createdAt": "2020-04-22T09:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NDI1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 541b10f700..c211ccce81 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NzA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412477075", "bodyText": "Shouldn't this constant be defined and used in the BRC1HUartProcessor instead?", "author": "cpmeister", "createdAt": "2020-04-21T20:41:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex 541b10f700..c211ccce81 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n import java.io.ByteArrayOutputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3Nzk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412477947", "bodyText": "Do not use casting to get around the null checker. It should be sufficient to store it in a local variable then null check that.", "author": "cpmeister", "createdAt": "2020-04-21T20:43:23Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                device.enableNotifications(c);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                    BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                if ((!command.handleResponse(scheduler, this, MadokaMessage.parse(response)))) {\n+                    logger.debug(\"Command {} could not handle response {}\", command.getClass().getSimpleName(),\n+                            HexUtils.bytesToHex(response));\n+                }\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        this.madokaSettings.setCommunicationControllerVersion(command.getCommunicationControllerVersion());\n+        this.madokaSettings.setRemoteControllerVersion(command.getRemoteControllerVersion());\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(),\n+                        DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                new StringType(command.getCommunicationControllerVersion()));\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                new StringType(command.getRemoteControllerVersion()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        DecimalType sp = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+        if (this.madokaSettings.getSetpoint() != null) {\n+            @NonNull\n+            DecimalType dt = (@NonNull DecimalType) this.madokaSettings.getSetpoint();\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        // If the mode has not changed - no need to refresh everything\n+        if (command.getOperationMode().equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(command.getOperationMode());\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(command.getOperationMode().name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (command.getOperationMode()) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (command.getOperationMode()) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        if (command.getIndoorTemperature() != null\n+                && (!command.getIndoorTemperature().equals(this.madokaSettings.getIndoorTemperature()))) {\n+            this.madokaSettings.setIndoorTemperature(command.getIndoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                    command.getIndoorTemperature());\n+        }\n+\n+        if (command.getOutdoorTemperature() == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!command.getOutdoorTemperature().equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(command.getOutdoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    command.getOutdoorTemperature());\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+            if (madokaSettings.getOperationMode() == null) {\n+                return;\n+            }\n+\n+            switch (madokaSettings.getOperationMode()) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case HEAT:\n+                this.madokaSettings.setSetpoint(command.getHeatingSetpoint());\n+                break;\n+            case COOL:\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            case AUTO:\n+                // TODO\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (madokaSettings.getSetpoint() != null) {\n+            @NonNull\n+            DecimalType dt = (@NonNull DecimalType) madokaSettings.getSetpoint();", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 84bcf98f0b..8b76029122 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -89,7 +89,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n         super(thing);\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     public void initialize() {\n         super.initialize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3ODQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412478454", "bodyText": "can you implement this?", "author": "cpmeister", "createdAt": "2020-04-21T20:44:14Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                device.enableNotifications(c);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                    BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                if ((!command.handleResponse(scheduler, this, MadokaMessage.parse(response)))) {\n+                    logger.debug(\"Command {} could not handle response {}\", command.getClass().getSimpleName(),\n+                            HexUtils.bytesToHex(response));\n+                }\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        this.madokaSettings.setCommunicationControllerVersion(command.getCommunicationControllerVersion());\n+        this.madokaSettings.setRemoteControllerVersion(command.getRemoteControllerVersion());\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(),\n+                        DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                new StringType(command.getCommunicationControllerVersion()));\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                new StringType(command.getRemoteControllerVersion()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        DecimalType sp = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+        if (this.madokaSettings.getSetpoint() != null) {\n+            @NonNull\n+            DecimalType dt = (@NonNull DecimalType) this.madokaSettings.getSetpoint();\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        // If the mode has not changed - no need to refresh everything\n+        if (command.getOperationMode().equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(command.getOperationMode());\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(command.getOperationMode().name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (command.getOperationMode()) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (command.getOperationMode()) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        if (command.getIndoorTemperature() != null\n+                && (!command.getIndoorTemperature().equals(this.madokaSettings.getIndoorTemperature()))) {\n+            this.madokaSettings.setIndoorTemperature(command.getIndoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                    command.getIndoorTemperature());\n+        }\n+\n+        if (command.getOutdoorTemperature() == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!command.getOutdoorTemperature().equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(command.getOutdoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    command.getOutdoorTemperature());\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+            if (madokaSettings.getOperationMode() == null) {\n+                return;\n+            }\n+\n+            switch (madokaSettings.getOperationMode()) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case HEAT:\n+                this.madokaSettings.setSetpoint(command.getHeatingSetpoint());\n+                break;\n+            case COOL:\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            case AUTO:\n+                // TODO", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 84bcf98f0b..8b76029122 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -89,7 +89,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n         super(thing);\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     public void initialize() {\n         super.initialize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MDU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412480582", "bodyText": "What is wrong with doing this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            @NonNull\n          \n          \n            \n                            BluetoothCharacteristic c = charNotif;\n          \n          \n            \n                            device.enableNotifications(c);\n          \n          \n            \n                            device.enableNotifications(charNotif);", "author": "cpmeister", "createdAt": "2020-04-21T20:47:54Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                device.enableNotifications(c);", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412835526", "bodyText": "No idea! I might have been drunk when coding this :-D", "author": "blafois", "createdAt": "2020-04-22T09:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MDU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 84bcf98f0b..8b76029122 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -89,7 +89,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n         super(thing);\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     public void initialize() {\n         super.initialize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MjE1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412482156", "bodyText": "What do you mean by query mode?\nWhy can't you use your getter commands to handle the refresh?", "author": "cpmeister", "createdAt": "2020-04-21T20:50:34Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNzM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412837348", "bodyText": "It was just done on purpose - channels are only refreshed when the bindings decides it - ie. with the refresh timer. It was to avoid too many refreshes coming from elsewhere. The BRC1H does not handle very well too many queries, and when it is stuck, you have to completely power off your entire AC installation (from the switchboard) which is not super convienient.", "author": "blafois", "createdAt": "2020-04-22T09:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MjE1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 84bcf98f0b..8b76029122 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -89,7 +89,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n         super(thing);\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     public void initialize() {\n         super.initialize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MzUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412483521", "bodyText": "Device disconnect/cleanup is already handled for you as part of super.dispose(). So you don't need to handle it yourself.", "author": "cpmeister", "createdAt": "2020-04-21T20:53:00Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 84bcf98f0b..8b76029122 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -89,7 +89,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n         super(thing);\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     public void initialize() {\n         super.initialize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NDY4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412484681", "bodyText": "Please try not to suppress any warnings. What is preventing you from removing this?", "author": "cpmeister", "createdAt": "2020-04-21T20:55:01Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 84bcf98f0b..8b76029122 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -89,7 +89,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n         super(thing);\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     public void initialize() {\n         super.initialize();\n"}}, {"oid": "a508dbf12b8333bd292d4b0a6ea77a164d2fcf60", "url": "https://github.com/openhab/openhab-addons/commit/a508dbf12b8333bd292d4b0a6ea77a164d2fcf60", "message": "Merge branch '2.5.x' into add-daikinmadoka-binding following 2.5.5 release", "committedDate": "2020-04-22T08:14:03Z", "type": "commit"}, {"oid": "f3e5557ead5d8b53513249e414070989ae8d2d02", "url": "https://github.com/openhab/openhab-addons/commit/f3e5557ead5d8b53513249e414070989ae8d2d02", "message": "Updates following @cpmeister comments on PR 7434\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-22T09:52:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5NjgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425396817", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                bos.write(Arrays.copyOfRange(msg, 1, msg.length));\n          \n          \n            \n                                bos.write(msg, 1, msg.length - 1);", "author": "cpmeister", "createdAt": "2020-05-14T20:01:35Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / (MAX_CHUNK_SIZE - 1.0));\n+        if (expectedChunks != messagesInQueue) {\n+            return false;\n+        }\n+\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n+            }\n+\n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+        this.uartMessages.add(byteValue);\n+        if (isMessageComplete()) {\n+\n+            // Beyond this point, full message received\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+            for (byte[] msg : uartMessages) {\n+                try {\n+                    bos.write(Arrays.copyOfRange(msg, 1, msg.length));", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 7666aa2273..7e07493563 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -13,14 +13,11 @@\n package org.openhab.binding.bluetooth.daikinmadoka.internal;\n \n import java.io.ByteArrayOutputStream;\n-import java.util.Arrays;\n import java.util.Comparator;\n import java.util.concurrent.ConcurrentSkipListSet;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMzU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425423556", "bodyText": "I assume this is some out of bounds exception regarding the messages. Instead of catching an exception here just perform a check to make sure that the exception doesn't occur.", "author": "cpmeister", "createdAt": "2020-05-14T20:53:17Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / (MAX_CHUNK_SIZE - 1.0));\n+        if (expectedChunks != messagesInQueue) {\n+            return false;\n+        }\n+\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n+            }\n+\n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+        this.uartMessages.add(byteValue);\n+        if (isMessageComplete()) {\n+\n+            // Beyond this point, full message received\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+            for (byte[] msg : uartMessages) {\n+                try {\n+                    bos.write(Arrays.copyOfRange(msg, 1, msg.length));\n+                } catch (Exception e) {\n+                    // should never happen.\n+                    logger.info(\"An unexpected error occured while re-assembling message chunks\", e);\n+                }", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 7666aa2273..7e07493563 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -13,14 +13,11 @@\n package org.openhab.binding.bluetooth.daikinmadoka.internal;\n \n import java.io.ByteArrayOutputStream;\n-import java.util.Arrays;\n import java.util.Comparator;\n import java.util.concurrent.ConcurrentSkipListSet;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n /**\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNTQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425425487", "bodyText": "It should be safe to change the return type to void since commands will just throw an exception if they fail.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n          \n          \n            \n                public abstract void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)", "author": "cpmeister", "createdAt": "2020-05-14T20:56:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile State state = State.NEW;\n+\n+    private final Lock stateLock = new ReentrantLock();\n+\n+    private final Condition stateCondition = stateLock.newCondition();\n+\n+    public abstract boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\nindex 6b5cb750d0..17186e7ce8 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java\n\n@@ -44,7 +44,7 @@ public abstract class BRC1HCommand {\n \n     private final Condition stateCondition = stateLock.newCondition();\n \n-    public abstract boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n+    public abstract void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n             throws MadokaParsingException;\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425425879", "bodyText": "What exception can be thrown here, can you make it specific?", "author": "cpmeister", "createdAt": "2020-05-14T20:57:35Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class GetPowerstateCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetPowerstateCommand.class);\n+\n+    private @Nullable Boolean powerState;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n+            throws MadokaParsingException {\n+        try {\n+            powerState = Integer.valueOf(mm.getValues().get(0x20).getRawValue()[0]) == 1;\n+\n+            logger.debug(\"PowerState: {}\", powerState);\n+\n+            setState(State.SUCCEEDED);\n+            executor.execute(() -> listener.receivedResponse(this));\n+\n+            return true;\n+        } catch (Exception e) {", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\nindex e2f688f241..ec580dc0d1 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java\n\n@@ -39,21 +39,21 @@ public class GetPowerstateCommand extends BRC1HCommand {\n     }\n \n     @Override\n-    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n             throws MadokaParsingException {\n-        try {\n-            powerState = Integer.valueOf(mm.getValues().get(0x20).getRawValue()[0]) == 1;\n+        byte[] powerStateValue = mm.getValues().get(0x20).getRawValue();\n \n-            logger.debug(\"PowerState: {}\", powerState);\n-\n-            setState(State.SUCCEEDED);\n-            executor.execute(() -> listener.receivedResponse(this));\n-\n-            return true;\n-        } catch (Exception e) {\n+        if (powerStateValue == null || powerStateValue.length != 1) {\n             setState(State.FAILED);\n-            throw new MadokaParsingException(e);\n+            throw new MadokaParsingException(\"Incorrect value for PowerState\");\n         }\n+\n+        powerState = Integer.valueOf(powerStateValue[0]) == 1;\n+\n+        logger.debug(\"PowerState: {}\", powerState);\n+\n+        setState(State.SUCCEEDED);\n+        executor.execute(() -> listener.receivedResponse(this));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNzAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425427022", "bodyText": "Here is an example of how to deal with the null checker warnings.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n          \n          \n            \n                        byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();\n          \n          \n            \n                    byte[] msg = mm.getRawMessage();\n          \n          \n            \n                    if (logger.isDebugEnabled() && msg != null) {", "author": "cpmeister", "createdAt": "2020-05-14T20:59:41Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetPowerstateCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetPowerstateCommand.class);\n+\n+    private OnOffType powerState;\n+\n+    public SetPowerstateCommand(OnOffType powerState) {\n+        this.powerState = powerState;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        MadokaValue mv = new MadokaValue(0x20, 1,\n+                new byte[] { (byte) (this.powerState == OnOffType.ON ? 0x01 : 0x00) });\n+\n+        return MadokaMessage.createRequest(this, mv);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetPowerstateCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetPowerstateCommand.java\nindex 84ca398d75..96796898ff 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetPowerstateCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetPowerstateCommand.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.NonNull;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.util.HexUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNzM2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425427364", "bodyText": "this.madokaSettings.getOperationMode() should be cached to a local variable so it can be reused.\nAlso make similar changes elsewhere.", "author": "cpmeister", "createdAt": "2020-05-14T21:00:18Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                    BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                if ((!command.handleResponse(scheduler, this, MadokaMessage.parse(response)))) {\n+                    logger.debug(\"Command {} could not handle response {}\", command.getClass().getSimpleName(),\n+                            HexUtils.bytesToHex(response));\n+                }\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        DecimalType sp = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+\n+        DecimalType dt = this.madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        OperationMode newMode = command.getOperationMode();\n+        // If the mode has not changed - no need to refresh everything\n+        if (newMode.equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(newMode);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(newMode.name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (newMode) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (newMode) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        DecimalType newIndoorTemp = command.getIndoorTemperature();\n+        if (newIndoorTemp != null) {\n+            if (!newIndoorTemp.equals(this.madokaSettings.getIndoorTemperature())) {\n+                this.madokaSettings.setIndoorTemperature(newIndoorTemp);\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                        newIndoorTemp);\n+            }\n+        }\n+\n+        DecimalType newOutdoorTemp = command.getOutdoorTemperature();\n+        if (newOutdoorTemp == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!newOutdoorTemp.equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(newOutdoorTemp);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    newOutdoorTemp);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+            if (madokaSettings.getOperationMode() == null) {\n+                return;\n+            }\n+\n+            switch (madokaSettings.getOperationMode()) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        if (this.madokaSettings.getOperationMode() == null) {", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 8b76029122..690a4ab880 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -97,10 +97,10 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n \n         // Load Configuration\n         config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n \n-        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n-                config.refreshInterval);\n-        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n \n         if (getBridge() == null) {\n             logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n"}}, {"oid": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "url": "https://github.com/openhab/openhab-addons/commit/2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "message": "Multiple fixes following PR review (+ removed all warnings)\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-16T16:11:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjQ0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192443", "bodyText": "This should address any null checker warnings here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (rawValue != null) {\n          \n          \n            \n                        byte[] v = rawValue;\n          \n          \n            \n                    byte[] v = rawValue;\n          \n          \n            \n                    if (v != null) {", "author": "cpmeister", "createdAt": "2020-05-16T21:23:27Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ */\n+@NonNullByDefault\n+public class MadokaValue {\n+\n+    private int id;\n+    private int size;\n+    private byte @Nullable [] rawValue;\n+\n+    public MadokaValue(int id, int size, byte[] rawValue) {\n+        this.id = id;\n+        this.size = size;\n+        this.rawValue = rawValue;\n+    }\n+\n+    public MadokaValue() {\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    public byte @Nullable [] getRawValue() {\n+        return rawValue;\n+    }\n+\n+    public void setRawValue(byte[] rawValue) {\n+        this.rawValue = rawValue;\n+    }\n+\n+    public long getComputedValue() {\n+        if (rawValue != null) {\n+            byte[] v = rawValue;", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java\nindex 3c1ad5493c..a716e16eb9 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java\n\n@@ -62,8 +62,8 @@ public class MadokaValue {\n     }\n \n     public long getComputedValue() {\n-        if (rawValue != null) {\n-            byte[] v = rawValue;\n+        byte[] v = rawValue;\n+        if (v != null) {\n             switch (size) {\n                 case 1:\n                     return v[0];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192776", "bodyText": "This should be the same right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });\n          \n          \n            \n                            heatingSetpointBytes);", "author": "cpmeister", "createdAt": "2020-05-16T21:28:03Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetSetpointCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetSetpointCommand.class);\n+\n+    private DecimalType coolingSetpoint;\n+    private DecimalType heatingSetpoint;\n+\n+    public SetSetpointCommand(DecimalType coolingSetpoint, DecimalType heatingSetpoint) {\n+        this.coolingSetpoint = coolingSetpoint;\n+        this.heatingSetpoint = heatingSetpoint;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        byte[] heatingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * heatingSetpoint.shortValue()))\n+                .array();\n+        byte[] coolingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * coolingSetpoint.shortValue()))\n+                .array();\n+\n+        MadokaValue mvHeatingSetpoint = new MadokaValue(0x21, 2,\n+                new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\nindex e97a770808..abe85145ac 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\n\n@@ -15,7 +15,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n import java.nio.ByteBuffer;\n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.NonNull;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.util.HexUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192790", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new byte[] { coolingSetpointBytes[0], coolingSetpointBytes[1] });\n          \n          \n            \n                            coolingSetpointBytes);", "author": "cpmeister", "createdAt": "2020-05-16T21:28:13Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetSetpointCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetSetpointCommand.class);\n+\n+    private DecimalType coolingSetpoint;\n+    private DecimalType heatingSetpoint;\n+\n+    public SetSetpointCommand(DecimalType coolingSetpoint, DecimalType heatingSetpoint) {\n+        this.coolingSetpoint = coolingSetpoint;\n+        this.heatingSetpoint = heatingSetpoint;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        byte[] heatingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * heatingSetpoint.shortValue()))\n+                .array();\n+        byte[] coolingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * coolingSetpoint.shortValue()))\n+                .array();\n+\n+        MadokaValue mvHeatingSetpoint = new MadokaValue(0x21, 2,\n+                new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });\n+\n+        MadokaValue mvCoolingSetpoint = new MadokaValue(0x20, 2,\n+                new byte[] { coolingSetpointBytes[0], coolingSetpointBytes[1] });", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\nindex e97a770808..abe85145ac 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\n\n@@ -15,7 +15,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n import java.nio.ByteBuffer;\n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.NonNull;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.util.HexUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n          \n          \n            \n                        byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();\n          \n          \n            \n                    byte[] msg = mm.getRawMessage();\n          \n          \n            \n                    if (logger.isDebugEnabled() && msg != null) {", "author": "cpmeister", "createdAt": "2020-05-16T21:29:44Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetSetpointCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetSetpointCommand.class);\n+\n+    private DecimalType coolingSetpoint;\n+    private DecimalType heatingSetpoint;\n+\n+    public SetSetpointCommand(DecimalType coolingSetpoint, DecimalType heatingSetpoint) {\n+        this.coolingSetpoint = coolingSetpoint;\n+        this.heatingSetpoint = heatingSetpoint;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        byte[] heatingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * heatingSetpoint.shortValue()))\n+                .array();\n+        byte[] coolingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * coolingSetpoint.shortValue()))\n+                .array();\n+\n+        MadokaValue mvHeatingSetpoint = new MadokaValue(0x21, 2,\n+                new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });\n+\n+        MadokaValue mvCoolingSetpoint = new MadokaValue(0x20, 2,\n+                new byte[] { coolingSetpointBytes[0], coolingSetpointBytes[1] });\n+\n+        return MadokaMessage.createRequest(this, mvCoolingSetpoint, mvHeatingSetpoint);\n+    }\n+\n+    @Override\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\nindex e97a770808..abe85145ac 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java\n\n@@ -15,7 +15,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n import java.nio.ByteBuffer;\n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.NonNull;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.library.types.DecimalType;\n import org.eclipse.smarthome.core.util.HexUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192933", "bodyText": "do same change here", "author": "cpmeister", "createdAt": "2020-05-16T21:30:38Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetOperationmodeCommand.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetOperationmodeCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetOperationmodeCommand.class);\n+\n+    private OperationMode operationMode;\n+\n+    public SetOperationmodeCommand(OperationMode operationMode) {\n+        this.operationMode = operationMode;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        MadokaValue mv = new MadokaValue(0x20, 1, new byte[] { (byte) this.operationMode.value() });\n+        return MadokaMessage.createRequest(this, mv);\n+    }\n+\n+    @Override\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetOperationmodeCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetOperationmodeCommand.java\nindex b8874c228e..d79ab3321c 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetOperationmodeCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetOperationmodeCommand.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.NonNull;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.util.HexUtils;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192981", "bodyText": "just do it everywhere else as well", "author": "cpmeister", "createdAt": "2020-05-16T21:31:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetFanspeedCommand.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetFanspeedCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetFanspeedCommand.class);\n+\n+    private FanSpeed coolingFanSpeed;\n+    private FanSpeed heatingFanSpeed;\n+\n+    public SetFanspeedCommand(FanSpeed coolingFanSpeed, FanSpeed heatingFanSpeed) {\n+        this.coolingFanSpeed = coolingFanSpeed;\n+        this.heatingFanSpeed = heatingFanSpeed;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        MadokaValue paramCoolingFanSpeed = new MadokaValue(0x20, 1, new byte[] { (byte) coolingFanSpeed.value() });\n+        MadokaValue paramHeatingFanSpeed = new MadokaValue(0x21, 1, new byte[] { (byte) heatingFanSpeed.value() });\n+\n+        return MadokaMessage.createRequest(this, paramCoolingFanSpeed, paramHeatingFanSpeed);\n+    }\n+\n+    @Override\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetFanspeedCommand.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetFanspeedCommand.java\nindex 2bfac5848e..21de12bee4 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetFanspeedCommand.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetFanspeedCommand.java\n\n@@ -14,7 +14,6 @@ package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n \n import java.util.concurrent.Executor;\n \n-import org.eclipse.jdt.annotation.NonNull;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.util.HexUtils;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MzMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426193333", "bodyText": "This should cleanup the code a little bit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void updateStateIfLinked(ChannelUID channelUID, State state) {\n          \n          \n            \n                    if (isLinked(channelUID)) {\n          \n          \n            \n                private void updateStateIfLinked(String channelId, State state) {\n          \n          \n            \n                    ChannelUID channelUID = new ChannelUID(getThing().getUID(),channelId);\n          \n          \n            \n                    if (isLinked(channelUID)) {", "author": "cpmeister", "createdAt": "2020-05-16T21:37:21Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (fs == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        DecimalType sp;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (sp == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+\n+        DecimalType dt = this.madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        OperationMode newMode = command.getOperationMode();\n+        // If the mode has not changed - no need to refresh everything\n+        if (newMode == null || newMode.equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(newMode);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(newMode.name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (newMode) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (newMode) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        DecimalType newIndoorTemp = command.getIndoorTemperature();\n+        if (newIndoorTemp != null) {\n+            if (!newIndoorTemp.equals(this.madokaSettings.getIndoorTemperature())) {\n+                this.madokaSettings.setIndoorTemperature(newIndoorTemp);\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                        newIndoorTemp);\n+            }\n+        }\n+\n+        DecimalType newOutdoorTemp = command.getOutdoorTemperature();\n+        if (newOutdoorTemp == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!newOutdoorTemp.equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(newOutdoorTemp);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    newOutdoorTemp);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+\n+            OperationMode operationMode = madokaSettings.getOperationMode();\n+            if (operationMode == null) {\n+                return;\n+            }\n+\n+            switch (operationMode) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        switch (operationMode) {\n+            case HEAT:\n+                this.madokaSettings.setSetpoint(command.getHeatingSetpoint());\n+                break;\n+            case COOL:\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            case AUTO:\n+                // Here we don't really care if we are taking cooling or heating...\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        DecimalType dt = madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+    }\n+\n+    /**\n+     * Received response to \"SetOperationmodeCommand\" command\n+     */\n+    @Override\n+    public void receivedResponse(SetOperationmodeCommand command) {\n+        this.madokaSettings.setOperationMode(command.getOperationMode());\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(command.getOperationMode().toString()));\n+    }\n+\n+    /**\n+     * Received response to \"SetFanSpeed\" command\n+     */\n+    @Override\n+    public void receivedResponse(SetFanspeedCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fanSpeed;\n+        switch (operationMode) {\n+            case HEAT:\n+                fanSpeed = command.getHeatingFanSpeed();\n+                this.madokaSettings.setFanspeed(fanSpeed);\n+                break;\n+            case COOL:\n+                fanSpeed = command.getCoolingFanSpeed();\n+                this.madokaSettings.setFanspeed(fanSpeed);\n+                break;\n+            case AUTO:\n+                fanSpeed = command.getCoolingFanSpeed(); // Arbitrary cooling or heating... They are the same!\n+                this.madokaSettings.setFanspeed(fanSpeed);\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fanSpeed.value()));\n+    }\n+\n+    private void updateStateIfLinked(ChannelUID channelUID, State state) {\n+        if (isLinked(channelUID)) {", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 690a4ab880..b1bd5cc0a5 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -122,12 +122,10 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n             submitCommand(new GetSetpointCommand());\n             submitCommand(new GetFanspeedCommand());\n         }, 10, c.refreshInterval, TimeUnit.SECONDS);\n-\n     }\n \n     @Override\n     public void dispose() {\n-\n         logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n \n         dispose(refreshJob);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MzQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426193454", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-05-16T21:38:59Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 690a4ab880..b1bd5cc0a5 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -122,12 +122,10 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n             submitCommand(new GetSetpointCommand());\n             submitCommand(new GetFanspeedCommand());\n         }, 10, c.refreshInterval, TimeUnit.SECONDS);\n-\n     }\n \n     @Override\n     public void dispose() {\n-\n         logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n \n         dispose(refreshJob);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MzQ2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426193462", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-05-16T21:39:04Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex 690a4ab880..b1bd5cc0a5 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -122,12 +122,10 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n             submitCommand(new GetSetpointCommand());\n             submitCommand(new GetFanspeedCommand());\n         }, 10, c.refreshInterval, TimeUnit.SECONDS);\n-\n     }\n \n     @Override\n     public void dispose() {\n-\n         logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n \n         dispose(refreshJob);\n"}}, {"oid": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "url": "https://github.com/openhab/openhab-addons/commit/751974e914ddfb27b12027f4fdc7777f3a8efbae", "message": "last round of PR fixes\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-17T10:53:01Z", "type": "commit"}, {"oid": "d503ff1f49727c564ca7304ebe78d0f6ec7954d3", "url": "https://github.com/openhab/openhab-addons/commit/d503ff1f49727c564ca7304ebe78d0f6ec7954d3", "message": "Updated to 2.5.6\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-19T13:05:13Z", "type": "commit"}, {"oid": "1e67d8672db35c5212cf6b37071645642047a1b8", "url": "https://github.com/openhab/openhab-addons/commit/1e67d8672db35c5212cf6b37071645642047a1b8", "message": "Fix OOB issue\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-19T14:07:19Z", "type": "commit"}, {"oid": "9d1b0c4dcf46a82a80804d48a5d4127e15f7a398", "url": "https://github.com/openhab/openhab-addons/commit/9d1b0c4dcf46a82a80804d48a5d4127e15f7a398", "message": "fix parsing issues\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-19T17:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MTc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r427671788", "bodyText": "Please cache characteristic.getByteValue() in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-05-20T00:16:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,720 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {", "originalCommit": "9d1b0c4dcf46a82a80804d48a5d4127e15f7a398", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81f8776065edef784fc706e09bf78129f1dc78b0", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex d4fc49c2b4..79462932ed 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -215,6 +215,44 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n                     logger.info(\"Data received is not a valid OPERATION MODE\", e);\n                 }\n                 break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n             case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n                 try {\n                     StringType homekitOperationMode = (StringType) command;\n"}}, {"oid": "81f8776065edef784fc706e09bf78129f1dc78b0", "url": "https://github.com/openhab/openhab-addons/commit/81f8776065edef784fc706e09bf78129f1dc78b0", "message": "Add HomeBridge support\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-20T13:21:49Z", "type": "commit"}, {"oid": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "url": "https://github.com/openhab/openhab-addons/commit/7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "message": "Last changes following PR comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-26T10:45:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MzUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434163524", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-06-02T20:42:20Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex a4d9e3c2e3..137e3fa20a 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -371,7 +371,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n                     command.setState(BRC1HCommand.State.FAILED);\n                 }\n             }\n-\n         } catch (Exception e) {\n             logger.debug(\"Error\", e);\n         } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434164508", "bodyText": "Can you be more specific here?\nNormally, you should not do such a \"catch all\", but rather let exceptions that are unexpected bubble up the stack.", "author": "kaikreuzer", "createdAt": "2020-06-02T20:44:19Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NDYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434794600", "bodyText": "The idea here is I need to make the command terminate (execute the finally block), whatever happens. Any suggestion to achieve this goal ?", "author": "blafois", "createdAt": "2020-06-03T19:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMzcwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434833700", "bodyText": "The finally does not look that important to me.\nLooking at it, I would rather suggest to not have currentCommand as a field in the class. Its only purpose seems to be to have a handle for interrupting it in case of a dispose call. But for this it would be cleaner to simply shut down the executor and tell it to interrupt existing jobs - so you could cancel the currentCommand within the InterruptedException catch clause.", "author": "kaikreuzer", "createdAt": "2020-06-03T20:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NDExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r442744111", "bodyText": "I still need the \"currentCommand\" to track it somewhere else, so I implemented a trick to let the exception bubble up.", "author": "blafois", "createdAt": "2020-06-19T09:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex a4d9e3c2e3..137e3fa20a 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -371,7 +371,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n                     command.setState(BRC1HCommand.State.FAILED);\n                 }\n             }\n-\n         } catch (Exception e) {\n             logger.debug(\"Error\", e);\n         } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165056", "bodyText": "still a todo?", "author": "kaikreuzer", "createdAt": "2020-06-02T20:45:25Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}. Reason: {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION,\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION,\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NTA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434795054", "bodyText": "It is just because at time of writing, i was using my AC in heating mode, not auto - now in auto ! :-)", "author": "blafois", "createdAt": "2020-06-03T19:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex a4d9e3c2e3..137e3fa20a 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -371,7 +371,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n                     command.setState(BRC1HCommand.State.FAILED);\n                 }\n             }\n-\n         } catch (Exception e) {\n             logger.debug(\"Error\", e);\n         } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTIyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165228", "bodyText": "still a todo?", "author": "kaikreuzer", "createdAt": "2020-06-02T20:45:44Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}. Reason: {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION,\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION,\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (fs == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED, new DecimalType(fs.value()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        DecimalType sp;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex a4d9e3c2e3..137e3fa20a 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -371,7 +371,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n                     command.setState(BRC1HCommand.State.FAILED);\n                 }\n             }\n-\n         } catch (Exception e) {\n             logger.debug(\"Error\", e);\n         } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165533", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-06-02T20:46:22Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}. Reason: {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION,\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION,\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (fs == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED, new DecimalType(fs.value()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        DecimalType sp;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (sp == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+\n+        DecimalType dt = this.madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT, dt);\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        OperationMode newMode = command.getOperationMode();\n+        // If the mode has not changed - no need to refresh everything\n+        if (newMode == null || newMode.equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(newMode);\n+\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE, new StringType(newMode.name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        OnOffType ooStatus = madokaSettings.getOnOffState();\n+\n+        if (ooStatus != null && ooStatus == OnOffType.ON) {\n+            switch (newMode) {\n+                case COOL:\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                            new StringType(\"Cooling\"));\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(2));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                            new StringType(\"Heating\"));\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(1));\n+                    break;\n+                case AUTO:\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                            new StringType(\"Auto\"));\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(3));\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (newMode) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+\n+            if (ooStatus != null && ooStatus == OnOffType.ON) {\n+                this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+                updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE,\n+                        new StringType(newHomekitTargetStatus));\n+            } else if (ooStatus != null && ooStatus == OnOffType.OFF) {\n+                newHomekitTargetStatus = \"Off\";\n+                this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+                updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE,\n+                        new StringType(newHomekitTargetStatus));\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS, oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE,\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(0));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex a4d9e3c2e3..137e3fa20a 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -371,7 +371,6 @@ public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements Re\n                     command.setState(BRC1HCommand.State.FAILED);\n                 }\n             }\n-\n         } catch (Exception e) {\n             logger.debug(\"Error\", e);\n         } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTg2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165861", "bodyText": "please add \"- Initial contribution\"", "author": "kaikreuzer", "createdAt": "2020-06-02T20:47:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 46fe97a55a..728a4093ec 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -20,9 +20,10 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n \n /**\n+ * As the protocol emutes an UART communication over BLE (characteristics write/notify), this class takes care of BLE\n+ * transport.\n  *\n- * @author Benjamin Lafois\n- *\n+ * @author Benjamin Lafois - Initial contribution\n  */\n @NonNullByDefault\n public class BRC1HUartProcessor {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165973", "bodyText": "add a short description", "author": "kaikreuzer", "createdAt": "2020-06-02T20:47:19Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 46fe97a55a..728a4093ec 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -20,9 +20,10 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n \n /**\n+ * As the protocol emutes an UART communication over BLE (characteristics write/notify), this class takes care of BLE\n+ * transport.\n  *\n- * @author Benjamin Lafois\n- *\n+ * @author Benjamin Lafois - Initial contribution\n  */\n @NonNullByDefault\n public class BRC1HUartProcessor {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjA4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166083", "bodyText": "remove or add content", "author": "kaikreuzer", "createdAt": "2020-06-02T20:47:34Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\nindex 46fe97a55a..728a4093ec 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java\n\n@@ -20,9 +20,10 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n \n /**\n+ * As the protocol emutes an UART communication over BLE (characteristics write/notify), this class takes care of BLE\n+ * transport.\n  *\n- * @author Benjamin Lafois\n- *\n+ * @author Benjamin Lafois - Initial contribution\n  */\n @NonNullByDefault\n public class BRC1HUartProcessor {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166315", "bodyText": "add description", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:02Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex d49ed98e8e..1843dc1a56 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -27,9 +27,9 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n+ * This class represents a message transmitted or received from the BRC1H controller.\n  *\n- * @author Benjamin Lafois\n- *\n+ * @author Benjamin Lafois - Initial contribution\n  */\n @NonNullByDefault\n public class MadokaMessage {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166408", "bodyText": "add \"- Initial contribution\"", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\nindex d49ed98e8e..1843dc1a56 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java\n\n@@ -27,9 +27,9 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n+ * This class represents a message transmitted or received from the BRC1H controller.\n  *\n- * @author Benjamin Lafois\n- *\n+ * @author Benjamin Lafois - Initial contribution\n  */\n @NonNullByDefault\n public class MadokaMessage {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166625", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:39Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzODYyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434838621", "bodyText": "\"dito\" meaning: Please add a short description on the javadoc of ALL classes - I see you have only updated the author tag so far.", "author": "kaikreuzer", "createdAt": "2020-06-03T20:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1MDQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r442750430", "bodyText": "Done.", "author": "blafois", "createdAt": "2020-06-19T10:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java\nindex 1aa7494884..ac473f454b 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java\n\n@@ -16,7 +16,7 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n \n /**\n  *\n- * @author Benjamin Lafois\n+ * @author Benjamin Lafois - Initial contribution\n  *\n  */\n @SuppressWarnings(\"serial\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166684", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:47Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\nindex 831166d350..804c0511b7 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java\n\n@@ -16,7 +16,7 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n \n /**\n  *\n- * @author Benjamin Lafois\n+ * @author Benjamin Lafois - Initial contribution\n  *\n  */\n @NonNullByDefault\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166831", "bodyText": "and the same for all classes :-)", "author": "kaikreuzer", "createdAt": "2020-06-02T20:49:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaSettings.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8bcaa5077daa9290ef027c07284162095ce73028", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaSettings.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaSettings.java\nindex 83dddb1453..1d44a049e6 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaSettings.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaSettings.java\n\n@@ -21,7 +21,7 @@ import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaPropertie\n \n /**\n  *\n- * @author Benjamin Lafois\n+ * @author Benjamin Lafois - Initial contribution\n  *\n  */\n @NonNullByDefault\n"}}, {"oid": "8bcaa5077daa9290ef027c07284162095ce73028", "url": "https://github.com/openhab/openhab-addons/commit/8bcaa5077daa9290ef027c07284162095ce73028", "message": "Fixes following PR review comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-03T19:59:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNjc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434836791", "bodyText": "btw, all those info loggings look a bit fishy to me. You are again doing a \"catch all\" here, but then claim that the issue is due to invalid data. If you are certain of that, you should imho be able to catch a more specific exception.\nIn case of an exception here: Can the situation be considered to be a bug that should be reported as an issue? I guess so. I would then even suggest to log it as a warning or even error, so that the user is clearly notified that something isn't working as expected and he needs to ask for help.", "author": "kaikreuzer", "createdAt": "2020-06-03T20:33:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0MDU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r442740552", "bodyText": "I have updated with WARN level instead of debug. The point is - if the FW gets updated - I'm not sure the way values are encoded might change or not - so I prefer catching it.", "author": "blafois", "createdAt": "2020-06-19T09:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNjc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "adf117d7c49dd2f597602205db94be5dbba5d71f", "chunk": "diff --git a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\nindex a4d9e3c2e3..02da7e4eb3 100644\n--- a/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n+++ b/bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java\n\n@@ -63,7 +63,7 @@ import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n- * sent to one of the channels.\n+ * sent to one of the channels as well as updating channel values.\n  *\n  * @author Benjamin Lafois - Initial contribution\n  */\n"}}, {"oid": "adf117d7c49dd2f597602205db94be5dbba5d71f", "url": "https://github.com/openhab/openhab-addons/commit/adf117d7c49dd2f597602205db94be5dbba5d71f", "message": "Another round of review fixes\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-19T10:04:39Z", "type": "commit"}, {"oid": "38e6b567b865ab3a2fb3d20b9a6bee586a409367", "url": "https://github.com/openhab/openhab-addons/commit/38e6b567b865ab3a2fb3d20b9a6bee586a409367", "message": "Bug fixes for channel Home Bridge\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-23T16:53:48Z", "type": "commit"}, {"oid": "5b4a7bd2671a8d7bc322e8ddd5e161eb407cbfb9", "url": "https://github.com/openhab/openhab-addons/commit/5b4a7bd2671a8d7bc322e8ddd5e161eb407cbfb9", "message": "minor indent fixes and update to 2.5.7\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-29T07:19:20Z", "type": "commit"}, {"oid": "be8e52197640d8563e38609d1d0cecdf9e1e1e70", "url": "https://github.com/openhab/openhab-addons/commit/be8e52197640d8563e38609d1d0cecdf9e1e1e70", "message": "Merge branch '2.5.x' into add-daikinmadoka-binding", "committedDate": "2020-06-29T07:28:49Z", "type": "commit"}, {"oid": "7360b4987790cd916c4370ff86bd8de12d15f3da", "url": "https://github.com/openhab/openhab-addons/commit/7360b4987790cd916c4370ff86bd8de12d15f3da", "message": "last cosmetic change and upgrade to 2.5.7\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-29T07:33:15Z", "type": "commit"}]}