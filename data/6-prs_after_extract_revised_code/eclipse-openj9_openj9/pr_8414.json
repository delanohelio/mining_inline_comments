{"pr_number": 8414, "pr_title": "JEP-370 Implementation (Part 2)", "pr_createdAt": "2020-01-27T05:50:21Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8414", "timeline": [{"oid": "7252558ffcea34df62dbfb45294fa86c68e2b211", "url": "https://github.com/eclipse-openj9/openj9/commit/7252558ffcea34df62dbfb45294fa86c68e2b211", "message": "Handle the difference in MemoryAddress VarHandles operations class\n\nVarHandle operations class:\nOpenJ9 - AccessMode.method(Receiver, args ..., VarHandle)\nOpenJDK - AccessMode.method(VarHandle, Receiver, args ...)\n\nThe location of VarHandle varies in the two implementations. OpenJ9 has\nVarHandle as the last argument whereas OpenJDK has VarHandle as the\nfirst argument.\n\nMethods accessModeType and toMethodHandle are updated to handle both\nscenarios.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-01-27T06:36:55Z", "type": "forcePushed"}, {"oid": "19f5fe28aa7d31cd4bfa5262b5447f407380d6e6", "url": "https://github.com/eclipse-openj9/openj9/commit/19f5fe28aa7d31cd4bfa5262b5447f407380d6e6", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-01-28T14:52:47Z", "type": "forcePushed"}, {"oid": "8f4d3ac23deee5a56fe66c25559168cb6c21ec39", "url": "https://github.com/eclipse-openj9/openj9/commit/8f4d3ac23deee5a56fe66c25559168cb6c21ec39", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-01-28T15:17:11Z", "type": "forcePushed"}, {"oid": "78a8f153c29d459723805e32a24675b834f10d32", "url": "https://github.com/eclipse-openj9/openj9/commit/78a8f153c29d459723805e32a24675b834f10d32", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-01-30T14:27:28Z", "type": "forcePushed"}, {"oid": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "url": "https://github.com/eclipse-openj9/openj9/commit/fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-01-30T14:34:32Z", "type": "forcePushed"}, {"oid": "f5978d5d20bedb88ca150558722bbb4556f59909", "url": "https://github.com/eclipse-openj9/openj9/commit/f5978d5d20bedb88ca150558722bbb4556f59909", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-05T01:01:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyNjIwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r374726209", "bodyText": "This feels like it's missing some cases.  The basicType() api should be total for all types - Either one of the primitive ones or L_TYPE", "author": "DanHeidinga", "createdAt": "2020-02-04T15:07:29Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;\n+\t\t\t\t} else if ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n+\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')) {\n+\t\t\t\t\tbasicType = I_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'J') {\n+\t\t\t\t\tbasicType = J_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'F') {\n+\t\t\t\t\tbasicType = F_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'D') {\n+\t\t\t\t\tbasicType = D_TYPE;\n+\t\t\t\t} else if (basicTypeChar == 'V') {\n+\t\t\t\t\tbasicType = V_TYPE;\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalError(\"Unknown basic type char: \" + basicTypeChar);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn basicType;", "originalCommit": "fe3507ecef6e9b968ee9d2ed5c4d20d0d3e03c6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwMTI4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375401283", "bodyText": "as per sun.misc.Wrapper enum values, all cases are covered.", "author": "babsingh", "createdAt": "2020-02-05T17:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyNjIwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "chunk": "diff --git a/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java b/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java\nindex 824365e79..56f47519b 100644\n--- a/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java\n+++ b/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java\n\n@@ -117,14 +117,16 @@ class LambdaForm {\n \t\tV_TYPE;\n \n \t\tstatic BasicType basicType(Class<?> cls) {\n+\t\t\t/* Wrapper.forPrimitiveType throws an IllegalArgumentException for\n+\t\t\t * non-primitive types (L_TYPE).\n+\t\t\t */\n \t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n \t\t\tBasicType basicType = null;\n \t\t\tif (wrapper != null) {\n \t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n-\t\t\t\tif (basicTypeChar == 'L') {\n-\t\t\t\t\tbasicType = L_TYPE;\n-\t\t\t\t} else if ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n-\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')) {\n+\t\t\t\tif ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n+\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')\n+\t\t\t\t) {\n \t\t\t\t\tbasicType = I_TYPE;\n \t\t\t\t} else if (basicTypeChar == 'J') {\n \t\t\t\t\tbasicType = J_TYPE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375372929", "bodyText": "Having called Wrapper.forPrimitiveType(cls), it should never be possible to get L_Type here", "author": "DanHeidinga", "createdAt": "2020-02-05T16:41:40Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java", "diffHunk": "@@ -108,10 +109,36 @@ MethodHandle resolve() {\n \t}\n \t\n \tenum BasicType {\n-\t\tL_TYPE;\n-\t\t\n+\t\tL_TYPE,\n+\t\tI_TYPE,\n+\t\tJ_TYPE,\n+\t\tF_TYPE,\n+\t\tD_TYPE,\n+\t\tV_TYPE;\n+\n \t\tstatic BasicType basicType(Class<?> cls) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n+\t\t\tBasicType basicType = null;\n+\t\t\tif (wrapper != null) {\n+\t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n+\t\t\t\tif (basicTypeChar == 'L') {\n+\t\t\t\t\tbasicType = L_TYPE;", "originalCommit": "f5978d5d20bedb88ca150558722bbb4556f59909", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwMDY5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375400692", "bodyText": "correct, IAE is thrown from Wrapper.forPrimitveType(cls) for a non-primitive type. i will remove the L_TYPE check.", "author": "babsingh", "createdAt": "2020-02-05T17:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MjM0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375482342", "bodyText": "removed.", "author": "babsingh", "createdAt": "2020-02-05T20:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjkyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "chunk": "diff --git a/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java b/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java\nindex 824365e79..56f47519b 100644\n--- a/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java\n+++ b/jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java\n\n@@ -117,14 +117,16 @@ class LambdaForm {\n \t\tV_TYPE;\n \n \t\tstatic BasicType basicType(Class<?> cls) {\n+\t\t\t/* Wrapper.forPrimitiveType throws an IllegalArgumentException for\n+\t\t\t * non-primitive types (L_TYPE).\n+\t\t\t */\n \t\t\tWrapper wrapper = Wrapper.forPrimitiveType(cls);\n \t\t\tBasicType basicType = null;\n \t\t\tif (wrapper != null) {\n \t\t\t\tchar basicTypeChar = wrapper.basicTypeChar();\n-\t\t\t\tif (basicTypeChar == 'L') {\n-\t\t\t\t\tbasicType = L_TYPE;\n-\t\t\t\t} else if ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n-\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')) {\n+\t\t\t\tif ((basicTypeChar == 'C') || (basicTypeChar == 'B') || (basicTypeChar == 'Z')\n+\t\t\t\t\t\t|| (basicTypeChar == 'I') || (basicTypeChar == 'S')\n+\t\t\t\t) {\n \t\t\t\t\tbasicType = I_TYPE;\n \t\t\t\t} else if (basicTypeChar == 'J') {\n \t\t\t\t\tbasicType = J_TYPE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375373841", "bodyText": "Can you move these closer to their first use?", "author": "DanHeidinga", "createdAt": "2020-02-05T16:43:13Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;", "originalCommit": "f5978d5d20bedb88ca150558722bbb4556f59909", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwOTUzNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375409537", "bodyText": "yes.", "author": "babsingh", "createdAt": "2020-02-05T17:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MjQxOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375482419", "bodyText": "moved closer.", "author": "babsingh", "createdAt": "2020-02-05T20:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3Mzg0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "chunk": "diff --git a/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\nindex b6437eec7..feb11d581 100644\n--- a/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\n+++ b/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\n\n@@ -369,14 +369,6 @@ public abstract class VarHandle extends VarHandleInternal\n \t\tAccessMode accessModes[] = AccessMode.values();\n \t\tint numAccessModes = accessModes.length;\n \n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tMethodType[] operationMTsExact = null;\n-\n-\t\tMethodType getter = null;\n-\t\tMethodType setter = null;\n-\t\t\n-\t\tClass<?> operationsClass = null;\n-\t\t\n \t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n \t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n \t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375374897", "bodyText": "Can you move the declarations of operationMTs & operationMTsExact closer to this code?", "author": "DanHeidinga", "createdAt": "2020-02-05T16:45:01Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the", "originalCommit": "f5978d5d20bedb88ca150558722bbb4556f59909", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwOTQzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375409438", "bodyText": "yes.", "author": "babsingh", "createdAt": "2020-02-05T17:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MjUxMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375482512", "bodyText": "moved closer.", "author": "babsingh", "createdAt": "2020-02-05T20:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDg5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "chunk": "diff --git a/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\nindex b6437eec7..feb11d581 100644\n--- a/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\n+++ b/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\n\n@@ -369,14 +369,6 @@ public abstract class VarHandle extends VarHandleInternal\n \t\tAccessMode accessModes[] = AccessMode.values();\n \t\tint numAccessModes = accessModes.length;\n \n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tMethodType[] operationMTsExact = null;\n-\n-\t\tMethodType getter = null;\n-\t\tMethodType setter = null;\n-\t\t\n-\t\tClass<?> operationsClass = null;\n-\t\t\n \t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n \t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n \t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375380455", "bodyText": "Is any of this data already available on the VarForm?", "author": "DanHeidinga", "createdAt": "2020-02-05T16:54:22Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -287,7 +358,147 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tthis.handleTable = handleTable;\n \t\tthis.modifiers = modifiers;\n \t}\n-\t\n+\n+/*[IF Java14]*/\n+\t/**\n+\t * Constructs a generic VarHandle instance.\n+\t *\n+\t * @param varForm an instance of VarForm.\n+\t */\n+\tVarHandle(VarForm varForm) {\n+\t\tAccessMode accessModes[] = AccessMode.values();\n+\t\tint numAccessModes = accessModes.length;\n+\n+\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n+\t\tMethodType[] operationMTsExact = null;\n+\n+\t\tMethodType getter = null;\n+\t\tMethodType setter = null;\n+\t\t\n+\t\tClass<?> operationsClass = null;\n+\t\t\n+\t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n+\t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n+\t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n+\t\t\n+\t\t/* Specify the exact operation method types if the actual receiver doesn't match the\n+\t\t * receiver derived from VarForm.\n+\t\t */\n+\t\tif (receiverActual != receiverVarForm) {\n+\t\t\toperationMTsExact = new MethodType[numAccessModes];\n+\t\t}\n+\t\t\n+\t\tfor (int i = 0; i < numAccessModes; i++) {\n+\t\t\tMemberName memberName = varForm.memberName_table[i];\n+\t\t\tif (memberName != null) {\n+\t\t\t\tMethod method = memberName.method;\n+\t\t\t\tif (method != null) {\n+\t\t\t\t\toperationMTs[i] = MethodType.methodType(method.getReturnType(), method.getParameterTypes());", "originalCommit": "f5978d5d20bedb88ca150558722bbb4556f59909", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwODc0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375408744", "bodyText": "No, this data is not already available in VarForm. VarForm has a list of MemberNames (one for each access mode) and a list of MethodTypes (one for each access type). Also, we use a stub implementation for MemberName where we only cache the Method passed to the constructor.", "author": "babsingh", "createdAt": "2020-02-05T17:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MzA4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375653081", "bodyText": "In the future, when we fully implement MemberName we should probably look at this again to see if it's still necessary or can be done more efficiently", "author": "DanHeidinga", "createdAt": "2020-02-06T05:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3ODUzMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r375878531", "bodyText": "@fengxue-IS plans to use OpenJDK MemberName and VarHandle via #7680, which is part of #7352. Minimal effort was put from an optimization side since these changes will be removed in the future.", "author": "babsingh", "createdAt": "2020-02-06T14:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MDQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "chunk": "diff --git a/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\nindex b6437eec7..feb11d581 100644\n--- a/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\n+++ b/jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java\n\n@@ -369,14 +369,6 @@ public abstract class VarHandle extends VarHandleInternal\n \t\tAccessMode accessModes[] = AccessMode.values();\n \t\tint numAccessModes = accessModes.length;\n \n-\t\tMethodType[] operationMTs = new MethodType[numAccessModes];\n-\t\tMethodType[] operationMTsExact = null;\n-\n-\t\tMethodType getter = null;\n-\t\tMethodType setter = null;\n-\t\t\n-\t\tClass<?> operationsClass = null;\n-\t\t\n \t\t/* The first argument in AccessType.GET MethodType is the receiver class. */\n \t\tClass<?> receiverActual = accessModeTypeUncached(AccessMode.GET).parameterType(0);\n \t\tClass<?> receiverVarForm = varForm.methodType_table[AccessType.GET.ordinal()].parameterType(0);\n"}}, {"oid": "8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "url": "https://github.com/eclipse-openj9/openj9/commit/8084315b21ce2eec06c4ec8228a9bc5a806e97e2", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-05T20:08:22Z", "type": "forcePushed"}, {"oid": "75a8afbb05b6932055230d2592baf0f98c58c025", "url": "https://github.com/eclipse-openj9/openj9/commit/75a8afbb05b6932055230d2592baf0f98c58c025", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-05T20:13:00Z", "type": "forcePushed"}, {"oid": "c40670fdbac6e3753c33258f4c283554637d36d7", "url": "https://github.com/eclipse-openj9/openj9/commit/c40670fdbac6e3753c33258f4c283554637d36d7", "message": "Implement LambdaForm.BasicType.basicType(Class<?> cls)\n\nBasicType.basicType takes a class as input and outputs the corresponding\nBasicType enum value depending on the class's basic type char. The\nclass's basic type char is derived using the sun.invoke.util.Wrapper\nclass.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:08:45Z", "type": "commit"}, {"oid": "f9279dab3189d2d46d5333edaf0499cf13450691", "url": "https://github.com/eclipse-openj9/openj9/commit/f9279dab3189d2d46d5333edaf0499cf13450691", "message": "Implement the constructor MemberName(Method method)\n\nThe method passed in the constructor, MemberName(Method method), is\ncached in the MemberName instance.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:08:45Z", "type": "commit"}, {"oid": "8e93a03359c07bfe1f41caab2e8db5bce7de614c", "url": "https://github.com/eclipse-openj9/openj9/commit/8e93a03359c07bfe1f41caab2e8db5bce7de614c", "message": "Initialize AccessMode.methodNameToAccessMode (HashMap)\n\nAccessMode.methodNameToAccessMode is a HashMap<String, AccessMode>,\nwhere the key is the method name and the value is the AccessMode enum\nvalue. This hashmap is used in AccessMode.valueFromMethodName to\nretrieve the AccessMode enum value for the corresponding method name. It\nis also directly accessed from VarForm.linkFromStatic. It is needed so\nthat OpenJ9 can consume OpenJDK's VarForm class.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:08:45Z", "type": "commit"}, {"oid": "2635bb540f6db2b30c906bb71bc826d766785261", "url": "https://github.com/eclipse-openj9/openj9/commit/2635bb540f6db2b30c906bb71bc826d766785261", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:08:45Z", "type": "forcePushed"}, {"oid": "37039483a3723441371bc6b881b3112e7e9cd11c", "url": "https://github.com/eclipse-openj9/openj9/commit/37039483a3723441371bc6b881b3112e7e9cd11c", "message": "Implement constructor VarHandle(VarForm varForm)\n\nIn this constructor, fieldType, coordinateTypes, handleTable and\nmodifiers are initialized using the VarForm class. This should allow us\nto consume OpenJDK's VarHandles with OpenJ9's VarHandle class as the\nbase class. Currently, it will only be used for OpenJDK's MemoryAddress\nVarHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:14:59Z", "type": "commit"}, {"oid": "28cbd710153191df11896c3f6c044b607db2051a", "url": "https://github.com/eclipse-openj9/openj9/commit/28cbd710153191df11896c3f6c044b607db2051a", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:15:17Z", "type": "forcePushed"}, {"oid": "04b7a7a5d1e82f99fe7e5f29c3341b55a7289465", "url": "https://github.com/eclipse-openj9/openj9/commit/04b7a7a5d1e82f99fe7e5f29c3341b55a7289465", "message": "Handle conversion from OpenJDK to OpenJ9 VarHandle operation methods\n\nOpenJDK VarHandle operation methods have the following parameter\nsequence: {VarHandle, Receiver, Intermediate ..., Value}.\n\nDuring invocation, OpenJ9 uses the following parameter sequence for the\nVarHandle operations: {Receiver, Intermediate ..., Value, VarHandle}.\n\nThe location of the VarHandle argument is different in the above two\ncases. MethodHandles.permuteArguments is used to translate from the\nOpenJ9 to OpenJDK invocation.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>\nCo-Authored-By: Tobi Ajila <atobia@ca.ibm.com>", "committedDate": "2020-02-09T03:23:22Z", "type": "commit"}, {"oid": "7739caba8955f54d8cc10c46a35c266bda3ebc1c", "url": "https://github.com/eclipse-openj9/openj9/commit/7739caba8955f54d8cc10c46a35c266bda3ebc1c", "message": "Implement VarHandle.AccessType.accessModeType\n\nAccessType.accessModeType is implemented to retrieve the receiver class\nfrom the derived VarHandle class since VarForm does not provide the\nexact receiver class. In VarForm, the receiver class is always\njava.lang.Object.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:23:35Z", "type": "commit"}, {"oid": "a90fba7d80cb348faa73bd8ebbfd1bd58f586c42", "url": "https://github.com/eclipse-openj9/openj9/commit/a90fba7d80cb348faa73bd8ebbfd1bd58f586c42", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:23:35Z", "type": "forcePushed"}, {"oid": "cc6d0faffa2c775715f4f9fe9d5f61617fbd9ab6", "url": "https://github.com/eclipse-openj9/openj9/commit/cc6d0faffa2c775715f4f9fe9d5f61617fbd9ab6", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:27:03Z", "type": "forcePushed"}, {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "url": "https://github.com/eclipse-openj9/openj9/commit/604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:28:08Z", "type": "commit"}, {"oid": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "url": "https://github.com/eclipse-openj9/openj9/commit/604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "message": "Initialize VarHandle.handleTable with exact method types\n\nWhen the AccessMode methods have the receiver class defined generically\nor as java.lang.Object in the derived VarHandle classes, then the\nhandleTable needs to be initialized with the exact method types, which\nwill be used during invocation of the AccessMode methods. The exact\nmethod types need to specify the actual receiver class. This change\nyields correct behavior with respect to WrongMethodTypeException and\nClassCastException. Without this change, ClassCastException is thrown\nwhen WrongMethodTypeException is expected.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-02-09T03:28:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwMDM4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r378900381", "bodyText": "Is this used?", "author": "DanHeidinga", "createdAt": "2020-02-13T14:39:10Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java", "diffHunk": "@@ -269,13 +276,65 @@ public static AccessMode valueFromMethodName(String methodName) {\n \t\tCOMPARE_AND_EXCHANGE,\n \t\tGET_AND_UPDATE;\n \n-\t\tMethodType accessModeType(Class<?> param1, Class<?> param2, Class<?>... params) {\n-\t\t\tthrow OpenJDKCompileStub.OpenJDKCompileStubThrowError();\n+\t\t/**\n+\t\t * Gets the MethodType associated with the AccessType.\n+\t\t * \n+\t\t * This method gets invoked by the derived VarHandle classes through accessModeTypeUncached.\n+\t\t * \n+\t\t * OpenJ9 only uses it to retrieve the receiver class, which is not available from VarForm.\n+\t\t * \n+\t\t * @param receiver class of the derived VarHandle.\n+\t\t * @param type is the field type or value type.\n+\t\t * @param args is the list of intermediate argument classes in the derived VarHandle's\n+\t\t * AccessMode methods.\n+\t\t * @return the MethodType for the corresponding AccessType.\n+\t\t */\n+\t\tMethodType accessModeType(Class<?> receiver, Class<?> type, Class<?>... args) {\n+\t\t\tList<Class<?>> paramList = new ArrayList<>();\n+\t\t\tClass<?> returnType = null;\n+\t\t\tswitch (this) {\n+\t\t\tcase GET:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tbreak;\n+\t\t\tcase SET:\n+\t\t\t\treturnType = void.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_SET:\n+\t\t\t\treturnType = boolean.class;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase COMPARE_AND_EXCHANGE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tCollections.addAll(paramList, type, type);\n+\t\t\t\tbreak;\n+\t\t\tcase GET_AND_UPDATE:\n+\t\t\t\treturnType = type;\n+\t\t\t\tparamList.add(receiver);\n+\t\t\t\tCollections.addAll(paramList, args);\n+\t\t\t\tparamList.add(type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new InternalError(\"Invalid AccessType.\");\n+\t\t\t}\n+\t\t\treturn MethodType.methodType(returnType, paramList);\n \t\t}\n \t}\n \t\n \tstatic final Unsafe _unsafe = Unsafe.getUnsafe();\n \tstatic final Lookup _lookup = Lookup.internalPrivilegedLookup;\n+\n+/*[IF Java14]*/\n+\tstatic final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException> AIOOBE_SUPPLIER = null;", "originalCommit": "604dd591f5a2ae2d22dc0c1cbe46cf2065eee38e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDk4OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8414#discussion_r378914989", "bodyText": "OpenJDK VarHandle<Type> classes (X-VarHandle.java.template; generated Java code) utilizes AIOOBE_SUPPLIER. OpenJ9 doesn't use the generated Java code from X-VarHandle.java.template since it has its own implementation. So, AIOOBE_SUPPLIER is left uninitialized in OpenJ9's VarHandle class.", "author": "babsingh", "createdAt": "2020-02-13T15:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwMDM4MQ=="}], "type": "inlineReview", "revised_code": null}]}