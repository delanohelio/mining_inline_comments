{"pr_number": 884, "pr_title": "Optional dependencies OKAPI-509", "pr_createdAt": "2020-02-21T13:53:16Z", "pr_url": "https://github.com/folio-org/okapi/pull/884", "timeline": [{"oid": "4fa12681144e5d5379765349d64bf18f78a9592b", "url": "https://github.com/folio-org/okapi/commit/4fa12681144e5d5379765349d64bf18f78a9592b", "message": "Optional dependencies OKAPI-509", "committedDate": "2020-02-21T13:52:05Z", "type": "commit"}, {"oid": "2262c06c9d4c7af7ee982db6eb7cbd6753af0156", "url": "https://github.com/folio-org/okapi/commit/2262c06c9d4c7af7ee982db6eb7cbd6753af0156", "message": "Unused argument", "committedDate": "2020-02-21T14:34:41Z", "type": "commit"}, {"oid": "ac150d772e4fb7fe5489ddae3b22132d62b1455e", "url": "https://github.com/folio-org/okapi/commit/ac150d772e4fb7fe5489ddae3b22132d62b1455e", "message": "Pull in dependencies for optional interface if already existing", "committedDate": "2020-02-24T10:37:00Z", "type": "commit"}, {"oid": "2b7ebd500e511e30634468f207fe6d0ed0ffed03", "url": "https://github.com/folio-org/okapi/commit/2b7ebd500e511e30634468f207fe6d0ed0ffed03", "message": "Change some log info to log debug", "committedDate": "2020-02-24T10:41:53Z", "type": "commit"}, {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b", "url": "https://github.com/folio-org/okapi/commit/66737df6b10006b74fdfdd990af6f631f9e3e37b", "message": "One more test case", "committedDate": "2020-02-24T10:49:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjg5NA==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383212894", "bodyText": "There are two relevant cases that should also been tested:\nIf mdA100, mdA110, mdD100 and mdD110 are available, and mdA100 and mdD100 are enabled.\nFirst case: Enable mdA110 and check that both are upgraded.\nSecond case: Enable mdD110 and check that both are upgraded.", "author": "julianladisch", "createdAt": "2020-02-24T11:28:34Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with a matched interface provided\n+  @Test\n+  public void testInstallOptional2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that is too low (error)\n+  @Test\n+  public void testInstallOptionalFail(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.failed());\n+      context.assertEquals(\"enable moduleD-1.1.0 failed: interface int required by module moduleD-1.1.0 not found\", res.cause().getMessage());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(null, tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }", "originalCommit": "66737df6b10006b74fdfdd990af6f631f9e3e37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyODAyOA==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383228028", "bodyText": "First case: only mdA110 will be upgraded, because mdD100 can use the provided interface of mdA110.\nSecond case: both will be upgraded, because mdD110 will require mdA110.", "author": "adamdickmeiss", "createdAt": "2020-02-24T12:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjg5NA=="}], "type": "inlineReview", "revised_code": {"commit": "0bee14755543a6c2a25e61c555992eec01668835", "chunk": "diff --git a/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java b/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\nindex 5520a17f..63f71e77 100644\n--- a/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\n+++ b/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\n\n@@ -359,6 +359,73 @@ public class DepResolutionTest {\n     });\n   }\n \n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdA110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule3(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n   // install optional with existing interface that needs upgrading, but\n   // there are multiple modules providing same interface\n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383213851", "bodyText": "In all these tests there is no need to use Async.\nReplace \"res -> { context.assertTrue(res.succeeded());\" by \"context.asyncAssertSuccess(res ->\"\nand \"res -> { context.assertTrue(res.failed());\" by \"context.asyncAssertFailure(exception ->\"", "author": "julianladisch", "createdAt": "2020-02-24T11:31:07Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();", "originalCommit": "66737df6b10006b74fdfdd990af6f631f9e3e37b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMDY4Ng==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383220686", "bodyText": "oh yes.. Seen that before", "author": "adamdickmeiss", "createdAt": "2020-02-24T11:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyNTA2MA==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383225060", "bodyText": "Can't do like that, cause AsyncResult != ExtendedAsyncResult. I know one could use a utility or something, but least the async is systematically used.", "author": "adamdickmeiss", "createdAt": "2020-02-24T11:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI1MjMyMw==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383252323", "bodyText": "That's true and technical dept. https://issues.folio.org/browse/OKAPI-810 \"Replace ExtendedAsyncResult by AsyncResult where possible\"", "author": "julianladisch", "createdAt": "2020-02-24T13:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0bee14755543a6c2a25e61c555992eec01668835", "chunk": "diff --git a/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java b/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\nindex 5520a17f..63f71e77 100644\n--- a/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\n+++ b/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\n\n@@ -359,6 +359,73 @@ public class DepResolutionTest {\n     });\n   }\n \n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdA110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule3(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n   // install optional with existing interface that needs upgrading, but\n   // there are multiple modules providing same interface\n   @Test\n"}}, {"oid": "f961e1f75c81e2cc1bd41213b77e61a0932a796e", "url": "https://github.com/folio-org/okapi/commit/f961e1f75c81e2cc1bd41213b77e61a0932a796e", "message": "checkInterfaceDep funcs into one again", "committedDate": "2020-02-24T11:46:45Z", "type": "commit"}, {"oid": "e3754a05ede3cbc3e9f219fd313730a8b9fcfee9", "url": "https://github.com/folio-org/okapi/commit/e3754a05ede3cbc3e9f219fd313730a8b9fcfee9", "message": "Bummer", "committedDate": "2020-02-24T11:53:54Z", "type": "commit"}, {"oid": "0bee14755543a6c2a25e61c555992eec01668835", "url": "https://github.com/folio-org/okapi/commit/0bee14755543a6c2a25e61c555992eec01668835", "message": "Two more tests cases", "committedDate": "2020-02-24T12:06:50Z", "type": "commit"}, {"oid": "7f9196e01f079f92ea80d4f1995573cf244f2d2c", "url": "https://github.com/folio-org/okapi/commit/7f9196e01f079f92ea80d4f1995573cf244f2d2c", "message": "Comments", "committedDate": "2020-02-24T12:08:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2MDQ3NQ==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383260475", "bodyText": "Yes, no moduleD upgrade is needed because moduleA's new interface is compatible (int-1.0 -> int-1.1).\nCan you add another test where moduleA-1.0.0 is upgraded to moduleA-2.0.0 with int-2.0 and this triggers the moduleD upgrade from moduleD-1.0.0 to moduleD-2.0.0 because moduleD-2.0.0 has optional dependency on int-2.0?", "author": "julianladisch", "createdAt": "2020-02-24T13:21:39Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,247 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with a matched interface provided\n+  @Test\n+  public void testInstallOptional2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that is too low (error)\n+  @Test\n+  public void testInstallOptionalFail(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.failed());\n+      context.assertEquals(\"enable moduleD-1.1.0 failed: interface int required by module moduleD-1.1.0 not found\", res.cause().getMessage());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(null, tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // upgrade base dependency which is still compatible with optional interface\n+  @Test\n+  public void testInstallOptionalExistingModule2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdA110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());", "originalCommit": "7f9196e01f079f92ea80d4f1995573cf244f2d2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1OTcwMw==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383859703", "bodyText": "Good one. That was a reverse dependency not catched.. Now fixed.", "author": "adamdickmeiss", "createdAt": "2020-02-25T12:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2MDQ3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "757aec1531861244e26af07a53574f885da4818d", "chunk": "diff --git a/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java b/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\nindex 1139bd32..508a97c0 100644\n--- a/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\n+++ b/okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java\n\n@@ -235,7 +252,7 @@ public class DepResolutionTest {\n     });\n   }\n \n-  // install optional with no provided ingerface enabled\n+  // install optional with no provided interface enabled\n   @Test\n   public void testInstallOptional1(TestContext context) {\n     Async async = context.async();\n"}}, {"oid": "757aec1531861244e26af07a53574f885da4818d", "url": "https://github.com/folio-org/okapi/commit/757aec1531861244e26af07a53574f885da4818d", "message": "Upgrade for \"leaf\" dependency", "committedDate": "2020-02-25T11:41:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2OTk3Mg==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383869972", "bodyText": "ret is not used. Can you remove this variable?", "author": "julianladisch", "createdAt": "2020-02-25T13:14:50Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "diffHunk": "@@ -458,14 +487,57 @@ private static void addOrReplace(List<TenantModuleDescriptor> tml, ModuleDescrip\n     tml.add(t);\n   }\n \n+  private static void upgradeLeafs(ModuleDescriptor md, Map<String, ModuleDescriptor> modsAvailable,\n+    Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n+\n+    Iterator<ModuleDescriptor> it = modsEnabled.values().iterator();\n+    while (it.hasNext()) {\n+      ModuleDescriptor me = it.next();\n+      if (me.equals(md)) {\n+        continue;\n+      }\n+      ModuleDescriptor mTo = null;\n+      for (InterfaceDescriptor prov : md.getProvidesList()) {\n+        for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n+          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n+            for (ModuleDescriptor ma : modsAvailable.values()) {\n+              if (me.getProduct().equals(ma.getProduct())) {\n+                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+                  if (prov.isCompatible(re1)) {\n+                    if (mTo == null || ma.compareTo(mTo) > 0) {\n+                      mTo = ma;\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+      if (mTo != null) {\n+        List<String> ret = addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);", "originalCommit": "757aec1531861244e26af07a53574f885da4818d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NDEwMA==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383894100", "bodyText": "Done", "author": "adamdickmeiss", "createdAt": "2020-02-25T13:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2OTk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8283500616b44cdf000965c9719e64fbc16c1a33", "chunk": "diff --git a/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java b/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java\nindex 5bd655c6..3f2c73ad 100644\n--- a/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java\n+++ b/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java\n\n@@ -499,23 +499,23 @@ public class DepResolution {\n       ModuleDescriptor mTo = null;\n       for (InterfaceDescriptor prov : md.getProvidesList()) {\n         for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n-          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n-            for (ModuleDescriptor ma : modsAvailable.values()) {\n-              if (me.getProduct().equals(ma.getProduct())) {\n-                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n-                  if (prov.isCompatible(re1)) {\n-                    if (mTo == null || ma.compareTo(mTo) > 0) {\n-                      mTo = ma;\n-                    }\n-                  }\n-                }\n+          if (!prov.getId().equals(req.getId()) || prov.isCompatible(req)) {\n+            continue;\n+          }\n+          for (ModuleDescriptor ma : modsAvailable.values()) {\n+            if (!me.getProduct().equals(ma.getProduct())) {\n+              continue;\n+            }\n+            for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+              if (prov.isCompatible(re1) && (mTo == null || ma.compareTo(mTo) > 0)) {\n+                mTo = ma;\n               }\n             }\n           }\n         }\n       }\n       if (mTo != null) {\n-        List<String> ret = addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);\n+        addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);\n         it = modsEnabled.values().iterator();\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4MDg5Ng==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383880896", "bodyText": "This will reduce the cyclomatic complexity from 52 to 37 -- less nesting improves readability:\n  for (InterfaceDescriptor prov : md.getProvidesList()) {\n    for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n      if (! prov.getId().equals(req.getId()) || prov.isCompatible(req)) {\n        continue;\n      }\n      for (ModuleDescriptor ma : modsAvailable.values()) {\n        if (! me.getProduct().equals(ma.getProduct())) {\n          continue;\n        }\n        for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n          if (prov.isCompatible(re1) && (mTo == null || ma.compareTo(mTo) > 0)) {\n            mTo = ma;\n          }\n        }\n      }\n    }\n  }", "author": "julianladisch", "createdAt": "2020-02-25T13:35:33Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "diffHunk": "@@ -458,14 +487,57 @@ private static void addOrReplace(List<TenantModuleDescriptor> tml, ModuleDescrip\n     tml.add(t);\n   }\n \n+  private static void upgradeLeafs(ModuleDescriptor md, Map<String, ModuleDescriptor> modsAvailable,\n+    Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n+\n+    Iterator<ModuleDescriptor> it = modsEnabled.values().iterator();\n+    while (it.hasNext()) {\n+      ModuleDescriptor me = it.next();\n+      if (me.equals(md)) {\n+        continue;\n+      }\n+      ModuleDescriptor mTo = null;\n+      for (InterfaceDescriptor prov : md.getProvidesList()) {\n+        for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n+          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n+            for (ModuleDescriptor ma : modsAvailable.values()) {\n+              if (me.getProduct().equals(ma.getProduct())) {\n+                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+                  if (prov.isCompatible(re1)) {\n+                    if (mTo == null || ma.compareTo(mTo) > 0) {\n+                      mTo = ma;\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }", "originalCommit": "757aec1531861244e26af07a53574f885da4818d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NDAzMA==", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383894030", "bodyText": "Done", "author": "adamdickmeiss", "createdAt": "2020-02-25T13:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4MDg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8283500616b44cdf000965c9719e64fbc16c1a33", "chunk": "diff --git a/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java b/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java\nindex 5bd655c6..3f2c73ad 100644\n--- a/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java\n+++ b/okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java\n\n@@ -499,23 +499,23 @@ public class DepResolution {\n       ModuleDescriptor mTo = null;\n       for (InterfaceDescriptor prov : md.getProvidesList()) {\n         for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n-          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n-            for (ModuleDescriptor ma : modsAvailable.values()) {\n-              if (me.getProduct().equals(ma.getProduct())) {\n-                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n-                  if (prov.isCompatible(re1)) {\n-                    if (mTo == null || ma.compareTo(mTo) > 0) {\n-                      mTo = ma;\n-                    }\n-                  }\n-                }\n+          if (!prov.getId().equals(req.getId()) || prov.isCompatible(req)) {\n+            continue;\n+          }\n+          for (ModuleDescriptor ma : modsAvailable.values()) {\n+            if (!me.getProduct().equals(ma.getProduct())) {\n+              continue;\n+            }\n+            for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+              if (prov.isCompatible(re1) && (mTo == null || ma.compareTo(mTo) > 0)) {\n+                mTo = ma;\n               }\n             }\n           }\n         }\n       }\n       if (mTo != null) {\n-        List<String> ret = addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);\n+        addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);\n         it = modsEnabled.values().iterator();\n       }\n     }\n"}}, {"oid": "8283500616b44cdf000965c9719e64fbc16c1a33", "url": "https://github.com/folio-org/okapi/commit/8283500616b44cdf000965c9719e64fbc16c1a33", "message": "SQ fixes", "committedDate": "2020-02-25T13:57:59Z", "type": "commit"}, {"oid": "86a6b902babeaf6d267c7840092e39e0d654502d", "url": "https://github.com/folio-org/okapi/commit/86a6b902babeaf6d267c7840092e39e0d654502d", "message": "Split updateLeafs into two", "committedDate": "2020-02-25T14:28:06Z", "type": "commit"}, {"oid": "32d462c44980ec702a94c1c6d4dd90da7452b2f3", "url": "https://github.com/folio-org/okapi/commit/32d462c44980ec702a94c1c6d4dd90da7452b2f3", "message": "Merge branch 'master' into okapi-509-optional-dependencies", "committedDate": "2020-02-25T14:40:58Z", "type": "commit"}]}