{"pr_number": 750, "pr_title": "PHOENIX-5799 - Inline Index Verification Output API", "pr_createdAt": "2020-04-01T00:10:34Z", "pr_url": "https://github.com/apache/phoenix/pull/750", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MDg3MA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r401950870", "bodyText": "How these two repositories differ from each other? Could the names be more explicit?", "author": "swaroopak", "createdAt": "2020-04-01T22:38:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -154,6 +143,8 @@\n     private int  singleRowRebuildReturnCode;\n     private Map<byte[], NavigableSet<byte[]>> familyMap;\n     private byte[][] viewConstants;\n+    private IndexVerificationResultRepository verificationResultRepository;", "originalCommit": "08f957046b0bbcd019a870ee77bb75850bcafe4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODU2OQ==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r401978569", "bodyText": "Each repo controls insert/select operations for a particular table: the result table (PHOENIX_INDEX_TOOL_RESULT) that stores summary information about the run (counters, etc), and the output table (PHOENIX_INDEX_TOOL) that contains the row-level information about the failed rows.\nPlease let me know if you have suggestions on clearer names.\n(The word \"Repository\", btw, is the name of the design pattern being used -- https://martinfowler.com/eaaCatalog/repository.html , from Martin Fowler's Patterns of Enterprise Architecture and Eric Evans' Domain Driven Design)", "author": "gjacoby126", "createdAt": "2020-04-02T00:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MDg3MA=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 611461ac9..8b7e3f2b7 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -145,6 +143,7 @@ public class IndexRebuildRegionScanner extends BaseRegionScanner {\n     private byte[][] viewConstants;\n     private IndexVerificationResultRepository verificationResultRepository;\n     private IndexVerificationOutputRepository verificationOutputRepository;\n+    private long maxLookBackInMills;\n \n     @VisibleForTesting\n     public IndexRebuildRegionScanner(final RegionScanner innerScanner, final Region region, final Scan scan,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MzcwMA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402643700", "bodyText": "Should not this be called IndexVerificationResultRepositoryIT?", "author": "kadirozde", "createdAt": "2020-04-02T22:58:42Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end.index;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.end2end.ParallelStatsDisabledIT;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+import org.apache.phoenix.mapreduce.index.IndexVerificationResultRepository;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class IndexVerificationResultRepositoryTest extends ParallelStatsDisabledIT {", "originalCommit": "e0ada5b0b339d381874e422ad0588fece35cc764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1Njc1NA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402656754", "bodyText": "Fair point. It's sort of between a true unit test and an IT, because it needs a minicluster but is exercising a particular class rather than something broader. I'll change the names.", "author": "gjacoby126", "createdAt": "2020-04-02T23:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NDI2MA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402744260", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-04-03T05:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MzcwMA=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryTest.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryIT.java\nsimilarity index 90%\nrename from phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryTest.java\nrename to phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryIT.java\nindex b184a4d28..0ffd13aa0 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryTest.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryIT.java\n\n@@ -35,7 +35,7 @@ import java.util.Map;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n \n-public class IndexVerificationResultRepositoryTest extends ParallelStatsDisabledIT {\n+public class IndexVerificationResultRepositoryIT extends ParallelStatsDisabledIT {\n \n     @BeforeClass\n     public static void setupClass() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0NDc0NA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402644744", "bodyText": "Should not this be called IndexVerificationOutputRepositoryIT?", "author": "kadirozde", "createdAt": "2020-04-02T23:01:34Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end.index;\n+\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.end2end.ParallelStatsDisabledIT;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository;\n+import org.apache.phoenix.mapreduce.index.IndexVerificationOutputRow;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.PHASE_AFTER_VALUE;\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.PHASE_BEFORE_VALUE;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class IndexVerificationOutputRepositoryTest extends ParallelStatsDisabledIT {", "originalCommit": "e0ada5b0b339d381874e422ad0588fece35cc764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NDI5NA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402744294", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-04-03T05:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0NDc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryTest.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java\nsimilarity index 99%\nrename from phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryTest.java\nrename to phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java\nindex d037cb76d..0b670440c 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryTest.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java\n\n@@ -44,7 +44,7 @@ import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputReposito\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotNull;\n \n-public class IndexVerificationOutputRepositoryTest extends ParallelStatsDisabledIT {\n+public class IndexVerificationOutputRepositoryIT extends ParallelStatsDisabledIT {\n \n     @BeforeClass\n     public static void setupClass() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MjUwOA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402652508", "bodyText": "Is this class is used only for IT? If so, it should not be under src/main, should it?", "author": "kadirozde", "createdAt": "2020-04-02T23:25:16Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class IndexVerificationOutputRow {", "originalCommit": "e0ada5b0b339d381874e422ad0588fece35cc764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1NzI1Mg==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402657252", "bodyText": "The purpose of the patch is to expose the output row and repo classes so they can be used both for tests and also externally in tools that programmatically query and analyze the output table. So it needs to be in main.", "author": "gjacoby126", "createdAt": "2020-04-02T23:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MjUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5MzEzOA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402693138", "bodyText": "It makes sense. Thx", "author": "kadirozde", "createdAt": "2020-04-03T01:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MjUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java\nindex 1ecac0892..8c54796d4 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java\n\n@@ -23,6 +23,7 @@ import java.util.Arrays;\n import java.util.Objects;\n \n public class IndexVerificationOutputRow {\n+    public static final String SCAN_MAX_TIMESTAMP = \"ScanMaxTimestamp: \";\n     private String dataTableName;\n     private String indexTableName;\n     private Long scanMaxTimestamp;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MzM2OA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403383368", "bodyText": "Do we need this constructor? I see that read (non static)methods make use of outputHTable which would not work with an instance created through this.", "author": "abhishek-chouhan", "createdAt": "2020-04-03T23:31:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class IndexVerificationOutputRepository {\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    private Table indexHTable;\n+    private byte[] indexName;\n+    private Table outputHTable;\n+    public final static String OUTPUT_TABLE_NAME = \"PHOENIX_INDEX_TOOL\";\n+    public final static byte[] OUTPUT_TABLE_NAME_BYTES = Bytes.toBytes(OUTPUT_TABLE_NAME);\n+    public final static byte[] OUTPUT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+\n+    public final static String DATA_TABLE_NAME = \"DTName\";\n+    public final static byte[] DATA_TABLE_NAME_BYTES = Bytes.toBytes(DATA_TABLE_NAME);\n+    public static String INDEX_TABLE_NAME = \"ITName\";\n+    public final static byte[] INDEX_TABLE_NAME_BYTES = Bytes.toBytes(INDEX_TABLE_NAME);\n+    public static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n+    public final static byte[] DATA_TABLE_ROW_KEY_BYTES = Bytes.toBytes(DATA_TABLE_ROW_KEY);\n+    public static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n+    public final static byte[] INDEX_TABLE_ROW_KEY_BYTES = Bytes.toBytes(INDEX_TABLE_ROW_KEY);\n+    public static String DATA_TABLE_TS = \"DTTS\";\n+    public final static byte[] DATA_TABLE_TS_BYTES = Bytes.toBytes(DATA_TABLE_TS);\n+    public static String INDEX_TABLE_TS = \"ITTS\";\n+    public final static byte[] INDEX_TABLE_TS_BYTES = Bytes.toBytes(INDEX_TABLE_TS);\n+    public static String ERROR_MESSAGE = \"Error\";\n+    public final static byte[] ERROR_MESSAGE_BYTES = Bytes.toBytes(ERROR_MESSAGE);\n+\n+    public static String  VERIFICATION_PHASE = \"Phase\";\n+    public final static byte[] VERIFICATION_PHASE_BYTES = Bytes.toBytes(VERIFICATION_PHASE);\n+    public final static String EXPECTED_VALUE = \"ExpectedValue\";\n+    public final static byte[] EXPECTED_VALUE_BYTES = Bytes.toBytes(EXPECTED_VALUE);\n+    public final static String ACTUAL_VALUE = \"ActualValue\";\n+    public final static byte[] ACTUAL_VALUE_BYTES = Bytes.toBytes(ACTUAL_VALUE);\n+    public static final byte[] E_VALUE_PREFIX_BYTES = Bytes.toBytes(\" E:\");\n+    public static final byte[] A_VALUE_PREFIX_BYTES = Bytes.toBytes(\" A:\");\n+    public static final int PREFIX_LENGTH = 3;\n+    public static final int TOTAL_PREFIX_LENGTH = 6;\n+    public static final byte[] PHASE_BEFORE_VALUE = Bytes.toBytes(\"BEFORE\");\n+    public static final byte[] PHASE_AFTER_VALUE = Bytes.toBytes(\"AFTER\");\n+\n+    /**\n+     * Only usable for the read path or for testing\n+     */\n+    public IndexVerificationOutputRepository(){", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjYwNg==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404312606", "bodyText": "The constructor's needed for a case in IndexTool where we're just creating the tables but not reading or writing the tables. I've added setters so that a developer can use the default constructor and still write after using the setters. Is that sufficient?", "author": "gjacoby126", "createdAt": "2020-04-06T18:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MzM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java\nindex 043f443e7..bcc2e736b 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java\n\n@@ -43,28 +43,29 @@ import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n \n-public class IndexVerificationOutputRepository {\n+public class IndexVerificationOutputRepository implements AutoCloseable {\n     public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n-    private Table indexHTable;\n+\n+    private Table indexTable;\n     private byte[] indexName;\n-    private Table outputHTable;\n+    private Table outputTable;\n     public final static String OUTPUT_TABLE_NAME = \"PHOENIX_INDEX_TOOL\";\n     public final static byte[] OUTPUT_TABLE_NAME_BYTES = Bytes.toBytes(OUTPUT_TABLE_NAME);\n     public final static byte[] OUTPUT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n \n     public final static String DATA_TABLE_NAME = \"DTName\";\n     public final static byte[] DATA_TABLE_NAME_BYTES = Bytes.toBytes(DATA_TABLE_NAME);\n-    public static String INDEX_TABLE_NAME = \"ITName\";\n+    public final static String INDEX_TABLE_NAME = \"ITName\";\n     public final static byte[] INDEX_TABLE_NAME_BYTES = Bytes.toBytes(INDEX_TABLE_NAME);\n-    public static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n+    public final static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n     public final static byte[] DATA_TABLE_ROW_KEY_BYTES = Bytes.toBytes(DATA_TABLE_ROW_KEY);\n-    public static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n+    public final static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n     public final static byte[] INDEX_TABLE_ROW_KEY_BYTES = Bytes.toBytes(INDEX_TABLE_ROW_KEY);\n-    public static String DATA_TABLE_TS = \"DTTS\";\n+    public final static String DATA_TABLE_TS = \"DTTS\";\n     public final static byte[] DATA_TABLE_TS_BYTES = Bytes.toBytes(DATA_TABLE_TS);\n-    public static String INDEX_TABLE_TS = \"ITTS\";\n+    public final static String INDEX_TABLE_TS = \"ITTS\";\n     public final static byte[] INDEX_TABLE_TS_BYTES = Bytes.toBytes(INDEX_TABLE_TS);\n-    public static String ERROR_MESSAGE = \"Error\";\n+    public final static String ERROR_MESSAGE = \"Error\";\n     public final static byte[] ERROR_MESSAGE_BYTES = Bytes.toBytes(ERROR_MESSAGE);\n \n     public static String  VERIFICATION_PHASE = \"Phase\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NDcxMw==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403384713", "bodyText": "Should we close indexHTable too?", "author": "abhishek-chouhan", "createdAt": "2020-04-03T23:37:26Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class IndexVerificationOutputRepository {\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    private Table indexHTable;\n+    private byte[] indexName;\n+    private Table outputHTable;\n+    public final static String OUTPUT_TABLE_NAME = \"PHOENIX_INDEX_TOOL\";\n+    public final static byte[] OUTPUT_TABLE_NAME_BYTES = Bytes.toBytes(OUTPUT_TABLE_NAME);\n+    public final static byte[] OUTPUT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+\n+    public final static String DATA_TABLE_NAME = \"DTName\";\n+    public final static byte[] DATA_TABLE_NAME_BYTES = Bytes.toBytes(DATA_TABLE_NAME);\n+    public static String INDEX_TABLE_NAME = \"ITName\";\n+    public final static byte[] INDEX_TABLE_NAME_BYTES = Bytes.toBytes(INDEX_TABLE_NAME);\n+    public static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n+    public final static byte[] DATA_TABLE_ROW_KEY_BYTES = Bytes.toBytes(DATA_TABLE_ROW_KEY);\n+    public static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n+    public final static byte[] INDEX_TABLE_ROW_KEY_BYTES = Bytes.toBytes(INDEX_TABLE_ROW_KEY);\n+    public static String DATA_TABLE_TS = \"DTTS\";\n+    public final static byte[] DATA_TABLE_TS_BYTES = Bytes.toBytes(DATA_TABLE_TS);\n+    public static String INDEX_TABLE_TS = \"ITTS\";\n+    public final static byte[] INDEX_TABLE_TS_BYTES = Bytes.toBytes(INDEX_TABLE_TS);\n+    public static String ERROR_MESSAGE = \"Error\";\n+    public final static byte[] ERROR_MESSAGE_BYTES = Bytes.toBytes(ERROR_MESSAGE);\n+\n+    public static String  VERIFICATION_PHASE = \"Phase\";\n+    public final static byte[] VERIFICATION_PHASE_BYTES = Bytes.toBytes(VERIFICATION_PHASE);\n+    public final static String EXPECTED_VALUE = \"ExpectedValue\";\n+    public final static byte[] EXPECTED_VALUE_BYTES = Bytes.toBytes(EXPECTED_VALUE);\n+    public final static String ACTUAL_VALUE = \"ActualValue\";\n+    public final static byte[] ACTUAL_VALUE_BYTES = Bytes.toBytes(ACTUAL_VALUE);\n+    public static final byte[] E_VALUE_PREFIX_BYTES = Bytes.toBytes(\" E:\");\n+    public static final byte[] A_VALUE_PREFIX_BYTES = Bytes.toBytes(\" A:\");\n+    public static final int PREFIX_LENGTH = 3;\n+    public static final int TOTAL_PREFIX_LENGTH = 6;\n+    public static final byte[] PHASE_BEFORE_VALUE = Bytes.toBytes(\"BEFORE\");\n+    public static final byte[] PHASE_AFTER_VALUE = Bytes.toBytes(\"AFTER\");\n+\n+    /**\n+     * Only usable for the read path or for testing\n+     */\n+    public IndexVerificationOutputRepository(){\n+\n+    }\n+\n+    @VisibleForTesting\n+    public IndexVerificationOutputRepository(byte[] indexName, Connection conn) throws SQLException {\n+        ConnectionQueryServices queryServices =\n+            conn.unwrap(PhoenixConnection.class).getQueryServices();\n+        outputHTable = queryServices.getTable(OUTPUT_TABLE_NAME_BYTES);\n+        indexHTable = queryServices.getTable(indexName);\n+    }\n+\n+    public IndexVerificationOutputRepository(byte[] indexName, HTableFactory hTableFactory) throws IOException {\n+        this.indexName = indexName;\n+        outputHTable = hTableFactory.getTable(new ImmutableBytesPtr(OUTPUT_TABLE_NAME_BYTES));\n+        indexHTable = hTableFactory.getTable(new ImmutableBytesPtr(indexName));\n+    }\n+\n+    public static byte[] generateOutputTableRowKey(long ts, byte[] indexTableName, byte[] dataRowKey ) {\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        byte[] rowKey;\n+        int targetOffset = 0;\n+        // The row key for the output table : timestamp | index table name | data row key\n+        rowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length +\n+            ROW_KEY_SEPARATOR_BYTE.length + dataRowKey.length];\n+        Bytes.putBytes(rowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        targetOffset += indexTableName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, dataRowKey, 0, dataRowKey.length);\n+        return rowKey;\n+    }\n+\n+    /**\n+     * Generates partial row key for use in a Scan to get all rows for an index verification\n+     */\n+    private static byte[] generatePartialOutputTableRowKey(long ts, byte[] indexTableName){\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        byte[] partialRowKey;\n+        int targetOffset = 0;\n+        // The row key for the output table : timestamp | index table name | data row key\n+        partialRowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length];\n+        Bytes.putBytes(partialRowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(partialRowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(partialRowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        return partialRowKey;\n+    }\n+\n+    public void createOutputTable(Connection connection) throws IOException, SQLException {\n+        ConnectionQueryServices queryServices = connection.unwrap(PhoenixConnection.class).getQueryServices();\n+        Admin admin = queryServices.getAdmin();\n+        if (!admin.tableExists(TableName.valueOf(OUTPUT_TABLE_NAME))) {\n+            HTableDescriptor tableDescriptor = new\n+                HTableDescriptor(TableName.valueOf(OUTPUT_TABLE_NAME));\n+            tableDescriptor.setValue(HColumnDescriptor.TTL,\n+                String.valueOf(MetaDataProtocol.DEFAULT_LOG_TTL));\n+            HColumnDescriptor columnDescriptor = new HColumnDescriptor(OUTPUT_TABLE_COLUMN_FAMILY);\n+            tableDescriptor.addFamily(columnDescriptor);\n+            admin.createTable(tableDescriptor);\n+        }\n+    }\n+        \n+    @VisibleForTesting\n+    public void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs,\n+                                          long indexRowTs,\n+                                          String errorMsg, byte[] expectedValue, byte[] actualValue,\n+                                          long scanMaxTs, byte[] tableName, boolean isBeforeRebuild)\n+        throws IOException {\n+        byte[] rowKey = generateOutputTableRowKey(scanMaxTs, indexHTable.getName().toBytes(), dataRowKey);\n+        Put put = new Put(rowKey);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, DATA_TABLE_NAME_BYTES,\n+            scanMaxTs, tableName);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, INDEX_TABLE_NAME_BYTES,\n+            scanMaxTs, indexName);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, DATA_TABLE_TS_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(dataRowTs)));\n+\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, INDEX_TABLE_ROW_KEY_BYTES,\n+            scanMaxTs, indexRowKey);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, INDEX_TABLE_TS_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(indexRowTs)));\n+        byte[] errorMessageBytes;\n+        if (expectedValue != null) {\n+            errorMessageBytes = getErrorMessageBytes(errorMsg, expectedValue, actualValue);\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, EXPECTED_VALUE_BYTES, expectedValue);\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, ACTUAL_VALUE_BYTES, actualValue);\n+        } else {\n+            errorMessageBytes = Bytes.toBytes(errorMsg);\n+        }\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, ERROR_MESSAGE_BYTES, scanMaxTs, errorMessageBytes);\n+        if (isBeforeRebuild) {\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, VERIFICATION_PHASE_BYTES, scanMaxTs, PHASE_BEFORE_VALUE);\n+        } else {\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, VERIFICATION_PHASE_BYTES, scanMaxTs, PHASE_AFTER_VALUE);\n+        }\n+        outputHTable.put(put);\n+    }\n+\n+    public static byte[] getErrorMessageBytes(String errorMsg, byte[] expectedValue, byte[] actualValue) {\n+        byte[] errorMessageBytes;\n+        errorMessageBytes = new byte[errorMsg.length() + expectedValue.length + actualValue.length +\n+            TOTAL_PREFIX_LENGTH];\n+        Bytes.putBytes(errorMessageBytes, 0, Bytes.toBytes(errorMsg), 0, errorMsg.length());\n+        int length = errorMsg.length();\n+        Bytes.putBytes(errorMessageBytes, length, E_VALUE_PREFIX_BYTES, 0, PREFIX_LENGTH);\n+        length += PREFIX_LENGTH;\n+        Bytes.putBytes(errorMessageBytes, length, expectedValue, 0, expectedValue.length);\n+        length += expectedValue.length;\n+        Bytes.putBytes(errorMessageBytes, length, A_VALUE_PREFIX_BYTES, 0, PREFIX_LENGTH);\n+        length += PREFIX_LENGTH;\n+        Bytes.putBytes(errorMessageBytes, length, actualValue, 0, actualValue.length);\n+        return errorMessageBytes;\n+    }\n+\n+    public List<IndexVerificationOutputRow> getOutputRows(long ts, byte[] indexName)\n+        throws IOException {\n+        Iterator<IndexVerificationOutputRow> iter = getOutputRowIterator(ts, indexName);\n+        List<IndexVerificationOutputRow> outputRowList = new ArrayList<IndexVerificationOutputRow>();\n+        while (iter.hasNext()){\n+            outputRowList.add(iter.next());\n+        }\n+        return outputRowList;\n+    }\n+\n+    public Iterator<IndexVerificationOutputRow> getOutputRowIterator(long ts, byte[] indexName)\n+        throws IOException {\n+        Scan scan = new Scan();\n+        byte[] partialKey = generatePartialOutputTableRowKey(ts, indexName);\n+        scan.withStartRow(partialKey);\n+        scan.withStopRow(ByteUtil.calculateTheClosestNextRowKeyForPrefix(partialKey));\n+        ResultScanner scanner = outputHTable.getScanner(scan);\n+        return new IndexVerificationOutputRowIterator(scanner.iterator());\n+    }\n+\n+    public static IndexVerificationOutputRow getOutputRowFromResult(Result result) {\n+        IndexVerificationOutputRow.IndexVerificationOutputRowBuilder builder =\n+            new IndexVerificationOutputRow.IndexVerificationOutputRowBuilder();\n+        byte[] rowKey = result.getRow();\n+        //rowkey is scanTs + SEPARATOR_BYTE + indexTableName + SEPARATOR_BYTE + dataTableRowKey\n+        byte[][] rowKeySplit = ByteUtil.splitArrayBySeparator(rowKey, ROW_KEY_SEPARATOR_BYTE[0]);\n+        builder.setScanMaxTimestamp(Long.parseLong(Bytes.toString(rowKeySplit[0])));\n+        builder.setIndexTableName(Bytes.toString(rowKeySplit[1]));\n+        builder.setDataTableRowKey(rowKeySplit[2]);\n+\n+        builder.setDataTableName(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            DATA_TABLE_NAME_BYTES)));\n+        builder.setIndexTableRowKey(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            INDEX_TABLE_ROW_KEY_BYTES));\n+        builder.setDataTableRowTimestamp(Long.parseLong(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            DATA_TABLE_TS_BYTES))));\n+        builder.setIndexTableRowTimestamp(Long.parseLong(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            INDEX_TABLE_TS_BYTES))));\n+        builder.setErrorMessage(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            ERROR_MESSAGE_BYTES)));\n+        //actual and expected value might not be present, but will just set to null if not\n+        builder.setExpectedValue(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY, EXPECTED_VALUE_BYTES));\n+        builder.setActualValue(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY, ACTUAL_VALUE_BYTES));\n+        builder.setPhaseValue(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY, VERIFICATION_PHASE_BYTES));\n+        return builder.build();\n+    }\n+\n+    public void close() throws IOException {\n+        if (outputHTable != null) {\n+            outputHTable.close();\n+        }", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDU4Mg==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404310582", "bodyText": "Good catch, thanks. Done.", "author": "gjacoby126", "createdAt": "2020-04-06T18:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NDcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java\nindex 043f443e7..bcc2e736b 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java\n\n@@ -43,28 +43,29 @@ import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n \n-public class IndexVerificationOutputRepository {\n+public class IndexVerificationOutputRepository implements AutoCloseable {\n     public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n-    private Table indexHTable;\n+\n+    private Table indexTable;\n     private byte[] indexName;\n-    private Table outputHTable;\n+    private Table outputTable;\n     public final static String OUTPUT_TABLE_NAME = \"PHOENIX_INDEX_TOOL\";\n     public final static byte[] OUTPUT_TABLE_NAME_BYTES = Bytes.toBytes(OUTPUT_TABLE_NAME);\n     public final static byte[] OUTPUT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n \n     public final static String DATA_TABLE_NAME = \"DTName\";\n     public final static byte[] DATA_TABLE_NAME_BYTES = Bytes.toBytes(DATA_TABLE_NAME);\n-    public static String INDEX_TABLE_NAME = \"ITName\";\n+    public final static String INDEX_TABLE_NAME = \"ITName\";\n     public final static byte[] INDEX_TABLE_NAME_BYTES = Bytes.toBytes(INDEX_TABLE_NAME);\n-    public static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n+    public final static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n     public final static byte[] DATA_TABLE_ROW_KEY_BYTES = Bytes.toBytes(DATA_TABLE_ROW_KEY);\n-    public static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n+    public final static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n     public final static byte[] INDEX_TABLE_ROW_KEY_BYTES = Bytes.toBytes(INDEX_TABLE_ROW_KEY);\n-    public static String DATA_TABLE_TS = \"DTTS\";\n+    public final static String DATA_TABLE_TS = \"DTTS\";\n     public final static byte[] DATA_TABLE_TS_BYTES = Bytes.toBytes(DATA_TABLE_TS);\n-    public static String INDEX_TABLE_TS = \"ITTS\";\n+    public final static String INDEX_TABLE_TS = \"ITTS\";\n     public final static byte[] INDEX_TABLE_TS_BYTES = Bytes.toBytes(INDEX_TABLE_TS);\n-    public static String ERROR_MESSAGE = \"Error\";\n+    public final static String ERROR_MESSAGE = \"Error\";\n     public final static byte[] ERROR_MESSAGE_BYTES = Bytes.toBytes(ERROR_MESSAGE);\n \n     public static String  VERIFICATION_PHASE = \"Phase\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NzAwNw==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403387007", "bodyText": "Check for indexHtable and close here too?", "author": "abhishek-chouhan", "createdAt": "2020-04-03T23:48:06Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class IndexVerificationResultRepository {\n+    private Table resultHTable;\n+    private Table indexHTable;\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    public final static String RESULT_TABLE_NAME = \"PHOENIX_INDEX_TOOL_RESULT\";\n+    public final static byte[] RESULT_TABLE_NAME_BYTES = Bytes.toBytes(RESULT_TABLE_NAME);\n+    public final static byte[] RESULT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+    public static String SCANNED_DATA_ROW_COUNT = \"ScannedDataRowCount\";\n+    public final static byte[] SCANNED_DATA_ROW_COUNT_BYTES = Bytes.toBytes(SCANNED_DATA_ROW_COUNT);\n+    public static String REBUILT_INDEX_ROW_COUNT = \"RebuiltIndexRowCount\";\n+    public final static byte[] REBUILT_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(REBUILT_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_VALID_INDEX_ROW_COUNT = \"BeforeRebuildValidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"BeforeRebuildExpiredIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT = \"BeforeRebuildMissingIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT = \"BeforeRebuildInvalidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_VALID_INDEX_ROW_COUNT = \"AfterValidExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"AfterRebuildExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_MISSING_INDEX_ROW_COUNT = \"AfterRebuildMissingIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT = \"AfterRebuildInvalidIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    /***\n+     * Only usable for read methods\n+     */\n+    public IndexVerificationResultRepository(){\n+\n+    }\n+\n+    public IndexVerificationResultRepository(Connection conn, byte[] indexNameBytes) throws SQLException {\n+        resultHTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        indexHTable = getTable(conn, indexNameBytes);\n+    }\n+\n+    public IndexVerificationResultRepository(byte[] indexName,\n+                                             HTableFactory hTableFactory) throws IOException {\n+        resultHTable = hTableFactory.getTable(new ImmutableBytesPtr(RESULT_TABLE_NAME_BYTES));\n+        indexHTable = hTableFactory.getTable(new ImmutableBytesPtr(indexName));\n+    }\n+\n+    public void createResultTable(Connection connection) throws IOException, SQLException {\n+        ConnectionQueryServices queryServices = connection.unwrap(PhoenixConnection.class).getQueryServices();\n+        Admin admin = queryServices.getAdmin();\n+\n+        if (!admin.tableExists(TableName.valueOf(RESULT_TABLE_NAME))) {\n+            HTableDescriptor tableDescriptor = new\n+                HTableDescriptor(TableName.valueOf(RESULT_TABLE_NAME));\n+            tableDescriptor.setValue(HColumnDescriptor.TTL, String.valueOf(MetaDataProtocol.DEFAULT_LOG_TTL));\n+            HColumnDescriptor columnDescriptor = new HColumnDescriptor(RESULT_TABLE_COLUMN_FAMILY);\n+            tableDescriptor.addFamily(columnDescriptor);\n+            admin.createTable(tableDescriptor);\n+        }\n+    }\n+    public static byte[] generateResultTableRowKey(long ts, byte[] indexTableName,  byte [] regionName,\n+                                                    byte[] startRow, byte[] stopRow) {\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        int targetOffset = 0;\n+        // The row key for the result table : timestamp | index table name | datable table region name |\n+        //                                    scan start row | scan stop row\n+        byte[] rowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length +\n+            ROW_KEY_SEPARATOR_BYTE.length + regionName.length + ROW_KEY_SEPARATOR_BYTE.length +\n+            startRow.length + ROW_KEY_SEPARATOR_BYTE.length + stopRow.length];\n+        Bytes.putBytes(rowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        targetOffset += indexTableName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, regionName, 0, regionName.length);\n+        targetOffset += regionName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, startRow, 0, startRow.length);\n+        targetOffset += startRow.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, stopRow, 0, stopRow.length);\n+        return rowKey;\n+    }\n+\n+    public void logToIndexToolResultTable(IndexToolVerificationResult verificationResult,\n+                                          IndexTool.IndexVerifyType verifyType, byte[] region) throws IOException {\n+        long scanMaxTs = verificationResult.getScanMaxTs();\n+        byte[] rowKey = generateResultTableRowKey(scanMaxTs, indexHTable.getName().toBytes(),\n+            region, verificationResult.getStartRow(),\n+            verificationResult.getStopRow());\n+        Put put = new Put(rowKey);\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, SCANNED_DATA_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getScannedDataRowCount())));\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, REBUILT_INDEX_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getRebuiltIndexRowCount())));\n+        if (verifyType == IndexTool.IndexVerifyType.BEFORE || verifyType == IndexTool.IndexVerifyType.BOTH ||\n+            verifyType == IndexTool.IndexVerifyType.ONLY) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildInvalidIndexRowCount())));\n+        }\n+        if (verifyType == IndexTool.IndexVerifyType.AFTER || verifyType == IndexTool.IndexVerifyType.BOTH) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildInvalidIndexRowCount())));\n+        }\n+        resultHTable.put(put);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Connection conn, long ts) throws IOException, SQLException {\n+        Table hTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        return getVerificationResult(hTable, ts);\n+    }\n+\n+    public Table getTable(Connection conn, byte[] tableName) throws SQLException {\n+        return conn.unwrap(PhoenixConnection.class).getQueryServices()\n+                .getTable(tableName);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Table htable, long ts)\n+        throws IOException {\n+        byte[] startRowKey = Bytes.toBytes(Long.toString(ts));\n+        byte[] stopRowKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(startRowKey);\n+        IndexToolVerificationResult verificationResult = new IndexToolVerificationResult(ts);\n+        Scan scan = new Scan();\n+        scan.withStartRow(startRowKey);\n+        scan.withStopRow(stopRowKey);\n+        ResultScanner scanner = htable.getScanner(scan);\n+        for (Result result = scanner.next(); result != null; result = scanner.next()) {\n+            boolean isFirst = true;\n+            for (Cell cell : result.rawCells()) {\n+                if (isFirst){\n+                    byte[][] rowKeyParts = ByteUtil.splitArrayBySeparator(result.getRow(),\n+                        ROW_KEY_SEPARATOR_BYTE[0]);\n+                    verificationResult.setStartRow(rowKeyParts[3]);\n+                    verificationResult.setStopRow(rowKeyParts[4]);\n+                    isFirst = false;\n+                }\n+                verificationResult.update(cell);\n+            }\n+        }\n+        return verificationResult;\n+    }\n+\n+    public void close() throws IOException {\n+        if (resultHTable != null) {", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDY3MA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404310670", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-04-06T18:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NzAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java\nindex 7e18802b5..ca8b12922 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java\n\n@@ -19,7 +19,6 @@ package org.apache.phoenix.mapreduce.index;\n \n import org.apache.hadoop.hbase.Cell;\n import org.apache.hadoop.hbase.HColumnDescriptor;\n-import org.apache.hadoop.hbase.HConstants;\n import org.apache.hadoop.hbase.HTableDescriptor;\n import org.apache.hadoop.hbase.TableName;\n import org.apache.hadoop.hbase.client.Admin;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNDczMA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403404730", "bodyText": "Why not reuse the same strings from table values? like DTName, ITName. Would be easier to track and reuse.", "author": "swaroopak", "createdAt": "2020-04-04T01:25:40Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class IndexVerificationOutputRow {\n+    private String dataTableName;\n+    private String indexTableName;\n+    private Long scanMaxTimestamp;\n+    private byte[] dataTableRowKey;\n+    private byte[] indexTableRowKey;\n+    private Long dataTableRowTimestamp;\n+    private Long indexTableRowTimestamp;\n+    private String errorMessage;\n+    private byte[] expectedValue;\n+    private byte[] actualValue;\n+    private byte[] phaseValue;\n+\n+    private IndexVerificationOutputRow(String dataTableName, String indexTableName,\n+                                       byte[] dataTableRowKey, Long scanMaxTimestamp,\n+                                      byte[] indexTableRowKey,\n+                                       long dataTableRowTimestamp, long indexTableRowTimestamp,\n+                                      String errorMessage, byte[] expectedValue, byte[] actualValue,\n+                                      byte[] phaseValue) {\n+        this.dataTableName = dataTableName;\n+        this.indexTableName = indexTableName;\n+        this.scanMaxTimestamp = scanMaxTimestamp;\n+        this.dataTableRowKey = dataTableRowKey;\n+        this.indexTableRowKey = indexTableRowKey;\n+        this.dataTableRowTimestamp = dataTableRowTimestamp;\n+        this.indexTableRowTimestamp = indexTableRowTimestamp;\n+        this.errorMessage = errorMessage;\n+        this.expectedValue = expectedValue;\n+        this.actualValue = actualValue;\n+        this.phaseValue = phaseValue;\n+    }\n+\n+    public String getDataTableName() {\n+        return dataTableName;\n+    }\n+\n+    public String getIndexTableName() {\n+        return indexTableName;\n+    }\n+\n+    public Long getScanMaxTimestamp() {\n+        return scanMaxTimestamp;\n+    }\n+\n+    public byte[] getIndexTableRowKey() {\n+        return indexTableRowKey;\n+    }\n+\n+    public long getIndexTableRowTimestamp() {\n+        return indexTableRowTimestamp;\n+    }\n+\n+    public String getErrorMessage() {\n+        return errorMessage;\n+    }\n+\n+    public byte[] getExpectedValue() {\n+        return expectedValue;\n+    }\n+\n+    public byte[] getActualValue() {\n+        return actualValue;\n+    }\n+\n+    public byte[] getPhaseValue() {\n+        return phaseValue;\n+    }\n+\n+    public byte[] getDataTableRowKey() {\n+        return dataTableRowKey;\n+    }\n+\n+    public Long getDataTableRowTimestamp() {\n+        return dataTableRowTimestamp;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == null ) {\n+            return false;\n+        }\n+        if (!(o instanceof  IndexVerificationOutputRow)) {\n+            return false;\n+        }\n+        IndexVerificationOutputRow otherRow = (IndexVerificationOutputRow) o;\n+\n+        return Objects.equals(dataTableName, otherRow.getDataTableName()) &&\n+            Objects.equals(indexTableName, otherRow.getIndexTableName()) &&\n+            Objects.equals(scanMaxTimestamp, otherRow.getScanMaxTimestamp()) &&\n+            Arrays.equals(dataTableRowKey, otherRow.getDataTableRowKey()) &&\n+            Arrays.equals(indexTableRowKey, otherRow.getIndexTableRowKey()) &&\n+            Objects.equals(dataTableRowTimestamp, otherRow.getDataTableRowTimestamp()) &&\n+            Objects.equals(indexTableRowTimestamp, otherRow.getIndexTableRowTimestamp()) &&\n+            Objects.equals(errorMessage, otherRow.getErrorMessage()) &&\n+            Arrays.equals(expectedValue, otherRow.getExpectedValue()) &&\n+            Arrays.equals(actualValue, otherRow.getActualValue()) &&\n+            Arrays.equals(phaseValue, otherRow.getPhaseValue());\n+    }\n+\n+    @Override\n+    public int hashCode(){\n+        return Objects.hashCode(scanMaxTimestamp) ^ Objects.hashCode(indexTableName) ^\n+            Arrays.hashCode(dataTableRowKey);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"DataTableName: \").append(dataTableName).append(\",\");", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDgwOQ==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404310809", "bodyText": "Good idea. Done.", "author": "gjacoby126", "createdAt": "2020-04-06T18:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNDczMA=="}], "type": "inlineReview", "revised_code": {"commit": "df24ffd03a3934efb86102b250285adcd5bf060f", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java\nindex 1ecac0892..8c54796d4 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java\n\n@@ -23,6 +23,7 @@ import java.util.Arrays;\n import java.util.Objects;\n \n public class IndexVerificationOutputRow {\n+    public static final String SCAN_MAX_TIMESTAMP = \"ScanMaxTimestamp: \";\n     private String dataTableName;\n     private String indexTableName;\n     private Long scanMaxTimestamp;\n"}}, {"oid": "df24ffd03a3934efb86102b250285adcd5bf060f", "url": "https://github.com/apache/phoenix/commit/df24ffd03a3934efb86102b250285adcd5bf060f", "message": "PHOENIX-5799 - Inline Index Verification Output API", "committedDate": "2020-04-07T22:24:53Z", "type": "commit"}, {"oid": "df24ffd03a3934efb86102b250285adcd5bf060f", "url": "https://github.com/apache/phoenix/commit/df24ffd03a3934efb86102b250285adcd5bf060f", "message": "PHOENIX-5799 - Inline Index Verification Output API", "committedDate": "2020-04-07T22:24:53Z", "type": "forcePushed"}]}