{"pr_number": 960, "pr_title": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "pr_createdAt": "2020-11-10T16:31:03Z", "pr_url": "https://github.com/apache/phoenix/pull/960", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NjI3Ng==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r520956276", "bodyText": "nit: Change to \"SYSTEM.TASK\" table", "author": "ChinmaySKulkarni", "createdAt": "2020-11-11T00:15:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java", "diffHunk": "@@ -431,6 +431,8 @@ public SQLException newException(SQLExceptionInfo info) {\n             PTable.LinkType.CHILD_TABLE + \") for view\"),\n     TABLE_NOT_IN_REGION(1145, \"XCL45\", \"No modifications allowed on this table. \"\n     + \"Table not in this region.\"),\n+    UNABLE_TO_UPSERT_TASK(1146, \"XCL46\",\n+        \"Error upserting records in Task system table\"),", "originalCommit": "81aab47ba9c16de77992f955ec08a52b9de898a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29b7780a2357f00c3d1a65f078026a709f574d5e", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java b/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java\nindex 7d7d51d30..1880d40d7 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/exception/SQLExceptionCode.java\n\n@@ -432,7 +432,7 @@ public enum SQLExceptionCode {\n     TABLE_NOT_IN_REGION(1145, \"XCL45\", \"No modifications allowed on this table. \"\n     + \"Table not in this region.\"),\n     UNABLE_TO_UPSERT_TASK(1146, \"XCL46\",\n-        \"Error upserting records in Task system table\"),\n+        \"Error upserting records in SYSTEM.TASK table\"),\n     /**\n      * Implementation defined class. Phoenix internal error. (errorcode 20, sqlstate INT).\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NzUxMQ==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r520957511", "bodyText": "If SYSTEM.TASK already exists on a cluster and you upgrade to 4.16 server bits and connect with a 4.16 client, will we still install this new coproc or does that need extra steps in the upgrade path?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-11T00:19:42Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java", "diffHunk": "@@ -1094,6 +1095,11 @@ private void addCoprocessors(byte[] tableName, TableDescriptorBuilder builder,\n                 if(!newDesc.hasCoprocessor(TaskRegionObserver.class.getName())) {\n                     builder.addCoprocessor(TaskRegionObserver.class.getName(), null, priority, null);\n                 }\n+                if (!newDesc.hasCoprocessor(", "originalCommit": "81aab47ba9c16de77992f955ec08a52b9de898a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMyOTY1MQ==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r521329651", "bodyText": "Yes, we would need to take care of upgrade path. Updated PR with changes in upgradeSystemTask() function by handling addition of this new coprocessor, test is available in BackwardCompatibilityIT for existence of new coprocessor in updated table descriptor.\nThanks for the suggestion @ChinmaySKulkarni", "author": "virajjasani", "createdAt": "2020-11-11T12:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NzUxMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1ODg2NA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r520958864", "bodyText": "If other mutations were made using the same connection, we will be returning the joined state of all of them here right? Don't we want to restrict to just returning mutations corresponding to the upsert into the SYSTEM.TASK table?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-11T00:23:49Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java", "diffHunk": "@@ -75,6 +85,38 @@ public Void run() throws Exception {\n         }\n     }\n \n+    private static List<Mutation> getMutationsForSystemTaskTable(\n+            PhoenixConnection conn, PreparedStatement stmt,\n+            boolean accessCheckEnabled) throws IOException {\n+        // we need to mutate SYSTEM.TASK with HBase/login user if access is enabled.\n+        if (accessCheckEnabled) {\n+            return User.runAsLoginUser(() -> {\n+                final RpcCall rpcContext = RpcUtil.getRpcContext();\n+                // setting RPC context as null so that user can be reset\n+                try {\n+                    RpcUtil.setRpcContext(null);\n+                    stmt.execute();\n+                    // retrieve mutations for SYSTEM.TASK upsert query\n+                    return conn.getMutationState().toMutations().next()", "originalCommit": "81aab47ba9c16de77992f955ec08a52b9de898a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29b7780a2357f00c3d1a65f078026a709f574d5e", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\nindex 14a77b7f3..160c4e045 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n\n@@ -97,8 +99,16 @@ public class Task {\n                     RpcUtil.setRpcContext(null);\n                     stmt.execute();\n                     // retrieve mutations for SYSTEM.TASK upsert query\n-                    return conn.getMutationState().toMutations().next()\n-                        .getSecond();\n+                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n+                        conn.getMutationState().toMutations();\n+                    List<Mutation> taskMutations = iterator.next().getSecond();\n+                    // we are expecting conn to be used for single upsert\n+                    // query on SYSTEM.TASK\n+                    if (iterator.hasNext()) {\n+                        throw new IOException(\"Provided connection should only \"\n+                            + \"contain mutations related to SYSTEM.TASK table\");\n+                    }\n+                    return taskMutations;\n                 } catch (SQLException e) {\n                     throw new IOException(e);\n                 } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1OTQzMA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r520959430", "bodyText": "I'm not sure I understand this comment. We want to use the endpoint if triggered from client-side right? Can you please explain the use of useTaskEndpoint?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-11T00:25:33Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java", "diffHunk": "@@ -141,12 +181,67 @@ public static void addTask(PhoenixConnection conn, PTable.TaskType taskType, Str\n                     PhoenixDatabaseMetaData.TASK_END_TS + \", \" +\n                     PhoenixDatabaseMetaData.TASK_DATA +\n                     \" ) VALUES(?,?,?,?,?,?,?,?,?)\");\n-            stmt = setValuesToAddTaskPS(stmt, taskType, tenantId, schemaName, tableName, taskStatus, data, priority, startTs, endTs);\n-            LOGGER.info(\"Adding task \" + taskType + \",\" +tableName + \",\" + taskStatus + \",\" + startTs, \",\"+endTs);\n+            stmt = setValuesToAddTaskPS(stmt, systemTaskParams.getTaskType(),\n+                systemTaskParams.getTenantId(),\n+                systemTaskParams.getSchemaName(),\n+                systemTaskParams.getTableName(),\n+                systemTaskParams.getTaskStatus(), systemTaskParams.getData(),\n+                systemTaskParams.getPriority(), systemTaskParams.getStartTs(),\n+                systemTaskParams.getEndTs());\n+            LOGGER.info(\"Adding task type: {} , tableName: {} , taskStatus: {}\"\n+                + \" , startTs: {} , endTs: {}\", systemTaskParams.getTaskType(),\n+                systemTaskParams.getTableName(),\n+                systemTaskParams.getTaskStatus(), systemTaskParams.getStartTs(),\n+                systemTaskParams.getEndTs());\n         } catch (SQLException e) {\n             throw new IOException(e);\n         }\n-        mutateSystemTaskTable(conn, stmt, accessCheckEnabled);\n+        // if query is getting executed by client (useTaskEndpoint is false),", "originalCommit": "81aab47ba9c16de77992f955ec08a52b9de898a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "29b7780a2357f00c3d1a65f078026a709f574d5e", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\nindex 14a77b7f3..160c4e045 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n\n@@ -196,9 +231,9 @@ public class Task {\n         } catch (SQLException e) {\n             throw new IOException(e);\n         }\n-        // if query is getting executed by client (useTaskEndpoint is false),\n-        // do not execute and commit mutations\n-        if (!systemTaskParams.isUseTaskEndpoint()) {\n+        // if query is getting executed by client, do not execute and commit\n+        // mutations\n+        if (isCommitAllowed) {\n             mutateSystemTaskTable(systemTaskParams.getConn(), stmt,\n                 systemTaskParams.isAccessCheckEnabled());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1OTkyNQ==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r520959925", "bodyText": "I'm unclear on the use of useTaskEndpoint. Here we are calling the endpoint anyways. In which cases are we planning on not using the endpoint? server-side invocations?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-11T00:27:04Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -4668,11 +4669,32 @@ public MutationState alterIndex(AlterIndexStatement statement) throws SQLExcepti\n                                 }};\n                                 try {\n                                     String json = JacksonUtil.getObjectWriter().writeValueAsString(props);\n-                                    Task.addTask(connection, PTable.TaskType.INDEX_REBUILD,\n-                                            tenantId, schemaName,\n-                                            dataTableName, PTable.TaskStatus.CREATED.toString(),\n-                                            json, null, ts, null, true);\n-                                    connection.commit();\n+                                    List<Mutation> sysTaskUpsertMutations = Task.getMutationsForAddTask(new SystemTaskParams.SystemTaskParamsBuilder()\n+                                        .setConn(connection)\n+                                        .setTaskType(\n+                                            PTable.TaskType.INDEX_REBUILD)\n+                                        .setTenantId(tenantId)\n+                                        .setSchemaName(schemaName)\n+                                        .setTableName(dataTableName)\n+                                        .setTaskStatus(\n+                                            PTable.TaskStatus.CREATED.toString())\n+                                        .setData(json)\n+                                        .setPriority(null)\n+                                        .setStartTs(ts)\n+                                        .setEndTs(null)\n+                                        .setAccessCheckEnabled(true)\n+                                        .setUseTaskEndpoint(true).build());", "originalCommit": "81aab47ba9c16de77992f955ec08a52b9de898a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMzMDE5OQ==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r521330199", "bodyText": "Right, we don't need this specifically if client is going to use separate method for retrieving mutation list. Updated the patch accordingly.", "author": "virajjasani", "createdAt": "2020-11-11T12:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1OTkyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "29b7780a2357f00c3d1a65f078026a709f574d5e", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\nindex 78e1941a3..c937c7f2e 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n\n@@ -4683,7 +4683,7 @@ public class MetaDataClient {\n                                         .setStartTs(ts)\n                                         .setEndTs(null)\n                                         .setAccessCheckEnabled(true)\n-                                        .setUseTaskEndpoint(true).build());\n+                                        .build());\n                                     byte[] rowKey = sysTaskUpsertMutations\n                                         .get(0).getRow();\n                                     MetaDataMutationResult metaDataMutationResult =\n"}}, {"oid": "29b7780a2357f00c3d1a65f078026a709f574d5e", "url": "https://github.com/apache/phoenix/commit/29b7780a2357f00c3d1a65f078026a709f574d5e", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-11T10:03:38Z", "type": "forcePushed"}, {"oid": "d715f8f82f3cb0d5cd1b136dc607ef63d7a53f1d", "url": "https://github.com/apache/phoenix/commit/d715f8f82f3cb0d5cd1b136dc607ef63d7a53f1d", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-11T12:35:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2MjMwNA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524762304", "bodyText": "I don't think this is a good idea. Instead why not just create a separate connectionOnServer and ensure that it contains just the mutations related to SYSTEM.TASK?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-16T23:42:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java", "diffHunk": "@@ -75,6 +87,55 @@ public Void run() throws Exception {\n         }\n     }\n \n+    private static List<Mutation> getMutationsForSystemTaskTable(\n+            PhoenixConnection conn, PreparedStatement stmt,\n+            boolean accessCheckEnabled) throws IOException {\n+        // we need to mutate SYSTEM.TASK with HBase/login user if access is enabled.\n+        if (accessCheckEnabled) {\n+            return User.runAsLoginUser(() -> {\n+                final RpcCall rpcContext = RpcUtil.getRpcContext();\n+                // setting RPC context as null so that user can be reset\n+                try {\n+                    RpcUtil.setRpcContext(null);\n+                    stmt.execute();\n+                    // retrieve mutations for SYSTEM.TASK upsert query\n+                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n+                        conn.getMutationState().toMutations();\n+                    List<Mutation> taskMutations = iterator.next().getSecond();\n+                    // we are expecting conn to be used for single upsert", "originalCommit": "8353f00b2503862856169ae4fef4c1bbc7b9f8a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkyODA4Mg==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524928082", "bodyText": "Added new connection in getMutationsForAddTask() to resolve this.\nThanks", "author": "virajjasani", "createdAt": "2020-11-17T07:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2MjMwNA=="}], "type": "inlineReview", "revised_code": {"commit": "9a45d6526f99d126bfc3632c0e698e2de92563b1", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\nindex 160c4e045..2adf5f5a9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n\n@@ -97,18 +99,7 @@ public class Task {\n                 // setting RPC context as null so that user can be reset\n                 try {\n                     RpcUtil.setRpcContext(null);\n-                    stmt.execute();\n-                    // retrieve mutations for SYSTEM.TASK upsert query\n-                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n-                        conn.getMutationState().toMutations();\n-                    List<Mutation> taskMutations = iterator.next().getSecond();\n-                    // we are expecting conn to be used for single upsert\n-                    // query on SYSTEM.TASK\n-                    if (iterator.hasNext()) {\n-                        throw new IOException(\"Provided connection should only \"\n-                            + \"contain mutations related to SYSTEM.TASK table\");\n-                    }\n-                    return taskMutations;\n+                    return executeStatementAndGetTaskMutations(conn, stmt);\n                 } catch (SQLException e) {\n                     throw new IOException(e);\n                 } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2MzAxNA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524763014", "bodyText": "Can it not be that the first next() gave you mutations corresponding to some other upsert/delete? Let's just use our own connection", "author": "ChinmaySKulkarni", "createdAt": "2020-11-16T23:43:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java", "diffHunk": "@@ -75,6 +87,55 @@ public Void run() throws Exception {\n         }\n     }\n \n+    private static List<Mutation> getMutationsForSystemTaskTable(\n+            PhoenixConnection conn, PreparedStatement stmt,\n+            boolean accessCheckEnabled) throws IOException {\n+        // we need to mutate SYSTEM.TASK with HBase/login user if access is enabled.\n+        if (accessCheckEnabled) {\n+            return User.runAsLoginUser(() -> {\n+                final RpcCall rpcContext = RpcUtil.getRpcContext();\n+                // setting RPC context as null so that user can be reset\n+                try {\n+                    RpcUtil.setRpcContext(null);\n+                    stmt.execute();\n+                    // retrieve mutations for SYSTEM.TASK upsert query\n+                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n+                        conn.getMutationState().toMutations();\n+                    List<Mutation> taskMutations = iterator.next().getSecond();\n+                    // we are expecting conn to be used for single upsert\n+                    // query on SYSTEM.TASK\n+                    if (iterator.hasNext()) {", "originalCommit": "8353f00b2503862856169ae4fef4c1bbc7b9f8a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a45d6526f99d126bfc3632c0e698e2de92563b1", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\nindex 160c4e045..2adf5f5a9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n\n@@ -97,18 +99,7 @@ public class Task {\n                 // setting RPC context as null so that user can be reset\n                 try {\n                     RpcUtil.setRpcContext(null);\n-                    stmt.execute();\n-                    // retrieve mutations for SYSTEM.TASK upsert query\n-                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n-                        conn.getMutationState().toMutations();\n-                    List<Mutation> taskMutations = iterator.next().getSecond();\n-                    // we are expecting conn to be used for single upsert\n-                    // query on SYSTEM.TASK\n-                    if (iterator.hasNext()) {\n-                        throw new IOException(\"Provided connection should only \"\n-                            + \"contain mutations related to SYSTEM.TASK table\");\n-                    }\n-                    return taskMutations;\n+                    return executeStatementAndGetTaskMutations(conn, stmt);\n                 } catch (SQLException e) {\n                     throw new IOException(e);\n                 } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2NDQ0NA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524764444", "bodyText": "Can we extract the this part into a small helper method? The else case is similar to the if just that we aren't running with impersonation", "author": "ChinmaySKulkarni", "createdAt": "2020-11-16T23:44:47Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java", "diffHunk": "@@ -75,6 +87,55 @@ public Void run() throws Exception {\n         }\n     }\n \n+    private static List<Mutation> getMutationsForSystemTaskTable(\n+            PhoenixConnection conn, PreparedStatement stmt,\n+            boolean accessCheckEnabled) throws IOException {\n+        // we need to mutate SYSTEM.TASK with HBase/login user if access is enabled.\n+        if (accessCheckEnabled) {\n+            return User.runAsLoginUser(() -> {\n+                final RpcCall rpcContext = RpcUtil.getRpcContext();\n+                // setting RPC context as null so that user can be reset\n+                try {\n+                    RpcUtil.setRpcContext(null);\n+                    stmt.execute();\n+                    // retrieve mutations for SYSTEM.TASK upsert query\n+                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n+                        conn.getMutationState().toMutations();\n+                    List<Mutation> taskMutations = iterator.next().getSecond();\n+                    // we are expecting conn to be used for single upsert\n+                    // query on SYSTEM.TASK\n+                    if (iterator.hasNext()) {\n+                        throw new IOException(\"Provided connection should only \"\n+                            + \"contain mutations related to SYSTEM.TASK table\");\n+                    }\n+                    return taskMutations;\n+                } catch (SQLException e) {\n+                    throw new IOException(e);\n+                } finally {\n+                    // setting RPC context back to original context of the RPC\n+                    RpcUtil.setRpcContext(rpcContext);\n+                }\n+            });\n+        } else {\n+            try {\n+                stmt.execute();", "originalCommit": "8353f00b2503862856169ae4fef4c1bbc7b9f8a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a45d6526f99d126bfc3632c0e698e2de92563b1", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\nindex 160c4e045..2adf5f5a9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n\n@@ -97,18 +99,7 @@ public class Task {\n                 // setting RPC context as null so that user can be reset\n                 try {\n                     RpcUtil.setRpcContext(null);\n-                    stmt.execute();\n-                    // retrieve mutations for SYSTEM.TASK upsert query\n-                    Iterator<Pair<byte[], List<Mutation>>> iterator =\n-                        conn.getMutationState().toMutations();\n-                    List<Mutation> taskMutations = iterator.next().getSecond();\n-                    // we are expecting conn to be used for single upsert\n-                    // query on SYSTEM.TASK\n-                    if (iterator.hasNext()) {\n-                        throw new IOException(\"Provided connection should only \"\n-                            + \"contain mutations related to SYSTEM.TASK table\");\n-                    }\n-                    return taskMutations;\n+                    return executeStatementAndGetTaskMutations(conn, stmt);\n                 } catch (SQLException e) {\n                     throw new IOException(e);\n                 } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MTc0MA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524771740", "bodyText": "Can we rename this variable? Sounds like it is set to false when we don't really want to commit, but rather just get the stmt object which we later use to get the List<Mutation>. This is used just for the index rebuild task that gets triggered from the client-side, right? For the tasks that are triggered from the server (i.e. from MetaDataEndpointImpl and TaskRO, we can just directly call Task.addTask() right?\nA more appropriate name would be shouldCommit or something.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-16T23:52:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java", "diffHunk": "@@ -141,12 +216,68 @@ public static void addTask(PhoenixConnection conn, PTable.TaskType taskType, Str\n                     PhoenixDatabaseMetaData.TASK_END_TS + \", \" +\n                     PhoenixDatabaseMetaData.TASK_DATA +\n                     \" ) VALUES(?,?,?,?,?,?,?,?,?)\");\n-            stmt = setValuesToAddTaskPS(stmt, taskType, tenantId, schemaName, tableName, taskStatus, data, priority, startTs, endTs);\n-            LOGGER.info(\"Adding task \" + taskType + \",\" +tableName + \",\" + taskStatus + \",\" + startTs, \",\"+endTs);\n+            stmt = setValuesToAddTaskPS(stmt, systemTaskParams.getTaskType(),\n+                systemTaskParams.getTenantId(),\n+                systemTaskParams.getSchemaName(),\n+                systemTaskParams.getTableName(),\n+                systemTaskParams.getTaskStatus(), systemTaskParams.getData(),\n+                systemTaskParams.getPriority(), systemTaskParams.getStartTs(),\n+                systemTaskParams.getEndTs());\n+            LOGGER.info(\"Adding task type: {} , tableName: {} , taskStatus: {}\"\n+                + \" , startTs: {} , endTs: {}\", systemTaskParams.getTaskType(),\n+                systemTaskParams.getTableName(),\n+                systemTaskParams.getTaskStatus(), systemTaskParams.getStartTs(),\n+                systemTaskParams.getEndTs());\n         } catch (SQLException e) {\n             throw new IOException(e);\n         }\n-        mutateSystemTaskTable(conn, stmt, accessCheckEnabled);\n+        // if query is getting executed by client, do not execute and commit\n+        // mutations\n+        if (isCommitAllowed) {", "originalCommit": "8353f00b2503862856169ae4fef4c1bbc7b9f8a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NzE2OA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524897168", "bodyText": "This is used just for the index rebuild task that gets triggered from the client-side, right? For the tasks that are triggered from the server (i.e. from MetaDataEndpointImpl and TaskRO, we can just directly call Task.addTask() right?\n\nThat's right, both of above are correct. Sure, let me rename it to shouldCommit, that one sounds better.", "author": "virajjasani", "createdAt": "2020-11-17T05:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MTc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "9a45d6526f99d126bfc3632c0e698e2de92563b1", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\nindex 160c4e045..2adf5f5a9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/task/Task.java\n\n@@ -233,19 +224,28 @@ public class Task {\n         }\n         // if query is getting executed by client, do not execute and commit\n         // mutations\n-        if (isCommitAllowed) {\n-            mutateSystemTaskTable(systemTaskParams.getConn(), stmt,\n+        if (shouldCommit) {\n+            mutateSystemTaskTable(connection, stmt,\n                 systemTaskParams.isAccessCheckEnabled());\n         }\n         return stmt;\n     }\n \n     public static List<Mutation> getMutationsForAddTask(\n-            SystemTaskParams systemTaskParams) throws IOException {\n-        PreparedStatement statement = addTaskAndGetStatement(systemTaskParams,\n-            false);\n-        return getMutationsForSystemTaskTable(systemTaskParams.getConn(),\n-            statement, systemTaskParams.isAccessCheckEnabled());\n+            SystemTaskParams systemTaskParams)\n+            throws IOException, SQLException {\n+        PhoenixConnection curConn = systemTaskParams.getConn();\n+        Configuration conf = curConn.getQueryServices().getConfiguration();\n+        // create new connection as we do not want to mix up mutationState\n+        // with existing connection\n+        try (PhoenixConnection newConnection =\n+                QueryUtil.getConnectionOnServer(curConn.getClientInfo(), conf)\n+                    .unwrap(PhoenixConnection.class)) {\n+            PreparedStatement statement = addTaskAndGetStatement(\n+                systemTaskParams, newConnection, false);\n+            return getMutationsForSystemTaskTable(newConnection,\n+                statement, systemTaskParams.isAccessCheckEnabled());\n+        }\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzNTY5MA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r524835690", "bodyText": "nice check for the coproc", "author": "yanxinyi", "createdAt": "2020-11-17T01:59:18Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java", "diffHunk": "@@ -319,6 +321,10 @@ public void testUpdatedSplitPolicyForSysTask() throws Exception {\n                 + compatibleClientVersion,\n                 tableDescriptor.getRegionSplitPolicyClassName(),\n                 SystemTaskSplitPolicy.class.getName());\n+            assertTrue(\"Coprocessor \" + TaskMetaDataEndpoint.class.getName()\n+                + \" has not been added with compatible client version: \"\n+                + compatibleClientVersion, tableDescriptor.hasCoprocessor(\n+                    TaskMetaDataEndpoint.class.getName()));", "originalCommit": "8353f00b2503862856169ae4fef4c1bbc7b9f8a1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc35c71c6bdb2a7b505f20a0994d45d6898cba96", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java\nindex f73f3bacb..d4eba776b 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java\n\n@@ -328,4 +330,19 @@ public class BackwardCompatibilityIT {\n         }\n         assertExpectedOutput(QUERY_CREATE_DIVERGED_VIEW);\n     }\n+\n+    @Test\n+    public void testSystemTaskCreationWithIndexAsyncRebuild() throws Exception {\n+        String[] versionArr = compatibleClientVersion.split(\"\\\\.\");\n+        int majorVersion = Integer.parseInt(versionArr[0]);\n+        int minorVersion = Integer.parseInt(versionArr[1]);\n+        // index async rebuild support min version check\n+        if (majorVersion > 4 || (majorVersion == 4 && minorVersion >= 15)) {\n+            executeQueryWithClientVersion(compatibleClientVersion,\n+                INDEX_REBUILD_ASYNC, zkQuorum);\n+            executeQueriesWithCurrentVersion(QUERY_INDEX_REBUILD_ASYNC, url, NONE);\n+            assertExpectedOutput(\"query_index_rebuild_async\");\n+        }\n+    }\n+\n }\n"}}, {"oid": "9a45d6526f99d126bfc3632c0e698e2de92563b1", "url": "https://github.com/apache/phoenix/commit/9a45d6526f99d126bfc3632c0e698e2de92563b1", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-17T07:26:22Z", "type": "forcePushed"}, {"oid": "4e73f70444c977c610e75e365e6b11c0d6b71365", "url": "https://github.com/apache/phoenix/commit/4e73f70444c977c610e75e365e6b11c0d6b71365", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-17T07:32:27Z", "type": "forcePushed"}, {"oid": "bc35c71c6bdb2a7b505f20a0994d45d6898cba96", "url": "https://github.com/apache/phoenix/commit/bc35c71c6bdb2a7b505f20a0994d45d6898cba96", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-17T12:34:39Z", "type": "forcePushed"}, {"oid": "ab57bb7cc2c4cc83917b11ac67b1746cda8fc037", "url": "https://github.com/apache/phoenix/commit/ab57bb7cc2c4cc83917b11ac67b1746cda8fc037", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-17T13:07:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTM5NA==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r525555394", "bodyText": "We should rename this test since we are no longer just checking that the split policy is updated. Also, better if we can do something like the following:\n\nConnect with an old client: If <4.15, SYS.TASK doesn't even exist, so nothing to do. If 4.15, confirm that SYS.TASK doesn't have the coproc loaded.\nThen connect with a new client (4.16) which will trigger the metadata upgrade and update the coproc. Now do your check for existence of the coproc. Similarly can be done for the split policy too.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T22:04:45Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java", "diffHunk": "@@ -319,7 +323,26 @@ public void testUpdatedSplitPolicyForSysTask() throws Exception {\n                 + compatibleClientVersion,", "originalCommit": "ab57bb7cc2c4cc83917b11ac67b1746cda8fc037", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkwNTY1Mg==", "url": "https://github.com/apache/phoenix/pull/960#discussion_r525905652", "bodyText": "Done. Thanks @ChinmaySKulkarni", "author": "virajjasani", "createdAt": "2020-11-18T08:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "dc92f74df34ee4860dd21027c6d61a076b1728a5", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java\nindex d0496277d..238c57486 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/BackwardCompatibilityIT.java\n\n@@ -312,23 +314,53 @@ public class BackwardCompatibilityIT {\n     }\n \n     @Test\n-    public void testUpdatedSplitPolicyForSysTask() throws Exception {\n-        executeQueryWithClientVersion(compatibleClientVersion, CREATE_DIVERGED_VIEW, zkQuorum);\n-        executeQueriesWithCurrentVersion(QUERY_CREATE_DIVERGED_VIEW, url, NONE);\n-        try (org.apache.hadoop.hbase.client.Connection conn =\n-                hbaseTestUtil.getConnection(); Admin admin = conn.getAdmin()) {\n+    public void testSplitPolicyAndCoprocessorForSysTask() throws Exception {\n+        executeQueryWithClientVersion(compatibleClientVersion,\n+            CREATE_DIVERGED_VIEW, zkQuorum);\n+\n+        String[] versionArr = compatibleClientVersion.split(\"\\\\.\");\n+        int majorVersion = Integer.parseInt(versionArr[0]);\n+        int minorVersion = Integer.parseInt(versionArr[1]);\n+        org.apache.hadoop.hbase.client.Connection conn = null;\n+        Admin admin = null;\n+        // if connected with client < 4.15, SYSTEM.TASK does not exist\n+        // if connected with client 4.15, SYSTEM.TASK exists without any\n+        // split policy and also TaskMetaDataEndpoint coprocessor would not\n+        // exist\n+        if (majorVersion == 4 && minorVersion == 15) {\n+            conn = hbaseTestUtil.getConnection();\n+            admin = conn.getAdmin();\n             TableDescriptor tableDescriptor = admin.getDescriptor(\n                 TableName.valueOf(PhoenixDatabaseMetaData.SYSTEM_TASK_NAME));\n-            assertEquals(\"split policy not updated with compatible client version: \"\n+            assertNull(\"split policy should be null with compatible client version: \"\n+                + compatibleClientVersion, tableDescriptor.getRegionSplitPolicyClassName());\n+            assertFalse(\"Coprocessor \" + TaskMetaDataEndpoint.class.getName()\n+                + \" should not have been added with compatible client version: \"\n                 + compatibleClientVersion,\n-                tableDescriptor.getRegionSplitPolicyClassName(),\n-                SystemTaskSplitPolicy.class.getName());\n-            assertTrue(\"Coprocessor \" + TaskMetaDataEndpoint.class.getName()\n-                + \" has not been added with compatible client version: \"\n-                + compatibleClientVersion, tableDescriptor.hasCoprocessor(\n-                    TaskMetaDataEndpoint.class.getName()));\n+                tableDescriptor.hasCoprocessor(TaskMetaDataEndpoint.class.getName()));\n+        }\n+\n+        executeQueriesWithCurrentVersion(QUERY_CREATE_DIVERGED_VIEW, url, NONE);\n+\n+        if (conn == null) {\n+            conn = hbaseTestUtil.getConnection();\n+            admin = conn.getAdmin();\n         }\n+        // connect with client > 4.15, and we have new split policy and new\n+        // coprocessor loaded\n+        TableDescriptor tableDescriptor = admin.getDescriptor(\n+            TableName.valueOf(PhoenixDatabaseMetaData.SYSTEM_TASK_NAME));\n+        assertEquals(\"split policy not updated with compatible client version: \"\n+            + compatibleClientVersion,\n+            tableDescriptor.getRegionSplitPolicyClassName(),\n+            SystemTaskSplitPolicy.class.getName());\n+        assertTrue(\"Coprocessor \" + TaskMetaDataEndpoint.class.getName()\n+            + \" has not been added with compatible client version: \"\n+            + compatibleClientVersion, tableDescriptor.hasCoprocessor(\n+            TaskMetaDataEndpoint.class.getName()));\n         assertExpectedOutput(QUERY_CREATE_DIVERGED_VIEW);\n+        admin.close();\n+        conn.close();\n     }\n \n     @Test\n"}}, {"oid": "dc92f74df34ee4860dd21027c6d61a076b1728a5", "url": "https://github.com/apache/phoenix/commit/dc92f74df34ee4860dd21027c6d61a076b1728a5", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-18T08:41:15Z", "type": "commit"}, {"oid": "dc92f74df34ee4860dd21027c6d61a076b1728a5", "url": "https://github.com/apache/phoenix/commit/dc92f74df34ee4860dd21027c6d61a076b1728a5", "message": "PHOENIX-6155 : Provide a coprocessor endpoint to avoid direct upserts into SYSTEM.TASK from the client", "committedDate": "2020-11-18T08:41:15Z", "type": "forcePushed"}]}