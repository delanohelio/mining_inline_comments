{"pr_number": 725, "pr_title": "PHOENIX-5749: Add unit tests for verifySingleIndexRow() of IndexRebui\u2026", "pr_createdAt": "2020-03-06T20:40:39Z", "pr_url": "https://github.com/apache/phoenix/pull/725", "timeline": [{"oid": "72d0124d63009e1bff961e712fe5d414934ff509", "url": "https://github.com/apache/phoenix/commit/72d0124d63009e1bff961e712fe5d414934ff509", "message": "PHOENIX-5749: Add unit tests for verifySingleIndexRow() of IndexRebuildRegionScanner", "committedDate": "2020-03-06T20:37:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzODUxOQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r389138519", "bodyText": "Why do you need to move this code out from this file? It is a static helper class and only meaningful in the context of index verification and not by itself.", "author": "kadirozde", "createdAt": "2020-03-06T20:53:22Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -109,231 +110,6 @@\n \n public class IndexRebuildRegionScanner extends BaseRegionScanner {\n \n-    public static class VerificationResult {", "originalCommit": "72d0124d63009e1bff961e712fe5d414934ff509", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTI0OQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391771249", "bodyText": "I agree that VerificationResult makes sense as an inner class of something, but since I'd eventually like to see the verification logic moved out into its own class (and the index generation logic moved out into its own class), I still support moving the VerificationResult out of IndexRebuildRegionScanner. :-)", "author": "gjacoby126", "createdAt": "2020-03-12T17:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzODUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2Mzc2NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392363765", "bodyText": "Also, for tests, it was 3 level indirection to access the PhaseResult, so I thought of putting it into its own class. :)", "author": "swaroopak", "createdAt": "2020-03-13T17:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzODUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 8e73a4b39..357df03a2 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -115,6 +114,9 @@ public class IndexRebuildRegionScanner extends BaseRegionScanner {\n     private static final int DEFAULT_CONCURRENT_INDEX_VERIFY_THREADS = 17;\n     public static final String INDEX_VERIFY_ROW_COUNTS_PER_TASK_CONF_KEY = \"index.verify.threads.max\";\n     private static final int DEFAULT_INDEX_VERIFY_ROW_COUNTS_PER_TASK = 2048;\n+    public static final String NO_EXPECTED_MUTATION = \"No expected mutation\";\n+    public static final String\n+            ACTUAL_MUTATION_IS_NULL_OR_EMPTY = \"actualMutationList is null or empty\";\n     private long pageSizeInRows = Long.MAX_VALUE;\n     private int rowCountPerTask;\n     private boolean hasMore;\n"}}, {"oid": "157bbf8b8e12e2ee1715c96dcd74f31e1188a7a2", "url": "https://github.com/apache/phoenix/commit/157bbf8b8e12e2ee1715c96dcd74f31e1188a7a2", "message": "Removing thread sleep and restructuring the setup", "committedDate": "2020-03-07T01:47:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ1MjA0NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r389452045", "bodyText": "Comparing one PhaseResult to another would be more intuitive and best implemented by overriding equals() instead of comparing output of toString() functions. You wouldn't even need assertVerificationPhaseResult() function then and Assert.Equals() would suffice.", "author": "priyankporwal", "createdAt": "2020-03-09T03:45:27Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_VALUE = \"UNEXPECTED_VALUE\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+\n+    private enum TestType {\n+        VALID,\n+        EXPIRED,\n+        INVALID_LESS_MUTATIONS,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR, expectedPR;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (kv.getType() == (KeyValue.Type.Put.getCode())) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        rebuildScanner.indexTableTTL = HConstants.FOREVER;\n+        rebuildScanner.indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the map\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        expectedPR = new IndexToolVerificationResult.PhaseResult(1, 0, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expiredIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult\n+                expectedPR = new IndexToolVerificationResult.PhaseResult(0, 1, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.EXPIRED);\n+            expireThisRow();\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_lessMutations() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_LESS_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_cellValue() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_CELL_VALUE);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_emptyCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EMPTY_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_diffColumn() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_COLUMN);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_extraCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EXTRA_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getInvalidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(0, 0, 0, 1);\n+    }\n+\n+    private void initializeLocalMockitoSetup(Map.Entry<byte[], List<Mutation>> entry, TestType testType)\n+            throws IOException {\n+        actualPR = new IndexToolVerificationResult.PhaseResult();\n+        byte[] indexKey = entry.getKey();\n+        when(indexRow.getRow()).thenReturn(indexKey);\n+        actualMutationList = buildActualIndexMutationsList(testType);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+    }\n+\n+    private List<Mutation> buildActualIndexMutationsList(TestType testType) {\n+        List<Mutation> actualMutations = new ArrayList<>();\n+        actualMutations.addAll(rebuildScanner.indexKeyToMutationMap.get(indexRow.getRow()));\n+        if(testType.equals(TestType.EXPIRED) || testType.equals(TestType.VALID)) {\n+            return actualMutations;\n+        }\n+        if (testType.equals(TestType.INVALID_LESS_MUTATIONS)) {\n+            return getTotalMutationsLessThanExpected(actualMutations);\n+        }\n+\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        newActualMutations.addAll(actualMutations);\n+\n+        for (Mutation m : actualMutations) {\n+            newActualMutations.remove(m);\n+            NavigableMap<byte [], List<Cell>> familyCellMap = m.getFamilyCellMap();\n+            List<Cell> cellList = familyCellMap.firstEntry().getValue();\n+            List <Cell> newCellList = new ArrayList<>();\n+            for (Cell c : cellList) {\n+                infiltrateCell(c, newCellList, testType);\n+            }\n+            familyCellMap.put(Bytes.toBytes(0), newCellList);\n+            m.setFamilyCellMap(familyCellMap);\n+            newActualMutations.add(m);\n+        }\n+        return newActualMutations;\n+    }\n+\n+    private void infiltrateCell(Cell c, List<Cell> newCellList, TestType e) {\n+        Cell newCell;\n+        switch(e) {\n+        case INVALID_COLUMN:\n+            newCell =\n+                CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        Bytes.toBytes(\"0:\" + UNEXPECTED_VALUE),\n+                        EnvironmentEdgeManager.currentTimeMillis(),\n+                        KeyValue.Type.Put.getCode(), Bytes.toBytes(\"zxcv\"));\n+            newCellList.add(newCell);\n+            newCellList.add(c);\n+            break;\n+        case INVALID_CELL_VALUE:\n+            if (CellUtil.matchingQualifier(c, EMPTY_COLUMN_BYTES)) {\n+                newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        Bytes.toBytes(FIRST_VALUE), EnvironmentEdgeManager.currentTimeMillis(),\n+                        KeyValue.Type.Put.getCode(),\n+                        Bytes.toBytes(\"zxcv\"));\n+                newCellList.add(newCell);\n+            } else {\n+                newCellList.add(c);\n+            }\n+            break;\n+        case INVALID_EMPTY_CELL:\n+            if (CellUtil.matchingQualifier(c, EMPTY_COLUMN_BYTES)) {\n+                newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        CellUtil.cloneQualifier(c), c.getTimestamp(),\n+                        KeyValue.Type.Delete.getCode(),\n+                        Bytes.toBytes(\"\\\\x02\"));\n+                newCellList.add(newCell);\n+            } else {\n+                newCellList.add(c);\n+            }\n+            break;\n+        case INVALID_EXTRA_CELL:\n+            if (CellUtil.matchingQualifier(c, EMPTY_COLUMN_BYTES)) {\n+                newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        Bytes.toBytes(FIRST_VALUE), EnvironmentEdgeManager.currentTimeMillis(),\n+                        KeyValue.Type.Put.getCode(),\n+                        Bytes.toBytes(\"zxcv\"));\n+                newCellList.add(newCell);\n+            }\n+            newCellList.add(c);\n+        }\n+    }\n+\n+    private void expireThisRow() {\n+        rebuildScanner.indexTableTTL = INDEX_TABLE_EXPIRY_SEC;\n+        UnitTestClock expiryClock = new UnitTestClock(5000);\n+        EnvironmentEdgeManager.injectEdge(expiryClock);\n+    }\n+\n+    private List<Mutation> getTotalMutationsLessThanExpected(List<Mutation> actualMutations) {\n+        Mutation m = actualMutations.get(0);\n+        NavigableMap<byte [], List<Cell>> familyCellMap = m.getFamilyCellMap();\n+        List<Cell> cellList = familyCellMap.firstEntry().getValue();\n+        Cell c = cellList.get(0);\n+        Cell newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                CellUtil.cloneQualifier(c), EnvironmentEdgeManager.currentTimeMillis(),\n+                KeyValue.Type.Delete.getCode(),\n+                    CellUtil.cloneValue(c));\n+        cellList.add(newCell);\n+        familyCellMap.put(Bytes.toBytes(0), cellList);\n+        m.setFamilyCellMap(familyCellMap);\n+        actualMutations.removeAll(actualMutations);\n+        actualMutations.add(m);\n+        return actualMutations;\n+    }\n+\n+    private void assertVerificationPhaseResult(IndexToolVerificationResult.PhaseResult actualPR,\n+            IndexToolVerificationResult.PhaseResult expectedPR) {\n+        Assert.assertTrue(actualPR.toString().equalsIgnoreCase(expectedPR.toString()));", "originalCommit": "157bbf8b8e12e2ee1715c96dcd74f31e1188a7a2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nindex 39fb95936..b2f6a671f 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n\n@@ -17,9 +17,11 @@\n  */\n package org.apache.phoenix.index;\n \n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import org.apache.hadoop.hbase.Cell;\n import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n import org.apache.hadoop.hbase.HConstants;\n import org.apache.hadoop.hbase.KeyValue;\n import org.apache.hadoop.hbase.client.Delete;\n"}}, {"oid": "f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "url": "https://github.com/apache/phoenix/commit/f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "message": "Added more scenarios to increase the branch coverage", "committedDate": "2020-03-10T04:07:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA4NjY5NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r390086695", "bodyText": "Do we still need this annotation if it is a public function?", "author": "wangweiming800", "createdAt": "2020-03-10T04:14:03Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -594,14 +376,16 @@ private boolean checkIndexRow(final byte[] indexRowKey, final Put put) throws IO\n         return true;\n     }\n \n-    private void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs, long indexRowTs,\n+    @VisibleForTesting", "originalCommit": "f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MTYyMg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391351622", "bodyText": "Nope!", "author": "swaroopak", "createdAt": "2020-03-12T01:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA4NjY5NQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "url": "https://github.com/apache/phoenix/commit/3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "message": "Fixing review comments", "committedDate": "2020-03-12T01:57:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTc2Mw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391771763", "bodyText": "tiny nit: unnecessary extra space", "author": "gjacoby126", "createdAt": "2020-03-12T17:16:48Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -359,23 +138,24 @@ public void add(VerificationResult verificationResult) {\n     private Table resultHTable = null;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n     private boolean verify = false;\n-    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n+    private  Map<byte[], List<Mutation>> indexKeyToMutationMap;", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 3c18edc71..ad549e536 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -138,7 +138,7 @@ public class IndexRebuildRegionScanner extends BaseRegionScanner {\n     private Table resultHTable = null;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n     private boolean verify = false;\n-    private  Map<byte[], List<Mutation>> indexKeyToMutationMap;\n+    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n     private Map<byte[], Pair<Put, Delete>> dataKeyToMutationMap;\n     private TaskRunner pool;\n     private TaskBatch<Boolean> tasks;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MjE2Nw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391772167", "bodyText": "nit: variable name is confusing, since it can be any int, not just Hconstants.forever", "author": "gjacoby126", "createdAt": "2020-03-12T17:17:33Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -552,6 +332,24 @@ private void setMutationAttributes(Mutation m, byte[] uuidValue) {\n         return uuidValue;\n     }\n \n+    @VisibleForTesting\n+    public int setIndexTableTTL(int forever) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 3c18edc71..ad549e536 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -333,8 +333,8 @@ public class IndexRebuildRegionScanner extends BaseRegionScanner {\n     }\n \n     @VisibleForTesting\n-    public int setIndexTableTTL(int forever) {\n-        indexTableTTL = forever;\n+    public int setIndexTableTTL(int ttl) {\n+        indexTableTTL = ttl;\n         return 0;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MzY0MA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391773640", "bodyText": "This change is a hint that index generation code should be its own class with its own public methods. (Not necessarily in this JIRA.) After all, this method doesn't really have much to do with \"scanning\".", "author": "gjacoby126", "createdAt": "2020-03-12T17:20:00Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -578,7 +376,7 @@ public ImmutableBytesWritable getLatestValue(ColumnReference ref, long ts) throw\n \n     }\n \n-    private byte[] getIndexRowKey(final Put dataRow) throws IOException {\n+    public byte[] getIndexRowKey(final Put dataRow) throws IOException {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3NDMwNA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391774304", "bodyText": "Likewise logging to the output table should likely be its own class (easier to mock, for one thing). Again, not necessarily for this JIRA.", "author": "gjacoby126", "createdAt": "2020-03-12T17:21:09Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -594,14 +392,16 @@ private boolean checkIndexRow(final byte[] indexRowKey, final Put put) throws IO\n         return true;\n     }\n \n-    private void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs, long indexRowTs,\n+    @VisibleForTesting\n+    public void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs, long indexRowTs,", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3NzUzNg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391777536", "bodyText": "tiny nit: extra space", "author": "gjacoby126", "createdAt": "2020-03-12T17:26:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -866,7 +668,7 @@ private boolean verifySingleIndexRow(Result indexRow, VerificationResult.PhaseRe\n         Mutation expected = null;\n         Mutation previousExpected;\n         Mutation actual;\n-        while (expectedIndex < expectedSize && actualIndex <actualSize) {\n+        while (expectedIndex < expectedSize && actualIndex < actualSize) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 3c18edc71..ad549e536 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -668,7 +668,7 @@ public class IndexRebuildRegionScanner extends BaseRegionScanner {\n         Mutation expected = null;\n         Mutation previousExpected;\n         Mutation actual;\n-        while (expectedIndex < expectedSize && actualIndex < actualSize) {\n+        while (expectedIndex < expectedSize && actualIndex <actualSize) {\n             previousExpected = expected;\n             expected = expectedMutationList.get(expectedIndex);\n             // Check if cell expired as per the current server's time and data table ttl\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3ODg3Mg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391778872", "bodyText": "Good job on overriding equals. However, Java requires that if you override equals you must also override hash code (and make them consistent)", "author": "gjacoby126", "createdAt": "2020-03-12T17:28:40Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexToolVerificationResult.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.coprocessor;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.REBUILT_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.RESULT_TABLE_COLUMN_FAMILY;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.SCANNED_DATA_ROW_COUNT_BYTES;\n+\n+public class IndexToolVerificationResult {\n+    public static class PhaseResult {\n+        long validIndexRowCount = 0;\n+        long expiredIndexRowCount = 0;\n+        long missingIndexRowCount = 0;\n+        long invalidIndexRowCount = 0;\n+\n+        public void add(PhaseResult phaseResult) {\n+            validIndexRowCount += phaseResult.validIndexRowCount;\n+            expiredIndexRowCount += phaseResult.expiredIndexRowCount;\n+            missingIndexRowCount += phaseResult.missingIndexRowCount;\n+            invalidIndexRowCount += phaseResult.invalidIndexRowCount;\n+        }\n+\n+        public PhaseResult(){}\n+\n+        public PhaseResult(long validIndexRowCount, long expiredIndexRowCount,\n+                long missingIndexRowCount, long invalidIndexRowCount) {\n+            this.validIndexRowCount = validIndexRowCount;\n+            this.expiredIndexRowCount = expiredIndexRowCount;\n+            this.missingIndexRowCount = missingIndexRowCount;\n+            this.invalidIndexRowCount = invalidIndexRowCount;\n+        }\n+\n+        public long getTotalCount() {\n+            return validIndexRowCount + expiredIndexRowCount + missingIndexRowCount + invalidIndexRowCount;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PhaseResult{\" +\n+                    \"validIndexRowCount=\" + validIndexRowCount +\n+                    \", expiredIndexRowCount=\" + expiredIndexRowCount +\n+                    \", missingIndexRowCount=\" + missingIndexRowCount +\n+                    \", invalidIndexRowCount=\" + invalidIndexRowCount +\n+                    '}';\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NDcxNQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392374715", "bodyText": "aah! ll do it with 17 and 31 way. :)", "author": "swaroopak", "createdAt": "2020-03-13T17:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3ODg3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexToolVerificationResult.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexToolVerificationResult.java\nindex 5309a9737..ed92fad43 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexToolVerificationResult.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexToolVerificationResult.java\n\n@@ -94,6 +94,16 @@ public class IndexToolVerificationResult {\n                     && this.invalidIndexRowCount == pr.invalidIndexRowCount\n                     && this.missingIndexRowCount == pr.missingIndexRowCount;\n         }\n+\n+        @Override\n+        public int hashCode() {\n+            long result = 17;\n+            result = 31 * result + expiredIndexRowCount;\n+            result = 31 * result + validIndexRowCount;\n+            result = 31 * result + missingIndexRowCount;\n+            result = 31 * result + invalidIndexRowCount;\n+            return (int)result;\n+        }\n     }\n \n     long scannedDataRowCount = 0;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MDA0MQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391780041", "bodyText": "nit: CREATE_TABLE_DDL", "author": "gjacoby126", "createdAt": "2020-03-12T17:30:34Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MDE3NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391780175", "bodyText": "nit: CREATE_INDEX_DDL", "author": "gjacoby126", "createdAt": "2020-03-12T17:30:47Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MjU3OQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391782579", "bodyText": "some of these are self explanatory, but a comment would be good", "author": "gjacoby126", "createdAt": "2020-03-12T17:34:49Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2ODQ1NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392468455", "bodyText": "added comment wherever felt necessary", "author": "swaroopak", "createdAt": "2020-03-13T20:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MjU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM4Nw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391787387", "bodyText": "These KeyValue.get* operations are deprecated. Actually, all operations directly on a KeyValue are deprecated. Should be using the Cell interface, which KeyValues implement.", "author": "gjacoby126", "createdAt": "2020-03-12T17:42:32Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4OTAwOA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391789008", "bodyText": "Better to use CellUtil.cloneRow, cloneFamily, etc. Can't seem to fine a cloneCell method anywhere, which is a little strange....", "author": "gjacoby126", "createdAt": "2020-03-12T17:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5MDY0Mg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391790642", "bodyText": "Ah, I see, later versions of HBase get CellBuilder/CellBuilderFactory but 1.x doesn't have it.", "author": "gjacoby126", "createdAt": "2020-03-12T17:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDQ5NA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391804494", "bodyText": "All of this partial mocking in initializeRebuildScannerAttributes and initalizeGlobalMockitoSetup should be taken as a \"code smell\" that the rebuild scanner needs to be broken apart into multiple classes. Generally when mocking you have one class under test which isn't mocked at all, and other dependent classes that aren't being tested that are completely mocked.\nAgain, don't have to fix this in this PR, because without the tests first it's hard to refactor this safely. But the refactoring should happen.", "author": "gjacoby126", "createdAt": "2020-03-12T18:12:50Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTgyNw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391805827", "bodyText": "forgot to assert?", "author": "gjacoby126", "createdAt": "2020-03-12T18:15:14Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjExNQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391806115", "bodyText": "nit: don't have to tell me you assert just before a line called assert. :-) Ditto for the other places this got pasted.", "author": "gjacoby126", "createdAt": "2020-03-12T18:15:48Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_moreActual() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MORE_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxOTU3Ng==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391819576", "bodyText": "should this be VALID_EMPTY?", "author": "gjacoby126", "createdAt": "2020-03-12T18:40:37Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_moreActual() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MORE_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allMix() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MIX_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allUnverified() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_NEW_UNVERIFIED_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expiredIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult\n+                expectedPR = new IndexToolVerificationResult.PhaseResult(0, 1, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.EXPIRED);\n+            expireThisRow();\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_cellValue() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_CELL_VALUE);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_emptyCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EMPTY_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_diffColumn() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_COLUMN);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_extraCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EXTRA_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expectedMutations_null() throws IOException {\n+        when(indexRow.getRow()).thenReturn(Bytes.toBytes(1));\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.NO_EXPECTED_MUTATION);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_null() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(null);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_empty() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        actualMutationList = new ArrayList<>();\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getValidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(1,0,0,0);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getInvalidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(0, 0, 0, 1);\n+    }\n+\n+    private void initializeLocalMockitoSetup(Map.Entry<byte[], List<Mutation>> entry,\n+            TestType testType)\n+            throws IOException {\n+        actualPR = new IndexToolVerificationResult.PhaseResult();\n+        byte[] indexKey = entry.getKey();\n+        when(indexRow.getRow()).thenReturn(indexKey);\n+        actualMutationList = buildActualIndexMutationsList(testType);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+    }\n+\n+    private List<Mutation> buildActualIndexMutationsList(TestType testType) {\n+        List<Mutation> actualMutations = new ArrayList<>();\n+        actualMutations.addAll(indexKeyToMutationMapLocal.get(indexRow.getRow()));\n+        if(testType.equals(TestType.EXPIRED)) {\n+            return actualMutations;\n+        }\n+        if(testType.toString().startsWith(\"VALID\")) {\n+            return getValidActualMutations(testType, actualMutations);\n+        }\n+        if(testType.toString().startsWith(\"INVALID\")) {\n+            return getInvalidActualMutations(testType, actualMutations);\n+        }\n+        return null;\n+    }\n+\n+    private List <Mutation> getValidActualMutations(TestType testType,\n+            List<Mutation> actualMutations) {\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        if(testType.equals(TestType.VALID)) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2Nzk0OA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392467948", "bodyText": "making it VALID_EXACT_MATCH.", "author": "swaroopak", "createdAt": "2020-03-13T20:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxOTU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyMDM3Nw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391820377", "bodyText": "Nice method name. :-)", "author": "gjacoby126", "createdAt": "2020-03-12T18:42:04Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_moreActual() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MORE_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allMix() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MIX_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allUnverified() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_NEW_UNVERIFIED_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expiredIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult\n+                expectedPR = new IndexToolVerificationResult.PhaseResult(0, 1, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.EXPIRED);\n+            expireThisRow();\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_cellValue() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_CELL_VALUE);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_emptyCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EMPTY_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_diffColumn() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_COLUMN);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_extraCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EXTRA_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expectedMutations_null() throws IOException {\n+        when(indexRow.getRow()).thenReturn(Bytes.toBytes(1));\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.NO_EXPECTED_MUTATION);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_null() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(null);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_empty() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        actualMutationList = new ArrayList<>();\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getValidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(1,0,0,0);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getInvalidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(0, 0, 0, 1);\n+    }\n+\n+    private void initializeLocalMockitoSetup(Map.Entry<byte[], List<Mutation>> entry,\n+            TestType testType)\n+            throws IOException {\n+        actualPR = new IndexToolVerificationResult.PhaseResult();\n+        byte[] indexKey = entry.getKey();\n+        when(indexRow.getRow()).thenReturn(indexKey);\n+        actualMutationList = buildActualIndexMutationsList(testType);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+    }\n+\n+    private List<Mutation> buildActualIndexMutationsList(TestType testType) {\n+        List<Mutation> actualMutations = new ArrayList<>();\n+        actualMutations.addAll(indexKeyToMutationMapLocal.get(indexRow.getRow()));\n+        if(testType.equals(TestType.EXPIRED)) {\n+            return actualMutations;\n+        }\n+        if(testType.toString().startsWith(\"VALID\")) {\n+            return getValidActualMutations(testType, actualMutations);\n+        }\n+        if(testType.toString().startsWith(\"INVALID\")) {\n+            return getInvalidActualMutations(testType, actualMutations);\n+        }\n+        return null;\n+    }\n+\n+    private List <Mutation> getValidActualMutations(TestType testType,\n+            List<Mutation> actualMutations) {\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        if(testType.equals(TestType.VALID)) {\n+            return actualMutations;\n+        }\n+        if (testType.equals(TestType.VALID_MIX_MUTATIONS)) {\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getDeleteMutation(actualMutations.get(0), new Long(1)));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+        }\n+        if (testType.equals(TestType.VALID_NEW_UNVERIFIED_MUTATIONS)) {\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), new Long(1)));\n+        }\n+        newActualMutations.addAll(actualMutations);\n+        if(testType.equals(TestType.VALID_MORE_MUTATIONS)) {\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getDeleteMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getDeleteMutation(actualMutations.get(0), new Long(1)));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), new Long(1)));\n+        }\n+        return newActualMutations;\n+    }\n+\n+    private List <Mutation> getInvalidActualMutations(TestType testType,\n+            List<Mutation> actualMutations) {\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        newActualMutations.addAll(actualMutations);\n+        for (Mutation m : actualMutations) {\n+            newActualMutations.remove(m);\n+            NavigableMap<byte[], List<Cell>> familyCellMap = m.getFamilyCellMap();\n+            List<Cell> cellList = familyCellMap.firstEntry().getValue();\n+            List<Cell> newCellList = new ArrayList<>();\n+            byte[] fam = CellUtil.cloneFamily(cellList.get(0));\n+            for (Cell c : cellList) {\n+                infiltrateCell(c, newCellList, testType);", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9445e9c9213771bb434677356a2c44ddb7bcd106", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nsimilarity index 94%\nrename from phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\nrename to phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\nindex 3fa0f746c..9674ed9a3 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/index/VerifySingleIndexRowTest.java\n\n@@ -40,7 +40,6 @@ import org.apache.phoenix.util.EnvironmentEdge;\n import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n"}}, {"oid": "9445e9c9213771bb434677356a2c44ddb7bcd106", "url": "https://github.com/apache/phoenix/commit/9445e9c9213771bb434677356a2c44ddb7bcd106", "message": "Fixing review comments", "committedDate": "2020-03-13T18:14:19Z", "type": "commit"}, {"oid": "aaf838478db333f263136fe538c51c31a114b3e3", "url": "https://github.com/apache/phoenix/commit/aaf838478db333f263136fe538c51c31a114b3e3", "message": "Adding comments and changed name", "committedDate": "2020-03-13T20:51:52Z", "type": "commit"}]}