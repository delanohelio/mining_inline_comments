{"pr_number": 935, "pr_title": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "pr_createdAt": "2020-10-22T16:55:14Z", "pr_url": "https://github.com/apache/phoenix/pull/935", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNDc1Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512334756", "bodyText": "nit: Don't need commit() since they are DDL statements.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:46:45Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java", "diffHunk": "@@ -387,6 +388,31 @@ public void testViewUsesTableLocalIndex() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCreateViewTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        final String schemaName = \"S_\" + generateUniqueName();\n+        final String tableName = \"T_\" + generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        final String dataTableFullName = SchemaUtil.getTableName(schemaName, tableName);\n+        final String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+        String tableDDL =\n+            \"CREATE TABLE \" + dataTableFullName + \" (\\n\" + \"ID1 VARCHAR(15) NOT NULL,\\n\"\n+                + \"ID2 VARCHAR(15) NOT NULL,\\n\" + \"CREATED_DATE DATE,\\n\"\n+                + \"CREATION_TIME BIGINT,\\n\" + \"LAST_USED DATE,\\n\"\n+                + \"CONSTRAINT PK PRIMARY KEY (ID1, ID2)) \";\n+        String viewDDL = \"CREATE VIEW \" + viewFullName  + \" AS SELECT * \" +\n+            \"FROM \" + dataTableFullName;\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            conn.commit();", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDIxMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080213", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-10-27T22:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNDc1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\nindex 08894a6e8..5b64fb77c 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\n\n@@ -390,7 +390,22 @@ public class ViewIT extends SplitSystemCatalogIT {\n \n     @Test\n     public void testCreateViewTimestamp() throws Exception {\n+        String tenantId = null;\n+        createViewTimestampHelper(tenantId);\n+    }\n+\n+    @Test\n+    public void testCreateTenantViewTimestamp() throws Exception {\n+        createViewTimestampHelper(TENANT1);\n+    }\n+\n+    private void createViewTimestampHelper(String tenantId) throws SQLException {\n         Properties props = new Properties();\n+        if (tenantId != null) {\n+            props.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        } else {\n+            tenantId = \"\";\n+        }\n         final String schemaName = \"S_\" + generateUniqueName();\n         final String tableName = \"T_\" + generateUniqueName();\n         final String viewName = \"V_\" + generateUniqueName();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTQ3NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512335474", "bodyText": "Once we converge on the expected behavior for column inheritance from a parent to its child views, we should add some tests for those scenarios too.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:49:23Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1217,50 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex c881965e1..1b48c6b4b 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1262,5 +1263,159 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n                 tableDDLTimestamp + 1 , conn);\n         }\n     }\n-    \n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String globalViewName = \"V_\" + generateUniqueName();\n+        String tenantViewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String globalViewFullName = SchemaUtil.getTableName(schemaName, globalViewName);\n+        String tenantViewFullName = SchemaUtil.getTableName(schemaName, tenantViewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        //create a table with a child global view, who then has a child tenant view\n+        String globalViewDDL =\n+            \"CREATE VIEW \" + globalViewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String tenantViewDDL =\n+            \"CREATE VIEW \" + tenantViewFullName + \" AS SELECT * FROM \" + globalViewFullName;\n+\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        long tableDDLTimestamp, globalViewDDLTimestamp;\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(globalViewDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+        }\n+        props.setProperty(TENANT_ID_ATTRIB, TENANT1);\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewDDL);\n+        }\n+        // First, check that adding a child view didn't change the timestamps\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            long newTableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+\n+            long newGlobalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, newGlobalViewDDLTimestamp);\n+        }\n+        Thread.sleep(1);\n+        //now add / drop a column from the tenant view and make sure it doesn't change its\n+        // ancestors' timestamps\n+        String tenantViewColumnAddDDL = \"ALTER VIEW \" + tenantViewFullName + \" ADD COL3 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String tenantViewColumnDropDDL = \"ALTER VIEW \" + tenantViewFullName + \" DROP COLUMN COL3 \";\n+\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewColumnAddDDL);\n+            long newTableDDLTimestamp = getLastDDLTimestamp(tenantConn, dataTableFullName);\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+\n+            long afterTenantColumnAddViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, afterTenantColumnAddViewDDLTimestamp);\n+\n+            tenantConn.createStatement().execute(tenantViewColumnDropDDL);\n+            //update the tenant view timestamp (we'll need it later)\n+            long afterTenantColumnDropTableDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                dataTableFullName);\n+            assertEquals(tableDDLTimestamp, afterTenantColumnDropTableDDLTimestamp);\n+\n+            long afterTenantColumnDropViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, afterTenantColumnDropViewDDLTimestamp);\n+        }\n+        Thread.sleep(1);\n+        //now add / drop a column from the base table and make sure it changes the timestamps for\n+        // both the global view (its child) and the tenant view (its grandchild)\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName, TENANT1);\n+                assertEquals(tableDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn,\n+                globalViewFullName);\n+            assertEquals(tableDDLTimestamp, globalViewDDLTimestamp);\n+\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName, TENANT1);\n+                assertEquals(tableDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn,\n+                globalViewFullName);\n+            assertEquals(tableDDLTimestamp, globalViewDDLTimestamp);\n+        }\n+\n+        //now add / drop a column from the global view and make sure it doesn't change its\n+        // parent (the base table) but does change the timestamp for its child (the tenant view)\n+        String globalViewColumnAddDDL = \"ALTER VIEW \" + globalViewFullName + \" ADD COL5 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String globalViewColumnDropDDL = \"ALTER VIEW \" + globalViewFullName + \" DROP COLUMN COL5 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(globalViewColumnAddDDL);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            long newTableDDLTimestamp = getLastDDLTimestamp(conn,\n+                dataTableFullName);\n+            //table DDL timestamp shouldn't have changed\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName, TENANT1);\n+                //but tenant timestamp should have changed\n+                assertEquals(globalViewDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+\n+            conn.createStatement().execute(globalViewColumnDropDDL);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            newTableDDLTimestamp = getLastDDLTimestamp(conn,\n+                dataTableFullName);\n+            //table DDL timestamp shouldn't have changed\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName, TENANT1);\n+                //but tenant timestamp should have changed\n+                assertEquals(globalViewDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+        }\n+\n+    }\n+\n+    public static long getLastDDLTimestamp(Connection conn, String dataTableFullName) throws SQLException {\n+        return getLastDDLTimestamp(conn, dataTableFullName, \"\");\n+    }\n+\n+    private static long getLastDDLTimestamp(Connection conn, String dataTableFullName,\n+                                       String tenantId) throws SQLException {\n+        String schemaName = SchemaUtil.getSchemaNameFromFullName(dataTableFullName);\n+        String tableName = SchemaUtil.getTableNameFromFullName(dataTableFullName);\n+        PhoenixDatabaseMetaData metadata = (PhoenixDatabaseMetaData) conn.getMetaData();\n+        ResultSet rs = metadata.getTables(tenantId, schemaName, tableName, null);\n+        assertTrue(\"No metadata returned\", rs.next());\n+        Long ddlTimestamp = rs.getLong(PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP);\n+        assertNotNull(\"JDBC DDL timestamp is null!\", ddlTimestamp);\n+        return ddlTimestamp;\n+    }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTYwMQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512335601", "bodyText": "Can we add a test which confirms that ALTER SET  doesn't modify the timestamp?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:49:53Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java", "diffHunk": "@@ -1326,7 +1327,40 @@ public void testAddingColumnsToTablesAndViews() throws Exception {\n             assertSequenceNumber(schemaName, viewName, PTable.INITIAL_SEQ_NUM + 1);\n         }\n     }\n-\t\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String columnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDI5NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080295", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-10-27T22:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\nindex a8061ce35..c82c111ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\n\n@@ -1361,6 +1362,41 @@ public class AlterTableIT extends ParallelStatsDisabledIT {\n         }\n     }\n \n+    @Test\n+    public void testSetPropertyDoesntUpdateDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String setPropertyDDL = \"ALTER TABLE \" + dataTableFullName +\n+            \" SET UPDATE_CACHE_FREQUENCY=300000 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(setPropertyDDL);\n+            PhoenixDatabaseMetaData metadata = (PhoenixDatabaseMetaData) conn.getMetaData();\n+            ResultSet rs = metadata.getTables(\"\", schemaName, dataTableName, null);\n+            assertTrue(\"No metadata returned\", rs.next());\n+            Long jdbcDDLTimestamp = rs.getLong(PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP);\n+            assertNotNull(\"JDBC DDL timestamp is null!\", jdbcDDLTimestamp);\n+            assertEquals(tableDDLTimestamp, jdbcDDLTimestamp.longValue());\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, dataTableFullName);\n+            assertNotNull(table);\n+            assertNotNull(table.getLastDDLTimestamp());\n+            assertEquals(tableDDLTimestamp, table.getLastDDLTimestamp().longValue());\n+        }\n+    }\n+\n \tprivate void assertEncodedCQValue(String columnFamily, String columnName, String schemaName, String tableName, int expectedValue) throws Exception {\n         String query = \"SELECT \" + COLUMN_QUALIFIER + \" FROM \\\"SYSTEM\\\".CATALOG WHERE \" + TABLE_SCHEM + \" = ? AND \" + TABLE_NAME\n                 + \" = ? \" + \" AND \" + COLUMN_FAMILY + \" = ?\" + \" AND \" + COLUMN_NAME  + \" = ?\" + \" AND \" + COLUMN_QUALIFIER  + \" IS NOT NULL\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTkzNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512335935", "bodyText": "Do we need some tests to confirm tenant-view behavior? And then subsequently make this helper method work for resolving those?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:50:54Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java", "diffHunk": "@@ -910,6 +911,48 @@ public void testTableDescriptorPriority() throws SQLException, IOException {\n         }\n     }\n \n+    @Test\n+    public void testCreateTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        final String schemaName = generateUniqueName();\n+        final String tableName = generateUniqueName();\n+        final String dataTableFullName = SchemaUtil.getTableName(schemaName, tableName);\n+        String ddl =\n+            \"CREATE TABLE \" + dataTableFullName + \" (\\n\" + \"ID1 VARCHAR(15) NOT NULL,\\n\"\n+                + \"ID2 VARCHAR(15) NOT NULL,\\n\" + \"CREATED_DATE DATE,\\n\"\n+                + \"CREATION_TIME BIGINT,\\n\" + \"LAST_USED DATE,\\n\"\n+                + \"CONSTRAINT PK PRIMARY KEY (ID1, ID2)) \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(ddl);\n+            verifyLastDDLTimestamp(schemaName, tableName, dataTableFullName, startTS, conn);\n+        }\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n+        long endTS = EnvironmentEdgeManager.currentTimeMillis();\n+        //First try the JDBC metadata API\n+        PhoenixDatabaseMetaData metadata = (PhoenixDatabaseMetaData) conn.getMetaData();\n+        ResultSet rs = metadata.getTables(\"\", schemaName, tableName, null);\n+        assertTrue(\"No metadata returned\", rs.next());\n+        Long ddlTimestamp = rs.getLong(PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP);\n+        assertNotNull(\"JDBC DDL timestamp is null!\", ddlTimestamp);\n+        assertTrue(\"JDBC DDL Timestamp not in the right range!\",\n+            ddlTimestamp >= startTS && ddlTimestamp <= endTS);\n+        //Now try the PTable API\n+        PTable table = PhoenixRuntime.getTableNoCache(conn, dataTableFullName);", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDM3MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080370", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-10-27T22:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzNTkzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java\nindex 86cd917d4..f09298290 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java\n\n@@ -931,10 +931,15 @@ public class CreateTableIT extends ParallelStatsDisabledIT {\n \n     public static long verifyLastDDLTimestamp(String schemaName, String tableName,\n                                               String dataTableFullName, long startTS, Connection conn) throws SQLException {\n+        return verifyLastDDLTimestamp(\"\", schemaName, tableName, dataTableFullName, startTS, conn);\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String tenantId, String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n         long endTS = EnvironmentEdgeManager.currentTimeMillis();\n         //First try the JDBC metadata API\n         PhoenixDatabaseMetaData metadata = (PhoenixDatabaseMetaData) conn.getMetaData();\n-        ResultSet rs = metadata.getTables(\"\", schemaName, tableName, null);\n+        ResultSet rs = metadata.getTables(tenantId, schemaName, tableName, null);\n         assertTrue(\"No metadata returned\", rs.next());\n         Long ddlTimestamp = rs.getLong(PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP);\n         assertNotNull(\"JDBC DDL timestamp is null!\", ddlTimestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODM1Mg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512338352", "bodyText": "Can we add a simple unit test for this inside MetaDataUtilTest?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:59:12Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java", "diffHunk": "@@ -107,6 +107,18 @@\n             HColumnDescriptor.KEEP_DELETED_CELLS,\n             HColumnDescriptor.REPLICATION_SCOPE);\n \n+    public static Mutation getLastDDLTimestampUpdate(byte[] tableHeaderRowKey,", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDQwMQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080401", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-10-27T22:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODM1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java\nindex 22d9b462c..bd37629d9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java\n\n@@ -107,7 +107,7 @@ public class MetaDataUtil {\n             HColumnDescriptor.KEEP_DELETED_CELLS,\n             HColumnDescriptor.REPLICATION_SCOPE);\n \n-    public static Mutation getLastDDLTimestampUpdate(byte[] tableHeaderRowKey,\n+    public static Put getLastDDLTimestampUpdate(byte[] tableHeaderRowKey,\n                                                      long clientTimestamp,\n                                                      long lastDDLTimestamp) {\n         //use client timestamp as the timestamp of the Cell, to match the other Cells that might\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512338581", "bodyText": "This will get triggered even for ALTER TABLE/VIEW SET <property>. I thought we didn't want to update the ddl timestamp in those cases.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-26T23:59:52Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -399,6 +399,10 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n+        //We're changing the application-facing schema by adding a column, so update the DDL\n+        // timestamp\n+        additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg0MzQ5Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512843496", "bodyText": "SET property goes through the column add logic? Thanks, didn't know that, will change the logic to not update the timestamp if no columns are being added, then add a test as you recommend above.", "author": "gjacoby126", "createdAt": "2020-10-27T16:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5NTg3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512895873", "bodyText": "Yes, thanks.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T17:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MDQ3Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r513080477", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-10-27T22:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzODU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\nindex 73b89a87a..4f6706154 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n\n@@ -399,10 +401,19 @@ public class AddColumnMutator implements ColumnMutator {\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n-        //We're changing the application-facing schema by adding a column, so update the DDL\n-        // timestamp\n-        additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n-            clientTimeStamp, EnvironmentEdgeManager.currentTimeMillis()));\n+        if (isAddingColumns) {\n+            //We're changing the application-facing schema by adding a column, so update the DDL\n+            // timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+            for (PTable viewTable : childViews) {\n+                byte[] viewHeaderRowKey = SchemaUtil.getTableKey(viewTable);\n+                additionalTableMetadataMutations.add(\n+                    MetaDataUtil.getLastDDLTimestampUpdate(viewHeaderRowKey,\n+                        clientTimeStamp, serverTimestamp));\n+            }\n+        }\n         tableMetaData.addAll(additionalTableMetadataMutations);\n         if (type == PTableType.VIEW) {\n             if ( EncodedColumnsUtil.usesEncodedColumnNames(table) && addingCol &&\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0Nzg2Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512347866", "bodyText": "This seems risky since we are relying on the fact that the PTable returned from the server has all the necessary attributes set as the PTable we create on the client-side. There are some that we set explicitly inside MetaDataClient which depend on the parent so I'm not sure we still have those set as expected.\nInstead, to be safe we can maybe getDDLTimestamp() from this returned PTable and set that in the builder. Better yet, we could just send the DDL timestamp in the server response rather than the entire PTable. We could then use the setter for this attribute when creating the PTable from its builder.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T00:33:17Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -3048,7 +3048,13 @@ public boolean isViewReferenced() {\n              * the counter as NULL_COUNTER for extra safety.\n              */\n             EncodedCQCounter cqCounterToBe = tableType == PTableType.VIEW ? NULL_COUNTER : cqCounter;\n-            PTable table = new PTableImpl.Builder()\n+            PTable table;\n+            //better to use the table sent back from the server so we get an accurate DDL\n+            // timestamp, which is server-generated.\n+            if (result.getTable() != null ) {", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg0NzM5OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512847398", "bodyText": "It seems strange that System.Catalog is the source of truth, we've just been there on the server, and yet the client copy controls. Will look closer at MetadataClient as you suggest to understand why.\nAre we missing tests? Because assuming the client-side copy should control, my replacing it with the server-side copy should have broken tests somewhere, and it doesn't appear to.", "author": "gjacoby126", "createdAt": "2020-10-27T16:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0Nzg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNjY3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512906673", "bodyText": "I'm not sure that would be covered by a test since we'd only see it if the test were to actually look at the cached PTable rather than say doing a PhoenixRuntime.getTableNoCache() right? Since we're changing what is cached, we should add some tests around this now to make sure the PTable has all expected fields set.\nI see some tests that should cover this code path inside AlterTableWithViewsIT (like testAlterPropertiesOfParentTable()) and also some in ViewTTLIT, but I'm not sure to what extent they would capture this.\nI'm mostly worried about things like setting certain properties based on the parent PTable or overriding null properties with the default values, etc. (see this and this). That's where I'm not sure that the PTable returned from the server will be identical to the one that's created by the client today, since I don't see any code in MetaDataEndpointImpl that does this.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T17:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0Nzg2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\nindex d4c5257b6..afe2adaf5 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n\n@@ -3048,68 +3062,63 @@ public class MetaDataClient {\n              * the counter as NULL_COUNTER for extra safety.\n              */\n             EncodedCQCounter cqCounterToBe = tableType == PTableType.VIEW ? NULL_COUNTER : cqCounter;\n-            PTable table;\n-            //better to use the table sent back from the server so we get an accurate DDL\n-            // timestamp, which is server-generated.\n-            if (result.getTable() != null ) {\n-                table = result.getTable();\n-            } else {\n-                table = new PTableImpl.Builder()\n-                    .setType(tableType)\n-                    .setState(indexState)\n-                    .setTimeStamp(timestamp != null ? timestamp : result.getMutationTime())\n-                    .setIndexDisableTimestamp(0L)\n-                    .setSequenceNumber(PTable.INITIAL_SEQ_NUM)\n-                    .setImmutableRows(isImmutableRows)\n-                    .setViewStatement(viewStatement)\n-                    .setDisableWAL(Boolean.TRUE.equals(disableWAL))\n-                    .setMultiTenant(multiTenant)\n-                    .setStoreNulls(storeNulls)\n-                    .setViewType(viewType)\n-                    .setViewIndexIdType(viewIndexIdType)\n-                    .setViewIndexId(result.getViewIndexId())\n-                    .setIndexType(indexType)\n-                    .setTransactionProvider(transactionProvider)\n-                    .setUpdateCacheFrequency(updateCacheFrequency)\n-                    .setNamespaceMapped(isNamespaceMapped)\n-                    .setAutoPartitionSeqName(autoPartitionSeq)\n-                    .setAppendOnlySchema(isAppendOnlySchema)\n-                    .setImmutableStorageScheme(immutableStorageScheme == null ?\n-                        ImmutableStorageScheme.ONE_CELL_PER_COLUMN : immutableStorageScheme)\n-                    .setQualifierEncodingScheme(encodingScheme == null ?\n-                        QualifierEncodingScheme.NON_ENCODED_QUALIFIERS : encodingScheme)\n-                    .setBaseColumnCount(baseTableColumnCount)\n-                    .setEncodedCQCounter(cqCounterToBe)\n-                    .setUseStatsForParallelization(useStatsForParallelizationProp)\n-                    .setExcludedColumns(ImmutableList.<PColumn>of())\n-                    .setTenantId(tenantId)\n-                    .setSchemaName(newSchemaName)\n-                    .setTableName(PNameFactory.newName(tableName))\n-                    .setPkName(pkName == null ? null : PNameFactory.newName(pkName))\n-                    .setDefaultFamilyName(defaultFamilyName == null ?\n-                        null : PNameFactory.newName(defaultFamilyName))\n-                    .setRowKeyOrderOptimizable(rowKeyOrderOptimizable)\n-                    .setBucketNum(saltBucketNum)\n-                    .setIndexes(Collections.<PTable>emptyList())\n-                    .setParentSchemaName((parent == null) ? null : parent.getSchemaName())\n-                    .setParentTableName((parent == null) ? null : parent.getTableName())\n-                    .setPhysicalNames(physicalNames == null ?\n-                        ImmutableList.<PName>of() : ImmutableList.copyOf(physicalNames))\n-                    .setColumns(columns.values())\n-                    .setPhoenixTTL(phoenixTTL == null ? PHOENIX_TTL_NOT_DEFINED : phoenixTTL)\n-                    .setPhoenixTTLHighWaterMark(phoenixTTLHighWaterMark == null ? MIN_PHOENIX_TTL_HWM : phoenixTTLHighWaterMark)\n-                    .setViewModifiedUpdateCacheFrequency(tableType == PTableType.VIEW &&\n-                        parent != null &&\n-                        parent.getUpdateCacheFrequency() != updateCacheFrequency)\n-                    .setViewModifiedUseStatsForParallelization(tableType == PTableType.VIEW &&\n-                        parent != null &&\n-                        parent.useStatsForParallelization()\n-                            != useStatsForParallelizationProp)\n-                    .setViewModifiedPhoenixTTL(tableType == PTableType.VIEW &&\n-                        parent != null && phoenixTTL != null &&\n-                        parent.getPhoenixTTL() != phoenixTTL)\n-                    .build();\n-            }\n+            PTable table = new PTableImpl.Builder()\n+                .setType(tableType)\n+                .setState(indexState)\n+                .setTimeStamp(timestamp != null ? timestamp : result.getMutationTime())\n+                .setIndexDisableTimestamp(0L)\n+                .setSequenceNumber(PTable.INITIAL_SEQ_NUM)\n+                .setImmutableRows(isImmutableRows)\n+                .setViewStatement(viewStatement)\n+                .setDisableWAL(Boolean.TRUE.equals(disableWAL))\n+                .setMultiTenant(multiTenant)\n+                .setStoreNulls(storeNulls)\n+                .setViewType(viewType)\n+                .setViewIndexIdType(viewIndexIdType)\n+                .setViewIndexId(result.getViewIndexId())\n+                .setIndexType(indexType)\n+                .setTransactionProvider(transactionProvider)\n+                .setUpdateCacheFrequency(updateCacheFrequency)\n+                .setNamespaceMapped(isNamespaceMapped)\n+                .setAutoPartitionSeqName(autoPartitionSeq)\n+                .setAppendOnlySchema(isAppendOnlySchema)\n+                .setImmutableStorageScheme(immutableStorageScheme == null ?\n+                    ImmutableStorageScheme.ONE_CELL_PER_COLUMN : immutableStorageScheme)\n+                .setQualifierEncodingScheme(encodingScheme == null ?\n+                    QualifierEncodingScheme.NON_ENCODED_QUALIFIERS : encodingScheme)\n+                .setBaseColumnCount(baseTableColumnCount)\n+                .setEncodedCQCounter(cqCounterToBe)\n+                .setUseStatsForParallelization(useStatsForParallelizationProp)\n+                .setExcludedColumns(ImmutableList.<PColumn>of())\n+                .setTenantId(tenantId)\n+                .setSchemaName(newSchemaName)\n+                .setTableName(PNameFactory.newName(tableName))\n+                .setPkName(pkName == null ? null : PNameFactory.newName(pkName))\n+                .setDefaultFamilyName(defaultFamilyName == null ?\n+                    null : PNameFactory.newName(defaultFamilyName))\n+                .setRowKeyOrderOptimizable(rowKeyOrderOptimizable)\n+                .setBucketNum(saltBucketNum)\n+                .setIndexes(Collections.<PTable>emptyList())\n+                .setParentSchemaName((parent == null) ? null : parent.getSchemaName())\n+                .setParentTableName((parent == null) ? null : parent.getTableName())\n+                .setPhysicalNames(physicalNames == null ?\n+                    ImmutableList.<PName>of() : ImmutableList.copyOf(physicalNames))\n+                .setColumns(columns.values())\n+                .setPhoenixTTL(phoenixTTL == null ? PHOENIX_TTL_NOT_DEFINED : phoenixTTL)\n+                .setPhoenixTTLHighWaterMark(phoenixTTLHighWaterMark == null ? MIN_PHOENIX_TTL_HWM : phoenixTTLHighWaterMark)\n+                .setViewModifiedUpdateCacheFrequency(tableType == PTableType.VIEW &&\n+                    parent != null &&\n+                    parent.getUpdateCacheFrequency() != updateCacheFrequency)\n+                .setViewModifiedUseStatsForParallelization(tableType == PTableType.VIEW &&\n+                    parent != null &&\n+                    parent.useStatsForParallelization()\n+                        != useStatsForParallelizationProp)\n+                .setViewModifiedPhoenixTTL(tableType == PTableType.VIEW &&\n+                    parent != null && phoenixTTL != null &&\n+                    parent.getPhoenixTTL() != phoenixTTL)\n+                .setLastDDLTimestamp(result.getTable() != null ?\n+                    result.getTable().getLastDDLTimestamp() : null)\n+                .build();\n             result = new MetaDataMutationResult(code, result.getMutationTime(), table, true);\n             addTableToCache(result);\n             return table;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0ODU0Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512348546", "bodyText": "It might be better to just send the DDL timestamp from the server instead of the entire PTable. This is because on the client, we set certain properties which may be derived from the parent, etc. so we probably can't blindly cache the PTable that is returned from the server anyhow.", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T00:36:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2100,6 +2115,13 @@ public void createTable(RpcController controller, CreateTableRequest request,\n                     builder.setViewIndexIdType(PLong.INSTANCE.getSqlType());\n                 }\n                 builder.setMutationTime(currentTimeStamp);\n+                //send the newly built table back because we generated the DDL timestamp server\n+                // side and the client doesn't have it.\n+                PTable newTable = buildTable(tableKey, cacheKey, region,\n+                    clientTimeStamp, clientVersion);\n+                if (newTable != null) {", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1MDE3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r512350173", "bodyText": "Similar kind of concern here?", "author": "ChinmaySKulkarni", "createdAt": "2020-10-27T00:42:16Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -4416,10 +4423,15 @@ else if (columnToDrop.isViewReferenced()) {\n                     // client-side cache as it would be too painful. Just let it pull it over from\n                     // the server when needed.\n                     if (tableColumnsToDrop.size() > 0) {\n-                        if (removedIndexTableOrColumn)\n+                        if (removedIndexTableOrColumn) {\n                             connection.removeTable(tenantId, tableName, table.getParentName() == null ? null : table.getParentName().getString(), table.getTimeStamp());\n-                        else\n-                            connection.removeColumn(tenantId, SchemaUtil.getTableName(schemaName, tableName) , tableColumnsToDrop, result.getMutationTime(), seqNum, TransactionUtil.getResolvedTime(connection, result));\n+                        }\n+                        else {\n+                            //replace the cache of this table with the updated one we got back\n+                            // from the server\n+                            connection.addTable(result.getTable(),", "originalCommit": "51cbc3ed03f0ac8baf82772839752517defb54b4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5252eda018d17a0ae0e1e95d61de1745db954283", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\nindex d4c5257b6..afe2adaf5 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n\n@@ -4423,15 +4439,9 @@ public class MetaDataClient {\n                     // client-side cache as it would be too painful. Just let it pull it over from\n                     // the server when needed.\n                     if (tableColumnsToDrop.size() > 0) {\n-                        if (removedIndexTableOrColumn) {\n-                            connection.removeTable(tenantId, tableName, table.getParentName() == null ? null : table.getParentName().getString(), table.getTimeStamp());\n-                        }\n-                        else {\n-                            //replace the cache of this table with the updated one we got back\n-                            // from the server\n-                            connection.addTable(result.getTable(),\n-                                TransactionUtil.getResolvedTime(connection, result));\n-                        }\n+                        //need to remove the cached table because the DDL timestamp changed. We\n+                        // also need to remove it if we dropped an indexed column\n+                        connection.removeTable(tenantId, tableName, table.getParentName() == null ? null : table.getParentName().getString(), table.getTimeStamp());\n                     }\n                     // If we have a VIEW, then only delete the metadata, and leave the table data alone\n                     if (table.getType() != PTableType.VIEW) {\n"}}, {"oid": "5252eda018d17a0ae0e1e95d61de1745db954283", "url": "https://github.com/apache/phoenix/commit/5252eda018d17a0ae0e1e95d61de1745db954283", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-05T17:55:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520170305", "bodyText": "In splittable-SYSTEM.CATALOG world, we avoid making synchronous changes to child views when the parent changes, so if a column is added to the parent, we wouldn't add that to each child view's metadata. Instead on resolving the view, we'd combine the parent columns and inherit them that way. This was done for scalability in case child views span many SYSCAT regions. I'm wondering if we can use similar inheritance logic for lastDDLTs of child views.\nThis becomes more complicated for diverged views. In that case, any columns added to a parent view/physical table are inherited by its child views only if they haven't diverged. In those cases, the LastDDLTs for diverged views ideally shouldn't even be modified if a column is added to its parent.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:48:02Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -399,6 +401,19 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n+        if (isAddingColumns) {\n+            //We're changing the application-facing schema by adding a column, so update the DDL\n+            // timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+            for (PTable viewTable : childViews) {", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTE5NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520171195", "bodyText": "Another complication is, pre-4.15 clients do not have this logic to just store view-specific columns. They don't have EXCLUDED_COLUMN linking rows either. The parent column combining logic in those cases is different too.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MDc3Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521480773", "bodyText": "@ChinmaySKulkarni - I see how inheritance logic could work for PTables, but how would we make that work for the JDBC metadata API? (see PhoenixDatabaseMetaData) I'm asserting throughout my tests that PTables and the metadata API give the same answers, but the metadata API is, I believe, just querying the table or view header row in System.Catalog.\n(Technically, the JDBC metadata API is the \"public\" one and the PTables API is the \"private\" one, though in all the external Phoenix-based applications I work with for my day job, I've switched to using PTables because the JDBC metadata API is just too inefficient since it never caches results.)\nAlso just want to note that in a follow-up JIRA to this, we're going to need to (optionally) call to an external schema registry when we create a table/view or add/remove a column from a table/view, and that will need to be synchronous, because the schema needs to be in the schema registry before DML using that schema starts being processed by the replication pipeline.", "author": "gjacoby126", "createdAt": "2020-11-11T16:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MTY4NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521481685", "bodyText": "Will make sure to exempt diverged columns, thanks for pointing that out.", "author": "gjacoby126", "createdAt": "2020-11-11T16:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUyOTIzMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521529233", "bodyText": "@ChinmaySKulkarni - is there an authoritative way to tell if a view is diverged? I don't see a PTable property. Is ViewUtil.isDivergedView(PTable) usable? Would I have to use ViewUtil.isDivergingView(PColumn, PTable) instead? Thanks!", "author": "gjacoby126", "createdAt": "2020-11-11T17:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MDMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\nindex 4f6706154..446f86f93 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n\n@@ -405,14 +404,12 @@ public class AddColumnMutator implements ColumnMutator {\n             //We're changing the application-facing schema by adding a column, so update the DDL\n             // timestamp\n             long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n-            additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n-                clientTimeStamp, serverTimestamp));\n-            for (PTable viewTable : childViews) {\n-                byte[] viewHeaderRowKey = SchemaUtil.getTableKey(viewTable);\n-                additionalTableMetadataMutations.add(\n-                    MetaDataUtil.getLastDDLTimestampUpdate(viewHeaderRowKey,\n-                        clientTimeStamp, serverTimestamp));\n+            if (MetaDataUtil.isTableQueryable(table.getType())) {\n+                additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                    clientTimeStamp, serverTimestamp));\n             }\n+            //we don't need to update the DDL timestamp for child views, because when we look up\n+            // a PTable, we'll take the max timestamp of a view and all its ancestors\n         }\n         tableMetaData.addAll(additionalTableMetadataMutations);\n         if (type == PTableType.VIEW) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTI3OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520171278", "bodyText": "Same concerns here with parent column inheritance and diverged views, etc.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:49:55Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,7 +272,20 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n-        tableMetaData.addAll(additionalTableMetaData);\n+        if (isDroppingColumns) {\n+            //We're changing the application-facing schema by dropping a column, so update the DDL\n+            // timestamp to current _server_ timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+            for (PTable viewTable : childViews) {", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\nindex 6b52369a7..916dd75ac 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n\n@@ -272,20 +272,17 @@ public class DropColumnMutator implements ColumnMutator {\n             }\n \n         }\n-        if (isDroppingColumns) {\n-            //We're changing the application-facing schema by dropping a column, so update the DDL\n-            // timestamp to current _server_ timestamp\n+        //We're changing the application-facing schema by dropping a column, so update the DDL\n+        // timestamp to current _server_ timestamp\n+        if (MetaDataUtil.isTableQueryable(table.getType())) {\n             long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n             additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n                 clientTimeStamp, serverTimestamp));\n-            for (PTable viewTable : childViews) {\n-                byte[] viewHeaderRowKey = SchemaUtil.getTableKey(viewTable);\n-                additionalTableMetaData.add(\n-                    MetaDataUtil.getLastDDLTimestampUpdate(viewHeaderRowKey,\n-                        clientTimeStamp, serverTimestamp));\n-            }\n-            tableMetaData.addAll(additionalTableMetaData);\n         }\n+        //we don't need to update the DDL timestamp for any child views we may have, because\n+        // when we look up a PTable for any of those child views, we'll take the max timestamp\n+        // of the view and all its ancestors\n+        tableMetaData.addAll(additionalTableMetaData);\n         if (deletePKColumn) {\n             if (table.getPKColumns().size() == 1) {\n                 return new MetaDataProtocol.MetaDataMutationResult(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MzM2Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520173367", "bodyText": "Why are we changing this?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T22:54:33Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataProtocol.java", "diffHunk": "@@ -94,7 +94,7 @@\n     public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_13_0 = MIN_SYSTEM_TABLE_TIMESTAMP_4_11_0;\n     public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_14_0 = MIN_TABLE_TIMESTAMP + 28;\n     public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_15_0 = MIN_TABLE_TIMESTAMP + 29;\n-    public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 = MIN_TABLE_TIMESTAMP + 31;\n+    public static final long MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 = MIN_TABLE_TIMESTAMP + 33;", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNjMxMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525336310", "bodyText": "As I mentioned in a different comment, each syscat column's timestamp needs to be unique", "author": "gjacoby126", "createdAt": "2020-11-17T17:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MzM2Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3NzU1OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520177558", "bodyText": "I'm a little unclear on these changes. Shouldn't all these 4.16-specific columns be added at the 4.16 ts rather than 4.16 ts - something?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:04:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java", "diffHunk": "@@ -3707,15 +3709,20 @@ protected PhoenixConnection upgradeSystemCatalogIfRequired(PhoenixConnection met\n             metaConnection = addColumnsIfNotExists(\n                 metaConnection,\n                 PhoenixDatabaseMetaData.SYSTEM_CATALOG,\n-                MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 - 1,\n+                MIN_SYSTEM_TABLE_TIMESTAMP_4_16_0 - 2,", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyNjMyMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521026323", "bodyText": "@ChinmaySKulkarni  The upgrade code requires that each new column has a distinct timestamp (for some reason)", "author": "gjacoby126", "createdAt": "2020-11-11T02:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3NzU1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTU0Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520179546", "bodyText": "nit: Instead of using u and v, use PTableType.. API", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:09:57Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java", "diffHunk": "@@ -2586,4 +2588,18 @@ public static boolean isNoUpgradeSet(Properties props) {\n     public static void doNotUpgradeOnFirstConnection(Properties props) {\n         props.setProperty(DO_NOT_UPGRADE, String.valueOf(true));\n     }\n+\n+    //When upgrading to Phoenix 4.16, make each existing table's DDL timestamp equal to its last\n+    // updated row timestamp.\n+    public static void bootstrapLastDDLTimestamp(PhoenixConnection metaConnection) throws SQLException  {\n+        String pkCols = TENANT_ID + \", \" + TABLE_SCHEM +\n+            \", \" + TABLE_NAME + \", \" + COLUMN_NAME + \", \" + COLUMN_FAMILY;\n+        String upsertSql =\n+            \"UPSERT INTO \" + SYSTEM_CATALOG_NAME + \" (\" + pkCols + \", \" +\n+        LAST_DDL_TIMESTAMP + \")\" + \" \" +\n+            \"SELECT \" + pkCols + \", PHOENIX_ROW_TIMESTAMP() FROM \" + SYSTEM_CATALOG_NAME + \" \" +\n+                \"WHERE \" + TABLE_TYPE + \" \" + \" in \" + \"('u','v')\";", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4ODg2OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520188868", "bodyText": "Also, can we add a comment about why we don't do this for system tables and indexes? Might be better to invert the condition and say WHERE TABLE_TYPE NOT IN ('s', i')", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAzMDUwOA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521030508", "bodyText": "Because I affirmatively only intend for it to affect tables and views, not \"not system tables or indexes\". I'll add a comment in the code though, good point.\nThe reason, btw, is that only tables and views are relevant schema for external systems trying to interpret Phoenix data. (This is a pre-req change for Phoenix change data capture, to allow Phoenix DML to be emitted as schema'ed messages into a message bus.) Indexes are an internal Phoenix optimization, and system tables are internal Phoenix config; no other system or external schema registry should care about them.\nIf some other kind of Phoenix schema object is created later, I'd want whoever creates it to opt-in to having a ddl timestamp, not need to remember to opt-out.", "author": "gjacoby126", "createdAt": "2020-11-11T02:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java\nindex 905471b13..58c275725 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java\n\n@@ -2591,15 +2591,20 @@ public class UpgradeUtil {\n \n     //When upgrading to Phoenix 4.16, make each existing table's DDL timestamp equal to its last\n     // updated row timestamp.\n-    public static void bootstrapLastDDLTimestamp(PhoenixConnection metaConnection) throws SQLException  {\n+    public static void bootstrapLastDDLTimestamp(Connection metaConnection) throws SQLException  {\n         String pkCols = TENANT_ID + \", \" + TABLE_SCHEM +\n             \", \" + TABLE_NAME + \", \" + COLUMN_NAME + \", \" + COLUMN_FAMILY;\n-        String upsertSql =\n+        final String upsertSql =\n             \"UPSERT INTO \" + SYSTEM_CATALOG_NAME + \" (\" + pkCols + \", \" +\n         LAST_DDL_TIMESTAMP + \")\" + \" \" +\n             \"SELECT \" + pkCols + \", PHOENIX_ROW_TIMESTAMP() FROM \" + SYSTEM_CATALOG_NAME + \" \" +\n-                \"WHERE \" + TABLE_TYPE + \" \" + \" in \" + \"('u','v')\";\n-        metaConnection.createStatement().execute(upsertSql);\n-        metaConnection.commit();\n+                \"WHERE \" + TABLE_TYPE + \" \" + \" in \" + \"('\" + PTableType.TABLE.getSerializedValue()\n+                + \"', '\" + PTableType.VIEW.getSerializedValue() + \"')\";\n+        LOGGER.info(\"Setting DDL timestamps for tables and views to row timestamps\");\n+        try (PreparedStatement stmt = metaConnection.prepareStatement(upsertSql)) {\n+            stmt.execute();\n+            metaConnection.commit();\n+        }\n+        LOGGER.info(\"Setting DDL timestamps for tables and views is complete\");\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3OTg5OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520179899", "bodyText": "Can we add a log before and after this UPSERT SELECT to help track the upgrade progress?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:10:51Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java", "diffHunk": "@@ -2586,4 +2588,18 @@ public static boolean isNoUpgradeSet(Properties props) {\n     public static void doNotUpgradeOnFirstConnection(Properties props) {\n         props.setProperty(DO_NOT_UPGRADE, String.valueOf(true));\n     }\n+\n+    //When upgrading to Phoenix 4.16, make each existing table's DDL timestamp equal to its last\n+    // updated row timestamp.\n+    public static void bootstrapLastDDLTimestamp(PhoenixConnection metaConnection) throws SQLException  {\n+        String pkCols = TENANT_ID + \", \" + TABLE_SCHEM +", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java\nindex 905471b13..58c275725 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/UpgradeUtil.java\n\n@@ -2591,15 +2591,20 @@ public class UpgradeUtil {\n \n     //When upgrading to Phoenix 4.16, make each existing table's DDL timestamp equal to its last\n     // updated row timestamp.\n-    public static void bootstrapLastDDLTimestamp(PhoenixConnection metaConnection) throws SQLException  {\n+    public static void bootstrapLastDDLTimestamp(Connection metaConnection) throws SQLException  {\n         String pkCols = TENANT_ID + \", \" + TABLE_SCHEM +\n             \", \" + TABLE_NAME + \", \" + COLUMN_NAME + \", \" + COLUMN_FAMILY;\n-        String upsertSql =\n+        final String upsertSql =\n             \"UPSERT INTO \" + SYSTEM_CATALOG_NAME + \" (\" + pkCols + \", \" +\n         LAST_DDL_TIMESTAMP + \")\" + \" \" +\n             \"SELECT \" + pkCols + \", PHOENIX_ROW_TIMESTAMP() FROM \" + SYSTEM_CATALOG_NAME + \" \" +\n-                \"WHERE \" + TABLE_TYPE + \" \" + \" in \" + \"('u','v')\";\n-        metaConnection.createStatement().execute(upsertSql);\n-        metaConnection.commit();\n+                \"WHERE \" + TABLE_TYPE + \" \" + \" in \" + \"('\" + PTableType.TABLE.getSerializedValue()\n+                + \"', '\" + PTableType.VIEW.getSerializedValue() + \"')\";\n+        LOGGER.info(\"Setting DDL timestamps for tables and views to row timestamps\");\n+        try (PreparedStatement stmt = metaConnection.prepareStatement(upsertSql)) {\n+            stmt.execute();\n+            metaConnection.commit();\n+        }\n+        LOGGER.info(\"Setting DDL timestamps for tables and views is complete\");\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4ODEyNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r520188127", "bodyText": "Do we want to restrict this to just tables and views i.e. 'u' and 'v' table_types? The upgrade code only adds a ts for existing tables and views, but not indexes and SYSTEM tables, but here we do it for all types. There will be inconsistency in that case between an index created before the 4.16 metadata upgrade (no ts) vs an index created after the 4.16 metadata upgrade (has ts), not to mention fresh clusters will have a ts for all entities.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-09T23:32:47Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2037,7 +2049,10 @@ public void createTable(RpcController controller, CreateTableRequest request,\n                     // view's property in case they are different from the parent\n                     ViewUtil.addTagsToPutsForViewAlteredProperties(tableMetadata, parentTable);\n                 }\n-\n+                //set the last DDL timestamp to the current server time since we're creating the\n+                // table\n+                tableMetadata.add(MetaDataUtil.getLastDDLTimestampUpdate(tableKey,\n+                    clientTimeStamp, EnvironmentEdgeManager.currentTimeMillis()));", "originalCommit": "5252eda018d17a0ae0e1e95d61de1745db954283", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAzMTI0MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r521031241", "bodyText": "Thanks, didn't realize those other types also went through that code path. Will add the restriction.", "author": "gjacoby126", "createdAt": "2020-11-11T02:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4ODEyNw=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\nindex b8d0abe3e..7f163067f 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n\n@@ -2050,9 +2049,13 @@ public class MetaDataEndpointImpl extends MetaDataProtocol implements Coprocesso\n                     ViewUtil.addTagsToPutsForViewAlteredProperties(tableMetadata, parentTable);\n                 }\n                 //set the last DDL timestamp to the current server time since we're creating the\n-                // table\n-                tableMetadata.add(MetaDataUtil.getLastDDLTimestampUpdate(tableKey,\n-                    clientTimeStamp, EnvironmentEdgeManager.currentTimeMillis()));\n+                // table. We only need to do this for tables and views because indexes and system\n+                // tables aren't relevant to external systems that may be tracking our schema\n+                // changes.\n+                if (MetaDataUtil.isTableQueryable(tableType)) {\n+                    tableMetadata.add(MetaDataUtil.getLastDDLTimestampUpdate(tableKey,\n+                        clientTimeStamp, EnvironmentEdgeManager.currentTimeMillis()));\n+                }\n                 // When we drop a view we first drop the view metadata and then drop the parent->child linking row\n                 List<Mutation> localMutations =\n                         Lists.newArrayListWithExpectedSize(tableMetadata.size());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4NjkyMg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522486922", "bodyText": "Do we need to add childViews to validateAndAddMetadata method ? Maybe I am reading it wrong but I don't see childViews getting used either in AddColumnMutator#validateAndAddMetadata or DropColumnMutator#validateAndAddMetadata.", "author": "shahrs87", "createdAt": "2020-11-12T22:56:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -293,7 +293,9 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                                          List<ImmutableBytesPtr> invalidateList,\n                                                          List<Region.RowLock> locks,\n                                                          long clientTimeStamp,\n-                                                         long clientVersion) {\n+                                                         long clientVersion,\n+                                                         boolean isAddingColumns,\n+                                                         List<PTable> childViews) {", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0MTg5Mg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522541892", "bodyText": "Good catch, it was necessary in a prior draft but the code that used it was just removed. I'll remove the parameter.", "author": "gjacoby126", "createdAt": "2020-11-13T01:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4NjkyMg=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\nindex b4b3810bd..446f86f93 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n\n@@ -293,9 +293,8 @@ public class AddColumnMutator implements ColumnMutator {\n                                                          List<ImmutableBytesPtr> invalidateList,\n                                                          List<Region.RowLock> locks,\n                                                          long clientTimeStamp,\n-                                                         long clientVersion,\n-                                                         boolean isAddingColumns,\n-                                                         List<PTable> childViews) {\n+                                                         final long clientVersion,\n+                                                         final boolean isAddingColumns) {\n         byte[] tenantId = rowKeyMetaData[TENANT_ID_INDEX];\n         byte[] schemaName = rowKeyMetaData[SCHEMA_NAME_INDEX];\n         byte[] tableName = rowKeyMetaData[TABLE_NAME_INDEX];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4OTk2NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522489964", "bodyText": "tableMetaData.addAll(additionalTableMetaData);\nThe above line won't be executed if isDroppingColumns is false. Earlier it was getting executed even if we are dropping columns.", "author": "shahrs87", "createdAt": "2020-11-12T23:01:32Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,7 +272,19 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n-        tableMetaData.addAll(additionalTableMetaData);\n+        if (isDroppingColumns) {\n+            //We're changing the application-facing schema by dropping a column, so update the DDL\n+            // timestamp to current _server_ timestamp\n+            if (MetaDataUtil.isTableQueryable(table.getType())) {\n+                long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+                additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                    clientTimeStamp, serverTimestamp));\n+            }\n+            //we don't need to update the DDL timestamp for any child views we may have, because\n+            // when we look up a PTable for any of those child views, we'll take the max timestamp\n+            // of the view and all its ancestors\n+            tableMetaData.addAll(additionalTableMetaData);", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\nindex f0afd00fd..916dd75ac 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n\n@@ -272,19 +272,17 @@ public class DropColumnMutator implements ColumnMutator {\n             }\n \n         }\n-        if (isDroppingColumns) {\n-            //We're changing the application-facing schema by dropping a column, so update the DDL\n-            // timestamp to current _server_ timestamp\n-            if (MetaDataUtil.isTableQueryable(table.getType())) {\n-                long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n-                additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n-                    clientTimeStamp, serverTimestamp));\n-            }\n-            //we don't need to update the DDL timestamp for any child views we may have, because\n-            // when we look up a PTable for any of those child views, we'll take the max timestamp\n-            // of the view and all its ancestors\n-            tableMetaData.addAll(additionalTableMetaData);\n+        //We're changing the application-facing schema by dropping a column, so update the DDL\n+        // timestamp to current _server_ timestamp\n+        if (MetaDataUtil.isTableQueryable(table.getType())) {\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n         }\n+        //we don't need to update the DDL timestamp for any child views we may have, because\n+        // when we look up a PTable for any of those child views, we'll take the max timestamp\n+        // of the view and all its ancestors\n+        tableMetaData.addAll(additionalTableMetaData);\n         if (deletePKColumn) {\n             if (table.getPKColumns().size() == 1) {\n                 return new MetaDataProtocol.MetaDataMutationResult(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDY0MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522490640", "bodyText": "The changes here looks exactly same as the changes in AddColumnMutator. Can we create a helper method which accepts table and additionalTableMetaData as argument ?", "author": "shahrs87", "createdAt": "2020-11-12T23:03:10Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,7 +272,19 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n-        tableMetaData.addAll(additionalTableMetaData);\n+        if (isDroppingColumns) {", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0OTEyMg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522549122", "bodyText": "It's not really general-purpose enough to put in a standalone Util method in MetaDataUtil, and since it's only 3 lines repeated in 2 places I figured the minor violation of DRY (Don't Repeat Yourself) wasn't worth working around, since all alternatives I could think of seemed a little ugly.\nFor example, I could put a static utility method in one of the mutators, but then one depends on the other which couples classes that shouldn't be...", "author": "gjacoby126", "createdAt": "2020-11-13T01:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5MDY0MA=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\nindex f0afd00fd..916dd75ac 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n\n@@ -272,19 +272,17 @@ public class DropColumnMutator implements ColumnMutator {\n             }\n \n         }\n-        if (isDroppingColumns) {\n-            //We're changing the application-facing schema by dropping a column, so update the DDL\n-            // timestamp to current _server_ timestamp\n-            if (MetaDataUtil.isTableQueryable(table.getType())) {\n-                long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n-                additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n-                    clientTimeStamp, serverTimestamp));\n-            }\n-            //we don't need to update the DDL timestamp for any child views we may have, because\n-            // when we look up a PTable for any of those child views, we'll take the max timestamp\n-            // of the view and all its ancestors\n-            tableMetaData.addAll(additionalTableMetaData);\n+        //We're changing the application-facing schema by dropping a column, so update the DDL\n+        // timestamp to current _server_ timestamp\n+        if (MetaDataUtil.isTableQueryable(table.getType())) {\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n         }\n+        //we don't need to update the DDL timestamp for any child views we may have, because\n+        // when we look up a PTable for any of those child views, we'll take the max timestamp\n+        // of the view and all its ancestors\n+        tableMetaData.addAll(additionalTableMetaData);\n         if (deletePKColumn) {\n             if (table.getPKColumns().size() == 1) {\n                 return new MetaDataProtocol.MetaDataMutationResult(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjI1MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522506250", "bodyText": "Unable to understand the need of this field addingColumns in builder ? If we need this, then why not a corresponding field in DropColumn request.", "author": "shahrs87", "createdAt": "2020-11-12T23:36:28Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java", "diffHunk": "@@ -2285,6 +2286,7 @@ public MetaDataResponse call(MetaDataService instance) throws IOException {\n                     builder.setClientVersion(VersionUtil.encodeVersion(PHOENIX_MAJOR_VERSION, PHOENIX_MINOR_VERSION, PHOENIX_PATCH_NUMBER));\n                     if (parentTable!=null)\n                         builder.setParentTable(PTableImpl.toProto(parentTable));\n+                    builder.setAddingColumns(addingColumns);", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU0OTk0OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522549948", "bodyText": "In a drop column request, the answer is always \"true\" so there's no need to set the variable; it's hard-coded when the MetadataEndpointImpl creates the DropColumnMutator. (AddColumnRequests can either be to add columns or alter table properties, and we need to distinguish to know whether to update the DDL timestamp; a drop is always a drop.)\nI'll remove the (useless) check on the variable in DropColumnMutator to make that more clear.", "author": "gjacoby126", "createdAt": "2020-11-13T01:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2NzcwNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523067705", "bodyText": "Thank you for educating me. :)", "author": "shahrs87", "createdAt": "2020-11-13T16:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNjI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java b/phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java\nindex 4446c2e17..f0ae550f9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/query/ConnectionQueryServicesImpl.java\n\n@@ -2288,7 +2302,7 @@ public class ConnectionQueryServicesImpl extends DelegateQueryServices implement\n                         builder.setParentTable(PTableImpl.toProto(parentTable));\n                     builder.setAddingColumns(addingColumns);\n                     instance.addColumn(controller, builder.build(), rpcCallback);\n-                    if(controller.getFailedOn() != null) {\n+                    if (controller.getFailedOn() != null) {\n                         throw controller.getFailedOn();\n                     }\n                     return rpcCallback.get();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODE2NQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522508165", "bodyText": "Here we are adding just 1 filed to builder method. Can we please undo the formatting changes which is making the diff look more than actual changes.", "author": "shahrs87", "createdAt": "2020-11-12T23:42:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -3063,60 +3063,62 @@ public boolean isViewReferenced() {\n              */\n             EncodedCQCounter cqCounterToBe = tableType == PTableType.VIEW ? NULL_COUNTER : cqCounter;\n             PTable table = new PTableImpl.Builder()\n-                    .setType(tableType)", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MTY1Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522551653", "bodyText": "Sorry for the inconvenience, but the formatting changes fix the spacing from being incorrect to correct. GitHub does have a \"Hide whitespace changes\" in the setting icon near the top of the page, btw, to make it easier to ignore.", "author": "gjacoby126", "createdAt": "2020-11-13T01:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3NTc5Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523075797", "bodyText": "I know this is a very nit pick.. but for split lines the spacing rule is 8 spaces. For conditional/loop statements body I agree it is 4 spaces.", "author": "shahrs87", "createdAt": "2020-11-13T16:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODE2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522509409", "bodyText": "I am not that much aware of the change here but isn't system table directly queryable ?", "author": "shahrs87", "createdAt": "2020-11-12T23:43:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java", "diffHunk": "@@ -107,6 +107,29 @@\n             HColumnDescriptor.KEEP_DELETED_CELLS,\n             HColumnDescriptor.REPLICATION_SCOPE);\n \n+    public static Put getLastDDLTimestampUpdate(byte[] tableHeaderRowKey,\n+                                                     long clientTimestamp,\n+                                                     long lastDDLTimestamp) {\n+        //use client timestamp as the timestamp of the Cell, to match the other Cells that might\n+        // be created by this DDL. But the actual value will be a _server_ timestamp\n+        Put p = new Put(tableHeaderRowKey, clientTimestamp);\n+        byte[] lastDDLTimestampBytes = PLong.INSTANCE.toBytes(lastDDLTimestamp);\n+        p.addColumn(PhoenixDatabaseMetaData.TABLE_FAMILY_BYTES,\n+            PhoenixDatabaseMetaData.LAST_DDL_TIMESTAMP_BYTES, lastDDLTimestampBytes);\n+        return p;\n+    }\n+\n+    /**\n+     * Checks if a table is meant to be queried directly (and hence is relevant to external\n+     * systems tracking Phoenix schema)\n+     * @param tableType\n+     * @return True if a table or view, false otherwise (such as for an index, system table, or\n+     * subquery)\n+     */\n+    public static boolean isTableQueryable(PTableType tableType) {", "originalCommit": "d7e52a93c8d8b5becdf3dd2d8e1ec8fe18074459", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1MDcwNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r522550707", "bodyText": "I struggled to find a good name here. \"Queryable\" was the best I could think of, by which I meant that tables and views are meant to be queried, but while you can directly query an index and a system table, end users aren't really supposed to. The internal schema of an index or a system table shouldn't be relevant to an external schema registry trying to track the schema of Phoenix tables.\nHappy to hear other naming suggestions.", "author": "gjacoby126", "createdAt": "2020-11-13T01:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3NzU1Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523077557", "bodyText": "I am ok with the name just wanted to learn more context. thank you !", "author": "shahrs87", "createdAt": "2020-11-13T16:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1OTk0Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525459943", "bodyText": "I also think this name is a little confusing. Maybe something like isTableTypeDirectlyQueried() is more in line with what we mean", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwOTQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "939db6e26a7538da918f967c49f1ab43b8f0c806", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java\nindex bae88b338..637d2f56b 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/MetaDataUtil.java\n\n@@ -126,7 +126,7 @@ public class MetaDataUtil {\n      * @return True if a table or view, false otherwise (such as for an index, system table, or\n      * subquery)\n      */\n-    public static boolean isTableQueryable(PTableType tableType) {\n+    public static boolean isTableTypeDirectlyQueried(PTableType tableType) {\n         return tableType.equals(PTableType.TABLE) || tableType.equals(PTableType.VIEW);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTc0Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523035743", "bodyText": "is this comment carried forward from previous test and no longer relevant here ?", "author": "shahrs87", "createdAt": "2020-11-13T15:47:25Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java", "diffHunk": "@@ -1326,7 +1328,69 @@ public void testAddingColumnsToTablesAndViews() throws Exception {\n             assertSequenceNumber(schemaName, viewName, PTable.INITIAL_SEQ_NUM + 1);\n         }\n     }\n-\t\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String columnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testSetPropertyDoesntUpdateDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String setPropertyDDL = \"ALTER TABLE \" + dataTableFullName +\n+            \" SET UPDATE_CACHE_FREQUENCY=300000 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNDk1NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525324954", "bodyText": "@gjacoby126  looks like this comment was missed ?", "author": "shahrs87", "createdAt": "2020-11-17T16:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNTc0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\nindex 2cc57018b..e7d12b42f 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\n\n@@ -1331,7 +1334,6 @@ public class AlterTableIT extends ParallelStatsDisabledIT {\n \n     @Test\n     public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n-        Properties props = new Properties();\n         String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n             + \" ENTITY_ID integer NOT NULL,\"\n             + \" COL1 integer NOT NULL,\"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzg2MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523037861", "bodyText": "just 1 minor nit. DriverManager has method getConnection without Properties argument. We can use that in all newly added test cases since we don't override any properties here. If it is too much change please feel free to ignore also.", "author": "shahrs87", "createdAt": "2020-11-13T15:50:44Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java", "diffHunk": "@@ -1326,7 +1328,69 @@ public void testAddingColumnsToTablesAndViews() throws Exception {\n             assertSequenceNumber(schemaName, viewName, PTable.INITIAL_SEQ_NUM + 1);\n         }\n     }\n-\t\n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" ENTITY_ID integer NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (ENTITY_ID, COL1, COL2)\"\n+            + \" ) \" + generateDDLOptions(\"\");\n+\n+        String columnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNDgwOQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525324809", "bodyText": "@gjacoby126  looks like this comment was missed ?", "author": "shahrs87", "createdAt": "2020-11-17T16:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\nindex 2cc57018b..e7d12b42f 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableIT.java\n\n@@ -1331,7 +1334,6 @@ public class AlterTableIT extends ParallelStatsDisabledIT {\n \n     @Test\n     public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n-        Properties props = new Properties();\n         String tableDDL = \"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n             + \" ENTITY_ID integer NOT NULL,\"\n             + \" COL1 integer NOT NULL,\"\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0MjUwOA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523042508", "bodyText": "Acc to comment, shouldn't the argument for startTime be \"viewDDLTimestamp + 1\"  since we are assuming that timestamp should change.", "author": "shahrs87", "createdAt": "2020-11-13T15:57:54Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 349148f74..4922c1f50 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1243,22 +1241,22 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(tableDDL);\n             //first get the original DDL timestamp when we created the table\n-            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 dataTableFullName, startTS,\n                 conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(viewDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName, tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             //now add a column and make sure the timestamp updates\n             conn.createStatement().execute(columnAddDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(columnDropDDL);\n-            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1 , conn);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDE0MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523044140", "bodyText": "I understand it is strictly not required but should we sleep for 1 millisecond just to make sure that 1 ms passed between divergeDDL and viewColumnAddDDL execution and the same argument applies for other ddl statements that we execute subsequently in this test.", "author": "shahrs87", "createdAt": "2020-11-13T16:00:25Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 349148f74..4922c1f50 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1243,22 +1241,22 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(tableDDL);\n             //first get the original DDL timestamp when we created the table\n-            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 dataTableFullName, startTS,\n                 conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(viewDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName, tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             //now add a column and make sure the timestamp updates\n             conn.createStatement().execute(columnAddDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(columnDropDDL);\n-            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1 , conn);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NjM5Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523046397", "bodyText": "Does it make sense to add a check that after dropping column from view it didn't change the ddlTimestamp of the base table ?", "author": "shahrs87", "createdAt": "2020-11-13T16:04:14Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwNTE3Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523105176", "bodyText": "There's already a check in a different test that dropping a view's column doesn't change the base table's timestamp, but no harm in also having a check here since it's an inherited column.", "author": "gjacoby126", "createdAt": "2020-11-13T17:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NjM5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 349148f74..4922c1f50 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1243,22 +1241,22 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(tableDDL);\n             //first get the original DDL timestamp when we created the table\n-            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 dataTableFullName, startTS,\n                 conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(viewDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName, tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             //now add a column and make sure the timestamp updates\n             conn.createStatement().execute(columnAddDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(columnDropDDL);\n-            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1 , conn);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0ODA3MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523048070", "bodyText": "Any reason why we want this test to run only if multiTenant is true ? I am not that much aware of this testsuite.\nIf we want to ensure isMultiTenant is true then can we change the test name to testLastDDLTimestampWith_Tenant_ChildViews to be more specific.", "author": "shahrs87", "createdAt": "2020-11-13T16:06:51Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNTgxNg==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525325816", "bodyText": "@gjacoby126  This is not a comment for changing anything. This is just for my knowledge.", "author": "shahrs87", "createdAt": "2020-11-17T17:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0ODA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDIyMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525334220", "bodyText": "@shahrs87 - the test deals in part with tenant-owned views, which don't make sense on a non-MT table.", "author": "gjacoby126", "createdAt": "2020-11-17T17:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0ODA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 349148f74..4922c1f50 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1243,22 +1241,22 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(tableDDL);\n             //first get the original DDL timestamp when we created the table\n-            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 dataTableFullName, startTS,\n                 conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(viewDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName, tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             //now add a column and make sure the timestamp updates\n             conn.createStatement().execute(columnAddDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(columnDropDDL);\n-            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1 , conn);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0OTkwNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523049907", "bodyText": "Should we move this helper method to CreateTableIT since we are doing almost same thing in CreateTableIT#verifyLastDDLTimestamp and additional timestamp bounds verification.", "author": "shahrs87", "createdAt": "2020-11-13T16:09:49Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String globalViewName = \"V_\" + generateUniqueName();\n+        String tenantViewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String globalViewFullName = SchemaUtil.getTableName(schemaName, globalViewName);\n+        String tenantViewFullName = SchemaUtil.getTableName(schemaName, tenantViewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        //create a table with a child global view, who then has a child tenant view\n+        String globalViewDDL =\n+            \"CREATE VIEW \" + globalViewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String tenantViewDDL =\n+            \"CREATE VIEW \" + tenantViewFullName + \" AS SELECT * FROM \" + globalViewFullName;\n+\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        long tableDDLTimestamp, globalViewDDLTimestamp;\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(globalViewDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+        }\n+        props.setProperty(TENANT_ID_ATTRIB, TENANT1);\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewDDL);\n+        }\n+        // First, check that adding a child view didn't change the timestamps\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            long newTableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+\n+            long newGlobalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, newGlobalViewDDLTimestamp);\n+        }\n+        Thread.sleep(1);\n+        //now add / drop a column from the tenant view and make sure it doesn't change its\n+        // ancestors' timestamps\n+        String tenantViewColumnAddDDL = \"ALTER VIEW \" + tenantViewFullName + \" ADD COL3 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String tenantViewColumnDropDDL = \"ALTER VIEW \" + tenantViewFullName + \" DROP COLUMN COL3 \";\n+\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewColumnAddDDL);\n+            long newTableDDLTimestamp = getLastDDLTimestamp(tenantConn, dataTableFullName);\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+\n+            long afterTenantColumnAddViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, afterTenantColumnAddViewDDLTimestamp);\n+\n+            tenantConn.createStatement().execute(tenantViewColumnDropDDL);\n+            //update the tenant view timestamp (we'll need it later)\n+            long afterTenantColumnDropTableDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                dataTableFullName);\n+            assertEquals(tableDDLTimestamp, afterTenantColumnDropTableDDLTimestamp);\n+\n+            long afterTenantColumnDropViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                globalViewFullName);\n+            assertEquals(globalViewDDLTimestamp, afterTenantColumnDropViewDDLTimestamp);\n+        }\n+        Thread.sleep(1);\n+        //now add / drop a column from the base table and make sure it changes the timestamps for\n+        // both the global view (its child) and the tenant view (its grandchild)\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                assertEquals(tableDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn,\n+                globalViewFullName);\n+            assertEquals(tableDDLTimestamp, globalViewDDLTimestamp);\n+\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                assertEquals(tableDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn,\n+                globalViewFullName);\n+            assertEquals(tableDDLTimestamp, globalViewDDLTimestamp);\n+        }\n+\n+        //now add / drop a column from the global view and make sure it doesn't change its\n+        // parent (the base table) but does change the timestamp for its child (the tenant view)\n+        String globalViewColumnAddDDL = \"ALTER VIEW \" + globalViewFullName + \" ADD COL5 varchar\" +\n+            \"(50) \" + \"NULL \";\n+        String globalViewColumnDropDDL = \"ALTER VIEW \" + globalViewFullName + \" DROP COLUMN COL5 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(globalViewColumnAddDDL);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            long newTableDDLTimestamp = getLastDDLTimestamp(conn,\n+                dataTableFullName);\n+            //table DDL timestamp shouldn't have changed\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                //but tenant timestamp should have changed\n+                assertEquals(globalViewDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+\n+            conn.createStatement().execute(globalViewColumnDropDDL);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+            newTableDDLTimestamp = getLastDDLTimestamp(conn,\n+                dataTableFullName);\n+            //table DDL timestamp shouldn't have changed\n+            assertEquals(tableDDLTimestamp, newTableDDLTimestamp);\n+            try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+                long tenantViewDDLTimestamp = getLastDDLTimestamp(tenantConn,\n+                    tenantViewFullName);\n+                //but tenant timestamp should have changed\n+                assertEquals(globalViewDDLTimestamp, tenantViewDDLTimestamp);\n+            }\n+        }\n+\n+    }\n+\n+    public static long getLastDDLTimestamp(Connection conn, String dataTableFullName) throws SQLException {", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 349148f74..4922c1f50 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1243,22 +1241,22 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(tableDDL);\n             //first get the original DDL timestamp when we created the table\n-            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 dataTableFullName, startTS,\n                 conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(viewDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName, tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             //now add a column and make sure the timestamp updates\n             conn.createStatement().execute(columnAddDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(columnDropDDL);\n-            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1 , conn);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MzEzNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523053137", "bodyText": "nit: could you please change the comment to be more specific.\n// First, check that adding a child view didn't change the timestamps of base table", "author": "shahrs87", "createdAt": "2020-11-13T16:14:56Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1218,248 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+                viewFullName, viewDDLTimestamp, conn);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);\n+            assertEquals(viewDDLTimestamp, getLastDDLTimestamp(conn, viewFullName));\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampWithChildViews() throws Exception {\n+        Assume.assumeTrue(isMultiTenant);\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String globalViewName = \"V_\" + generateUniqueName();\n+        String tenantViewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String globalViewFullName = SchemaUtil.getTableName(schemaName, globalViewName);\n+        String tenantViewFullName = SchemaUtil.getTableName(schemaName, tenantViewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        //create a table with a child global view, who then has a child tenant view\n+        String globalViewDDL =\n+            \"CREATE VIEW \" + globalViewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String tenantViewDDL =\n+            \"CREATE VIEW \" + tenantViewFullName + \" AS SELECT * FROM \" + globalViewFullName;\n+\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        long tableDDLTimestamp, globalViewDDLTimestamp;\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            conn.createStatement().execute(globalViewDDL);\n+            tableDDLTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+            globalViewDDLTimestamp = getLastDDLTimestamp(conn, globalViewFullName);\n+        }\n+        props.setProperty(TENANT_ID_ATTRIB, TENANT1);\n+        try (Connection tenantConn = DriverManager.getConnection(getUrl(), props)) {\n+            tenantConn.createStatement().execute(tenantViewDDL);\n+        }\n+        // First, check that adding a child view didn't change the timestamps", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMyNjA4OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525326089", "bodyText": "@gjacoby126  looks like this comment was missed ?", "author": "shahrs87", "createdAt": "2020-11-17T17:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MzEzNw=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 349148f74..4922c1f50 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1243,22 +1241,22 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(tableDDL);\n             //first get the original DDL timestamp when we created the table\n-            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, dataTableName,\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 dataTableFullName, startTS,\n                 conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(viewDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName, tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             //now add a column and make sure the timestamp updates\n             conn.createStatement().execute(columnAddDDL);\n-            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1, conn);\n             Thread.sleep(1);\n             conn.createStatement().execute(columnDropDDL);\n-            CreateTableIT.verifyLastDDLTimestamp(schemaName, viewName,\n+            CreateTableIT.verifyLastDDLTimestamp(\n                 viewFullName,\n                 tableDDLTimestamp + 1 , conn);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1NDk0Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523054947", "bodyText": "I don't see any usage of first 3 arguments String tenantId, String schemaName, String tableName\nMaybe you used them in earlier draft then removed them ?", "author": "shahrs87", "createdAt": "2020-11-13T16:17:55Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java", "diffHunk": "@@ -910,6 +911,41 @@ public void testTableDescriptorPriority() throws SQLException, IOException {\n         }\n     }\n \n+    @Test\n+    public void testCreateTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        final String schemaName = generateUniqueName();\n+        final String tableName = generateUniqueName();\n+        final String dataTableFullName = SchemaUtil.getTableName(schemaName, tableName);\n+        String ddl =\n+            \"CREATE TABLE \" + dataTableFullName + \" (\\n\" + \"ID1 VARCHAR(15) NOT NULL,\\n\"\n+                + \"ID2 VARCHAR(15) NOT NULL,\\n\" + \"CREATED_DATE DATE,\\n\"\n+                + \"CREATION_TIME BIGINT,\\n\" + \"LAST_USED DATE,\\n\"\n+                + \"CONSTRAINT PK PRIMARY KEY (ID1, ID2)) \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(ddl);\n+            verifyLastDDLTimestamp(schemaName, tableName, dataTableFullName, startTS, conn);\n+        }\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n+        return verifyLastDDLTimestamp(\"\", schemaName, tableName, dataTableFullName, startTS, conn);\n+    }\n+\n+    public static long verifyLastDDLTimestamp(String tenantId, String schemaName, String tableName,\n+                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java\nindex 4b5e44f8e..51d1c3159 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/CreateTableIT.java\n\n@@ -925,24 +925,23 @@ public class CreateTableIT extends ParallelStatsDisabledIT {\n         long startTS = EnvironmentEdgeManager.currentTimeMillis();\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(ddl);\n-            verifyLastDDLTimestamp(schemaName, tableName, dataTableFullName, startTS, conn);\n+            verifyLastDDLTimestamp(dataTableFullName, startTS, conn);\n         }\n     }\n \n-    public static long verifyLastDDLTimestamp(String schemaName, String tableName,\n-                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n-        return verifyLastDDLTimestamp(\"\", schemaName, tableName, dataTableFullName, startTS, conn);\n-    }\n-\n-    public static long verifyLastDDLTimestamp(String tenantId, String schemaName, String tableName,\n-                                              String dataTableFullName, long startTS, Connection conn) throws SQLException {\n+    public static long verifyLastDDLTimestamp(String dataTableFullName, long startTS, Connection conn) throws SQLException {\n         long endTS = EnvironmentEdgeManager.currentTimeMillis();\n         //Now try the PTable API\n+        long ddlTimestamp = getLastDDLTimestamp(conn, dataTableFullName);\n+        assertTrue(\"PTable DDL Timestamp not in the right range!\",\n+            ddlTimestamp >= startTS && ddlTimestamp <= endTS);\n+        return ddlTimestamp;\n+    }\n+\n+    public static long getLastDDLTimestamp(Connection conn, String dataTableFullName) throws SQLException {\n         PTable table = PhoenixRuntime.getTableNoCache(conn, dataTableFullName);\n         assertNotNull(\"PTable is null!\", table);\n-        assertNotNull(\"PTable DDL timestamp is null!\", table.getLastDDLTimestamp());\n-        assertTrue(\"PTable DDL Timestamp not in the right range!\",\n-            table.getLastDDLTimestamp() >= startTS && table.getLastDDLTimestamp() <= endTS);\n+        assertNotNull(\"DDL timestamp is null!\", table.getLastDDLTimestamp());\n         return table.getLastDDLTimestamp();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2NTM0MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r523065340", "bodyText": "nit: indentation mismatch.", "author": "shahrs87", "createdAt": "2020-11-13T16:34:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2802,7 +2827,8 @@ private MetaDataMutationResult mutateColumn(\n                         getParentPhysicalTableName(table), table.getType());\n \n                 result = mutator.validateAndAddMetadata(table, rowKeyMetaData, tableMetadata,\n-                        region, invalidateList, locks, clientTimeStamp, clientVersion);\n+                        region, invalidateList, locks, clientTimeStamp, clientVersion,\n+                    isAddingOrDroppingColumns);", "originalCommit": "07c5ed5b6bb14ce4f583431f25b5ebf6699d8958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\nindex 6f5db2426..7f163067f 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n\n@@ -2828,7 +2828,7 @@ public class MetaDataEndpointImpl extends MetaDataProtocol implements Coprocesso\n \n                 result = mutator.validateAndAddMetadata(table, rowKeyMetaData, tableMetadata,\n                         region, invalidateList, locks, clientTimeStamp, clientVersion,\n-                    isAddingOrDroppingColumns);\n+                        isAddingOrDroppingColumns);\n                 // if the update mutation caused tables to be deleted, the mutation code returned\n                 // will be MutationCode.TABLE_ALREADY_EXISTS\n                 if (result != null\n"}}, {"oid": "7f6c9895009a67280e825944ab0019096b916fc2", "url": "https://github.com/apache/phoenix/commit/7f6c9895009a67280e825944ab0019096b916fc2", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-17T21:35:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1MjIxMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525452210", "bodyText": "nit: We already have conn.commit()inside nullDDLTimestamps()", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:49:29Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java", "diffHunk": "@@ -747,4 +640,83 @@ private void verifyExpectedCellValue(byte[] rowKey, byte[] syscatBytes,\n             assertArrayEquals(expectedDateTypeBytes, CellUtil.cloneValue(cell));\n         }\n     }\n+\n+    @Test\n+    public void testLastDDLTimestampBootstrap() throws Exception {\n+        //Create a table, view, and index\n+        String schemaName = \"S_\" + generateUniqueName();\n+        String tableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String fullTableName = SchemaUtil.getTableName(schemaName, tableName);\n+        String fullViewName = SchemaUtil.getTableName(schemaName, viewName);\n+        try (Connection conn = getConnection(false, null)) {\n+            conn.createStatement().execute(\n+                \"CREATE TABLE \" + fullTableName\n+                    + \" (PK1 VARCHAR NOT NULL, PK2 VARCHAR, KV1 VARCHAR, KV2 VARCHAR CONSTRAINT \" +\n+                    \"PK PRIMARY KEY(PK1, PK2)) \");\n+            conn.createStatement().execute(\n+                \"CREATE VIEW \" + fullViewName + \" AS SELECT * FROM \" + fullTableName);\n+\n+            //Now we null out any existing last ddl timestamps\n+            nullDDLTimestamps(conn);\n+            conn.commit();", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80982e2a559aaad6a0d25885455b0bc6698ac58b", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java\nindex 22fdaf794..87307f5f3 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java\n\n@@ -659,7 +659,6 @@ public class UpgradeIT extends ParallelStatsDisabledIT {\n \n             //Now we null out any existing last ddl timestamps\n             nullDDLTimestamps(conn);\n-            conn.commit();\n \n             //now get the row timestamps for each header row\n             long tableTS = getRowTimestampForMetadata(conn, schemaName, tableName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDE1OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525454159", "bodyText": "Should we also move this test to UpgradeNamespaceIT?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:51:04Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java", "diffHunk": "@@ -91,122 +100,6 @@\n @Category(NeedsOwnMiniClusterTest.class)\n public class UpgradeIT extends ParallelStatsDisabledIT {\n \n-    @Test\n-    public void testMapTableToNamespaceDuringUpgrade()\n-            throws SQLException, IOException, IllegalArgumentException, InterruptedException {\n-        String[] strings = new String[] { \"a\", \"b\", \"c\", \"d\" };\n-\n-        try (Connection conn = DriverManager.getConnection(getUrl())) {\n-            String schemaName = \"TEST\";\n-            String phoenixFullTableName = schemaName + \".\" + generateUniqueName();\n-            String indexName = \"IDX_\" + generateUniqueName();\n-            String localIndexName = \"LIDX_\" + generateUniqueName();\n-\n-            String viewName = \"VIEW_\" + generateUniqueName();\n-            String viewIndexName = \"VIDX_\" + generateUniqueName();\n-\n-            String[] tableNames = new String[] { phoenixFullTableName, schemaName + \".\" + indexName,\n-                    schemaName + \".\" + localIndexName, \"diff.\" + viewName, \"test.\" + viewName, viewName};\n-            String[] viewIndexes = new String[] { \"diff.\" + viewIndexName, \"test.\" + viewIndexName };\n-            conn.createStatement().execute(\"CREATE TABLE \" + phoenixFullTableName\n-                    + \"(k VARCHAR PRIMARY KEY, v INTEGER, f INTEGER, g INTEGER NULL, h INTEGER NULL)\");\n-            PreparedStatement upsertStmt = conn\n-                    .prepareStatement(\"UPSERT INTO \" + phoenixFullTableName + \" VALUES(?, ?, 0, 0, 0)\");\n-            int i = 1;\n-            for (String str : strings) {\n-                upsertStmt.setString(1, str);\n-                upsertStmt.setInt(2, i++);\n-                upsertStmt.execute();\n-            }\n-            conn.commit();\n-            // creating local index\n-            conn.createStatement()\n-                    .execute(\"create local index \" + localIndexName + \" on \" + phoenixFullTableName + \"(K)\");\n-            // creating global index\n-            conn.createStatement().execute(\"create index \" + indexName + \" on \" + phoenixFullTableName + \"(k)\");\n-            // creating view in schema 'diff'\n-            conn.createStatement().execute(\"CREATE VIEW diff.\" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // creating view in schema 'test'\n-            conn.createStatement().execute(\"CREATE VIEW test.\" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            conn.createStatement().execute(\"CREATE VIEW \" + viewName + \"(col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // Creating index on views\n-            conn.createStatement().execute(\"create index \" + viewIndexName + \"  on diff.\" + viewName + \"(col)\");\n-            conn.createStatement().execute(\"create index \" + viewIndexName + \" on test.\" + viewName + \"(col)\");\n-\n-            // validate data\n-            for (String tableName : tableNames) {\n-                ResultSet rs = conn.createStatement().executeQuery(\"select * from \" + tableName);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(1));\n-                }\n-            }\n-\n-            // validate view Index data\n-            for (String viewIndex : viewIndexes) {\n-                ResultSet rs = conn.createStatement().executeQuery(\"select * from \" + viewIndex);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(2));\n-                }\n-            }\n-\n-            HBaseAdmin admin = conn.unwrap(PhoenixConnection.class).getQueryServices().getAdmin();\n-            assertTrue(admin.tableExists(phoenixFullTableName));\n-            assertTrue(admin.tableExists(schemaName + QueryConstants.NAME_SEPARATOR + indexName));\n-            assertTrue(admin.tableExists(MetaDataUtil.getViewIndexPhysicalName(Bytes.toBytes(phoenixFullTableName))));\n-            Properties props = new Properties();\n-            props.setProperty(QueryServices.IS_NAMESPACE_MAPPING_ENABLED, Boolean.toString(true));\n-            props.setProperty(QueryServices.IS_SYSTEM_TABLE_MAPPED_TO_NAMESPACE, Boolean.toString(false));\n-            admin.close();\n-            PhoenixConnection phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-            UpgradeUtil.upgradeTable(phxConn, phoenixFullTableName);\n-            phxConn.close();\n-            props = new Properties();\n-            phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-            // purge MetaDataCache except for system tables\n-            phxConn.getMetaDataCache().pruneTables(new PMetaData.Pruner() {\n-                @Override public boolean prune(PTable table) {\n-                    return table.getType() != PTableType.SYSTEM;\n-                }\n-\n-                @Override public boolean prune(PFunction function) {\n-                    return false;\n-                }\n-            });\n-            admin = phxConn.getQueryServices().getAdmin();\n-            String hbaseTableName = SchemaUtil.getPhysicalTableName(Bytes.toBytes(phoenixFullTableName), true)\n-                    .getNameAsString();\n-            assertTrue(admin.tableExists(hbaseTableName));\n-            assertTrue(admin.tableExists(Bytes.toBytes(hbaseTableName)));\n-            assertTrue(admin.tableExists(schemaName + QueryConstants.NAMESPACE_SEPARATOR + indexName));\n-            assertTrue(admin.tableExists(MetaDataUtil.getViewIndexPhysicalName(Bytes.toBytes(hbaseTableName))));\n-            i = 0;\n-            // validate data\n-            for (String tableName : tableNames) {\n-                ResultSet rs = phxConn.createStatement().executeQuery(\"select * from \" + tableName);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(1));\n-                }\n-            }\n-            // validate view Index data\n-            for (String viewIndex : viewIndexes) {\n-                ResultSet rs = conn.createStatement().executeQuery(\"select * from \" + viewIndex);\n-                for (String str : strings) {\n-                    assertTrue(rs.next());\n-                    assertEquals(str, rs.getString(2));\n-                }\n-            }\n-            PName tenantId = phxConn.getTenantId();\n-            PName physicalName = PNameFactory.newName(hbaseTableName);\n-            String newSchemaName = MetaDataUtil.getViewIndexSequenceSchemaName(physicalName, true);\n-            String newSequenceName = MetaDataUtil.getViewIndexSequenceName(physicalName, tenantId, true);\n-            verifySequenceValue(null, newSequenceName, newSchemaName, Short.MIN_VALUE + 3);\n-            admin.close();\n-        }\n-    }\n-\n     @Test\n     public void testMapMultiTenantTableToNamespaceDuringUpgrade() throws SQLException, SnapshotCreationException,", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0OTI2MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r527049260", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-11-19T17:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDE1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "171e7e2891314a309eafb03bd5c5fe37bf85bc89", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java\nindex 22fdaf794..8a6fac044 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/UpgradeIT.java\n\n@@ -99,135 +99,6 @@ import org.junit.experimental.categories.Category;\n \n @Category(NeedsOwnMiniClusterTest.class)\n public class UpgradeIT extends ParallelStatsDisabledIT {\n-\n-    @Test\n-    public void testMapMultiTenantTableToNamespaceDuringUpgrade() throws SQLException, SnapshotCreationException,\n-            IllegalArgumentException, IOException, InterruptedException {\n-        String[] strings = new String[] { \"a\", \"b\", \"c\", \"d\" };\n-        String schemaName1 = \"S_\" +generateUniqueName(); // TEST\n-        String schemaName2 = \"S_\" +generateUniqueName(); // DIFF\n-        String phoenixFullTableName = schemaName1 + \".\" + generateUniqueName();\n-        String hbaseTableName = SchemaUtil.getPhysicalTableName(Bytes.toBytes(phoenixFullTableName), true)\n-                .getNameAsString();\n-        String indexName = \"IDX_\" + generateUniqueName();\n-        String viewName = \"V_\" + generateUniqueName();\n-        String viewName1 = \"V1_\" + generateUniqueName();\n-        String viewIndexName = \"V_IDX_\" + generateUniqueName();\n-        String tenantViewIndexName = \"V1_IDX_\" + generateUniqueName();\n-\n-        String[] tableNames = new String[] { phoenixFullTableName, schemaName2 + \".\" + viewName1, schemaName1 + \".\" + viewName1, viewName1 };\n-        String[] viewIndexes = new String[] { schemaName1 + \".\" + viewIndexName, schemaName2 + \".\" + viewIndexName };\n-        String[] tenantViewIndexes = new String[] { schemaName1 + \".\" + tenantViewIndexName, schemaName2 + \".\" + tenantViewIndexName };\n-        try (Connection conn = DriverManager.getConnection(getUrl())) {\n-            conn.createStatement().execute(\"CREATE TABLE \" + phoenixFullTableName\n-                    + \"(k VARCHAR not null, v INTEGER not null, f INTEGER, g INTEGER NULL, h INTEGER NULL CONSTRAINT pk PRIMARY KEY(k,v)) MULTI_TENANT=true\");\n-            PreparedStatement upsertStmt = conn\n-                    .prepareStatement(\"UPSERT INTO \" + phoenixFullTableName + \" VALUES(?, ?, 0, 0, 0)\");\n-            int i = 1;\n-            for (String str : strings) {\n-                upsertStmt.setString(1, str);\n-                upsertStmt.setInt(2, i++);\n-                upsertStmt.execute();\n-            }\n-            conn.commit();\n-\n-            // creating global index\n-            conn.createStatement().execute(\"create index \" + indexName + \" on \" + phoenixFullTableName + \"(f)\");\n-            // creating view in schema 'diff'\n-            conn.createStatement().execute(\"CREATE VIEW \" + schemaName2 + \".\" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // creating view in schema 'test'\n-            conn.createStatement().execute(\"CREATE VIEW \" + schemaName1 + \".\" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            conn.createStatement().execute(\"CREATE VIEW \" + viewName + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // Creating index on views\n-            conn.createStatement().execute(\"create local index \" + viewIndexName + \" on \" + schemaName2 + \".\" + viewName + \"(col)\");\n-            conn.createStatement().execute(\"create local index \" + viewIndexName + \" on \" + schemaName1 + \".\" + viewName + \"(col)\");\n-        }\n-        Properties props = new Properties();\n-        String tenantId = strings[0];\n-        props.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n-        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n-            PreparedStatement upsertStmt = conn\n-                    .prepareStatement(\"UPSERT INTO \" + phoenixFullTableName + \"(k,v,f,g,h)  VALUES(?, ?, 0, 0, 0)\");\n-            int i = 1;\n-            for (String str : strings) {\n-                upsertStmt.setString(1, str);\n-                upsertStmt.setInt(2, i++);\n-                upsertStmt.execute();\n-            }\n-            conn.commit();\n-            // creating view in schema 'diff'\n-            conn.createStatement()\n-                    .execute(\"CREATE VIEW \" + schemaName2 + \".\" + viewName1 + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // creating view in schema 'test'\n-            conn.createStatement()\n-                    .execute(\"CREATE VIEW \" + schemaName1 + \".\" + viewName1 + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            conn.createStatement().execute(\"CREATE VIEW \" + viewName1 + \" (col VARCHAR) AS SELECT * FROM \" + phoenixFullTableName);\n-            // Creating index on views\n-            conn.createStatement().execute(\"create index \" + tenantViewIndexName + \" on \" + schemaName2 + \".\" + viewName1 + \"(col)\");\n-            conn.createStatement().execute(\"create index \" + tenantViewIndexName + \" on \" + schemaName1 + \".\" + viewName1 + \"(col)\");\n-        }\n-\n-        props = new Properties();\n-        props.setProperty(QueryServices.IS_NAMESPACE_MAPPING_ENABLED, Boolean.toString(true));\n-        props.setProperty(QueryServices.IS_SYSTEM_TABLE_MAPPED_TO_NAMESPACE, Boolean.toString(false));\n-        PhoenixConnection phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-        UpgradeUtil.upgradeTable(phxConn, phoenixFullTableName);\n-        props.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n-        phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-        // purge MetaDataCache except for system tables\n-        phxConn.getMetaDataCache().pruneTables(new PMetaData.Pruner() {\n-            @Override public boolean prune(PTable table) {\n-                return table.getType() != PTableType.SYSTEM;\n-            }\n-\n-            @Override public boolean prune(PFunction function) {\n-                return false;\n-            }\n-        });\n-        int i = 1;\n-        String indexPhysicalTableName = Bytes\n-                .toString(MetaDataUtil.getViewIndexPhysicalName(Bytes.toBytes(hbaseTableName)));\n-        // validate data with tenant\n-        for (String tableName : tableNames) {\n-            assertTableUsed(phxConn, tableName, hbaseTableName);\n-            ResultSet rs = phxConn.createStatement().executeQuery(\"select * from \" + tableName);\n-            assertTrue(rs.next());\n-            do {\n-                assertEquals(i++, rs.getInt(1));\n-            } while (rs.next());\n-            i = 1;\n-        }\n-        // validate view Index data\n-        for (String viewIndex : tenantViewIndexes) {\n-            assertTableUsed(phxConn, viewIndex, indexPhysicalTableName);\n-            ResultSet rs = phxConn.createStatement().executeQuery(\"select * from \" + viewIndex);\n-            assertTrue(rs.next());\n-            do {\n-                assertEquals(i++, rs.getInt(2));\n-            } while (rs.next());\n-            i = 1;\n-        }\n-        phxConn.close();\n-        props.remove(PhoenixRuntime.TENANT_ID_ATTRIB);\n-        phxConn = DriverManager.getConnection(getUrl(), props).unwrap(PhoenixConnection.class);\n-\n-        // validate view Index data\n-        for (String viewIndex : viewIndexes) {\n-            assertTableUsed(phxConn, viewIndex, hbaseTableName);\n-            ResultSet rs = phxConn.createStatement().executeQuery(\"select * from \" + viewIndex);\n-            for (String str : strings) {\n-                assertTrue(rs.next());\n-                assertEquals(str, rs.getString(1));\n-            }\n-        }\n-        phxConn.close();\n-    }\n-\n-    public void assertTableUsed(Connection conn, String phoenixTableName, String hbaseTableName) throws SQLException {\n-        ResultSet rs = conn.createStatement().executeQuery(\"EXPLAIN SELECT * FROM \" + phoenixTableName);\n-        assertTrue(rs.next());\n-        assertTrue(rs.getString(1).contains(hbaseTableName));\n-    }\n         \n     @Test\n     public void testUpgradeRequiredPreventsSQL() throws SQLException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDk5Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525454997", "bodyText": "nit: Don't need the tenantId variable here", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:51:43Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java", "diffHunk": "@@ -387,6 +388,48 @@ public void testViewUsesTableLocalIndex() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCreateViewTimestamp() throws Exception {\n+        String tenantId = null;\n+        createViewTimestampHelper(tenantId);", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0NzQ3OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r527047479", "bodyText": "I could just pass null, but this seemed more self-documenting (because the name makes it clear that I'm passing a null tenant id, rather than making someone need to look at the function def to figure that out)", "author": "gjacoby126", "createdAt": "2020-11-19T17:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NDk5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\nindex 3cb61b27e..f51ded684 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\n\n@@ -382,7 +313,8 @@ public class ViewIT extends SplitSystemCatalogIT {\n     public void testViewUsesTableLocalIndex() throws Exception {\n         if (transactionProvider == null ||\n                 !TransactionFactory.getTransactionProvider(\n-                        TransactionFactory.Provider.valueOf(transactionProvider))\n+                        TransactionFactory.Provider.valueOf(\n+                                transactionProvider))\n                         .isUnsupported(Feature.ALLOW_LOCAL_INDEX)) {\n             testViewUsesTableIndex(true);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NjM3Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525456376", "bodyText": "I think we can remove this else block since the reinitialized value for tenantId isn't being used anywhere", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T19:52:52Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java", "diffHunk": "@@ -387,6 +388,48 @@ public void testViewUsesTableLocalIndex() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCreateViewTimestamp() throws Exception {\n+        String tenantId = null;\n+        createViewTimestampHelper(tenantId);\n+    }\n+\n+    @Test\n+    public void testCreateTenantViewTimestamp() throws Exception {\n+        createViewTimestampHelper(TENANT1);\n+    }\n+\n+    private void createViewTimestampHelper(String tenantId) throws SQLException {\n+        Properties props = new Properties();\n+        if (tenantId != null) {\n+            props.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        } else {\n+            tenantId = \"\";", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0OTUwOQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r527049509", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-11-19T17:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NjM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7f6c9895009a67280e825944ab0019096b916fc2", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\nindex 3cb61b27e..f51ded684 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewIT.java\n\n@@ -382,7 +313,8 @@ public class ViewIT extends SplitSystemCatalogIT {\n     public void testViewUsesTableLocalIndex() throws Exception {\n         if (transactionProvider == null ||\n                 !TransactionFactory.getTransactionProvider(\n-                        TransactionFactory.Provider.valueOf(transactionProvider))\n+                        TransactionFactory.Provider.valueOf(\n+                                transactionProvider))\n                         .isUnsupported(Feature.ALLOW_LOCAL_INDEX)) {\n             testViewUsesTableIndex(true);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTQ0OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525539449", "bodyText": "This is not entirely true. I know this is frustrating (I was in the same boat), but in 4.15+ based on what I've gathered, here are the rules for column inheritance w.r.t. diverged and non-diverged views:\nDropping columns from a parent\n\nAny columns dropped from an ancestor that is a physical base table are \"inherited\" by its entire child view hierarchy. This is obvious since the physical column no longer exists and so any descendant view wouldn't be able to project anything for those dropped columns.\n\nSince the shape of the child view changes in this case, we should probably use max(view_DDL_ts, parent_DDL_ts_corresponding_to_col_drop).\nNot sure how easy of a change it would be to store this ts corresponding to column dropped from the parent.\n\n\nAny columns dropped from an ancestor that is a view are \"inherited\" by its entire child view hierarchy even if a child view has diverged.\n\nSame here\n\n\n\nAdding columns to a parent\n\nAny columns added to an ancestor that is a view or physical base table are only inherited by its descendant views that have not diverged.\n\nI think your changes already capture this.\n\n\n\nOverall, the rule seems to be:\nOnce a view diverges from its parent, any columns added to an ancestor base table/view are no longer propagated to the view. A column dropped on an ancestor base table/view is however, always propagated to the child view.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:34:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MTU1Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525571557", "bodyText": "That doesn't seem like desirable behavior to me as a feature. As we discussed offline, I think diverged views should have been written to get all ancestor DDL changes. (Also, I think we should allow column projection in view definitions -- SELECT COL1, COL2 FROM FOO rather than SELECT * FROM FOO--, rather than having diverged views at all, but that's a whole new feature and out of scope for this discussion.)\nBut setting all that aside, it's the column drops that are the dangerous operations, because they can break existing queries, not column adds, which are always benign. (Don't care about a new column? Don't select it!) So if I were trying to allow for a view to split off from its parent and be semi-independent, it's the drops I'd try to shield it from, not additions.", "author": "gjacoby126", "createdAt": "2020-11-17T22:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NTI0Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525575243", "bodyText": "I agree, but as you said, changing the behavior of diverged views is out of scope for this discussion.\nAs far as current behavior goes, since columns dropped from parents are always inherited by all views (diverged or not), the lastDDLTs should be updated for even diverged views in those cases, whereas your current changes won't do that.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T22:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTQ0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 4922c1f50..909bcbda0 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1279,17 +1279,18 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n             + \" %s ID char(1) NOT NULL,\"\n             + \" COL1 integer NOT NULL,\"\n             + \" COL2 bigint,\"\n+            + \" COL3 bigint,\"\n             + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n             + \" ) %s\");\n \n         String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n \n         String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n-        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n-        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n-        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL4 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL5 varchar\" +\n             \"(50) NULL\";\n-        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n         try (Connection conn = DriverManager.getConnection(getUrl())) {\n             conn.createStatement().execute(tableDDL);\n             long tableDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525539735", "bodyText": "We should ideally drop a pre-existing column from the parent for this test rather than a column that was newly added to the parent.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:35:07Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MzA1MA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525573050", "bodyText": "I'll do as you suggest, but should it make a difference?", "author": "gjacoby126", "createdAt": "2020-11-17T22:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODM0Nw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525578347", "bodyText": "If the column is added to the base table after its child view diverges, they view won't inherit it anyways, so dropping the same column from the parent shouldn't change the lastDDLTs of the view either. On the contrary, if an existing column is dropped, that should change the ts of the view. In fact this sounds like a good additional test to add.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T22:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwNzQ1OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r526307458", "bodyText": "Switched the test to drop an original table column. (But did not add an additional test because of the open question about what diverged views should do.)", "author": "gjacoby126", "createdAt": "2020-11-18T18:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 4922c1f50..909bcbda0 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1279,17 +1279,18 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n             + \" %s ID char(1) NOT NULL,\"\n             + \" COL1 integer NOT NULL,\"\n             + \" COL2 bigint,\"\n+            + \" COL3 bigint,\"\n             + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n             + \" ) %s\");\n \n         String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n \n         String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n-        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n-        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n-        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL4 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL5 varchar\" +\n             \"(50) NULL\";\n-        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n         try (Connection conn = DriverManager.getConnection(getUrl())) {\n             conn.createStatement().execute(tableDDL);\n             long tableDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzOTkxMA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525539910", "bodyText": "Same here.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:35:27Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 4922c1f50..909bcbda0 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1279,17 +1279,18 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n             + \" %s ID char(1) NOT NULL,\"\n             + \" COL1 integer NOT NULL,\"\n             + \" COL2 bigint,\"\n+            + \" COL3 bigint,\"\n             + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n             + \" ) %s\");\n \n         String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n \n         String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n-        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n-        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n-        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL4 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL5 varchar\" +\n             \"(50) NULL\";\n-        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n         try (Connection conn = DriverManager.getConnection(getUrl())) {\n             conn.createStatement().execute(tableDDL);\n             long tableDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MDI5Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525540293", "bodyText": "Column drop should change the last DDL timestamp for child views as explained in my previous comment.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:36:11Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java", "diffHunk": "@@ -1216,5 +1216,251 @@ public void testDroppingIndexedColDropsViewIndex() throws Exception {\n             assertNull(results.next());\n         }\n     }\n-    \n+\n+    @Test\n+    public void testAddThenDropColumnTableDDLTimestamp() throws Exception {\n+        Properties props = new Properties();\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint NOT NULL,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1, COL2)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String columnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String columnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        long startTS = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(tableDDL);\n+            //first get the original DDL timestamp when we created the table\n+            long tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                dataTableFullName, startTS,\n+                conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            //now add a column and make sure the timestamp updates\n+            conn.createStatement().execute(columnAddDDL);\n+            tableDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(columnDropDDL);\n+            CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName,\n+                tableDDLTimestamp + 1 , conn);\n+        }\n+    }\n+\n+    @Test\n+    public void testLastDDLTimestampForDivergedViews() throws Exception {\n+        //Phoenix allows users to \"drop\" columns from views that are inherited from their ancestor\n+        // views or tables. These columns are then excluded from the view schema, and the view is\n+        // considered \"diverged\" from its parents, and so no longer inherit any additional schema\n+        // changes that are applied to their ancestors. This test make sure that this behavior\n+        // extends to DDL timestamp\n+        String schemaName = SCHEMA1;\n+        String dataTableName = \"T_\" + generateUniqueName();\n+        String viewName = \"V_\" + generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String viewFullName = SchemaUtil.getTableName(schemaName, viewName);\n+\n+        String tableDDL = generateDDL(\"CREATE TABLE IF NOT EXISTS \" + dataTableFullName + \" (\"\n+            + \" %s ID char(1) NOT NULL,\"\n+            + \" COL1 integer NOT NULL,\"\n+            + \" COL2 bigint,\"\n+            + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n+            + \" ) %s\");\n+\n+        String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n+\n+        String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+            \"(50) NULL\";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(tableDDL);\n+            long tableDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName);\n+            conn.createStatement().execute(viewDDL);\n+            long viewDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, viewFullName);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(divergeDDL);\n+            //verify table DDL timestamp DID NOT change\n+            assertEquals(tableDDLTimestamp, CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName));\n+            //verify view DDL timestamp changed\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, viewDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewColumnAddDDL);\n+            //verify DDL timestamp changed because we added a column to the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, viewDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(viewColumnDropDDL);\n+            //verify DDL timestamp changed because we dropped a column from the view\n+            viewDDLTimestamp = CreateTableIT.verifyLastDDLTimestamp(\n+                viewFullName, viewDDLTimestamp + 1, conn);\n+            Thread.sleep(1);\n+            conn.createStatement().execute(tableColumnAddDDL);\n+            //verify DDL timestamp DID NOT change because we added a column from the base table\n+            assertEquals(viewDDLTimestamp, CreateTableIT.getLastDDLTimestamp(conn, viewFullName));\n+            conn.createStatement().execute(tableColumnDropDDL);", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\nindex 4922c1f50..909bcbda0 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/AlterTableWithViewsIT.java\n\n@@ -1279,17 +1279,18 @@ public class AlterTableWithViewsIT extends SplitSystemCatalogIT {\n             + \" %s ID char(1) NOT NULL,\"\n             + \" COL1 integer NOT NULL,\"\n             + \" COL2 bigint,\"\n+            + \" COL3 bigint,\"\n             + \" CONSTRAINT NAME_PK PRIMARY KEY (%s ID, COL1)\"\n             + \" ) %s\");\n \n         String viewDDL = \"CREATE VIEW \" + viewFullName + \" AS SELECT * FROM \" + dataTableFullName;\n \n         String divergeDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL2\";\n-        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL3 varchar(50) NULL \";\n-        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL3 \";\n-        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL4 varchar\" +\n+        String viewColumnAddDDL = \"ALTER VIEW \" + viewFullName + \" ADD COL4 varchar(50) NULL \";\n+        String viewColumnDropDDL = \"ALTER VIEW \" + viewFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnAddDDL = \"ALTER TABLE \" + dataTableFullName + \" ADD COL5 varchar\" +\n             \"(50) NULL\";\n-        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL4 \";\n+        String tableColumnDropDDL = \"ALTER TABLE \" + dataTableFullName + \" DROP COLUMN COL3 \";\n         try (Connection conn = DriverManager.getConnection(getUrl())) {\n             conn.createStatement().execute(tableDDL);\n             long tableDDLTimestamp = CreateTableIT.getLastDDLTimestamp(conn, dataTableFullName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MTkyMw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525541923", "bodyText": "Just for clarity, can we mention that this logic only applies to non-diverged views?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:39:15Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java", "diffHunk": "@@ -399,6 +400,17 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table, byte[][] rowK\n                                 rowKeyMetaData[TABLE_NAME_INDEX])));\n             }\n         }\n+        if (isAddingColumns) {\n+            //We're changing the application-facing schema by adding a column, so update the DDL\n+            // timestamp\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            if (MetaDataUtil.isTableQueryable(table.getType())) {\n+                additionalTableMetadataMutations.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                    clientTimeStamp, serverTimestamp));\n+            }\n+            //we don't need to update the DDL timestamp for child views, because when we look up", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\nindex 446f86f93..dffc7ac46 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/AddColumnMutator.java\n\n@@ -409,7 +409,8 @@ public class AddColumnMutator implements ColumnMutator {\n                     clientTimeStamp, serverTimestamp));\n             }\n             //we don't need to update the DDL timestamp for child views, because when we look up\n-            // a PTable, we'll take the max timestamp of a view and all its ancestors\n+            // a PTable, we'll take the max timestamp of a view and all its ancestors. This is true\n+            // whether the view is diverged or not.\n         }\n         tableMetaData.addAll(additionalTableMetadataMutations);\n         if (type == PTableType.VIEW) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MjIyMQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525542221", "bodyText": "For clarity, can we mention that this logic also applies for diverged views?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:39:45Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java", "diffHunk": "@@ -268,6 +272,16 @@ public MetaDataMutationResult validateAndAddMetadata(PTable table,\n             }\n \n         }\n+        //We're changing the application-facing schema by dropping a column, so update the DDL\n+        // timestamp to current _server_ timestamp\n+        if (MetaDataUtil.isTableQueryable(table.getType())) {\n+            long serverTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+            additionalTableMetaData.add(MetaDataUtil.getLastDDLTimestampUpdate(tableHeaderRowKey,\n+                clientTimeStamp, serverTimestamp));\n+        }\n+        //we don't need to update the DDL timestamp for any child views we may have, because", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\nindex 916dd75ac..e26478eca 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/DropColumnMutator.java\n\n@@ -281,7 +281,7 @@ public class DropColumnMutator implements ColumnMutator {\n         }\n         //we don't need to update the DDL timestamp for any child views we may have, because\n         // when we look up a PTable for any of those child views, we'll take the max timestamp\n-        // of the view and all its ancestors\n+        // of the view and all its ancestors. This is true whether the view is diverged or not.\n         tableMetaData.addAll(additionalTableMetaData);\n         if (deletePKColumn) {\n             if (table.getPKColumns().size() == 1) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0Mjg2Ng==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525542866", "bodyText": "This comment is no longer valid right?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:40:59Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2846,21 +2872,25 @@ private MetaDataMutationResult mutateColumn(\n                 separateLocalAndRemoteMutations(region, tableMetadata, localMutations,\n                         remoteMutations);\n                 if (!remoteMutations.isEmpty()) {\n-                    // there should only be remote mutations if we are adding a column to a view\n+                    // there should only be remote mutations if we are updating the last ddl", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MzY2MQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525573661", "bodyText": "Oops, forgot to undo that comment change. Thanks, will fix.", "author": "gjacoby126", "createdAt": "2020-11-17T22:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0Mjg2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\nindex 987d5456b..22673b719 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n\n@@ -2872,11 +2880,10 @@ public class MetaDataEndpointImpl extends MetaDataProtocol implements Coprocesso\n                 separateLocalAndRemoteMutations(region, tableMetadata, localMutations,\n                         remoteMutations);\n                 if (!remoteMutations.isEmpty()) {\n-                    // there should only be remote mutations if we are updating the last ddl\n-                    // timestamp for child views, or we are adding a column to a view\n+                    // there should only be remote mutations if we are adding a column to a view\n                     // that uses encoded column qualifiers (the remote mutations are to update the\n                     // encoded column qualifier counter on the parent table)\n-                    if (childViews.size() > 0 || ( mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN\n+                    if (( mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN\n                             && type == PTableType.VIEW\n                             && table.getEncodingScheme() !=\n                             QualifierEncodingScheme.NON_ENCODED_QUALIFIERS)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzU4OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525543589", "bodyText": "Shouldn't this be done even if if (!remoteMutations.isEmpty()) is false if the table/view has child views??", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:42:22Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -2846,21 +2872,25 @@ private MetaDataMutationResult mutateColumn(\n                 separateLocalAndRemoteMutations(region, tableMetadata, localMutations,\n                         remoteMutations);\n                 if (!remoteMutations.isEmpty()) {\n-                    // there should only be remote mutations if we are adding a column to a view\n+                    // there should only be remote mutations if we are updating the last ddl\n+                    // timestamp for child views, or we are adding a column to a view\n                     // that uses encoded column qualifiers (the remote mutations are to update the\n                     // encoded column qualifier counter on the parent table)\n-                    if (mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN\n+                    if (childViews.size() > 0 || ( mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4ODU1OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525588559", "bodyText": "I added the childViews.size() check when I was sending the ddl timestamp mutations remotely to the child view header rows, which I stopped doing in the last draft. That part of the if clause should just be removed right? Or was the existing logic wrong if a child view existed?", "author": "gjacoby126", "createdAt": "2020-11-17T23:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzU4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\nindex 987d5456b..22673b719 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java\n\n@@ -2872,11 +2880,10 @@ public class MetaDataEndpointImpl extends MetaDataProtocol implements Coprocesso\n                 separateLocalAndRemoteMutations(region, tableMetadata, localMutations,\n                         remoteMutations);\n                 if (!remoteMutations.isEmpty()) {\n-                    // there should only be remote mutations if we are updating the last ddl\n-                    // timestamp for child views, or we are adding a column to a view\n+                    // there should only be remote mutations if we are adding a column to a view\n                     // that uses encoded column qualifiers (the remote mutations are to update the\n                     // encoded column qualifier counter on the parent table)\n-                    if (childViews.size() > 0 || ( mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN\n+                    if (( mutator.getMutateColumnType() == ColumnMutator.MutateColumnType.ADD_COLUMN\n                             && type == PTableType.VIEW\n                             && table.getEncodingScheme() !=\n                             QualifierEncodingScheme.NON_ENCODED_QUALIFIERS)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525549727", "bodyText": "Except for when a column is dropped from some ancestor after the view diverged. In that case, they do \"inherit\" that change, just like they would have before diverging.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:53:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/ViewUtil.java", "diffHunk": "@@ -654,10 +654,17 @@ public static PTable addDerivedColumnsFromParent(PTable view, PTable parentTable\n         }\n \n         long maxTableTimestamp = view.getTimeStamp();\n+        long maxDDLTimestamp = view.getLastDDLTimestamp() != null ? view.getLastDDLTimestamp() : 0L;\n         int numPKCols = view.getPKColumns().size();\n-        // set the final table timestamp as the max timestamp of the view/view index or its\n-        // ancestors\n+        // set the final table timestamp and DDL timestamp as the respective max timestamps of the\n+        // view/view index or its ancestors\n         maxTableTimestamp = Math.max(maxTableTimestamp, parentTable.getTimeStamp());\n+        //Diverged views no longer inherit ddl timestamps from their ancestors because they don't\n+        // inherit column changes", "originalCommit": "68558234b685922a6c3b29d86153d0054e0f7b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTc5Mw==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525551793", "bodyText": "Maybe we need to introduce another field in PTable to explicitly store any drop column DDLs being issued to a table/view. Then we could use that to get the lastDDLTs of diverged views.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-17T21:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDA3OQ==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525580079", "bodyText": "I'd be more inclined to:\nStep 1. Update the last ddl timestamp on either add or drop column, and accept that in a future JIRA the schema registry will be redundantly updated in the (hopefully rare) event that a base table of a diverged view adds a column. Essentially this removes the diverged view check here in ViewUtil. (Easy)\nOptional Step 2. Then in a second JIRA change the diverged view logic to inherit changes on both add column and drop column so the updates aren't really redundant. (Harder, but leaves us in a better state)\nIf there's some compelling reason to keep the existing logic, I'm interested to learn about it, but right now it doesn't seem to justify the enormous complexity (which just keeps compounding with time!) that it requires.", "author": "gjacoby126", "createdAt": "2020-11-17T22:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDc0NA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r525580744", "bodyText": "(Especially since this all appears to be undocumented behavior.)", "author": "gjacoby126", "createdAt": "2020-11-17T22:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwNzk1OA==", "url": "https://github.com/apache/phoenix/pull/935#discussion_r526307958", "bodyText": "@ChinmaySKulkarni - Pushed up a commit that implements Step 1 described above.", "author": "gjacoby126", "createdAt": "2020-11-18T18:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/ViewUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/ViewUtil.java\nindex 9041044c6..5ce60e670 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/ViewUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/ViewUtil.java\n\n@@ -659,12 +659,10 @@ public class ViewUtil {\n         // set the final table timestamp and DDL timestamp as the respective max timestamps of the\n         // view/view index or its ancestors\n         maxTableTimestamp = Math.max(maxTableTimestamp, parentTable.getTimeStamp());\n-        //Diverged views no longer inherit ddl timestamps from their ancestors because they don't\n-        // inherit column changes\n-        if (!ViewUtil.isDivergedView(view)) {\n-            maxDDLTimestamp = Math.max(maxDDLTimestamp,\n+\n+        maxDDLTimestamp = Math.max(maxDDLTimestamp,\n                 parentTable.getLastDDLTimestamp() != null ? parentTable.getLastDDLTimestamp() : 0L);\n-        }\n+\n         if (hasIndexId) {\n             // add all pk columns of parent tables to indexes\n             // skip salted column as it will be added from the base table columns\n"}}, {"oid": "f427501628fcb482405b0c0dff7cf510650dee00", "url": "https://github.com/apache/phoenix/commit/f427501628fcb482405b0c0dff7cf510650dee00", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:33:32Z", "type": "commit"}, {"oid": "d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "url": "https://github.com/apache/phoenix/commit/d62faa2e2ff95ff93d10dfc946f8d6dd8c39f418", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:33:33Z", "type": "commit"}, {"oid": "75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "url": "https://github.com/apache/phoenix/commit/75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:52:39Z", "type": "commit"}, {"oid": "75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "url": "https://github.com/apache/phoenix/commit/75c5bdfd326cdf71c0a3ec8b76756ffa0ae1e058", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-18T21:52:39Z", "type": "forcePushed"}, {"oid": "80982e2a559aaad6a0d25885455b0bc6698ac58b", "url": "https://github.com/apache/phoenix/commit/80982e2a559aaad6a0d25885455b0bc6698ac58b", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-19T05:55:55Z", "type": "commit"}, {"oid": "171e7e2891314a309eafb03bd5c5fe37bf85bc89", "url": "https://github.com/apache/phoenix/commit/171e7e2891314a309eafb03bd5c5fe37bf85bc89", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-19T17:02:06Z", "type": "commit"}, {"oid": "939db6e26a7538da918f967c49f1ab43b8f0c806", "url": "https://github.com/apache/phoenix/commit/939db6e26a7538da918f967c49f1ab43b8f0c806", "message": "PHOENIX-6186 - Store last DDL timestamp in System.Catalog", "committedDate": "2020-11-19T21:56:04Z", "type": "commit"}]}