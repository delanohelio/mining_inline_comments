{"pr_number": 913, "pr_title": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "pr_createdAt": "2020-10-06T23:55:13Z", "pr_url": "https://github.com/apache/phoenix/pull/913", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDEyMQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r520944121", "bodyText": "We already have immutable table creation in other tests in this class. Do we need this test?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-10T23:40:51Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java", "diffHunk": "@@ -98,4 +99,13 @@ public void testQueryWithMultipleColumnFamiliesAndMultipleConditionsForImmutable\n             }\n         }\n     }\n+\n+    @Test\n+    public void testImmutableTableCreation() throws Exception {", "originalCommit": "976ae42c53350982b71a91b06b54c820d01e76db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDYwOQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r533790609", "bodyText": "Correct, @ChinmaySKulkarni , doesn't look like we need this. Removed it.", "author": "gjacoby126", "createdAt": "2020-12-01T23:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDEyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\nindex 9886d0907..771f2e16d 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\n\n@@ -99,13 +99,4 @@ public class ImmutableTableIT extends ParallelStatsDisabledIT {\n             }\n         }\n     }\n-\n-    @Test\n-    public void testImmutableTableCreation() throws Exception {\n-        TestDDLUtil testDDLUtil = new TestDDLUtil(false);\n-        try (Connection conn = DriverManager.getConnection(getUrl())) {\n-            testDDLUtil.createBaseTable(conn, generateUniqueName(), generateUniqueName(), false,\n-                null, null, false);\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDc2Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r520944763", "bodyText": "I might be wrong here, but don't we already have a class like this introduced by @jpisaac for creating test tables, indices, etc. and test data too?", "author": "ChinmaySKulkarni", "createdAt": "2020-11-10T23:42:31Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/util/TestDDLUtil.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.util;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class TestDDLUtil {", "originalCommit": "976ae42c53350982b71a91b06b54c820d01e76db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTY3Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r533789672", "bodyText": "Switched WALAnnotationIT to use @jpisaac 's SchemaBuilder class (and enhanced it a bit to fill in a couple feature gaps)", "author": "gjacoby126", "createdAt": "2020-12-01T23:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NDc2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/util/TestDDLUtil.java b/phoenix-core/src/test/java/org/apache/phoenix/util/TestDDLUtil.java\nindex 10028ce9a..e0989883f 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/util/TestDDLUtil.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/util/TestDDLUtil.java\n\n@@ -17,11 +17,15 @@\n  */\n package org.apache.phoenix.util;\n \n+import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;\n+\n import java.sql.Connection;\n import java.sql.SQLException;\n \n public class TestDDLUtil {\n     private boolean isNamespaceMapped;\n+    private boolean isChangeDetectionEnabled;\n+\n     public TestDDLUtil(boolean isNamespaceMapped) {\n         this.isNamespaceMapped = isNamespaceMapped;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjE5Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r520946196", "bodyText": "nit: add a newline", "author": "ChinmaySKulkarni", "createdAt": "2020-11-10T23:46:29Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestDDLUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private TestDDLUtil ddlUtil;\n+    private boolean isImmutable;\n+    private boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+        ddlUtil = new TestDDLUtil(false);\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<String, String>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        boolean createGlobalIndex = false;\n+        upsertAndDeleteHelper(tableInfo, createGlobalIndex);\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getTableName(), PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        boolean createGlobalIndex = true;\n+        upsertAndDeleteHelper(tableInfo, createGlobalIndex);\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getTableName(), PTableType.TABLE, minTimestamp, true);\n+        assertAnnotation(2, tableInfo.getPhysicalGlobalIndexName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getIndexName(), PTableType.INDEX, minTimestamp, true);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private void upsertAndDeleteHelper(TestTableInfo tableInfo, boolean createGlobalIndex) throws SQLException {\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, tableInfo.getSchemaName(), tableInfo.getTableName(),\n+                isMultiTenant, null, null, isImmutable);\n+            if (createGlobalIndex) {\n+                ddlUtil.createIndex(conn, tableInfo.getSchemaName(), tableInfo.getIndexName(),\n+                    tableInfo.getTableName(), \"v1\", false, false);\n+            }\n+            String upsertSql = \"UPSERT INTO \" + tableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT\n+            //(i.e, it generates the Mutations and then pushes them to server, rather than\n+            // running a select query and deleting the mutations returned)\n+            String deleteSql = \"DELETE FROM \" + tableInfo.getFullTableName() + \" \" +\n+                \"WHERE t_id = 'a' AND k1 = 'b'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertSelectClientSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo baseTableInfo = new TestTableInfo();\n+        TestTableInfo targetTableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            //upsert selecting from a different table will force processing to be client-side\n+            ddlUtil.createBaseTable(conn, baseTableInfo.getSchemaName(), baseTableInfo.getTableName(),\n+                isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseTableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            ddlUtil.createBaseTable(conn, targetTableInfo.getSchemaName(),\n+                targetTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            String sql = \"UPSERT INTO \" + targetTableInfo.getFullTableName() +\n+                \" (t_id, k1, k2, v1, v2) SELECT * FROM \" + baseTableInfo.getFullTableName();\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+        }\n+        assertAnnotation(1, baseTableInfo.getPhysicalTableName(), null,\n+            baseTableInfo.getSchemaName(), baseTableInfo.getTableName(), PTableType.TABLE,\n+            minTimestamp, true);\n+        assertAnnotation(1, targetTableInfo.getPhysicalTableName(), null,\n+            targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testUpsertSelectServerSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeFalse(isImmutable); //only mutable tables can be processed server-side\n+        TestTableInfo targetTableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, targetTableInfo.getSchemaName(),\n+                targetTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + targetTableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            conn.setAutoCommit(true); //required for server side execution\n+            clearAnnotations(TableName.valueOf(SchemaUtil.getPhysicalHBaseTableName(\n+                targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+                false).getString()));\n+            String sql = \"UPSERT INTO \" + targetTableInfo.getFullTableName() +\n+                \" (t_id, k1, k2, v1, v2) SELECT * FROM \" + targetTableInfo.getFullTableName();\n+            conn.createStatement().execute(sql);\n+        }\n+        assertAnnotation(1, targetTableInfo.getPhysicalTableName(), null,\n+            targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testGroupedUpsertSelect() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        //because we're inserting to a different table than we're selecting from, this should be\n+        // processed client-side\n+        TestTableInfo baseTableInfo = new TestTableInfo();\n+        TestTableInfo targetTableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, baseTableInfo.getSchemaName(),\n+                baseTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            ddlUtil.createBaseTable(conn, targetTableInfo.getSchemaName(),\n+                targetTableInfo.getTableName(), isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseTableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            String aggSql = \"UPSERT INTO \" + targetTableInfo.getFullTableName() +\n+                \" SELECT t_id, k1, k2, MIN(v1), AVG(v2) FROM \" + baseTableInfo.getFullTableName() +\n+                \" GROUP BY t_id, k1, k2\";\n+            conn.createStatement().execute(aggSql);\n+            conn.commit();\n+        }\n+        assertAnnotation(1, baseTableInfo.getPhysicalTableName(), null,\n+            baseTableInfo.getSchemaName(), baseTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+        assertAnnotation(1, targetTableInfo.getPhysicalTableName(), null,\n+            targetTableInfo.getSchemaName(), targetTableInfo.getTableName(),\n+            PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testRangeDeleteServerSide() throws Exception {\n+        boolean isClientSide = false;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    private void testRangeDeleteHelper(boolean isClientSide) throws SQLException, IOException {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            ddlUtil.createBaseTable(conn, tableInfo.getSchemaName(), tableInfo.getTableName(),\n+                isMultiTenant, null, null, isImmutable);\n+            conn.createStatement().execute(\"UPSERT INTO \" + tableInfo.getFullTableName() + \" VALUES\" +\n+                \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            //Deleting by a partial PK to so that it executes a SELECT and then deletes the\n+            // returned mutations\n+            String sql = \"DELETE FROM \" + tableInfo.getFullTableName() + \" \" +\n+                \"WHERE t_id = 'a' AND k1 = 'b'\";\n+\n+            if (isClientSide) {\n+                sql += \" LIMIT 1\";\n+            }\n+            conn.setAutoCommit(!isClientSide);\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+        }\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getTableName(), PTableType.TABLE, minTimestamp, true);\n+    }\n+\n+    @Test\n+    public void testRangeDeleteClientSide() throws Exception {\n+        boolean isClientSide = true;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    @Test\n+    public void testGlobalViewUpsert() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        TestTableInfo tableInfo = new TestTableInfo();\n+        long minTimestamp = EnvironmentEdgeManager.currentTimeMillis();\n+        try (Connection conn = getConnection()) {\n+            createGlobalViewHelper(tableInfo, conn);\n+            conn.createStatement().execute(\"UPSERT INTO \" + tableInfo.getFullViewName()\n+                + \" VALUES\" + \" ('a', 'b', 2, 'bc', 3)\");\n+            conn.commit();\n+            String deleteSql = \"DELETE FROM \" + tableInfo.getFullViewName() + \" \" +\n+                \"WHERE t_id = 'a' AND k1 = 'b' and k2 = 2\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();        }\n+        assertAnnotation(2, tableInfo.getPhysicalTableName(), null, tableInfo.getSchemaName(),\n+            tableInfo.getViewName(), PTableType.VIEW, minTimestamp, true);\n+    }\n+    private void createGlobalViewHelper(TestTableInfo tableInfo, Connection conn) throws SQLException {", "originalCommit": "976ae42c53350982b71a91b06b54c820d01e76db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDQzOQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r533790439", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-12-01T23:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NjE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex 9507bed32..ef26c0c6b 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -30,22 +30,23 @@ import org.apache.hadoop.hbase.wal.WAL;\n import org.apache.hadoop.hbase.wal.WALKey;\n import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n import org.apache.phoenix.execute.MutationState;\n import org.apache.phoenix.hbase.index.IndexRegionObserver;\n import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n import org.apache.phoenix.schema.PTableType;\n-import org.apache.phoenix.util.EnvironmentEdgeManager;\n import org.apache.phoenix.util.MetaDataUtil;\n import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.ReadOnlyProps;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.apache.phoenix.util.TestDDLUtil;\n import org.apache.phoenix.util.TestUtil;\n import org.junit.Assert;\n import org.junit.Assume;\n import org.junit.BeforeClass;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n"}}, {"oid": "9c1f0d169152e5eeb945dee60685209667811bd0", "url": "https://github.com/apache/phoenix/commit/9c1f0d169152e5eeb945dee60685209667811bd0", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-11-20T22:10:38Z", "type": "forcePushed"}, {"oid": "bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "url": "https://github.com/apache/phoenix/commit/bc9b26ce09b0d39623b427227cc72e8bfe9f31d3", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-08T17:16:19Z", "type": "forcePushed"}, {"oid": "233766547c1db7700356eb74f1a018b4c12c6275", "url": "https://github.com/apache/phoenix/commit/233766547c1db7700356eb74f1a018b4c12c6275", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-08T21:58:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNTAxMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539235012", "bodyText": "nit: we are assigning these variables representing MutationMetadataType twice (null and scan.getAttribute()), should we assign all of them just once by removing null assignments?", "author": "virajjasani", "createdAt": "2020-12-09T11:39:39Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -644,4 +651,33 @@ public boolean next(List<Cell> resultsToReturn) throws IOException {\n     public long getMaxResultSize() {\n         return scan.getMaxResultSize();\n     }\n+\n+    private void annotateDataMutations(UngroupedAggregateRegionObserver.MutationList mutationsList,\n+                                       Scan scan) {\n+        byte[] tenantId = null;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM1MDc0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541350748", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-12-11T22:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNTAxMg=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\nindex 5895e8c37..a96303add 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\n\n@@ -647,6 +638,15 @@ public class UngroupedAggregateRegionScanner extends BaseRegionScanner {\n         }\n     }\n \n+    private void annotateAndCommit(UngroupedAggregateRegionObserver.MutationList mutations) throws IOException {\n+        if (isDelete || isUpsert) {\n+            annotateDataMutations(mutations, scan);\n+        }\n+        ungroupedAggregateRegionObserver.commit(region, mutations, indexUUID, blockingMemStoreSize, indexMaintainersPtr, txState,\n+            targetHTable, useIndexProto, isPKChanging, clientVersionBytes);\n+        mutations.clear();\n+    }\n+\n     @Override\n     public long getMaxResultSize() {\n         return scan.getMaxResultSize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNjk0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539236948", "bodyText": "nit: redundant?", "author": "virajjasani", "createdAt": "2020-12-09T11:42:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -64,6 +64,7 @@\n import org.apache.phoenix.cache.GlobalCache;\n import org.apache.phoenix.cache.TenantCache;\n import org.apache.phoenix.exception.DataExceedsCapacityException;\n+import org.apache.phoenix.execute.MutationState;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0NzMzNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541347335", "bodyText": "removed", "author": "gjacoby126", "createdAt": "2020-12-11T22:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzNjk0OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539380246", "bodyText": "In case of old client - new server case, changeDetectionEnabledKv will be null right?", "author": "virajjasani", "createdAt": "2020-12-09T15:02:20Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/MetaDataEndpointImpl.java", "diffHunk": "@@ -1160,6 +1169,12 @@ private PTable getTable(RegionScanner scanner, long clientTimeStamp, long tableT\n            null : PLong.INSTANCE.getCodec().decodeLong(lastDDLTimestampKv.getValueArray(),\n                 lastDDLTimestampKv.getValueOffset(), SortOrder.getDefault());\n \n+        Cell changeDetectionEnabledKv = tableKeyValues[CHANGE_DETECTION_ENABLED_INDEX];\n+        boolean isChangeDetectionEnabled = changeDetectionEnabledKv != null", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNzQwNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539637405", "bodyText": "So long as some other client hasn't set CHANGE_DETECTION_ENABLED=true on the table via an ALTER statement.", "author": "gjacoby126", "createdAt": "2020-12-09T20:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMzQ3NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539703474", "bodyText": "If a new client modifies some table's CDE field, there won't be a problem for old clients interacting with the table right?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0Njc5NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541346794", "bodyText": "Since it's an optional field in the protobuf and the old client won't even know to deserialize it I don't think it would cause a problem.", "author": "gjacoby126", "createdAt": "2020-12-11T22:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDI0Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4NzI5OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539387298", "bodyText": "nit: we can keep both util methods private?", "author": "virajjasani", "createdAt": "2020-12-09T15:10:37Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -682,6 +687,49 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n         values.putAll(modifiedValues);\n     }\n \n+    public static void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+        //only annotate if the change detection flag is on the table and HBase supports\n+        // preWALAppend coprocs server-side\n+        if (table == null || !table.isChangeDetectionEnabled()\n+            || !HbaseCompatCapabilities.hasPreWALAppend()) {\n+            return;\n+        }\n+        //annotate each mutation with enough metadata so that anyone interested can\n+        // deterministically figure out exactly what Phoenix schema object created the mutation\n+        // Server-side we can annotate the HBase WAL with these.\n+        for (Mutation mutation : rowMutations) {\n+            annotateMutationWithMetadata(table, mutation);\n+        }\n+\n+    }\n+\n+    public static void annotateMutationWithMetadata(PTable table, Mutation mutation) {", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2MjM3Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541362377", "bodyText": "Switched to private", "author": "gjacoby126", "createdAt": "2020-12-11T22:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4NzI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\nindex 27baf4dd3..8b572524c 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n\n@@ -687,7 +687,7 @@ public class MutationState implements SQLCloseable {\n         values.putAll(modifiedValues);\n     }\n \n-    public static void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+    private void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n         //only annotate if the change detection flag is on the table and HBase supports\n         // preWALAppend coprocs server-side\n         if (table == null || !table.isChangeDetectionEnabled()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMjg5NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539402895", "bodyText": "nit: should we avoid defining constants in Compat classes?", "author": "virajjasani", "createdAt": "2020-12-09T15:28:19Z", "path": "phoenix-hbase-compat-1.3.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatIndexRegionObserver.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.compat.hbase.coprocessor;\n+\n+import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class CompatIndexRegionObserver extends BaseRegionObserver {\n+    public static String PHOENIX_APPEND_METADATA_TO_WAL = \"phoenix.append.metadata.to.wal\";\n+    public static boolean DEFAULT_PHOENIX_APPEND_METADATA_TO_WAL = false;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzOTczOA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539639738", "bodyText": "These aren't used, will remove.", "author": "gjacoby126", "createdAt": "2020-12-09T20:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMjg5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "chunk": "diff --git a/phoenix-hbase-compat-1.3.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatIndexRegionObserver.java b/phoenix-hbase-compat-1.3.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatIndexRegionObserver.java\nindex 75d02fd96..57e4685f9 100644\n--- a/phoenix-hbase-compat-1.3.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatIndexRegionObserver.java\n+++ b/phoenix-hbase-compat-1.3.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatIndexRegionObserver.java\n\n@@ -28,15 +28,13 @@ import java.util.HashMap;\n import java.util.Map;\n \n public class CompatIndexRegionObserver extends BaseRegionObserver {\n-    public static String PHOENIX_APPEND_METADATA_TO_WAL = \"phoenix.append.metadata.to.wal\";\n-    public static boolean DEFAULT_PHOENIX_APPEND_METADATA_TO_WAL = false;\n \n     public void preWALAppend(ObserverContext<RegionCoprocessorEnvironment> c, WALKey key,\n                              WALEdit edit) {\n         //no-op implementation for HBase 1.3 and 1.4 that doesn't support this co-proc hook.\n     }\n \n-    protected void appendToWALKey(WALKey key, String attrKey, byte[] attrValue) {\n+    public static void appendToWALKey(WALKey key, String attrKey, byte[] attrValue) {\n         //no-op for HBase 1.3 and 1.4 because we don't have WALKey.addExtendedAttribute(String,\n         // byte[])\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNjY3NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539406674", "bodyText": "appendToWALKey() is public only in 1.5 compact class but not in 1.3/1.4 compact classes, without which this could cause compilation issue while running against 1.3/1.4.", "author": "virajjasani", "createdAt": "2020-12-09T15:32:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.util;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+\n+import java.util.Map;\n+\n+/**\n+ * Utility functions shared between IndexRegionObserver and GlobalIndexChecker for annotating the\n+ * HBase WAL with Phoenix-level metadata about mutations.\n+ */\n+public class WALAnnotationUtil {\n+\n+    public static void appendMutationAttributesToWALKey(WALKey key,\n+                                        IndexRegionObserver.BatchMutateContext context) {\n+        if (context != null && context.getOriginalMutations().size() > 0) {\n+            Mutation firstMutation = context.getOriginalMutations().get(0);\n+            Map<String, byte[]> attrMap = firstMutation.getAttributesMap();\n+            for (MutationState.MutationMetadataType metadataType :\n+                MutationState.MutationMetadataType.values()) {\n+                String metadataTypeKey = metadataType.toString();\n+                if (attrMap.containsKey(metadataTypeKey)) {\n+                    CompatIndexRegionObserver.appendToWALKey(key, metadataTypeKey,", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NjYzNw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539466637", "bodyText": "Moreover, 1.3/1.4 compact classes don't have it as static", "author": "virajjasani", "createdAt": "2020-12-09T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNjY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MjcyMQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539642721", "bodyText": "Oops, thanks for the catch.", "author": "gjacoby126", "createdAt": "2020-12-09T20:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNjY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java\nindex 8a847cb3c..76564a6ab 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java\n\n@@ -15,9 +15,8 @@\n  */\n package org.apache.phoenix.util;\n \n-import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Durability;\n import org.apache.hadoop.hbase.client.Mutation;\n-import org.apache.hadoop.hbase.util.Bytes;\n import org.apache.hadoop.hbase.wal.WALKey;\n import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n import org.apache.phoenix.execute.MutationState;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1NDA2NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539454064", "bodyText": "If possible, we can refactor this validation in a small util method and it can be used by both workflows: createTable/createIndex and addColumn/alterIndex?", "author": "virajjasani", "createdAt": "2020-12-09T16:28:00Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java", "diffHunk": "@@ -2102,6 +2106,17 @@ private PTable createTableInternal(CreateTableStatement statement, byte[][] spli\n                 }\n             }\n \n+            Boolean isChangeDetectionEnabledProp =\n+                (Boolean) TableProperty.CHANGE_DETECTION_ENABLED.getValue(tableProps);\n+            if (isChangeDetectionEnabledProp != null) {\n+                if (tableType != TABLE && tableType != VIEW) {\n+                    throw new SQLExceptionInfo.Builder(\n+                        SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY)", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3NDQ5Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542574493", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-12-14T17:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1NDA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\nindex b052458c6..7c3ed2082 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/schema/MetaDataClient.java\n\n@@ -2108,14 +2108,7 @@ public class MetaDataClient {\n \n             Boolean isChangeDetectionEnabledProp =\n                 (Boolean) TableProperty.CHANGE_DETECTION_ENABLED.getValue(tableProps);\n-            if (isChangeDetectionEnabledProp != null) {\n-                if (tableType != TABLE && tableType != VIEW) {\n-                    throw new SQLExceptionInfo.Builder(\n-                        SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY)\n-                        .build()\n-                        .buildException();\n-                }\n-            }\n+            verifyChangeDetectionTableType(tableType, isChangeDetectionEnabledProp);\n \n             if (parent != null && tableType == PTableType.INDEX) {\n                 timestamp = TransactionUtil.getTableTimestamp(connection, transactionProvider != null, transactionProvider);\n"}}, {"oid": "3d85019370ddbc6564aff6b958189ae8617a5a63", "url": "https://github.com/apache/phoenix/commit/3d85019370ddbc6564aff6b958189ae8617a5a63", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-09T21:10:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDYxNA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539560614", "bodyText": "nit: is the import necessary? Seems like the only change on this file is this import", "author": "gokceni", "createdAt": "2020-12-09T18:50:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java", "diffHunk": "@@ -17,6 +17,7 @@\n  */\n package org.apache.phoenix.end2end;\n \n+import org.apache.phoenix.util.TestDDLUtil;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3MzMxNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542573315", "bodyText": "Removed", "author": "gjacoby126", "createdAt": "2020-12-14T17:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\nindex 771f2e16d..9ae505d62 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\n\n@@ -17,7 +17,6 @@\n  */\n package org.apache.phoenix.end2end;\n \n-import org.apache.phoenix.util.TestDDLUtil;\n import org.junit.Test;\n \n import java.sql.Connection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NDYyMA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539564620", "bodyText": "ditto", "author": "gokceni", "createdAt": "2020-12-09T18:56:43Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java", "diffHunk": "@@ -72,6 +72,7 @@\n import org.apache.phoenix.util.PropertiesUtil;\n import org.apache.phoenix.util.QueryUtil;\n import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestDDLUtil;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3MzQyNA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542573424", "bodyText": "Removed", "author": "gjacoby126", "createdAt": "2020-12-14T17:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NDYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\nindex f8b7f43a5..7890e19c8 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\n\n@@ -72,7 +71,6 @@ import org.apache.phoenix.util.PhoenixRuntime;\n import org.apache.phoenix.util.PropertiesUtil;\n import org.apache.phoenix.util.QueryUtil;\n import org.apache.phoenix.util.SchemaUtil;\n-import org.apache.phoenix.util.TestDDLUtil;\n import org.apache.phoenix.util.TestUtil;\n import org.junit.Assert;\n import org.junit.Ignore;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MTg2MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539571860", "bodyText": "TODO seems to be dropped but not implemented?", "author": "gokceni", "createdAt": "2020-12-09T19:07:48Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/GroupedAggregateRegionObserver.java", "diffHunk": "@@ -400,7 +400,6 @@ protected boolean isRegionObserverFor(Scan scan) {\n      * Used for an aggregate query in which the key order does not necessarily match the group by\n      * key order. In this case, we must collect all distinct groups within a region into a map,\n      * aggregating as we go.\n-     * @param limit TODO", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0NTU5Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541345592", "bodyText": "Removed the params from the Javadoc as they were Javadoc errors.", "author": "gjacoby126", "createdAt": "2020-12-11T22:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MTg2MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MzAzMA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539573030", "bodyText": "nit: lonely import", "author": "gokceni", "createdAt": "2020-12-09T19:09:43Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java", "diffHunk": "@@ -73,6 +73,7 @@\n import org.apache.hadoop.io.WritableUtils;\n import org.apache.phoenix.coprocessor.generated.PTableProtos;\n import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java\nindex d553bec15..ed4ea74c9 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java\n\n@@ -73,13 +73,10 @@ import org.apache.hadoop.hbase.util.Pair;\n import org.apache.hadoop.io.WritableUtils;\n import org.apache.phoenix.coprocessor.generated.PTableProtos;\n import org.apache.phoenix.exception.SQLExceptionCode;\n-import org.apache.phoenix.execute.MutationState;\n-import org.apache.phoenix.exception.SQLExceptionInfo;\n import org.apache.phoenix.execute.TupleProjector;\n import org.apache.phoenix.expression.Expression;\n import org.apache.phoenix.expression.ExpressionType;\n import org.apache.phoenix.filter.AllVersionsIndexRebuildFilter;\n-import org.apache.phoenix.hbase.index.IndexRegionObserver;\n import org.apache.phoenix.hbase.index.Indexer;\n import org.apache.phoenix.hbase.index.covered.update.ColumnReference;\n import org.apache.phoenix.hbase.index.exception.IndexWriteException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MjU5MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539672591", "bodyText": "It would be nice to refactor this perhaps to a new method? Lines 596 to 602 is same as 616 to 622", "author": "gokceni", "createdAt": "2020-12-09T21:47:25Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -609,6 +613,9 @@ public boolean next(List<Cell> resultsToReturn) throws IOException {\n                     } while (hasMore && (EnvironmentEdgeManager.currentTimeMillis() - startTime) < pageSizeInMs);\n \n                     if (!mutations.isEmpty()) {\n+                        if (isDelete || isUpsert) {\n+                            annotateDataMutations(mutations, scan);\n+                        }", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM0OTk5Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541349997", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-12-11T22:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MjU5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\nindex 5895e8c37..a96303add 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\n\n@@ -613,12 +609,7 @@ public class UngroupedAggregateRegionScanner extends BaseRegionScanner {\n                     } while (hasMore && (EnvironmentEdgeManager.currentTimeMillis() - startTime) < pageSizeInMs);\n \n                     if (!mutations.isEmpty()) {\n-                        if (isDelete || isUpsert) {\n-                            annotateDataMutations(mutations, scan);\n-                        }\n-                        ungroupedAggregateRegionObserver.commit(region, mutations, indexUUID, blockingMemStoreSize, indexMaintainersPtr, txState,\n-                                targetHTable, useIndexProto, isPKChanging, clientVersionBytes);\n-                        mutations.clear();\n+                        annotateAndCommit(mutations);\n                     }\n                     if (!indexMutations.isEmpty()) {\n                         ungroupedAggregateRegionObserver.commitBatch(region, indexMutations, blockingMemStoreSize);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MzI4Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539673286", "bodyText": "Would this be populated for both view indexes and regular indexes and local indexes?", "author": "gokceni", "createdAt": "2020-12-09T21:48:35Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/generated/ServerCachingProtos.java", "diffHunk": "@@ -2192,6 +2192,21 @@ public Builder setColumnNameBytes(\n      */\n     com.google.protobuf.ByteString\n         getParentTableTypeBytes();\n+\n+    // optional string logicalIndexName = 25;\n+    /**\n+     * <code>optional string logicalIndexName = 25;</code>\n+     */\n+    boolean hasLogicalIndexName();\n+    /**\n+     * <code>optional string logicalIndexName = 25;</code>\n+     */\n+    java.lang.String getLogicalIndexName();", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3OTQyNg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542579426", "bodyText": "@gjacoby126 thanks for addressing my comments. There is just this question remaining.", "author": "gokceni", "createdAt": "2020-12-14T17:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MzI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MTc0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542791748", "bodyText": "@gokceni  Correct, should be populated for all indexes.", "author": "gjacoby126", "createdAt": "2020-12-14T21:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MzI4Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3Mzg0MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539673840", "bodyText": "perhaps move this to line 684? (out of if else?)", "author": "gokceni", "createdAt": "2020-12-09T21:49:31Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -674,6 +678,7 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n                         mutation.setAttribute(PhoenixIndexBuilder.ATOMIC_OP_ATTRIB, onDupKeyBytes);\n                     }\n                 }\n+                annotateMutationsWithMetadata(table, rowMutations);", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNDk1NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539704955", "bodyText": "+1, there is no difference between the if and else as far as annotation goes right?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3Mzg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3Mjk0Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542572942", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-12-14T17:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3Mzg0MA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\nindex 8b572524c..7641db412 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n\n@@ -678,9 +677,9 @@ public class MutationState implements SQLCloseable {\n                         mutation.setAttribute(PhoenixIndexBuilder.ATOMIC_OP_ATTRIB, onDupKeyBytes);\n                     }\n                 }\n-                annotateMutationsWithMetadata(table, rowMutations);\n                 rowMutationsPertainingToIndex = rowMutations;\n             }\n+            annotateMutationsWithMetadata(table, rowMutations);\n             mutationList.addAll(rowMutations);\n             if (mutationsPertainingToIndex != null) mutationsPertainingToIndex.addAll(rowMutationsPertainingToIndex);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3NTkzNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539675935", "bodyText": "Actually why not use the this method in the Ungroupped..Scanner in that for loop that goes over mutations? Also mutation  durability was not checked there I think", "author": "gokceni", "createdAt": "2020-12-09T21:52:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -682,6 +687,49 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n         values.putAll(modifiedValues);\n     }\n \n+    private void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+        //only annotate if the change detection flag is on the table and HBase supports\n+        // preWALAppend coprocs server-side\n+        if (table == null || !table.isChangeDetectionEnabled()\n+            || !HbaseCompatCapabilities.hasPreWALAppend()) {\n+            return;\n+        }\n+        //annotate each mutation with enough metadata so that anyone interested can\n+        // deterministically figure out exactly what Phoenix schema object created the mutation\n+        // Server-side we can annotate the HBase WAL with these.\n+        for (Mutation mutation : rowMutations) {\n+            annotateMutationWithMetadata(table, mutation);\n+        }\n+\n+    }\n+\n+    public static void annotateMutationWithMetadata(PTable table, Mutation mutation) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2MjcyMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541362722", "bodyText": "Consolidated in WALAnnotationUtil as @ChinmaySKulkarni suggested.", "author": "gjacoby126", "createdAt": "2020-12-11T22:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3NTkzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\nindex 8b572524c..7641db412 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n\n@@ -678,9 +677,9 @@ public class MutationState implements SQLCloseable {\n                         mutation.setAttribute(PhoenixIndexBuilder.ATOMIC_OP_ATTRIB, onDupKeyBytes);\n                     }\n                 }\n-                annotateMutationsWithMetadata(table, rowMutations);\n                 rowMutationsPertainingToIndex = rowMutations;\n             }\n+            annotateMutationsWithMetadata(table, rowMutations);\n             mutationList.addAll(rowMutations);\n             if (mutationsPertainingToIndex != null) mutationsPertainingToIndex.addAll(rowMutationsPertainingToIndex);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDA3NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539644075", "bodyText": "nit: unused import", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:00:48Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java", "diffHunk": "@@ -17,6 +17,7 @@\n  */\n package org.apache.phoenix.end2end;\n \n+import org.apache.phoenix.util.TestDDLUtil;", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\nindex 771f2e16d..9ae505d62 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/ImmutableTableIT.java\n\n@@ -17,7 +17,6 @@\n  */\n package org.apache.phoenix.end2end;\n \n-import org.apache.phoenix.util.TestDDLUtil;\n import org.junit.Test;\n \n import java.sql.Connection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTUxMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649512", "bodyText": "nit: static import assertFalse() like you've done for assertNotNull()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:09:49Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTY1Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649657", "bodyText": "nit: static import assertEquals()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:10:05Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTgyNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649825", "bodyText": "nit: static import assertTrue()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:10:21Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0OTk5Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539649997", "bodyText": "nit: static import fail()", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:10:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTM4OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539651388", "bodyText": "Isn't there a config that toggles client-side vs. server-side deletes? Just curious, will setting this config to client-side cause some of these tests to fail?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:12:58Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private long upsertAndDeleteHelper(SchemaBuilder builder, boolean createGlobalIndex) throws Exception {\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+\n+            if (createGlobalIndex) {\n+                builder.withTableOptions(tableOptions).withTableIndexDefaults().build();\n+            } else {\n+                builder.withTableOptions(tableOptions).build();\n+            }\n+\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', 'c')\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change Detection Enabled is false!\",\n+                table.isChangeDetectionEnabled());\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4OTc5Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539689792", "bodyText": "Even if the delete is issued as a select from the client and delete mutations are issued for those, we would still get the same mutations as if the client had directly issued DELETE mutations right? And then WAL annotations wouldn't change either in both scenarios right? If so, why are we preferring one over the other in the test?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTIxOQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539739219", "bodyText": "The annotation happens in different code paths depending on whether the delete gets executed client side (where it happens in MutationState) or server side (where it happens in the coproc), so I have tests for both to make sure that both work properly.", "author": "gjacoby126", "createdAt": "2020-12-09T23:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MTM4OA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MzI3MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539653270", "bodyText": "Do we want to do some upserts and call getEntriesForTable() again at this point, just to ensure that entries exist now that change detection is enabled?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:16:05Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTU5MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539739591", "bodyText": "We could, but isn't that covered by all the other tests?", "author": "gjacoby126", "createdAt": "2020-12-10T00:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1MzI3MA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTI1NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539655255", "bodyText": "So the idea is that the WAL entry corresponding to an upsert/delete on an entity (table or view) will contain an annotation which has the lastDDLTimestamp of the entity and this can be used against a potential schema registry to find what was the schema of the entity at that point in time when the mutation was issued on it?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:19:13Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private long upsertAndDeleteHelper(SchemaBuilder builder, boolean createGlobalIndex) throws Exception {\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+\n+            if (createGlobalIndex) {\n+                builder.withTableOptions(tableOptions).withTableIndexDefaults().build();\n+            } else {\n+                builder.withTableOptions(tableOptions).build();\n+            }\n+\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', 'c')\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change Detection Enabled is false!\",\n+                table.isChangeDetectionEnabled());\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT\n+            //(i.e, it generates the Mutations and then pushes them to server, rather than\n+            // running a select query and deleting the mutations returned)\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityTableName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = 'b'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            return table.getLastDDLTimestamp();\n+        }\n+    }\n+\n+    private SchemaBuilder.TableOptions getTableOptions() {\n+        SchemaBuilder.TableOptions tableOptions =\n+            SchemaBuilder.TableOptions.withDefaults();\n+        tableOptions.setImmutable(isImmutable);\n+        tableOptions.setMultiTenant(isMultiTenant);\n+        tableOptions.setChangeDetectionEnabled(true);\n+        return tableOptions;\n+    }\n+\n+    @Test\n+    public void testUpsertSelectClientSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder baseBuilder = new SchemaBuilder(getUrl());\n+            SchemaBuilder targetBuilder = new SchemaBuilder(getUrl());\n+            //upsert selecting from a different table will force processing to be client-side\n+            baseBuilder.withTableOptions(getTableOptions()).build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseBuilder.getEntityTableName() + \" \" +\n+                \"VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            targetBuilder.withTableOptions(getTableOptions()).build();\n+            String sql = \"UPSERT INTO \" + targetBuilder.getEntityTableName() +\n+                \" (OID, KP, COL1, COL2, COL3) SELECT * FROM \" + baseBuilder.getEntityTableName();\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+            int expectedAnnotations = 1;\n+            verifyBaseAndTargetAnnotations(conn, baseBuilder, targetBuilder, expectedAnnotations);\n+        }\n+    }\n+\n+    private void verifyBaseAndTargetAnnotations(Connection conn, SchemaBuilder baseBuilder,\n+                                                SchemaBuilder targetBuilder,\n+                                                int expectedAnnotations) throws SQLException, IOException {\n+        PTable baseTable = PhoenixRuntime.getTableNoCache(conn,\n+            baseBuilder.getEntityTableName());\n+        assertAnnotation(expectedAnnotations, baseBuilder.getPhysicalTableName(false), null,\n+            baseBuilder.getTableOptions().getSchemaName(),\n+            baseBuilder.getDataOptions().getTableName(),\n+            PTableType.TABLE,\n+            baseTable.getLastDDLTimestamp());\n+        PTable targetTable = PhoenixRuntime.getTableNoCache(conn,\n+            targetBuilder.getEntityTableName());\n+        assertAnnotation(expectedAnnotations, targetBuilder.getPhysicalTableName(false), null,\n+            targetBuilder.getTableOptions().getSchemaName(), targetBuilder.getDataOptions().getTableName(),\n+            PTableType.TABLE, targetTable.getLastDDLTimestamp());\n+    }\n+\n+    @Test\n+    public void testUpsertSelectServerSide() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeFalse(isImmutable); //only mutable tables can be processed server-side\n+        SchemaBuilder targetBuilder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            targetBuilder.withTableOptions(getTableOptions()).build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + targetBuilder.getEntityTableName() + \" \" +\n+                \"VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            conn.setAutoCommit(true); //required for server side execution\n+            clearAnnotations(TableName.valueOf(targetBuilder.getPhysicalTableName(false)));\n+            String sql = \"UPSERT INTO \" + targetBuilder.getEntityTableName() +\n+                \" (OID, KP, COL1, COL2, COL3) SELECT * FROM \" + targetBuilder.getEntityTableName();\n+            conn.createStatement().execute(sql);\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, targetBuilder.getEntityTableName());\n+            assertAnnotation(1, targetBuilder.getPhysicalTableName(false), null,\n+                targetBuilder.getTableOptions().getSchemaName(),\n+                targetBuilder.getDataOptions().getTableName(),\n+                PTableType.TABLE, table.getLastDDLTimestamp());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testGroupedUpsertSelect() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        //because we're inserting to a different table than we're selecting from, this should be\n+        // processed client-side\n+        SchemaBuilder baseBuilder = new SchemaBuilder(getUrl());\n+        SchemaBuilder targetBuilder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            baseBuilder.withTableOptions(getTableOptions()).build();\n+            targetBuilder.withTableOptions(getTableOptions()).build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + baseBuilder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            String aggSql = \"UPSERT INTO \" + targetBuilder.getEntityTableName() +\n+                \" SELECT OID, KP, MAX(COL1), MIN(COL2), MAX(COL3) FROM \" + baseBuilder.getEntityTableName() +\n+                \" GROUP BY OID, KP\";\n+            conn.createStatement().execute(aggSql);\n+            conn.commit();\n+            int expectedAnnotations = 1;\n+            verifyBaseAndTargetAnnotations(conn, baseBuilder, targetBuilder, expectedAnnotations);\n+        }\n+    }\n+\n+    @Test\n+    public void testRangeDeleteServerSide() throws Exception {\n+        boolean isClientSide = false;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    private void testRangeDeleteHelper(boolean isClientSide) throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        builder.withTableOptions(getTableOptions()).build();\n+        try (Connection conn = getConnection()) {\n+            conn.createStatement().execute(\"UPSERT INTO \" + builder.getEntityTableName() +\n+                \" VALUES ('a', 'b', '2', 'bc', '3')\");\n+            conn.commit();\n+            //Deleting by a partial PK to so that it executes a SELECT and then deletes the\n+            // returned mutations\n+            String sql = \"DELETE FROM \" + builder.getEntityTableName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = 'b'\";\n+\n+            if (isClientSide) {\n+                sql += \" LIMIT 1\";\n+            }\n+            conn.setAutoCommit(!isClientSide);\n+            conn.createStatement().execute(sql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            assertAnnotation(2, table.getPhysicalName().getString(), null,\n+                table.getSchemaName().getString(),\n+                table.getTableName().getString(), PTableType.TABLE, table.getLastDDLTimestamp());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testRangeDeleteClientSide() throws Exception {\n+        boolean isClientSide = true;\n+        testRangeDeleteHelper(isClientSide);\n+    }\n+\n+    @Test\n+    public void testGlobalViewUpsert() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            createGlobalViewHelper(builder, conn);\n+            conn.createStatement().execute(\"UPSERT INTO \" + builder.getEntityGlobalViewName()\n+                + \" VALUES\" + \" ('a', '\" + PhoenixTestBuilder.DDLDefaults.DEFAULT_KP +\n+                \"', '2', 'bc', '3', 'c')\");\n+            conn.commit();\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityGlobalViewName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = '\" + PhoenixTestBuilder.DDLDefaults.DEFAULT_KP + \"' \" +\n+                \"and ID = 'c'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            PTable view = PhoenixRuntime.getTableNoCache(conn, builder.getEntityGlobalViewName());\n+            assertAnnotation(2, view.getPhysicalName().getString(), null,\n+                view.getSchemaName().getString(),\n+                view.getTableName().getString(), PTableType.VIEW, view.getLastDDLTimestamp());\n+        }\n+\n+    }\n+\n+    private void createGlobalViewHelper(SchemaBuilder builder, Connection conn) throws Exception {\n+        builder.withTableOptions(getTableOptions()).\n+            withGlobalViewOptions(getGlobalViewOptions(builder)).build();\n+        PTable view = PhoenixRuntime.getTableNoCache(conn, builder.getEntityGlobalViewName());\n+        Assert.assertTrue(\"View does not have change detection enabled!\",\n+            view.isChangeDetectionEnabled());\n+    }\n+\n+    private SchemaBuilder.GlobalViewOptions getGlobalViewOptions(SchemaBuilder builder) {\n+        SchemaBuilder.GlobalViewOptions options = SchemaBuilder.GlobalViewOptions.withDefaults();\n+        options.setChangeDetectionEnabled(true);\n+        return options;\n+    }\n+\n+    @Test\n+    public void testTenantViewUpsert() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeTrue(isMultiTenant);\n+        boolean createIndex = false;\n+        tenantViewHelper(createIndex);\n+    }\n+\n+    private void tenantViewHelper(boolean createIndex) throws Exception {\n+        //create a base table, global view, and child tenant view, then insert / delete into the\n+        // child tenant view. Make sure that the annotations use the tenant view name\n+        String tenant = generateUniqueName();\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        try (Connection conn = getConnection()) {\n+            createGlobalViewHelper(builder, conn);\n+        }\n+        try (Connection conn = getTenantConnection(tenant)) {\n+            SchemaBuilder.DataOptions dataOptions = builder.getDataOptions();\n+            dataOptions.setTenantId(tenant);\n+            if (createIndex) {\n+                builder.withTenantViewOptions(getTenantViewOptions(builder)).\n+                    withDataOptions(dataOptions).withTenantViewIndexDefaults().build();\n+            } else {\n+                builder.withTenantViewOptions(getTenantViewOptions(builder)).\n+                    withDataOptions(dataOptions).build();\n+            }\n+            builder.withTenantViewOptions(getTenantViewOptions(builder)).\n+                withDataOptions(dataOptions).withTenantViewIndexDefaults().build();\n+            conn.createStatement().execute(\"UPSERT INTO \" + builder.getEntityTenantViewName()\n+                + \" VALUES\" + \" ('\" + PhoenixTestBuilder.DDLDefaults.DEFAULT_KP + \"', '2', 'bc', \" +\n+                \"'3', 'c', \" + \"'col4', 'col5', 'col6', 'd')\");\n+            conn.commit();\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityTenantViewName() + \" \" +\n+                \"WHERE KP = '\"+ PhoenixTestBuilder.DDLDefaults.DEFAULT_KP +\n+                \"' and COL1 = '2' AND ID = 'c' AND ZID = 'd'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            PTable view = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTenantViewName());\n+            assertAnnotation(2, view.getPhysicalName().getString(), tenant,\n+                view.getSchemaName().getString(),\n+                view.getTableName().getString(), PTableType.VIEW, view.getLastDDLTimestamp());\n+            if (createIndex) {\n+                assertAnnotation(0,\n+                    MetaDataUtil.getViewIndexPhysicalName(builder.getEntityTableName()),\n+                    tenant, view.getSchemaName().getString(),\n+                    SchemaUtil.getTableNameFromFullName(builder.getEntityTenantViewIndexName()),\n+                    PTableType.INDEX,\n+                    view.getLastDDLTimestamp());\n+            }\n+        }\n+\n+    }\n+\n+    private SchemaBuilder.TenantViewOptions getTenantViewOptions(SchemaBuilder builder) {\n+        SchemaBuilder.TenantViewOptions options = SchemaBuilder.TenantViewOptions.withDefaults();\n+        options.setChangeDetectionEnabled(true);\n+        return options;\n+    }\n+\n+    @Test\n+    public void testTenantViewUpsertWithIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        Assume.assumeTrue(isMultiTenant);\n+        tenantViewHelper(true);\n+    }\n+\n+    private List<Map<String, byte[]>> getEntriesForTable(TableName tableName) throws IOException {\n+        AnnotatedWALObserver c = getTestCoprocessor(tableName);\n+        List<Map<String, byte[]>> entries = c.getWalAnnotationsByTable(tableName);\n+        return entries != null ? entries : new ArrayList<Map<String, byte[]>>();\n+    }\n+\n+    private AnnotatedWALObserver getTestCoprocessor(TableName tableName) throws IOException {\n+        HRegionInfo info = getUtility().getHBaseCluster().getRegions(tableName).get(0).getRegionInfo();\n+        WAL wal = getUtility().getHBaseCluster().getRegionServer(0).getWAL(info);\n+        WALCoprocessorHost host = wal.getCoprocessorHost();\n+        return (AnnotatedWALObserver) host.findCoprocessor(AnnotatedWALObserver.class.getName());\n+    }\n+\n+    private void clearAnnotations(TableName tableName) throws IOException {\n+        AnnotatedWALObserver observer = getTestCoprocessor(tableName);\n+        observer.clearAnnotations();\n+    }\n+\n+    private void assertAnnotation(int numOccurrences, String physicalTableName, String tenant,\n+                                  String schemaName,\n+                                  String logicalTableName,\n+                                  PTableType tableType, long ddlTimestamp) throws IOException {", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczOTc3MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539739771", "bodyText": "Correct.", "author": "gjacoby126", "createdAt": "2020-12-10T00:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0MDA2Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539740063", "bodyText": "The part that does that will be contributed to phoenix-connectors, and @bharathv is currently developing it.", "author": "gjacoby126", "createdAt": "2020-12-10T00:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MTAxMw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539661013", "bodyText": "Can you please add a comment here for clarity to mention that the upsert/delete statements won't affect this timestamp and it reflects the time of creation of the table in this case (since there is no other ALTER statement)?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:28:17Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the\n+    // \"base\" table data they index.\n+\n+    private long upsertAndDeleteHelper(SchemaBuilder builder, boolean createGlobalIndex) throws Exception {\n+        try (Connection conn = getConnection()) {\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+\n+            if (createGlobalIndex) {\n+                builder.withTableOptions(tableOptions).withTableIndexDefaults().build();\n+            } else {\n+                builder.withTableOptions(tableOptions).build();\n+            }\n+\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', 'c')\";\n+            conn.createStatement().execute(upsertSql);\n+            conn.commit();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change Detection Enabled is false!\",\n+                table.isChangeDetectionEnabled());\n+            //Deleting by entire PK gets executed as more like an UPSERT VALUES than an UPSERT SELECT\n+            //(i.e, it generates the Mutations and then pushes them to server, rather than\n+            // running a select query and deleting the mutations returned)\n+            String deleteSql = \"DELETE FROM \" + builder.getEntityTableName() + \" \" +\n+                \"WHERE OID = 'a' AND KP = 'b'\";\n+            conn.createStatement().execute(deleteSql);\n+            conn.commit();\n+            return table.getLastDDLTimestamp();", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2Mjg0NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539662844", "bodyText": "When we expect 0 numOccurences, the logicalname and ddlTimestamp are not used right? Can we pass in null or modify the assertAnnotation() to make this clear?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:31:20Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDQwNQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539664405", "bodyText": "When you say \"aren't supported\", do you mean there should be no virtual table name corresponding to the local index in the WAL annotations for the base table? Can we add a test for this?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T21:33:52Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionInfo;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.coprocessor.BaseWALObserver;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.WALCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.regionserver.wal.WALCoprocessorHost;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.PhoenixTestBuilder;\n+import org.apache.phoenix.query.PhoenixTestBuilder.SchemaBuilder;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableType;\n+import org.apache.phoenix.util.MetaDataUtil;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.apache.phoenix.util.TestUtil;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertNotNull;\n+\n+@RunWith(Parameterized.class)\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class WALAnnotationIT extends BaseUniqueNamesOwnClusterIT {\n+    private final boolean isImmutable;\n+    private final boolean isMultiTenant;\n+\n+    // name is used by failsafe as file name in reports\n+    @Parameterized.Parameters(name = \"WALAnnotationIT_isImmutable={0}_isMultiTenant={1}\")\n+    public static synchronized Collection<Object[]> data() {\n+        return Arrays.asList(new Object[]{true, true}, new Object[]{true, false},\n+            new Object[]{false, true}, new Object[]{false, false});\n+    }\n+\n+    public WALAnnotationIT(boolean isImmutable, boolean isMultiTenant) {\n+        this.isImmutable = isImmutable;\n+        this.isMultiTenant = isMultiTenant;\n+    }\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> props = new HashMap<>(2);\n+        props.put(\"hbase.coprocessor.wal.classes\",\n+            AnnotatedWALObserver.class.getName());\n+        props.put(IndexRegionObserver.PHOENIX_APPEND_METADATA_TO_WAL, \"true\");\n+        props.put(QueryServices.ENABLE_SERVER_UPSERT_SELECT, \"true\");\n+        setUpTestDriver(new ReadOnlyProps(props.entrySet().iterator()));\n+    }\n+\n+    @Test\n+    public void testSimpleUpsertAndDelete() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = false;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+    }\n+\n+    @Test\n+    public void testNoAnnotationsIfChangeDetectionDisabled() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.setAutoCommit(true);\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            SchemaBuilder.TableOptions tableOptions = getTableOptions();\n+            tableOptions.setChangeDetectionEnabled(false);\n+            builder.withTableOptions(tableOptions).build();\n+            PTable table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it shouldn't be!\",\n+                table.isChangeDetectionEnabled());\n+            String upsertSql = \"UPSERT INTO \" + builder.getEntityTableName() + \" VALUES\" +\n+                \" ('a', 'b', '2', 'bc', '3')\";\n+            conn.createStatement().execute(upsertSql);\n+            List<Map<String, byte[]>> entries =\n+                getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+            //now flip to TRUE so we can test disabling it\n+            String enableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+            conn.createStatement().execute(enableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertTrue(\"Change detection is disabled when it should be enabled!\",\n+                table.isChangeDetectionEnabled());\n+            //set to FALSE\n+            String disableSql =\n+                \"ALTER TABLE \" + builder.getEntityTableName() +\n+                    \" SET \" + CHANGE_DETECTION_ENABLED + \"=FALSE\";\n+            conn.createStatement().execute(disableSql);\n+            table = PhoenixRuntime.getTableNoCache(conn, builder.getEntityTableName());\n+            Assert.assertFalse(\"Change detection is enabled when it should be disabled!\",\n+                table.isChangeDetectionEnabled());\n+            //now upsert again\n+            conn.createStatement().execute(upsertSql);\n+            //check that we still didn't annotate anything\n+            entries = getEntriesForTable(TableName.valueOf(builder.getPhysicalTableName(false)));\n+            Assert.assertEquals(0, entries.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testCantSetChangeDetectionOnIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            SchemaBuilder builder = new SchemaBuilder(getUrl());\n+            builder.withTableDefaults().build();\n+            try {\n+                String badIndexSql =\n+                    \"CREATE INDEX IDX_SHOULD_FAIL\"  + \" ON \" + builder.getEntityTableName() +\n+                        \"(COL1) \"\n+                        + CHANGE_DETECTION_ENABLED + \"=TRUE\";\n+                conn.createStatement().execute(badIndexSql);\n+                Assert.fail(\"Didn't throw a SQLException for setting change detection on an \" +\n+                    \"index at create time!\");\n+            } catch (SQLException se) {\n+                TestUtil.assertSqlExceptionCode(\n+                    SQLExceptionCode.CHANGE_DETECTION_SUPPORTED_FOR_TABLES_AND_VIEWS_ONLY, se);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUpsertAndDeleteWithGlobalIndex() throws Exception {\n+        Assume.assumeTrue(HbaseCompatCapabilities.hasPreWALAppend());\n+        SchemaBuilder builder = new SchemaBuilder(getUrl());\n+        boolean createGlobalIndex = true;\n+        long ddlTimestamp = upsertAndDeleteHelper(builder, createGlobalIndex);\n+        assertAnnotation(2, builder.getPhysicalTableName(false), null,\n+            builder.getTableOptions().getSchemaName(),\n+            builder.getDataOptions().getTableName(), PTableType.TABLE, ddlTimestamp);\n+        assertAnnotation(0, builder.getPhysicalTableIndexName(false),\n+            null, builder.getTableOptions().getSchemaName(),\n+            SchemaUtil.getTableNameFromFullName(builder.getEntityTableIndexName()),\n+            PTableType.INDEX,\n+            ddlTimestamp);\n+    }\n+\n+    //Note that local secondary indexes aren't supported because they go in the same WALEdit as the", "originalCommit": "233766547c1db7700356eb74f1a018b4c12c6275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0MjMyNg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539742326", "bodyText": "Actually the opposite -- when a local index is present I believe the WALEdits will have a mix of Cells from both the base table and the local index, because local indexes are stored within the actual table, just in a separate CF. So the later phases of change detection (that read the WALs) will have to filter out Cells that have the local index CF.", "author": "gjacoby126", "createdAt": "2020-12-10T00:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzMzM4OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r540433388", "bodyText": "Ok, got it.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-10T19:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDQwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\nindex ef26c0c6b..e4618c7ed 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/WALAnnotationIT.java\n\n@@ -66,7 +66,11 @@ import java.util.Objects;\n import java.util.Properties;\n \n import static org.apache.phoenix.jdbc.PhoenixDatabaseMetaData.CHANGE_DETECTION_ENABLED;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n @RunWith(Parameterized.class)\n @Category(NeedsOwnMiniClusterTest.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MTM0NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539691345", "bodyText": "Is this a connection leak?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:20:35Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java", "diffHunk": "@@ -247,9 +195,10 @@ public void testMultiTenantViewLocalIndex() throws Exception {\n \t\tString indexName = \"IND_\" + generateUniqueName();\n         String fullTableName = SchemaUtil.getTableName(SCHEMA1, tableName);\n         String fullViewName = SchemaUtil.getTableName(SCHEMA2, generateUniqueName());\n-        \n-        createBaseTable(SCHEMA1, tableName, true, null, null, true);\n-        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        Connection conn = getConnection();", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\nindex f8b7f43a5..7890e19c8 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\n\n@@ -196,75 +194,76 @@ public class ViewIndexIT extends SplitSystemCatalogIT {\n         String fullTableName = SchemaUtil.getTableName(SCHEMA1, tableName);\n         String fullViewName = SchemaUtil.getTableName(SCHEMA2, generateUniqueName());\n \n-        Connection conn = getConnection();\n+        try (Connection conn = getConnection();\n+             Connection conn1 = getTenantConnection(\"10\")) {\n \n-        createBaseTable(conn, SCHEMA1, tableName, true, null, null, true);\n-        PreparedStatement stmt = conn.prepareStatement(\n+            createBaseTable(conn, SCHEMA1, tableName, true, null, null, true);\n+            PreparedStatement stmt = conn.prepareStatement(\n                 \"UPSERT INTO \" + fullTableName\n-                + \" VALUES(?,?,?,?,?)\");\n-        stmt.setString(1, \"10\");\n-        stmt.setString(2, \"a\");\n-        stmt.setInt(3, 1);\n-        stmt.setString(4, \"x1\");\n-        stmt.setInt(5, 100);\n-        stmt.execute();\n-        stmt.setString(1, \"10\");\n-        stmt.setString(2, \"b\");\n-        stmt.setInt(3, 2);\n-        stmt.setString(4, \"x2\");\n-        stmt.setInt(5, 200);\n-        stmt.execute();\n-        stmt.setString(1, \"10\");\n-        stmt.setString(2, \"c\");\n-        stmt.setInt(3, 3);\n-        stmt.setString(4, \"x3\");\n-        stmt.setInt(5, 300);\n-        stmt.execute();\n-        stmt.setString(1, \"20\");\n-        stmt.setString(2, \"d\");\n-        stmt.setInt(3, 4);\n-        stmt.setString(4, \"x4\");\n-        stmt.setInt(5, 400);\n-        stmt.execute();\n-        conn.commit();\n-\n-        Connection conn1 = getTenantConnection(\"10\");\n-        conn1.createStatement().execute(\"CREATE VIEW \" + fullViewName\n+                    + \" VALUES(?,?,?,?,?)\");\n+            stmt.setString(1, \"10\");\n+            stmt.setString(2, \"a\");\n+            stmt.setInt(3, 1);\n+            stmt.setString(4, \"x1\");\n+            stmt.setInt(5, 100);\n+            stmt.execute();\n+            stmt.setString(1, \"10\");\n+            stmt.setString(2, \"b\");\n+            stmt.setInt(3, 2);\n+            stmt.setString(4, \"x2\");\n+            stmt.setInt(5, 200);\n+            stmt.execute();\n+            stmt.setString(1, \"10\");\n+            stmt.setString(2, \"c\");\n+            stmt.setInt(3, 3);\n+            stmt.setString(4, \"x3\");\n+            stmt.setInt(5, 300);\n+            stmt.execute();\n+            stmt.setString(1, \"20\");\n+            stmt.setString(2, \"d\");\n+            stmt.setInt(3, 4);\n+            stmt.setString(4, \"x4\");\n+            stmt.setInt(5, 400);\n+            stmt.execute();\n+            conn.commit();\n+\n+            conn1.createStatement().execute(\"CREATE VIEW \" + fullViewName\n                 + \" AS select * from \" + fullTableName);\n-        conn1.createStatement().execute(\"CREATE LOCAL INDEX \"\n+            conn1.createStatement().execute(\"CREATE LOCAL INDEX \"\n                 + indexName + \" ON \"\n                 + fullViewName + \"(v2)\");\n-        conn1.commit();\n-        \n-        String sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 = 100\";\n-        ResultSet rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n-        assertEquals(\n+            conn1.commit();\n+\n+            String sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 = 100\";\n+            ResultSet rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n+            assertEquals(\n                 \"CLIENT PARALLEL 1-WAY RANGE SCAN OVER \" + SchemaUtil.getPhysicalTableName(Bytes.toBytes(fullTableName), isNamespaceMapped) + \" [1,'10',100]\\n\" +\n-                \"    SERVER FILTER BY FIRST KEY ONLY\\n\" +\n-                \"CLIENT MERGE SORT\", QueryUtil.getExplainPlan(rs));\n-        rs = conn1.prepareStatement(sql).executeQuery();\n-        assertTrue(rs.next());\n-        assertFalse(rs.next());\n-        \n-        TestUtil.analyzeTable(conn, fullTableName);\n-        List<KeyRange> guideposts = TestUtil.getAllSplits(conn, fullTableName);\n-        assertEquals(1, guideposts.size());\n-        assertEquals(KeyRange.EVERYTHING_RANGE, guideposts.get(0));\n-        \n-        conn.createStatement().execute(\"ALTER TABLE \" + fullTableName + \" SET \" + PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH + \"=20\");\n-        \n-        TestUtil.analyzeTable(conn, fullTableName);\n-        guideposts = TestUtil.getAllSplits(conn, fullTableName);\n-        assertEquals(5, guideposts.size());\n-\n-        // Confirm that when view index used, the GUIDE_POSTS_WIDTH from the data physical table\n-        // was used\n-        sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 >= 100\";\n-        rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n-        stmt = conn1.prepareStatement(sql);\n-        stmt.executeQuery();\n-        QueryPlan plan = stmt.unwrap(PhoenixStatement.class).getQueryPlan();\n-        assertEquals(4, plan.getSplits().size());\n+                    \"    SERVER FILTER BY FIRST KEY ONLY\\n\" +\n+                    \"CLIENT MERGE SORT\", QueryUtil.getExplainPlan(rs));\n+            rs = conn1.prepareStatement(sql).executeQuery();\n+            assertTrue(rs.next());\n+            assertFalse(rs.next());\n+\n+            TestUtil.analyzeTable(conn, fullTableName);\n+            List<KeyRange> guideposts = TestUtil.getAllSplits(conn, fullTableName);\n+            assertEquals(1, guideposts.size());\n+            assertEquals(KeyRange.EVERYTHING_RANGE, guideposts.get(0));\n+\n+            conn.createStatement().execute(\"ALTER TABLE \" + fullTableName + \" SET \" + PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH + \"=20\");\n+\n+            TestUtil.analyzeTable(conn, fullTableName);\n+            guideposts = TestUtil.getAllSplits(conn, fullTableName);\n+            assertEquals(5, guideposts.size());\n+\n+            // Confirm that when view index used, the GUIDE_POSTS_WIDTH from the data physical table\n+            // was used\n+            sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 >= 100\";\n+            rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n+            stmt = conn1.prepareStatement(sql);\n+            stmt.executeQuery();\n+            QueryPlan plan = stmt.unwrap(PhoenixStatement.class).getQueryPlan();\n+            assertEquals(4, plan.getSplits().size());\n+        }\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5MTQ0Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539691447", "bodyText": "Is this a connection leak?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:20:46Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java", "diffHunk": "@@ -278,10 +227,8 @@ public void testMultiTenantViewLocalIndex() throws Exception {\n         stmt.setInt(5, 400);\n         stmt.execute();\n         conn.commit();\n-        \n-        Properties props  = PropertiesUtil.deepCopy(TestUtil.TEST_PROPERTIES);\n-        props.setProperty(\"TenantId\", \"10\");\n-        Connection conn1 = DriverManager.getConnection(getUrl(), props);\n+\n+        Connection conn1 = getTenantConnection(\"10\");", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\nindex f8b7f43a5..7890e19c8 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/ViewIndexIT.java\n\n@@ -196,75 +194,76 @@ public class ViewIndexIT extends SplitSystemCatalogIT {\n         String fullTableName = SchemaUtil.getTableName(SCHEMA1, tableName);\n         String fullViewName = SchemaUtil.getTableName(SCHEMA2, generateUniqueName());\n \n-        Connection conn = getConnection();\n+        try (Connection conn = getConnection();\n+             Connection conn1 = getTenantConnection(\"10\")) {\n \n-        createBaseTable(conn, SCHEMA1, tableName, true, null, null, true);\n-        PreparedStatement stmt = conn.prepareStatement(\n+            createBaseTable(conn, SCHEMA1, tableName, true, null, null, true);\n+            PreparedStatement stmt = conn.prepareStatement(\n                 \"UPSERT INTO \" + fullTableName\n-                + \" VALUES(?,?,?,?,?)\");\n-        stmt.setString(1, \"10\");\n-        stmt.setString(2, \"a\");\n-        stmt.setInt(3, 1);\n-        stmt.setString(4, \"x1\");\n-        stmt.setInt(5, 100);\n-        stmt.execute();\n-        stmt.setString(1, \"10\");\n-        stmt.setString(2, \"b\");\n-        stmt.setInt(3, 2);\n-        stmt.setString(4, \"x2\");\n-        stmt.setInt(5, 200);\n-        stmt.execute();\n-        stmt.setString(1, \"10\");\n-        stmt.setString(2, \"c\");\n-        stmt.setInt(3, 3);\n-        stmt.setString(4, \"x3\");\n-        stmt.setInt(5, 300);\n-        stmt.execute();\n-        stmt.setString(1, \"20\");\n-        stmt.setString(2, \"d\");\n-        stmt.setInt(3, 4);\n-        stmt.setString(4, \"x4\");\n-        stmt.setInt(5, 400);\n-        stmt.execute();\n-        conn.commit();\n-\n-        Connection conn1 = getTenantConnection(\"10\");\n-        conn1.createStatement().execute(\"CREATE VIEW \" + fullViewName\n+                    + \" VALUES(?,?,?,?,?)\");\n+            stmt.setString(1, \"10\");\n+            stmt.setString(2, \"a\");\n+            stmt.setInt(3, 1);\n+            stmt.setString(4, \"x1\");\n+            stmt.setInt(5, 100);\n+            stmt.execute();\n+            stmt.setString(1, \"10\");\n+            stmt.setString(2, \"b\");\n+            stmt.setInt(3, 2);\n+            stmt.setString(4, \"x2\");\n+            stmt.setInt(5, 200);\n+            stmt.execute();\n+            stmt.setString(1, \"10\");\n+            stmt.setString(2, \"c\");\n+            stmt.setInt(3, 3);\n+            stmt.setString(4, \"x3\");\n+            stmt.setInt(5, 300);\n+            stmt.execute();\n+            stmt.setString(1, \"20\");\n+            stmt.setString(2, \"d\");\n+            stmt.setInt(3, 4);\n+            stmt.setString(4, \"x4\");\n+            stmt.setInt(5, 400);\n+            stmt.execute();\n+            conn.commit();\n+\n+            conn1.createStatement().execute(\"CREATE VIEW \" + fullViewName\n                 + \" AS select * from \" + fullTableName);\n-        conn1.createStatement().execute(\"CREATE LOCAL INDEX \"\n+            conn1.createStatement().execute(\"CREATE LOCAL INDEX \"\n                 + indexName + \" ON \"\n                 + fullViewName + \"(v2)\");\n-        conn1.commit();\n-        \n-        String sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 = 100\";\n-        ResultSet rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n-        assertEquals(\n+            conn1.commit();\n+\n+            String sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 = 100\";\n+            ResultSet rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n+            assertEquals(\n                 \"CLIENT PARALLEL 1-WAY RANGE SCAN OVER \" + SchemaUtil.getPhysicalTableName(Bytes.toBytes(fullTableName), isNamespaceMapped) + \" [1,'10',100]\\n\" +\n-                \"    SERVER FILTER BY FIRST KEY ONLY\\n\" +\n-                \"CLIENT MERGE SORT\", QueryUtil.getExplainPlan(rs));\n-        rs = conn1.prepareStatement(sql).executeQuery();\n-        assertTrue(rs.next());\n-        assertFalse(rs.next());\n-        \n-        TestUtil.analyzeTable(conn, fullTableName);\n-        List<KeyRange> guideposts = TestUtil.getAllSplits(conn, fullTableName);\n-        assertEquals(1, guideposts.size());\n-        assertEquals(KeyRange.EVERYTHING_RANGE, guideposts.get(0));\n-        \n-        conn.createStatement().execute(\"ALTER TABLE \" + fullTableName + \" SET \" + PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH + \"=20\");\n-        \n-        TestUtil.analyzeTable(conn, fullTableName);\n-        guideposts = TestUtil.getAllSplits(conn, fullTableName);\n-        assertEquals(5, guideposts.size());\n-\n-        // Confirm that when view index used, the GUIDE_POSTS_WIDTH from the data physical table\n-        // was used\n-        sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 >= 100\";\n-        rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n-        stmt = conn1.prepareStatement(sql);\n-        stmt.executeQuery();\n-        QueryPlan plan = stmt.unwrap(PhoenixStatement.class).getQueryPlan();\n-        assertEquals(4, plan.getSplits().size());\n+                    \"    SERVER FILTER BY FIRST KEY ONLY\\n\" +\n+                    \"CLIENT MERGE SORT\", QueryUtil.getExplainPlan(rs));\n+            rs = conn1.prepareStatement(sql).executeQuery();\n+            assertTrue(rs.next());\n+            assertFalse(rs.next());\n+\n+            TestUtil.analyzeTable(conn, fullTableName);\n+            List<KeyRange> guideposts = TestUtil.getAllSplits(conn, fullTableName);\n+            assertEquals(1, guideposts.size());\n+            assertEquals(KeyRange.EVERYTHING_RANGE, guideposts.get(0));\n+\n+            conn.createStatement().execute(\"ALTER TABLE \" + fullTableName + \" SET \" + PhoenixDatabaseMetaData.GUIDE_POSTS_WIDTH + \"=20\");\n+\n+            TestUtil.analyzeTable(conn, fullTableName);\n+            guideposts = TestUtil.getAllSplits(conn, fullTableName);\n+            assertEquals(5, guideposts.size());\n+\n+            // Confirm that when view index used, the GUIDE_POSTS_WIDTH from the data physical table\n+            // was used\n+            sql = \"SELECT * FROM \" + fullViewName + \" WHERE v2 >= 100\";\n+            rs = conn1.prepareStatement(\"EXPLAIN \" + sql).executeQuery();\n+            stmt = conn1.prepareStatement(sql);\n+            stmt.executeQuery();\n+            QueryPlan plan = stmt.unwrap(PhoenixStatement.class).getQueryPlan();\n+            assertEquals(4, plan.getSplits().size());\n+        }\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNTk5OQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539705999", "bodyText": "I think we need to do this check everywhere. Also, can this be moved to a relevant Util class since we'd want to potentially call this method in all places where annotation is required?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:47:30Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java", "diffHunk": "@@ -682,6 +687,49 @@ private void generateMutations(final TableRef tableRef, final long mutationTimes\n         values.putAll(modifiedValues);\n     }\n \n+    private void annotateMutationsWithMetadata(PTable table, List<Mutation> rowMutations) {\n+        //only annotate if the change detection flag is on the table and HBase supports\n+        // preWALAppend coprocs server-side\n+        if (table == null || !table.isChangeDetectionEnabled()\n+            || !HbaseCompatCapabilities.hasPreWALAppend()) {\n+            return;\n+        }\n+        //annotate each mutation with enough metadata so that anyone interested can\n+        // deterministically figure out exactly what Phoenix schema object created the mutation\n+        // Server-side we can annotate the HBase WAL with these.\n+        for (Mutation mutation : rowMutations) {\n+            annotateMutationWithMetadata(table, mutation);\n+        }\n+\n+    }\n+\n+    public static void annotateMutationWithMetadata(PTable table, Mutation mutation) {\n+        if (mutation.getDurability() == Durability.SKIP_WAL) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNjU5MQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539706591", "bodyText": "Maybe WALAnnotationUtil?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNTk5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\nindex 8b572524c..7641db412 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/execute/MutationState.java\n\n@@ -678,9 +677,9 @@ public class MutationState implements SQLCloseable {\n                         mutation.setAttribute(PhoenixIndexBuilder.ATOMIC_OP_ATTRIB, onDupKeyBytes);\n                     }\n                 }\n-                annotateMutationsWithMetadata(table, rowMutations);\n                 rowMutationsPertainingToIndex = rowMutations;\n             }\n+            annotateMutationsWithMetadata(table, rowMutations);\n             mutationList.addAll(rowMutations);\n             if (mutationsPertainingToIndex != null) mutationsPertainingToIndex.addAll(rowMutationsPertainingToIndex);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNjg3Mg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539706872", "bodyText": "I thought we weren't going to annotate indexes.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:49:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -1034,6 +1066,15 @@ private void removeBatchMutateContext(ObserverContext<RegionCoprocessorEnvironme\n       this.batchMutateContext.remove();\n   }\n \n+    @Override\n+    public void preWALAppend(ObserverContext<RegionCoprocessorEnvironment> c, WALKey key,\n+                             WALEdit edit) {\n+        if (HbaseCompatCapabilities.hasPreWALAppend() && shouldWALAppend) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0Mjk3Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539742976", "bodyText": "Despite the name, IndexRegionObserver is actually the coproc that lives on base tables, not indexes. (GlobalIndexChecker is the index coproc)", "author": "gjacoby126", "createdAt": "2020-12-10T00:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNjg3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzI5OQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539707299", "bodyText": "A lot of these imports seem to be unused", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:50:20Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java", "diffHunk": "@@ -50,11 +53,19 @@\n import org.apache.hadoop.hbase.filter.FilterList;\n import org.apache.hadoop.hbase.filter.PageFilter;\n import org.apache.hadoop.hbase.io.ImmutableBytesWritable;\n+import org.apache.hadoop.hbase.regionserver.MiniBatchOperationInProgress;\n import org.apache.hadoop.hbase.regionserver.Region;\n import org.apache.hadoop.hbase.regionserver.RegionScanner;\n import org.apache.hadoop.hbase.regionserver.ScannerContext;\n+import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatGlobalIndexChecker;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n import org.apache.phoenix.coprocessor.BaseScannerRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2Mzk1Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541363956", "bodyText": "Fixed -- lots were remnants from when we annotated indexes", "author": "gjacoby126", "createdAt": "2020-12-11T22:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java b/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java\nindex 0a4f99f96..696186131 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java\n\n@@ -53,19 +50,11 @@ import org.apache.hadoop.hbase.filter.Filter;\n import org.apache.hadoop.hbase.filter.FilterList;\n import org.apache.hadoop.hbase.filter.PageFilter;\n import org.apache.hadoop.hbase.io.ImmutableBytesWritable;\n-import org.apache.hadoop.hbase.regionserver.MiniBatchOperationInProgress;\n import org.apache.hadoop.hbase.regionserver.Region;\n import org.apache.hadoop.hbase.regionserver.RegionScanner;\n import org.apache.hadoop.hbase.regionserver.ScannerContext;\n-import org.apache.hadoop.hbase.regionserver.wal.WALEdit;\n import org.apache.hadoop.hbase.util.Bytes;\n-import org.apache.hadoop.hbase.wal.WALKey;\n-import org.apache.phoenix.compat.hbase.HbaseCompatCapabilities;\n-import org.apache.phoenix.compat.hbase.coprocessor.CompatGlobalIndexChecker;\n-import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n import org.apache.phoenix.coprocessor.BaseScannerRegionObserver;\n-import org.apache.phoenix.execute.MutationState;\n-import org.apache.phoenix.hbase.index.IndexRegionObserver;\n import org.apache.phoenix.hbase.index.covered.update.ColumnReference;\n import org.apache.phoenix.hbase.index.metrics.GlobalIndexCheckerSource;\n import org.apache.phoenix.hbase.index.metrics.MetricsIndexerSourceFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzg3Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539707876", "bodyText": "Is this mainly for view indexes? For local indexes we aren't doing any annotation and for global indexes, the logical name is the name of PTable. Can you please clarify and/or add a comment about this?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T22:51:35Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/index/IndexMaintainer.java", "diffHunk": "@@ -1257,7 +1261,11 @@ public ImmutableBytesPtr getEmptyKeyValueFamily() {\n         // If if there are no covered columns, we know it's our default name\n         return emptyKeyValueCFPtr;\n     }\n-    \n+\n+    public String getLogicalIndexName() {\n+        return logicalIndexName;", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2NDY4NQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541364685", "bodyText": "Correct. Will add a comment.", "author": "gjacoby126", "createdAt": "2020-12-11T22:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/index/IndexMaintainer.java b/phoenix-core/src/main/java/org/apache/phoenix/index/IndexMaintainer.java\nindex 12df0b09a..6039bb2e7 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/index/IndexMaintainer.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/index/IndexMaintainer.java\n\n@@ -1262,6 +1262,13 @@ public class IndexMaintainer implements Writable, Iterable<ColumnReference> {\n         return emptyKeyValueCFPtr;\n     }\n \n+    /**\n+     * The logical index name. For global indexes on base tables this will be the same as the\n+     * physical index table name (unless namespaces are enabled, then . gets replaced with : for\n+     * the physical table name). For view indexes, the logical and physical names will be\n+     * different because all view indexes of a base table are stored in the same physical table\n+     * @return The logical index name\n+     */\n     public String getLogicalIndexName() {\n         return logicalIndexName;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxODIwMQ==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539718201", "bodyText": "@gjacoby126 Here is my understanding overall, please correct me if I'm wrong. There are 2 basic paths:\n\n(Client-side delete and upsert-values) Client issues Puts/Deletes directly: This is handled in MutationState. annotateMutationsWithMetadata()\n(Server-side delete and upsert-selects) Client issues scans, the server intercepts this and issues Put/Delete mutations based on the results read: This is what this method handles right? My understanding is we set the scan attributes in UpsertCompiler and DeleteCompiler and this is intercepted in UngroupedAggregateRegionScanner  where we read the scan attribute and set it on the mutations.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:12:54Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/ScanUtil.java", "diffHunk": "@@ -1239,4 +1239,21 @@ public static boolean isDummy(List<Cell> result) {\n         Cell cell = result.get(0);\n         return CellUtil.matchingColumn(cell, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY);\n     }\n+\n+    public static void setWALAnnotationAttributes(PTable table, Scan scan) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDA3Mw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539724073", "bodyText": "Can we add comments based on this in the compiler and/or this method. Also a similar comment in MutationState would be helpful.", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxODIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM4MjYyMA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541382620", "bodyText": "Added comments to the Utility methods in ScanUtil and WALAnnotationUtil to avoid duplication", "author": "gjacoby126", "createdAt": "2020-12-11T22:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxODIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/ScanUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/ScanUtil.java\nindex 4e54c73d3..28e58a0be 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/ScanUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/ScanUtil.java\n\n@@ -1240,6 +1240,15 @@ public class ScanUtil {\n         return CellUtil.matchingColumn(cell, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY);\n     }\n \n+    /**\n+     *  Put the attributes we want to annotate the WALs with (such as logical table name,\n+     *  tenant, DDL timestamp, etc) on the Scan object so that on the\n+     *  Ungrouped/GroupedAggregateCoprocessor side, we\n+     *  annotate the mutations with them, and then they get written into the WAL as part of\n+     *  the RegionObserver's doWALAppend hook.\n+     * @param table Table metadata for the target table/view of the write\n+     * @param scan Scan to trigger the server-side coproc\n+     */\n     public static void setWALAnnotationAttributes(PTable table, Scan scan) {\n         if (table.isChangeDetectionEnabled()) {\n             if (table.getTenantId() != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDI0OA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539724248", "bodyText": "We should check WAL durability here as well right?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:25:59Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -644,4 +651,33 @@ public boolean next(List<Cell> resultsToReturn) throws IOException {\n     public long getMaxResultSize() {\n         return scan.getMaxResultSize();\n     }\n+\n+    private void annotateDataMutations(UngroupedAggregateRegionObserver.MutationList mutationsList,\n+                                       Scan scan) {\n+        byte[] tenantId = null;\n+        byte[] logicalTableName = null;\n+        byte[] schemaName = null;\n+        byte[] tableType = null;\n+        byte[] ddlTimestamp = null;\n+        tenantId =\n+            scan.getAttribute(MutationState.MutationMetadataType.TENANT_ID.toString());\n+        schemaName =\n+            scan.getAttribute(MutationState.MutationMetadataType.SCHEMA_NAME.toString());\n+        logicalTableName =\n+            scan.getAttribute(MutationState.MutationMetadataType.LOGICAL_TABLE_NAME.toString());\n+        tableType =\n+            scan.getAttribute(MutationState.MutationMetadataType.TABLE_TYPE.toString());\n+        ddlTimestamp = scan.getAttribute(MutationState.MutationMetadataType.TIMESTAMP.toString());\n+\n+        for (Mutation m : mutationsList) {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\nindex 5895e8c37..a96303add 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java\n\n@@ -647,6 +638,15 @@ public class UngroupedAggregateRegionScanner extends BaseRegionScanner {\n         }\n     }\n \n+    private void annotateAndCommit(UngroupedAggregateRegionObserver.MutationList mutations) throws IOException {\n+        if (isDelete || isUpsert) {\n+            annotateDataMutations(mutations, scan);\n+        }\n+        ungroupedAggregateRegionObserver.commit(region, mutations, indexUUID, blockingMemStoreSize, indexMaintainersPtr, txState,\n+            targetHTable, useIndexProto, isPKChanging, clientVersionBytes);\n+        mutations.clear();\n+    }\n+\n     @Override\n     public long getMaxResultSize() {\n         return scan.getMaxResultSize();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDkxNw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539724917", "bodyText": "Since this is specific to indexing, can we rename the class to reflect that?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:27:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.util;\n+\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WALKey;\n+import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n+import org.apache.phoenix.execute.MutationState;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+\n+import java.util.Map;\n+\n+/**\n+ * Utility functions shared between IndexRegionObserver and GlobalIndexChecker for annotating the\n+ * HBase WAL with Phoenix-level metadata about mutations.\n+ */\n+public class WALAnnotationUtil {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2NzA5Nw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541367097", "bodyText": "It's not specific to indexing.", "author": "gjacoby126", "createdAt": "2020-12-11T22:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNDkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java b/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java\nindex 8a847cb3c..76564a6ab 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/util/WALAnnotationUtil.java\n\n@@ -15,9 +15,8 @@\n  */\n package org.apache.phoenix.util;\n \n-import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Durability;\n import org.apache.hadoop.hbase.client.Mutation;\n-import org.apache.hadoop.hbase.util.Bytes;\n import org.apache.hadoop.hbase.wal.WALKey;\n import org.apache.phoenix.compat.hbase.coprocessor.CompatIndexRegionObserver;\n import org.apache.phoenix.execute.MutationState;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNTQxOA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539725418", "bodyText": "nit: Fix indentation.\nAlso, what is this change for?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:28:39Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/coprocessor/TaskMetaDataEndpointTest.java", "diffHunk": "@@ -139,7 +140,12 @@ public RegionServerServices getRegionServerServices() {\n             public ConcurrentMap<String, Object> getSharedData() {\n                 return null;\n             }\n-        };\n+\n+                    @Override", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3MjAzMg==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r542572032", "bodyText": "A previous version of this patch had PHOENIX-6155 but not its addendum that fixed compilation on certain HBase versions. The current version has the addendum and so this file shouldn't be altered in this patch anymore.", "author": "gjacoby126", "createdAt": "2020-12-14T17:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNTQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/coprocessor/TaskMetaDataEndpointTest.java b/phoenix-core/src/test/java/org/apache/phoenix/coprocessor/TaskMetaDataEndpointTest.java\nindex 437b7fe14..fb2e9e9a5 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/coprocessor/TaskMetaDataEndpointTest.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/coprocessor/TaskMetaDataEndpointTest.java\n\n@@ -140,12 +139,7 @@ public class TaskMetaDataEndpointTest {\n             public ConcurrentMap<String, Object> getSharedData() {\n                 return null;\n             }\n-\n-                    @Override\n-                    public MetricRegistry getMetricRegistryForRegionServer() {\n-                        return null;\n-                    }\n-                };\n+        };\n         taskMetaDataEndpoint = new TaskMetaDataEndpoint();\n         taskMetaDataEndpoint.start(environment);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNTc0MA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539725740", "bodyText": "Can these variables be private?", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:29:24Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java", "diffHunk": "@@ -644,6 +646,9 @@ public void upsertRows(int startRowIndex, int numRows) throws Exception {\n         String entityTableName;\n         String entityGlobalViewName;\n         String entityTenantViewName;\n+        String entityTableIndexName;", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java b/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java\nindex 9c4d3fbdb..41ac3b46a 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java\n\n@@ -643,12 +646,12 @@ public class PhoenixTestBuilder {\n         boolean tenantViewIndexCreated = false;\n         String url;\n         String entityKeyPrefix;\n-        String entityTableName;\n-        String entityGlobalViewName;\n-        String entityTenantViewName;\n-        String entityTableIndexName;\n-        String entityGlobalViewIndexName;\n-        String entityTenantViewIndexName;\n+        private String entityTableName;\n+        private String entityGlobalViewName;\n+        private String entityTenantViewName;\n+        private String entityTableIndexName;\n+        private String entityGlobalViewIndexName;\n+        private String entityTenantViewIndexName;\n         PTable baseTable;\n         ConnectOptions connectOptions;\n         TableOptions tableOptions;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyNjI2Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539726266", "bodyText": "nit: Use a static constant representing CHANGE_DETECTION_ENABLED instead", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:30:20Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java", "diffHunk": "@@ -1230,6 +1285,12 @@ private String buildCreateGlobalViewStmt(String fullGlobalViewName, String fullT\n                     .append((globalViewOptions.tableProps.isEmpty() ?\n                             \"\" :\n                             globalViewOptions.tableProps));\n+            if (globalViewOptions.isChangeDetectionEnabled()) {\n+                if (!globalViewOptions.tableProps.isEmpty()) {\n+                    statement.append(\", \");\n+                }\n+                statement.append(\"CHANGE_DETECTION_ENABLED=true\");", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java b/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java\nindex 9c4d3fbdb..41ac3b46a 100644\n--- a/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java\n+++ b/phoenix-core/src/test/java/org/apache/phoenix/query/PhoenixTestBuilder.java\n\n@@ -1289,7 +1292,7 @@ public class PhoenixTestBuilder {\n                 if (!globalViewOptions.tableProps.isEmpty()) {\n                     statement.append(\", \");\n                 }\n-                statement.append(\"CHANGE_DETECTION_ENABLED=true\");\n+                statement.append(CHANGE_DETECTION_ENABLED + \"=true\");\n             }\n             LOGGER.info(statement.toString());\n             return statement.toString();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTY4Ng==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r539729686", "bodyText": "Super nit: multi-line comments throughout the pr have no space for the first line and 1 space for subsequent ones. Maybe keep it the same for all lines, unless this is some convention I'm unaware of, in which case ignore :D", "author": "ChinmaySKulkarni", "createdAt": "2020-12-09T23:38:11Z", "path": "phoenix-hbase-compat-1.5.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatGlobalIndexChecker.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.compat.hbase.coprocessor;\n+\n+import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;\n+\n+public class CompatGlobalIndexChecker extends BaseRegionObserver {\n+    //HBase 1.5+ has preWALAppend already declared in BaseRegionObserver, so this class is only", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM4MzEwNw==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541383107", "bodyText": "This particular file no longer exists, but I fixed some of these as I found them. The reason why is just that I usually don't type a space when I start a one-line comment, and when I find I need to make it multi-line the IDE fixes the spacing on subsequent lines but not the first one. :-)", "author": "gjacoby126", "createdAt": "2020-12-11T22:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-hbase-compat-1.5.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatGlobalIndexChecker.java b/phoenix-hbase-compat-1.5.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatGlobalIndexChecker.java\ndeleted file mode 100644\nindex d9ffcb088..000000000\n--- a/phoenix-hbase-compat-1.5.0/src/main/java/org/apache/phoenix/compat/hbase/coprocessor/CompatGlobalIndexChecker.java\n+++ /dev/null\n\n@@ -1,27 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.phoenix.compat.hbase.coprocessor;\n-\n-import org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;\n-\n-public class CompatGlobalIndexChecker extends BaseRegionObserver {\n-    //HBase 1.5+ has preWALAppend already declared in BaseRegionObserver, so this class is only\n-    // needed to harmonize with the version of CompatGlobalIndexChecker in the 1.3 and 1.4 compat\n-    // projects, which have to declare preWALAppend there. GlobalIndexChecker will inherit from\n-    // whichever CompatGlobalIndexChecker is defined for the HBase profile at compile time.\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM2NDM2NA==", "url": "https://github.com/apache/phoenix/pull/913#discussion_r541364364", "bodyText": "We don't need CompatGlobalIndexChecker now that we don't annotate indexes so I removed it", "author": "gjacoby126", "createdAt": "2020-12-11T22:27:46Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java", "diffHunk": "@@ -93,10 +106,11 @@\n  * the verified version that is masked by the unverified version(s).\n  *\n  */\n-public class GlobalIndexChecker extends BaseRegionObserver {\n+public class GlobalIndexChecker extends CompatGlobalIndexChecker {", "originalCommit": "3d85019370ddbc6564aff6b958189ae8617a5a63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java b/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java\nindex 0a4f99f96..696186131 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/index/GlobalIndexChecker.java\n\n@@ -106,7 +94,7 @@ import org.slf4j.LoggerFactory;\n  * the verified version that is masked by the unverified version(s).\n  *\n  */\n-public class GlobalIndexChecker extends CompatGlobalIndexChecker {\n+public class GlobalIndexChecker extends BaseRegionObserver {\n     private static final Logger LOG = LoggerFactory.getLogger(GlobalIndexChecker.class);\n     private HTableFactory hTableFactory;\n     private GlobalIndexCheckerSource metricsSource;\n"}}, {"oid": "8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "url": "https://github.com/apache/phoenix/commit/8c396ea468b839cd0f7b4e89bf9ce2199037afcd", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-11T23:05:39Z", "type": "forcePushed"}, {"oid": "3c25fc8e03d0c3c831243e7f76e932d803446592", "url": "https://github.com/apache/phoenix/commit/3c25fc8e03d0c3c831243e7f76e932d803446592", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-14T17:16:42Z", "type": "commit"}, {"oid": "3c25fc8e03d0c3c831243e7f76e932d803446592", "url": "https://github.com/apache/phoenix/commit/3c25fc8e03d0c3c831243e7f76e932d803446592", "message": "PHOENIX-5435 - Annotate HBase WALs with Phoenix Metadata", "committedDate": "2020-12-14T17:16:42Z", "type": "forcePushed"}]}