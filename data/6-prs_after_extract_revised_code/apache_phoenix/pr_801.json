{"pr_number": 801, "pr_title": "PHOENIX-5951 - Index rebuild output logging for past-max-lookback row\u2026", "pr_createdAt": "2020-06-11T20:25:36Z", "pr_url": "https://github.com/apache/phoenix/pull/801", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2MTMyNg==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439561326", "bodyText": "Let's remove the *", "author": "gokceni", "createdAt": "2020-06-12T17:48:35Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java", "diffHunk": "@@ -53,6 +54,7 @@\n import java.util.Map;\n \n import static org.apache.phoenix.coprocessor.MetaDataProtocol.DEFAULT_LOG_TTL;\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.IndexVerificationErrorType.*;", "originalCommit": "d873b8c87a4a1178d912d5f8f42d62affc846ad7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NjI4Mw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439666283", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-06-12T22:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2MTMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "c44c19f3d8c007996190366461aba628101ef80d", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java\nindex 2ff291daa..37c7fdc70 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryIT.java\n\n@@ -54,7 +54,9 @@ import java.util.List;\n import java.util.Map;\n \n import static org.apache.phoenix.coprocessor.MetaDataProtocol.DEFAULT_LOG_TTL;\n-import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.IndexVerificationErrorType.*;\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.IndexVerificationErrorType.BEYOND_MAX_LOOKBACK_INVALID;\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.IndexVerificationErrorType.BEYOND_MAX_LOOKBACK_MISSING;\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.IndexVerificationErrorType.INVALID_ROW;\n import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.OUTPUT_TABLE_NAME_BYTES;\n import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.PHASE_AFTER_VALUE;\n import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.PHASE_BEFORE_VALUE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2MjU5MA==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439562590", "bodyText": "Should this be false? I feel like \"beyond max lookback\" is kind of analogy to debug log. Why don't we make it false?", "author": "gokceni", "createdAt": "2020-06-12T17:51:14Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -98,6 +103,9 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n+    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS_CONF_KEY =\n+        \"phoenix.log.beyond.max.lookback.age.invalid.rows\";\n+    public static final boolean DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS = true;", "originalCommit": "d873b8c87a4a1178d912d5f8f42d62affc846ad7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NjMyMw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439666323", "bodyText": "Done", "author": "gjacoby126", "createdAt": "2020-06-12T22:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2MjU5MA=="}], "type": "inlineReview", "revised_code": {"commit": "c44c19f3d8c007996190366461aba628101ef80d", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 059367dc8..6f39837bc 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -96,97 +94,68 @@ import org.apache.phoenix.util.ServerUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.base.Throwables;\n import com.google.common.collect.Maps;\n \n public class IndexRebuildRegionScanner extends GlobalIndexRegionScanner {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n-    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS_CONF_KEY =\n-        \"phoenix.log.beyond.max.lookback.age.invalid.rows\";\n-    public static final boolean DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS = true;\n-    private final long maxBatchSizeBytes;\n-    private final long blockingMemstoreSize;\n-    private final byte[] clientVersionBytes;\n+    public static final String PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS =\n+        \"phoenix.index.mr.log.beyond.max.lookback.errors\";\n+    public static final boolean DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS = false;\n     private boolean useProto = true;\n     private byte[] indexRowKey;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n+    private static boolean ignoreIndexRebuildForTesting  = false;\n+    public static void setIgnoreIndexRebuildForTesting(boolean ignore) { ignoreIndexRebuildForTesting = ignore; }\n+    private byte[] indexRowKeyforReadRepair;\n     private IndexTool.IndexDisableLoggingType disableLoggingVerifyType = IndexTool.IndexDisableLoggingType.NONE;\n-    private boolean verify = false;\n-    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n-    private Map<byte[], Pair<Put, Delete>> dataKeyToMutationMap;\n-    private UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver;\n-    protected UngroupedAggregateRegionObserver.MutationList mutations;\n-    private boolean isBeforeRebuilt = true;\n-    private boolean partialRebuild = false;\n     private int singleRowRebuildReturnCode;\n-    private Map<byte[], NavigableSet<byte[]>> familyMap;\n     private byte[][] viewConstants;\n-    private IndexVerificationOutputRepository verificationOutputRepository;\n+    private IndexVerificationOutputRepository verificationOutputRepository = null;\n     private boolean skipped = false;\n     private boolean shouldVerifyCheckDone = false;\n+    final private RegionCoprocessorEnvironment env;\n+    private byte[][] indexRegionEndKeys;\n+    private byte[] nextStartKey;\n+    private boolean hasMoreIncr = false;\n+    private long minTimestamp = 0;\n \n     @VisibleForTesting\n     public IndexRebuildRegionScanner(final RegionScanner innerScanner, final Region region, final Scan scan,\n-                              final RegionCoprocessorEnvironment env,\n-                              UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver) throws IOException {\n+                              final RegionCoprocessorEnvironment env) throws IOException {\n         super(innerScanner, region, scan, env);\n-        final Configuration config = env.getConfiguration();\n-        if (scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_PAGING) == null) {\n-            partialRebuild = true;\n-        }\n-        maxBatchSizeBytes = config.getLong(MUTATE_BATCH_SIZE_BYTES_ATTRIB,\n-                QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE_BYTES);\n-        mutations = new UngroupedAggregateRegionObserver.MutationList(maxBatchSize);\n-        blockingMemstoreSize = UngroupedAggregateRegionObserver.getBlockingMemstoreSize(region, config);\n-        clientVersionBytes = scan.getAttribute(BaseScannerRegionObserver.CLIENT_VERSION);\n-        indexMetaData = scan.getAttribute(PhoenixIndexCodec.INDEX_PROTO_MD);\n-        if (indexMetaData == null) {\n-            useProto = false;\n-        }\n-        familyMap = scan.getFamilyMap();\n-        if (familyMap.isEmpty()) {\n-            familyMap = null;\n-        }\n-        this.ungroupedAggregateRegionObserver = ungroupedAggregateRegionObserver;\n-        indexRowKey = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n-        if (indexRowKey != null) {\n+        this.env = env;\n+        indexRowKeyforReadRepair = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n+        if (indexRowKeyforReadRepair != null) {\n             setReturnCodeForSingleRowRebuild();\n             pageSizeInRows = 1;\n+        } else {\n+            try(org.apache.hadoop.hbase.client.Connection connection =\n+                        HBaseFactoryProvider.getHConnectionFactory().createConnection(env.getConfiguration())) {\n+                indexRegionEndKeys = connection.getRegionLocator(indexHTable.getName()).getEndKeys();\n+            }\n         }\n-        byte[] valueBytes = scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_VERIFY_TYPE);\n-        if (valueBytes != null) {\n-            verifyType = IndexTool.IndexVerifyType.fromValue(valueBytes);\n-            if (verifyType != IndexTool.IndexVerifyType.NONE) {\n-                verify = true;\n-                boolean shouldLogBeyondMaxLookbackInvalidRows =\n-                    config.getBoolean(PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS_CONF_KEY,\n-                        DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS);\n-                viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n-                byte[] disableLoggingValueBytes =\n-                    scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n-                if (disableLoggingValueBytes != null) {\n-                    disableLoggingVerifyType =\n-                        IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n-                }\n-                verificationOutputRepository =\n-                    new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                        , hTableFactory, disableLoggingVerifyType);\n-                verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n-                verificationResult = new IndexToolVerificationResult(scan);\n-                        new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                            , hTableFactory, disableLoggingVerifyType);\n-                verificationResultRepository =\n-                    new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n-                indexKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                dataKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                pool = new WaitForCompletionTaskRunner(ThreadPoolManager.getExecutor(\n-                        new ThreadPoolBuilder(\"IndexVerify\",\n-                                env.getConfiguration()).setMaxThread(NUM_CONCURRENT_INDEX_VERIFY_THREADS_CONF_KEY,\n-                                DEFAULT_CONCURRENT_INDEX_VERIFY_THREADS).setCoreTimeout(\n-                                INDEX_WRITER_KEEP_ALIVE_TIME_CONF_KEY), env));\n+        if (verify) {\n+            boolean shouldLogBeyondMaxLookbackInvalidRows =\n+                env.getConfiguration().getBoolean(PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS,\n+                    DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS);\n+            viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n+            byte[] disableLoggingValueBytes =\n+                scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n+            if (disableLoggingValueBytes != null) {\n+                disableLoggingVerifyType =\n+                    IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n             }\n+            verificationOutputRepository =\n+                new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n+                    , hTableFactory, disableLoggingVerifyType);\n+            verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n+            verificationResult = new IndexToolVerificationResult(scan);\n+            verificationResultRepository =\n+                new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n+            nextStartKey = null;\n+            minTimestamp = scan.getTimeRange().getMin();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDI3OQ==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439600279", "bodyText": "invalid and missing, right?", "author": "swaroopak", "createdAt": "2020-06-12T19:16:29Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -98,6 +103,9 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n+    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS_CONF_KEY =", "originalCommit": "d873b8c87a4a1178d912d5f8f42d62affc846ad7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NjM4OQ==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439666389", "bodyText": "Switched to \"ERROR\" to encompass both INVALID and MISSING.", "author": "gjacoby126", "createdAt": "2020-06-12T22:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c44c19f3d8c007996190366461aba628101ef80d", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 059367dc8..6f39837bc 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -96,97 +94,68 @@ import org.apache.phoenix.util.ServerUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.base.Throwables;\n import com.google.common.collect.Maps;\n \n public class IndexRebuildRegionScanner extends GlobalIndexRegionScanner {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n-    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS_CONF_KEY =\n-        \"phoenix.log.beyond.max.lookback.age.invalid.rows\";\n-    public static final boolean DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS = true;\n-    private final long maxBatchSizeBytes;\n-    private final long blockingMemstoreSize;\n-    private final byte[] clientVersionBytes;\n+    public static final String PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS =\n+        \"phoenix.index.mr.log.beyond.max.lookback.errors\";\n+    public static final boolean DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS = false;\n     private boolean useProto = true;\n     private byte[] indexRowKey;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n+    private static boolean ignoreIndexRebuildForTesting  = false;\n+    public static void setIgnoreIndexRebuildForTesting(boolean ignore) { ignoreIndexRebuildForTesting = ignore; }\n+    private byte[] indexRowKeyforReadRepair;\n     private IndexTool.IndexDisableLoggingType disableLoggingVerifyType = IndexTool.IndexDisableLoggingType.NONE;\n-    private boolean verify = false;\n-    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n-    private Map<byte[], Pair<Put, Delete>> dataKeyToMutationMap;\n-    private UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver;\n-    protected UngroupedAggregateRegionObserver.MutationList mutations;\n-    private boolean isBeforeRebuilt = true;\n-    private boolean partialRebuild = false;\n     private int singleRowRebuildReturnCode;\n-    private Map<byte[], NavigableSet<byte[]>> familyMap;\n     private byte[][] viewConstants;\n-    private IndexVerificationOutputRepository verificationOutputRepository;\n+    private IndexVerificationOutputRepository verificationOutputRepository = null;\n     private boolean skipped = false;\n     private boolean shouldVerifyCheckDone = false;\n+    final private RegionCoprocessorEnvironment env;\n+    private byte[][] indexRegionEndKeys;\n+    private byte[] nextStartKey;\n+    private boolean hasMoreIncr = false;\n+    private long minTimestamp = 0;\n \n     @VisibleForTesting\n     public IndexRebuildRegionScanner(final RegionScanner innerScanner, final Region region, final Scan scan,\n-                              final RegionCoprocessorEnvironment env,\n-                              UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver) throws IOException {\n+                              final RegionCoprocessorEnvironment env) throws IOException {\n         super(innerScanner, region, scan, env);\n-        final Configuration config = env.getConfiguration();\n-        if (scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_PAGING) == null) {\n-            partialRebuild = true;\n-        }\n-        maxBatchSizeBytes = config.getLong(MUTATE_BATCH_SIZE_BYTES_ATTRIB,\n-                QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE_BYTES);\n-        mutations = new UngroupedAggregateRegionObserver.MutationList(maxBatchSize);\n-        blockingMemstoreSize = UngroupedAggregateRegionObserver.getBlockingMemstoreSize(region, config);\n-        clientVersionBytes = scan.getAttribute(BaseScannerRegionObserver.CLIENT_VERSION);\n-        indexMetaData = scan.getAttribute(PhoenixIndexCodec.INDEX_PROTO_MD);\n-        if (indexMetaData == null) {\n-            useProto = false;\n-        }\n-        familyMap = scan.getFamilyMap();\n-        if (familyMap.isEmpty()) {\n-            familyMap = null;\n-        }\n-        this.ungroupedAggregateRegionObserver = ungroupedAggregateRegionObserver;\n-        indexRowKey = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n-        if (indexRowKey != null) {\n+        this.env = env;\n+        indexRowKeyforReadRepair = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n+        if (indexRowKeyforReadRepair != null) {\n             setReturnCodeForSingleRowRebuild();\n             pageSizeInRows = 1;\n+        } else {\n+            try(org.apache.hadoop.hbase.client.Connection connection =\n+                        HBaseFactoryProvider.getHConnectionFactory().createConnection(env.getConfiguration())) {\n+                indexRegionEndKeys = connection.getRegionLocator(indexHTable.getName()).getEndKeys();\n+            }\n         }\n-        byte[] valueBytes = scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_VERIFY_TYPE);\n-        if (valueBytes != null) {\n-            verifyType = IndexTool.IndexVerifyType.fromValue(valueBytes);\n-            if (verifyType != IndexTool.IndexVerifyType.NONE) {\n-                verify = true;\n-                boolean shouldLogBeyondMaxLookbackInvalidRows =\n-                    config.getBoolean(PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS_CONF_KEY,\n-                        DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_INVALID_ROWS);\n-                viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n-                byte[] disableLoggingValueBytes =\n-                    scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n-                if (disableLoggingValueBytes != null) {\n-                    disableLoggingVerifyType =\n-                        IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n-                }\n-                verificationOutputRepository =\n-                    new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                        , hTableFactory, disableLoggingVerifyType);\n-                verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n-                verificationResult = new IndexToolVerificationResult(scan);\n-                        new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                            , hTableFactory, disableLoggingVerifyType);\n-                verificationResultRepository =\n-                    new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n-                indexKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                dataKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                pool = new WaitForCompletionTaskRunner(ThreadPoolManager.getExecutor(\n-                        new ThreadPoolBuilder(\"IndexVerify\",\n-                                env.getConfiguration()).setMaxThread(NUM_CONCURRENT_INDEX_VERIFY_THREADS_CONF_KEY,\n-                                DEFAULT_CONCURRENT_INDEX_VERIFY_THREADS).setCoreTimeout(\n-                                INDEX_WRITER_KEEP_ALIVE_TIME_CONF_KEY), env));\n+        if (verify) {\n+            boolean shouldLogBeyondMaxLookbackInvalidRows =\n+                env.getConfiguration().getBoolean(PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS,\n+                    DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS);\n+            viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n+            byte[] disableLoggingValueBytes =\n+                scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n+            if (disableLoggingValueBytes != null) {\n+                disableLoggingVerifyType =\n+                    IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n             }\n+            verificationOutputRepository =\n+                new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n+                    , hTableFactory, disableLoggingVerifyType);\n+            verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n+            verificationResult = new IndexToolVerificationResult(scan);\n+            verificationResultRepository =\n+                new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n+            nextStartKey = null;\n+            minTimestamp = scan.getTimeRange().getMin();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDY3NQ==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439600675", "bodyText": "shall we be specific with INVALID_INDEX_ROW and same for others?", "author": "swaroopak", "createdAt": "2020-06-12T19:17:34Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java", "diffHunk": "@@ -85,6 +88,15 @@\n     public static final byte[] PHASE_BEFORE_VALUE = Bytes.toBytes(\"BEFORE\");\n     public static final byte[] PHASE_AFTER_VALUE = Bytes.toBytes(\"AFTER\");\n \n+\n+    public enum IndexVerificationErrorType {\n+        INVALID_ROW,", "originalCommit": "d873b8c87a4a1178d912d5f8f42d62affc846ad7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY1Njk1NA==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439656954", "bodyText": "Since all of them refer to index rows, and Index is in the name of the enum, isn't that implicit?", "author": "gjacoby126", "createdAt": "2020-06-12T21:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMDY3NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NTA3Ng==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r439675076", "bodyText": "Can this property be modified via -D option from the client-side? Good to have a test for that.", "author": "swaroopak", "createdAt": "2020-06-12T23:07:44Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -152,6 +158,9 @@ public IndexRebuildRegionScanner(final RegionScanner innerScanner, final Region\n             verifyType = IndexTool.IndexVerifyType.fromValue(valueBytes);\n             if (verifyType != IndexTool.IndexVerifyType.NONE) {\n                 verify = true;\n+                boolean shouldLogBeyondMaxLookbackInvalidRows =\n+                    config.getBoolean(PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS_CONF_KEY,", "originalCommit": "7434f798e4b965124e1ffd6eadbdf9979acdf3fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNzEwNQ==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r440427105", "bodyText": "So far I have done nothing special to allow it be overridden from client-side. If the IndexTool is already taking all conf parameters from the client and using them on the server-side, then that's the case for this as well, and if it's not, it's not. (At a cursory look it appears that it's only certain flags which the InputFormat explicitly passes as scan attributes to the coproc?)\nMy original intention was that this would be a cluster-wide setting. I could change it to be overridable.\n@swaroopak - if this were overridable from the client-side, what kind of test would be sufficient? Given the long running time of our index tool tests already, I'm reluctant to add yet-another-end-to-end test just to check that a flag is carried through, but I'm not sure what other options there are to actually verify that each of the several layers passes the config through properly.", "author": "gjacoby126", "createdAt": "2020-06-15T20:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjk2Nw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r440506967", "bodyText": "It is important that we have this property overridable for each IndexTool run. You could modify the existing/the one added in this PR run of IndexTool to make sure the property changes from the client-side are reflecting properly.", "author": "swaroopak", "createdAt": "2020-06-15T23:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMzE4Nw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r445913187", "bodyText": "@swaroopak - Added a test in latest commit.", "author": "gjacoby126", "createdAt": "2020-06-26T00:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3NTA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c44c19f3d8c007996190366461aba628101ef80d", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex e1af34e64..6f39837bc 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -101,90 +100,62 @@ public class IndexRebuildRegionScanner extends GlobalIndexRegionScanner {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n-    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS_CONF_KEY =\n-        \"phoenix.log.beyond.max.lookback.age.error.rows\";\n-    public static final boolean DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS = false;\n-    private final long maxBatchSizeBytes;\n-    private final long blockingMemstoreSize;\n-    private final byte[] clientVersionBytes;\n+    public static final String PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS =\n+        \"phoenix.index.mr.log.beyond.max.lookback.errors\";\n+    public static final boolean DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS = false;\n     private boolean useProto = true;\n     private byte[] indexRowKey;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n+    private static boolean ignoreIndexRebuildForTesting  = false;\n+    public static void setIgnoreIndexRebuildForTesting(boolean ignore) { ignoreIndexRebuildForTesting = ignore; }\n+    private byte[] indexRowKeyforReadRepair;\n     private IndexTool.IndexDisableLoggingType disableLoggingVerifyType = IndexTool.IndexDisableLoggingType.NONE;\n-    private boolean verify = false;\n-    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n-    private Map<byte[], Pair<Put, Delete>> dataKeyToMutationMap;\n-    private UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver;\n-    protected UngroupedAggregateRegionObserver.MutationList mutations;\n-    private boolean isBeforeRebuilt = true;\n-    private boolean partialRebuild = false;\n     private int singleRowRebuildReturnCode;\n-    private Map<byte[], NavigableSet<byte[]>> familyMap;\n     private byte[][] viewConstants;\n-    private IndexVerificationOutputRepository verificationOutputRepository;\n+    private IndexVerificationOutputRepository verificationOutputRepository = null;\n     private boolean skipped = false;\n     private boolean shouldVerifyCheckDone = false;\n+    final private RegionCoprocessorEnvironment env;\n+    private byte[][] indexRegionEndKeys;\n+    private byte[] nextStartKey;\n+    private boolean hasMoreIncr = false;\n+    private long minTimestamp = 0;\n \n     @VisibleForTesting\n     public IndexRebuildRegionScanner(final RegionScanner innerScanner, final Region region, final Scan scan,\n-                              final RegionCoprocessorEnvironment env,\n-                              UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver) throws IOException {\n+                              final RegionCoprocessorEnvironment env) throws IOException {\n         super(innerScanner, region, scan, env);\n-        final Configuration config = env.getConfiguration();\n-        if (scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_PAGING) == null) {\n-            partialRebuild = true;\n-        }\n-        maxBatchSizeBytes = config.getLong(MUTATE_BATCH_SIZE_BYTES_ATTRIB,\n-                QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE_BYTES);\n-        mutations = new UngroupedAggregateRegionObserver.MutationList(maxBatchSize);\n-        blockingMemstoreSize = UngroupedAggregateRegionObserver.getBlockingMemstoreSize(region, config);\n-        clientVersionBytes = scan.getAttribute(BaseScannerRegionObserver.CLIENT_VERSION);\n-        indexMetaData = scan.getAttribute(PhoenixIndexCodec.INDEX_PROTO_MD);\n-        if (indexMetaData == null) {\n-            useProto = false;\n-        }\n-        familyMap = scan.getFamilyMap();\n-        if (familyMap.isEmpty()) {\n-            familyMap = null;\n-        }\n-        this.ungroupedAggregateRegionObserver = ungroupedAggregateRegionObserver;\n-        indexRowKey = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n-        if (indexRowKey != null) {\n+        this.env = env;\n+        indexRowKeyforReadRepair = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n+        if (indexRowKeyforReadRepair != null) {\n             setReturnCodeForSingleRowRebuild();\n             pageSizeInRows = 1;\n+        } else {\n+            try(org.apache.hadoop.hbase.client.Connection connection =\n+                        HBaseFactoryProvider.getHConnectionFactory().createConnection(env.getConfiguration())) {\n+                indexRegionEndKeys = connection.getRegionLocator(indexHTable.getName()).getEndKeys();\n+            }\n         }\n-        byte[] valueBytes = scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_VERIFY_TYPE);\n-        if (valueBytes != null) {\n-            verifyType = IndexTool.IndexVerifyType.fromValue(valueBytes);\n-            if (verifyType != IndexTool.IndexVerifyType.NONE) {\n-                verify = true;\n-                boolean shouldLogBeyondMaxLookbackInvalidRows =\n-                    config.getBoolean(PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS_CONF_KEY,\n-                        DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS);\n-                viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n-                byte[] disableLoggingValueBytes =\n-                    scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n-                if (disableLoggingValueBytes != null) {\n-                    disableLoggingVerifyType =\n-                        IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n-                }\n-                verificationOutputRepository =\n-                    new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                        , hTableFactory, disableLoggingVerifyType);\n-                verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n-                verificationResult = new IndexToolVerificationResult(scan);\n-                        new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                            , hTableFactory, disableLoggingVerifyType);\n-                verificationResultRepository =\n-                    new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n-                indexKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                dataKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                pool = new WaitForCompletionTaskRunner(ThreadPoolManager.getExecutor(\n-                        new ThreadPoolBuilder(\"IndexVerify\",\n-                                env.getConfiguration()).setMaxThread(NUM_CONCURRENT_INDEX_VERIFY_THREADS_CONF_KEY,\n-                                DEFAULT_CONCURRENT_INDEX_VERIFY_THREADS).setCoreTimeout(\n-                                INDEX_WRITER_KEEP_ALIVE_TIME_CONF_KEY), env));\n+        if (verify) {\n+            boolean shouldLogBeyondMaxLookbackInvalidRows =\n+                env.getConfiguration().getBoolean(PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS,\n+                    DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS);\n+            viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n+            byte[] disableLoggingValueBytes =\n+                scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n+            if (disableLoggingValueBytes != null) {\n+                disableLoggingVerifyType =\n+                    IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n             }\n+            verificationOutputRepository =\n+                new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n+                    , hTableFactory, disableLoggingVerifyType);\n+            verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n+            verificationResult = new IndexToolVerificationResult(scan);\n+            verificationResultRepository =\n+                new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n+            nextStartKey = null;\n+            minTimestamp = scan.getTimeRange().getMin();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NzcwMw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r440287703", "bodyText": "Can we please have this config be named consistently like the previous one?\n\"phoenix.mr.index.IndexDisableLoggingType=BEFORE\" .. It would make it easier to find and put those together whenever they need non-default values.", "author": "priyankporwal", "createdAt": "2020-06-15T16:09:46Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -91,13 +95,15 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.base.Throwables;\n import com.google.common.collect.Maps;\n \n public class IndexRebuildRegionScanner extends GlobalIndexRegionScanner {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n+    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS_CONF_KEY =\n+        \"phoenix.log.beyond.max.lookback.age.error.rows\";", "originalCommit": "7434f798e4b965124e1ffd6eadbdf9979acdf3fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c44c19f3d8c007996190366461aba628101ef80d", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex e1af34e64..6f39837bc 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -101,90 +100,62 @@ public class IndexRebuildRegionScanner extends GlobalIndexRegionScanner {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n-    public static final String PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS_CONF_KEY =\n-        \"phoenix.log.beyond.max.lookback.age.error.rows\";\n-    public static final boolean DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS = false;\n-    private final long maxBatchSizeBytes;\n-    private final long blockingMemstoreSize;\n-    private final byte[] clientVersionBytes;\n+    public static final String PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS =\n+        \"phoenix.index.mr.log.beyond.max.lookback.errors\";\n+    public static final boolean DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS = false;\n     private boolean useProto = true;\n     private byte[] indexRowKey;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n+    private static boolean ignoreIndexRebuildForTesting  = false;\n+    public static void setIgnoreIndexRebuildForTesting(boolean ignore) { ignoreIndexRebuildForTesting = ignore; }\n+    private byte[] indexRowKeyforReadRepair;\n     private IndexTool.IndexDisableLoggingType disableLoggingVerifyType = IndexTool.IndexDisableLoggingType.NONE;\n-    private boolean verify = false;\n-    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n-    private Map<byte[], Pair<Put, Delete>> dataKeyToMutationMap;\n-    private UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver;\n-    protected UngroupedAggregateRegionObserver.MutationList mutations;\n-    private boolean isBeforeRebuilt = true;\n-    private boolean partialRebuild = false;\n     private int singleRowRebuildReturnCode;\n-    private Map<byte[], NavigableSet<byte[]>> familyMap;\n     private byte[][] viewConstants;\n-    private IndexVerificationOutputRepository verificationOutputRepository;\n+    private IndexVerificationOutputRepository verificationOutputRepository = null;\n     private boolean skipped = false;\n     private boolean shouldVerifyCheckDone = false;\n+    final private RegionCoprocessorEnvironment env;\n+    private byte[][] indexRegionEndKeys;\n+    private byte[] nextStartKey;\n+    private boolean hasMoreIncr = false;\n+    private long minTimestamp = 0;\n \n     @VisibleForTesting\n     public IndexRebuildRegionScanner(final RegionScanner innerScanner, final Region region, final Scan scan,\n-                              final RegionCoprocessorEnvironment env,\n-                              UngroupedAggregateRegionObserver ungroupedAggregateRegionObserver) throws IOException {\n+                              final RegionCoprocessorEnvironment env) throws IOException {\n         super(innerScanner, region, scan, env);\n-        final Configuration config = env.getConfiguration();\n-        if (scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_PAGING) == null) {\n-            partialRebuild = true;\n-        }\n-        maxBatchSizeBytes = config.getLong(MUTATE_BATCH_SIZE_BYTES_ATTRIB,\n-                QueryServicesOptions.DEFAULT_MUTATE_BATCH_SIZE_BYTES);\n-        mutations = new UngroupedAggregateRegionObserver.MutationList(maxBatchSize);\n-        blockingMemstoreSize = UngroupedAggregateRegionObserver.getBlockingMemstoreSize(region, config);\n-        clientVersionBytes = scan.getAttribute(BaseScannerRegionObserver.CLIENT_VERSION);\n-        indexMetaData = scan.getAttribute(PhoenixIndexCodec.INDEX_PROTO_MD);\n-        if (indexMetaData == null) {\n-            useProto = false;\n-        }\n-        familyMap = scan.getFamilyMap();\n-        if (familyMap.isEmpty()) {\n-            familyMap = null;\n-        }\n-        this.ungroupedAggregateRegionObserver = ungroupedAggregateRegionObserver;\n-        indexRowKey = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n-        if (indexRowKey != null) {\n+        this.env = env;\n+        indexRowKeyforReadRepair = scan.getAttribute(BaseScannerRegionObserver.INDEX_ROW_KEY);\n+        if (indexRowKeyforReadRepair != null) {\n             setReturnCodeForSingleRowRebuild();\n             pageSizeInRows = 1;\n+        } else {\n+            try(org.apache.hadoop.hbase.client.Connection connection =\n+                        HBaseFactoryProvider.getHConnectionFactory().createConnection(env.getConfiguration())) {\n+                indexRegionEndKeys = connection.getRegionLocator(indexHTable.getName()).getEndKeys();\n+            }\n         }\n-        byte[] valueBytes = scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_VERIFY_TYPE);\n-        if (valueBytes != null) {\n-            verifyType = IndexTool.IndexVerifyType.fromValue(valueBytes);\n-            if (verifyType != IndexTool.IndexVerifyType.NONE) {\n-                verify = true;\n-                boolean shouldLogBeyondMaxLookbackInvalidRows =\n-                    config.getBoolean(PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS_CONF_KEY,\n-                        DEFAULT_PHOENIX_LOG_BEYOND_MAX_LOOKBACK_ERROR_ROWS);\n-                viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n-                byte[] disableLoggingValueBytes =\n-                    scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n-                if (disableLoggingValueBytes != null) {\n-                    disableLoggingVerifyType =\n-                        IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n-                }\n-                verificationOutputRepository =\n-                    new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                        , hTableFactory, disableLoggingVerifyType);\n-                verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n-                verificationResult = new IndexToolVerificationResult(scan);\n-                        new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n-                            , hTableFactory, disableLoggingVerifyType);\n-                verificationResultRepository =\n-                    new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n-                indexKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                dataKeyToMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n-                pool = new WaitForCompletionTaskRunner(ThreadPoolManager.getExecutor(\n-                        new ThreadPoolBuilder(\"IndexVerify\",\n-                                env.getConfiguration()).setMaxThread(NUM_CONCURRENT_INDEX_VERIFY_THREADS_CONF_KEY,\n-                                DEFAULT_CONCURRENT_INDEX_VERIFY_THREADS).setCoreTimeout(\n-                                INDEX_WRITER_KEEP_ALIVE_TIME_CONF_KEY), env));\n+        if (verify) {\n+            boolean shouldLogBeyondMaxLookbackInvalidRows =\n+                env.getConfiguration().getBoolean(PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS,\n+                    DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS);\n+            viewConstants = IndexUtil.deserializeViewConstantsFromScan(scan);\n+            byte[] disableLoggingValueBytes =\n+                scan.getAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE);\n+            if (disableLoggingValueBytes != null) {\n+                disableLoggingVerifyType =\n+                    IndexTool.IndexDisableLoggingType.fromValue(disableLoggingValueBytes);\n             }\n+            verificationOutputRepository =\n+                new IndexVerificationOutputRepository(indexMaintainer.getIndexTableName()\n+                    , hTableFactory, disableLoggingVerifyType);\n+            verificationOutputRepository.setShouldLogBeyondMaxLookback(shouldLogBeyondMaxLookbackInvalidRows);\n+            verificationResult = new IndexToolVerificationResult(scan);\n+            verificationResultRepository =\n+                new IndexVerificationResultRepository(indexMaintainer.getIndexTableName(), hTableFactory);\n+            nextStartKey = null;\n+            minTimestamp = scan.getTimeRange().getMin();\n         }\n     }\n \n"}}, {"oid": "c44c19f3d8c007996190366461aba628101ef80d", "url": "https://github.com/apache/phoenix/commit/c44c19f3d8c007996190366461aba628101ef80d", "message": "PHOENIX-5951 - Index rebuild output logging for past-max-lookback rows should be configurable", "committedDate": "2020-06-18T00:42:15Z", "type": "forcePushed"}, {"oid": "548afaeba0ceccaca7e65426d84b8bfee368f27e", "url": "https://github.com/apache/phoenix/commit/548afaeba0ceccaca7e65426d84b8bfee368f27e", "message": "PHOENIX-5951 - Index rebuild output logging for past-max-lookback rows should be configurable", "committedDate": "2020-06-26T17:56:35Z", "type": "forcePushed"}, {"oid": "1f79bf1e21f7c68992f3bd0073f178050ec166b6", "url": "https://github.com/apache/phoenix/commit/1f79bf1e21f7c68992f3bd0073f178050ec166b6", "message": "PHOENIX-5951 - Index rebuild output logging for past-max-lookback rows should be configurable", "committedDate": "2020-06-27T00:21:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2OTYzOQ==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446469639", "bodyText": "nit: looks like this made its way in the rebase?", "author": "swaroopak", "createdAt": "2020-06-27T01:49:16Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -96,6 +102,11 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(IndexRebuildRegionScanner.class);\n \n+    public static final String PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS =\n+        \"phoenix.index.mr.log.beyond.max.lookback.errors\";\n+    public static final boolean DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS = false;\n+    private boolean useProto = true;\n+    private byte[] indexRowKey;", "originalCommit": "1f79bf1e21f7c68992f3bd0073f178050ec166b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MTgyMA==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446491820", "bodyText": "indexRowKey and useProto are not used", "author": "kadirozde", "createdAt": "2020-06-27T06:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2OTYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMDA0Ng==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r447110046", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-06-29T16:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2OTYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "0ffe578d52c8be925c3e39fcc49f1d2fda0265d6", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\nindex 37d3f6b7a..e2418baf6 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java\n\n@@ -105,8 +105,6 @@ public class IndexRebuildRegionScanner extends GlobalIndexRegionScanner {\n     public static final String PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS =\n         \"phoenix.index.mr.log.beyond.max.lookback.errors\";\n     public static final boolean DEFAULT_PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS = false;\n-    private boolean useProto = true;\n-    private byte[] indexRowKey;\n     private static boolean ignoreIndexRebuildForTesting  = false;\n     public static void setIgnoreIndexRebuildForTesting(boolean ignore) { ignoreIndexRebuildForTesting = ignore; }\n     private byte[] indexRowKeyforReadRepair;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MTU4MQ==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446491581", "bodyText": "This is not the right conf key to set here", "author": "kadirozde", "createdAt": "2020-06-27T06:21:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java", "diffHunk": "@@ -1006,6 +1011,72 @@ public void testDisableOutputLogging() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testEnableOutputLoggingForMaxLookback() throws Exception {\n+        //by default we don't log invalid or missing rows past max lookback age to the\n+        // PHOENIX_INDEX_TOOL table. Verify that we can flip that logging on from the client-side\n+        // using a system property (such as from the command line) and have it log rows on the\n+        // server-side\n+        if (!mutable) {\n+            return;\n+        }\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+            ManualEnvironmentEdge injectEdge = new ManualEnvironmentEdge();\n+            injectEdge.setValue(EnvironmentEdgeManager.currentTimeMillis());\n+            EnvironmentEdgeManager.injectEdge(injectEdge);\n+            deleteAllRows(conn,\n+                TableName.valueOf(IndexVerificationOutputRepository.OUTPUT_TABLE_NAME));\n+            String stmString1 =\n+                \"CREATE TABLE \" + dataTableFullName\n+                    + \" (ID INTEGER NOT NULL PRIMARY KEY, NAME VARCHAR, ZIP INTEGER) \";\n+            conn.createStatement().execute(stmString1);\n+\n+            injectEdge.incrementValue(1L);\n+            String upsertQuery = String.format(\"UPSERT INTO %s VALUES(?, ?, ?)\", dataTableFullName);\n+            PreparedStatement stmt1 = conn.prepareStatement(upsertQuery);\n+\n+            // insert two rows\n+            IndexToolIT.upsertRow(stmt1, 1);\n+            IndexToolIT.upsertRow(stmt1, 2);\n+            conn.commit();\n+            injectEdge.incrementValue(1L); //we have to increment time to see our writes\n+            //now create an index async so it won't have the two rows in the base table\n+\n+            String stmtString2 =\n+                String.format(\n+                    \"CREATE INDEX %s ON %s (LPAD(UPPER(NAME, 'en_US'),8,'x')||'_xyz') ASYNC \",\n+                    indexTableName, dataTableFullName);\n+            conn.createStatement().execute(stmtString2);\n+            conn.commit();\n+            injectEdge.incrementValue(MAX_LOOKBACK_AGE * 1000);\n+            deleteAllRows(conn, TableName.valueOf(IndexVerificationOutputRepository.OUTPUT_TABLE_NAME));\n+            getUtility().getConfiguration().\n+                set(IndexRebuildRegionScanner.INDEX_VERIFY_ROW_COUNTS_PER_TASK_CONF_KEY, \"true\");", "originalCommit": "1f79bf1e21f7c68992f3bd0073f178050ec166b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc3MDYyMg==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446770622", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-06-29T04:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MTU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c39f932198fcf0273413902f42e593f020ec515a", "chunk": "diff --git a/phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java b/phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java\nindex 38adc5dc5..02163551a 100644\n--- a/phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java\n+++ b/phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java\n\n@@ -1057,7 +1056,7 @@ public class IndexToolForNonTxGlobalIndexIT extends BaseUniqueNamesOwnClusterIT\n             injectEdge.incrementValue(MAX_LOOKBACK_AGE * 1000);\n             deleteAllRows(conn, TableName.valueOf(IndexVerificationOutputRepository.OUTPUT_TABLE_NAME));\n             getUtility().getConfiguration().\n-                set(IndexRebuildRegionScanner.INDEX_VERIFY_ROW_COUNTS_PER_TASK_CONF_KEY, \"true\");\n+                set(IndexRebuildRegionScanner.PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS, \"true\");\n             IndexTool it = IndexToolIT.runIndexTool(directApi, useSnapshot, schemaName,\n                 dataTableName,\n                 indexTableName, null, 0, IndexTool.IndexVerifyType.ONLY);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MTkzNw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446491937", "bodyText": "Thanks for correcting the comment", "author": "kadirozde", "createdAt": "2020-06-27T06:25:53Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1223,7 +1254,7 @@ public int prepareIndexMutations(Put put, Delete del, Map<byte[], List<Mutation>\n                                      Set<byte[]> mostRecentIndexRowKeys) throws IOException {\n         List<Mutation> indexMutations = prepareIndexMutationsForRebuild(indexMaintainer, put, del);\n         boolean mostRecentDone = false;\n-        // Do not populate mostRecentIndexRowKeys when verifyType != IndexTool.IndexVerifyType.ONLY\n+        // Do not populate mostRecentIndexRowKeys when verifyType is NONE or AFTER", "originalCommit": "1f79bf1e21f7c68992f3bd0073f178050ec166b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MjAzNw==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446492037", "bodyText": "PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS rather than INDEX_VERIFY_ROW_COUNTS_PER_TASK_CONF_KEY", "author": "kadirozde", "createdAt": "2020-06-27T06:27:10Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/PhoenixServerBuildIndexInputFormat.java", "diffHunk": "@@ -108,6 +109,12 @@ protected QueryPlan getQueryPlan(final JobContext context, final Configuration c\n                 scan.setAttribute(BaseScannerRegionObserver.INDEX_RETRY_VERIFY, Bytes.toBytes(lastVerifyTimeValue));\n                 scan.setAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE,\n                     getDisableLoggingVerifyType(configuration).toBytes());\n+                String shouldLogMaxLookbackOutput =\n+                    configuration.get(IndexRebuildRegionScanner.INDEX_VERIFY_ROW_COUNTS_PER_TASK_CONF_KEY);", "originalCommit": "1f79bf1e21f7c68992f3bd0073f178050ec166b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc3MDU5NA==", "url": "https://github.com/apache/phoenix/pull/801#discussion_r446770594", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-06-29T04:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MjAzNw=="}], "type": "inlineReview", "revised_code": {"commit": "c39f932198fcf0273413902f42e593f020ec515a", "chunk": "diff --git a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/PhoenixServerBuildIndexInputFormat.java b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/PhoenixServerBuildIndexInputFormat.java\nindex 21b95cfdd..db59d4e80 100644\n--- a/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/PhoenixServerBuildIndexInputFormat.java\n+++ b/phoenix-core/src/main/java/org/apache/phoenix/mapreduce/PhoenixServerBuildIndexInputFormat.java\n\n@@ -110,7 +110,7 @@ public class PhoenixServerBuildIndexInputFormat<T extends DBWritable> extends Ph\n                 scan.setAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_VERIFY_TYPE,\n                     getDisableLoggingVerifyType(configuration).toBytes());\n                 String shouldLogMaxLookbackOutput =\n-                    configuration.get(IndexRebuildRegionScanner.INDEX_VERIFY_ROW_COUNTS_PER_TASK_CONF_KEY);\n+                    configuration.get(IndexRebuildRegionScanner.PHOENIX_INDEX_MR_LOG_BEYOND_MAX_LOOKBACK_ERRORS);\n                 if (shouldLogMaxLookbackOutput != null) {\n                     scan.setAttribute(BaseScannerRegionObserver.INDEX_REBUILD_DISABLE_LOGGING_BEYOND_MAXLOOKBACK_AGE,\n                         Bytes.toBytes(shouldLogMaxLookbackOutput));\n"}}, {"oid": "c39f932198fcf0273413902f42e593f020ec515a", "url": "https://github.com/apache/phoenix/commit/c39f932198fcf0273413902f42e593f020ec515a", "message": "PHOENIX-5951 - Index rebuild output logging for past-max-lookback rows should be configurable", "committedDate": "2020-06-29T04:41:33Z", "type": "commit"}, {"oid": "c39f932198fcf0273413902f42e593f020ec515a", "url": "https://github.com/apache/phoenix/commit/c39f932198fcf0273413902f42e593f020ec515a", "message": "PHOENIX-5951 - Index rebuild output logging for past-max-lookback rows should be configurable", "committedDate": "2020-06-29T04:41:33Z", "type": "forcePushed"}, {"oid": "0ffe578d52c8be925c3e39fcc49f1d2fda0265d6", "url": "https://github.com/apache/phoenix/commit/0ffe578d52c8be925c3e39fcc49f1d2fda0265d6", "message": "PHOENIX-5951 - IndexTool output logging for past-max-lookback rows should be configurable", "committedDate": "2020-06-29T16:37:41Z", "type": "commit"}]}