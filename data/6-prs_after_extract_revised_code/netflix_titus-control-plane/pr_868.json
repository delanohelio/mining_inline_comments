{"pr_number": 868, "pr_title": "Read archived data from active job/task tables if not found in the archive tables", "pr_createdAt": "2020-06-10T22:03:25Z", "pr_url": "https://github.com/Netflix/titus-control-plane/pull/868", "timeline": [{"oid": "ed6bcebd02563745cdac5c01c132e9d375b77413", "url": "https://github.com/Netflix/titus-control-plane/commit/ed6bcebd02563745cdac5c01c132e9d375b77413", "message": "Read archived data from active job/task tables if not found in the archive tables\n\nIt is possible that finished jobs/tasks are not moved after they are finished to\nthe archive tables. This may happen during failover which happens\nimmediately after a job completes, but is not archived yet. To read such\nabandoned items (which are ignored when loading active data into memory), we\nhave to make a fallback query in case the primary archive table does not contain\nan entry.", "committedDate": "2020-06-10T21:57:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjE2NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438466164", "bodyText": "please add some documentation here (and consider renaming the method) since now it will also always returns active tasks for the job. It seems to be handled correctly by the only current caller, but it may cause confusion in the future", "author": "fabiokung", "createdAt": "2020-06-10T23:45:16Z", "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {", "originalCommit": "ed6bcebd02563745cdac5c01c132e9d375b77413", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTYzOQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438955639", "bodyText": "Active state should never be read like that (all of it is read on startup). But technically you are right that we could read active data with this method. I will add a comment documenting this.", "author": "tbak", "createdAt": "2020-06-11T17:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2NjE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "3f3afdc6bd660b3f03485a3f04a78b2441d81d8a", "chunk": "diff --git a/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java b/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java\nindex e21ea704d..527ddb43d 100644\n--- a/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java\n+++ b/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java\n\n@@ -604,6 +604,15 @@ public class CassandraJobStore implements JobStore {\n         ).toCompletable();\n     }\n \n+    /**\n+     * This method reads data from the archive table, and if not found checks the active table for its existence.\n+     * The latter is needed as sometimes a job may not be correctly archived, and we do not have a reconciliation process\n+     * that would fix it.\n+     * <p>\n+     * This method should be only used to get state of a finished job. It would return a persisted state for an active job\n+     * as well, as a side effect for the workaround implemented here. A caller should not piggyback on this behavior, as\n+     * it may change at any point in time.\n+     */\n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n         Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MDM4Mw==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438480383", "bodyText": "Is the variable name correct? Seems like these could be active or archived depending on the statement provided.", "author": "andrew-leung", "createdAt": "2020-06-11T00:36:46Z", "path": "titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java", "diffHunk": "@@ -606,43 +606,62 @@ public Completable deleteTask(Task task) {\n \n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n-        return Observable.fromCallable((Callable<Statement>) () -> retrieveArchivedJobStatement.bind(jobId)).flatMap(statement -> execute(statement)\n-                .map(resultSet -> {\n-                    Row row = resultSet.one();\n-                    if (row == null) {\n-                        throw JobStoreException.jobDoesNotExist(jobId);\n-                    }\n-                    String value = row.getString(0);\n-                    return (Job<?>) ObjectMappers.readValue(mapper, value, Job.class);\n-                }));\n+        Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n+                .switchIfEmpty(retrieveEntityById(jobId, Job.class, retrieveActiveJobStatement))\n+                .switchIfEmpty(Observable.error(JobStoreException.jobDoesNotExist(jobId)));\n+        return (Observable) action;\n     }\n \n     @Override\n     public Observable<Task> retrieveArchivedTasksForJob(String jobId) {\n-        return Observable.fromCallable(() -> retrieveArchivedTaskIdsForJobStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n-                .flatMap(retrieveActiveTaskIdsForJob -> execute(retrieveActiveTaskIdsForJob).flatMap(taskIdsResultSet -> {\n-                    List<String> taskIds = taskIdsResultSet.all().stream().map(row -> row.getString(0)).collect(Collectors.toList());\n-                    List<Observable<ResultSet>> observables = taskIds.stream().map(retrieveArchivedTaskStatement::bind).map(this::execute).collect(Collectors.toList());\n-                    return Observable.merge(observables, getConcurrencyLimit()).flatMapIterable(tasksResultSet -> tasksResultSet.all().stream()\n-                            .map(row -> row.getString(0))\n-                            .map(value -> deserializeTask(value))\n-                            .collect(Collectors.toList()));\n-                }));\n+        return retrieveArchivedTasksForJob(jobId, retrieveArchivedTaskIdsForJobStatement, retrieveArchivedTaskStatement)\n+                .switchIfEmpty(retrieveArchivedTasksForJob(jobId, retrieveActiveTaskIdsForJobStatement, retrieveActiveTaskStatement));\n+    }\n+\n+    private Observable<Task> retrieveArchivedTasksForJob(String jobId, PreparedStatement taskIdStatement, PreparedStatement taskStatement) {\n+        return Observable.fromCallable(() -> taskIdStatement.bind(jobId).setFetchSize(Integer.MAX_VALUE))\n+                .flatMap(retrieveActiveTaskIdsForJob ->", "originalCommit": "ed6bcebd02563745cdac5c01c132e9d375b77413", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NTkzNw==", "url": "https://github.com/Netflix/titus-control-plane/pull/868#discussion_r438955937", "bodyText": "I will change this, and add a comment.", "author": "tbak", "createdAt": "2020-06-11T17:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MDM4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3f3afdc6bd660b3f03485a3f04a78b2441d81d8a", "chunk": "diff --git a/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java b/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java\nindex e21ea704d..527ddb43d 100644\n--- a/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java\n+++ b/titus-ext/cassandra/src/main/java/com/netflix/titus/ext/cassandra/store/CassandraJobStore.java\n\n@@ -604,6 +604,15 @@ public class CassandraJobStore implements JobStore {\n         ).toCompletable();\n     }\n \n+    /**\n+     * This method reads data from the archive table, and if not found checks the active table for its existence.\n+     * The latter is needed as sometimes a job may not be correctly archived, and we do not have a reconciliation process\n+     * that would fix it.\n+     * <p>\n+     * This method should be only used to get state of a finished job. It would return a persisted state for an active job\n+     * as well, as a side effect for the workaround implemented here. A caller should not piggyback on this behavior, as\n+     * it may change at any point in time.\n+     */\n     @Override\n     public Observable<Job<?>> retrieveArchivedJob(String jobId) {\n         Observable<Job> action = retrieveEntityById(jobId, Job.class, retrieveArchivedJobStatement)\n"}}, {"oid": "3f3afdc6bd660b3f03485a3f04a78b2441d81d8a", "url": "https://github.com/Netflix/titus-control-plane/commit/3f3afdc6bd660b3f03485a3f04a78b2441d81d8a", "message": "Code review updates", "committedDate": "2020-06-11T17:43:45Z", "type": "commit"}]}