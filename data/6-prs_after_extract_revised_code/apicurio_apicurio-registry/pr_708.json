{"pr_number": 708, "pr_title": "Enhance ibmcompat API methods", "pr_createdAt": "2020-07-24T15:50:51Z", "pr_url": "https://github.com/Apicurio/apicurio-registry/pull/708", "timeline": [{"oid": "685c7c7ca35b119f1d8c3469faacdc378aad062c", "url": "https://github.com/Apicurio/apicurio-registry/commit/685c7c7ca35b119f1d8c3469faacdc378aad062c", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-07-25T00:20:00Z", "type": "forcePushed"}, {"oid": "ceb8eae9cd931724e37ca28a334e48d1c91bc827", "url": "https://github.com/Apicurio/apicurio-registry/commit/ceb8eae9cd931724e37ca28a334e48d1c91bc827", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-07-25T23:17:17Z", "type": "forcePushed"}, {"oid": "64a78a7ae61b080ec02c78d17ace6528ca57ce7b", "url": "https://github.com/Apicurio/apicurio-registry/commit/64a78a7ae61b080ec02c78d17ace6528ca57ce7b", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-07-28T13:28:17Z", "type": "forcePushed"}, {"oid": "849b83085ae9e6920c589946828019b6d524bb51", "url": "https://github.com/Apicurio/apicurio-registry/commit/849b83085ae9e6920c589946828019b6d524bb51", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-07-30T10:00:33Z", "type": "forcePushed"}, {"oid": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "url": "https://github.com/Apicurio/apicurio-registry/commit/9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "message": "Enhance ibmcompat API PATCH methods\n\n - This commit adds implementations and tests for the two lifecycle\nmanagement methods of the ibmcompat API:\n    - `PATCH ibmcompat/schemas/{schema-id}`\n    - `PATCH ibmcompat/schemas/{schema-id}/versions/{version-id}`\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-07-31T15:37:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NTU0NQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463685545", "bodyText": "This seems like an OK short term solution.  But it would be good to think about what other options we might have here to avoid this.  Especially since the current implementation is hard coded to wait for about 1s.  Any async storage (infinispan and kafka streams are both async) cannot make a 1s guarantee.  So we would at least need to make the wait time adjustable.  But even better would be if we could enhance the storage layer in some way to avoid this wait time.  I'm open to ideas!  :)", "author": "EricWittmann", "createdAt": "2020-07-31T15:41:08Z", "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -52,12 +77,147 @@\n     private List<SchemaVersion> getSchemaVersions(String schemaid) {\n         return storage.getArtifactVersions(schemaid)\n                       .stream()\n-                      .map(l -> {\n-                          SchemaVersion sv = new SchemaVersion();\n-                          sv.setId(l.intValue());\n-                          sv.setEnabled(true);\n-                          return sv;\n-                      }).collect(Collectors.toList());\n+                      .map(versionid -> getSchemaVersion(schemaid, versionid))\n+                      .filter(schemaVersion -> schemaVersion != null)\n+                      .collect(Collectors.toList());\n+    }\n+\n+    private SchemaVersion getLatestSchemaVersion(String schemaid) {\n+        return getSchemaVersion(schemaid, storage.getArtifact(schemaid).getVersion());\n+    }\n+\n+    private SchemaVersion getSchemaVersion(String schemaid, Long versionid) {\n+        SchemaVersion schemaVersion = new SchemaVersion();\n+        try {\n+            ArtifactVersionMetaDataDto artifactMetaData = storage.getArtifactVersionMetaData(schemaid, versionid);\n+            schemaVersion.setId(versionid.intValue()); // TODO not safe!\n+            schemaVersion.setDate(new Date(artifactMetaData.getCreatedOn()));\n+            schemaVersion.setName(artifactMetaData.getName());\n+            schemaVersion.setEnabled(!ArtifactState.DISABLED.equals(artifactMetaData.getState()));\n+            SchemaState versionState = new SchemaState();\n+            if(ArtifactState.DEPRECATED.equals(artifactMetaData.getState())) {\n+                versionState.setState(SchemaState.StateEnum.DEPRECATED);\n+            } else {\n+                versionState.setState(SchemaState.StateEnum.ACTIVE);\n+            }\n+            schemaVersion.setState(versionState);\n+        } catch (ArtifactNotFoundException e) {\n+            return null;\n+        }\n+        return schemaVersion;\n+    }\n+\n+    private void populateSchemaSummary(String schemaid, SchemaSummary schemaSummary) {\n+        List<ArtifactState> versionStates = storage.getArtifactVersions(schemaid).stream()\n+            .map(version -> storage.getArtifactVersionMetaData(schemaid, version).getState())\n+            .collect(Collectors.toList());\n+\n+        schemaSummary.setId(schemaid);\n+        schemaSummary.setName(schemaid); // TODO - add mechanism to store an artifact-level name\n+\n+        // The schema is disabled if all versions are disabled\n+        boolean isSchemaDisabled = versionStates.stream().allMatch(versionState -> ArtifactState.DISABLED.equals(versionState));\n+        schemaSummary.setEnabled(!isSchemaDisabled);\n+\n+        // The schema is deprecated if all versions are deprecated\n+        boolean isSchemaDeprecated = versionStates.stream().allMatch(versionState -> ArtifactState.DEPRECATED.equals(versionState));\n+        SchemaState schemaState = new SchemaState();\n+        if(isSchemaDeprecated) {\n+            schemaState.setState(SchemaState.StateEnum.DEPRECATED);\n+        } else {\n+            schemaState.setState(SchemaState.StateEnum.ACTIVE);\n+        }\n+        schemaSummary.setState(schemaState);\n+    }\n+\n+    private void handleArtifactCreation(AsyncResponse response, String artifactId, String versionName, Throwable t) {\n+        if (t != null) {\n+            response.resume(t);\n+            return;\n+        }\n+\n+        if (!doesArtifactExist(artifactId)) {\n+            // Some storage (such as asyncmem) needs a wait before the artifact is available for updating\n+            try {\n+                waitForArtifactCreation(artifactId);", "originalCommit": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM5MTkzMA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r464391930", "bodyText": "Any kind of wait / retry should be dealt differently -- see how we handle this with AsyncBiFunctionService in Streams storage.\nSo you actually get a remote callback.", "author": "alesj", "createdAt": "2020-08-03T12:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NTU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM4OTYzMw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r468389633", "bodyText": "Yep - the reason for this block is due to how AsyncInMem storage adds a delay to the creation timestamp for the new artifact [1] and so when I call the updateArtifactMetaData() call (at line 157, which is currently commented out), it checks the artifact creation time, and returns an ArtifactNotFoundException as the creation timestamp has not yet been met, due to the added delay [2].\n[1] \n  \n    \n      apicurio-registry/storage/asyncmem/src/main/java/io/apicurio/registry/asyncmem/AsyncInMemoryRegistryStorage.java\n    \n    \n        Lines 105 to 107\n      in\n      54d82c2\n    \n    \n    \n    \n\n        \n          \n           long creationTime = amdd.getCreatedOn() + createDelay; \n        \n\n        \n          \n           this.artifactCreation.put(artifactId, creationTime); \n        \n\n        \n          \n           this.globalCreation.put(globalId, creationTime); \n        \n    \n  \n\n\n[2] https://github.com/ajborley/apicurio-registry/blob/54d82c269c6f57be4f80c7bae4a9b00dfe789ffd/storage/asyncmem/src/main/java/io/apicurio/registry/asyncmem/AsyncInMemoryRegistryStorage.java#L360-L363\nPotential fixes for this could be to allow some of the metadata to be set as part of the artifact creation, or maybe somehow ignore the timestamp check when making updateArtifactMetaData calls within the server.\nI haven't seen similar issues with other storage types needing a wait/retry, but I haven't checked them all extensively.", "author": "ajborley", "createdAt": "2020-08-11T07:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NTU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyMTc3NA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r468821774", "bodyText": "The purpose of the asyncmem storage type is to mimic the async nature of the Kafka based storages.  Especially when in a clustered environment, the Kafka storages may return a 404 for a GET immediately after a POST (create an artifact and then quickly ask for it may result in a NotFound).  This is from a remote client perspective, of course.  We had some issues in our integration tests around this - the tests need to understand that a slight delay is possible.  So I created the asyncmem storage to force the delay so I could shake out any problems in the tests.\n(Note:  the integration tests are run by QE against real deployments, including clustered deployments)\nSo I think this is somewhat of an unintended consequence.  Still, I think we should open a separate GitHub issue to discuss the things you're trying to do in the ibmcompat API layer - we can enhance the storage interface to accommodate those needs.", "author": "EricWittmann", "createdAt": "2020-08-11T19:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NTU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "chunk": "diff --git a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\nindex bca978a0..9f8a11d1 100644\n--- a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n+++ b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n\n@@ -150,10 +145,7 @@ public class ApiServiceImpl implements ApiService {\n             // Set the artifact name from the version name\n             EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n             dto.setName(versionName);\n-            //\n-            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n-            // The consumer thread appears to be blocked. Help needed here.\n-            //\n+            // TODO: On Kafka topic storage, updateArtifactMetaData does not return. Help needed here.\n             // storage.updateArtifactMetaData(artifactId, dto);\n \n             // Prepare the response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjA4NA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463686084", "bodyText": "Right - this will not work. @alesj can provide a good explanation.  This has come up before and I was looking for a link to that explanation but I couldn't dig it up quickly.", "author": "EricWittmann", "createdAt": "2020-07-31T15:42:11Z", "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -52,12 +77,147 @@\n     private List<SchemaVersion> getSchemaVersions(String schemaid) {\n         return storage.getArtifactVersions(schemaid)\n                       .stream()\n-                      .map(l -> {\n-                          SchemaVersion sv = new SchemaVersion();\n-                          sv.setId(l.intValue());\n-                          sv.setEnabled(true);\n-                          return sv;\n-                      }).collect(Collectors.toList());\n+                      .map(versionid -> getSchemaVersion(schemaid, versionid))\n+                      .filter(schemaVersion -> schemaVersion != null)\n+                      .collect(Collectors.toList());\n+    }\n+\n+    private SchemaVersion getLatestSchemaVersion(String schemaid) {\n+        return getSchemaVersion(schemaid, storage.getArtifact(schemaid).getVersion());\n+    }\n+\n+    private SchemaVersion getSchemaVersion(String schemaid, Long versionid) {\n+        SchemaVersion schemaVersion = new SchemaVersion();\n+        try {\n+            ArtifactVersionMetaDataDto artifactMetaData = storage.getArtifactVersionMetaData(schemaid, versionid);\n+            schemaVersion.setId(versionid.intValue()); // TODO not safe!\n+            schemaVersion.setDate(new Date(artifactMetaData.getCreatedOn()));\n+            schemaVersion.setName(artifactMetaData.getName());\n+            schemaVersion.setEnabled(!ArtifactState.DISABLED.equals(artifactMetaData.getState()));\n+            SchemaState versionState = new SchemaState();\n+            if(ArtifactState.DEPRECATED.equals(artifactMetaData.getState())) {\n+                versionState.setState(SchemaState.StateEnum.DEPRECATED);\n+            } else {\n+                versionState.setState(SchemaState.StateEnum.ACTIVE);\n+            }\n+            schemaVersion.setState(versionState);\n+        } catch (ArtifactNotFoundException e) {\n+            return null;\n+        }\n+        return schemaVersion;\n+    }\n+\n+    private void populateSchemaSummary(String schemaid, SchemaSummary schemaSummary) {\n+        List<ArtifactState> versionStates = storage.getArtifactVersions(schemaid).stream()\n+            .map(version -> storage.getArtifactVersionMetaData(schemaid, version).getState())\n+            .collect(Collectors.toList());\n+\n+        schemaSummary.setId(schemaid);\n+        schemaSummary.setName(schemaid); // TODO - add mechanism to store an artifact-level name\n+\n+        // The schema is disabled if all versions are disabled\n+        boolean isSchemaDisabled = versionStates.stream().allMatch(versionState -> ArtifactState.DISABLED.equals(versionState));\n+        schemaSummary.setEnabled(!isSchemaDisabled);\n+\n+        // The schema is deprecated if all versions are deprecated\n+        boolean isSchemaDeprecated = versionStates.stream().allMatch(versionState -> ArtifactState.DEPRECATED.equals(versionState));\n+        SchemaState schemaState = new SchemaState();\n+        if(isSchemaDeprecated) {\n+            schemaState.setState(SchemaState.StateEnum.DEPRECATED);\n+        } else {\n+            schemaState.setState(SchemaState.StateEnum.ACTIVE);\n+        }\n+        schemaSummary.setState(schemaState);\n+    }\n+\n+    private void handleArtifactCreation(AsyncResponse response, String artifactId, String versionName, Throwable t) {\n+        if (t != null) {\n+            response.resume(t);\n+            return;\n+        }\n+\n+        if (!doesArtifactExist(artifactId)) {\n+            // Some storage (such as asyncmem) needs a wait before the artifact is available for updating\n+            try {\n+                waitForArtifactCreation(artifactId);\n+            } catch (ArtifactNotFoundException e) {\n+                response.resume(e);\n+                return;\n+            }\n+        }\n+\n+        try {\n+            // Set the artifact name from the version name\n+            EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n+            dto.setName(versionName);\n+            //\n+            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n+            // The consumer thread appears to be blocked. Help needed here.\n+            //\n+            // storage.updateArtifactMetaData(artifactId, dto);", "originalCommit": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM5NDEwNA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r464394104", "bodyText": "A single (separate) call should not be a problem.\nWe had problems were we nested ComplationStage calls -- and the thread of the first one was used for others as well. Of course then the first one never finished.", "author": "alesj", "createdAt": "2020-08-03T12:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQyOTE3Ng==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r464429176", "bodyText": "Is that not what's happening here?  I assumed it was the same problem.", "author": "EricWittmann", "createdAt": "2020-08-03T13:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1NTU2MQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r464455561", "bodyText": "I guess it could be ... if the method that calls this is called in some nested CS -- didn't track that much :-)", "author": "alesj", "createdAt": "2020-08-03T14:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjA4NA=="}], "type": "inlineReview", "revised_code": {"commit": "d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "chunk": "diff --git a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\nindex bca978a0..9f8a11d1 100644\n--- a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n+++ b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n\n@@ -150,10 +145,7 @@ public class ApiServiceImpl implements ApiService {\n             // Set the artifact name from the version name\n             EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n             dto.setName(versionName);\n-            //\n-            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n-            // The consumer thread appears to be blocked. Help needed here.\n-            //\n+            // TODO: On Kafka topic storage, updateArtifactMetaData does not return. Help needed here.\n             // storage.updateArtifactMetaData(artifactId, dto);\n \n             // Prepare the response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjUzNQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463686535", "bodyText": "Icky - at the very least needs to be configurable.  See my other comment on this.", "author": "EricWittmann", "createdAt": "2020-07-31T15:43:01Z", "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -52,12 +77,147 @@\n     private List<SchemaVersion> getSchemaVersions(String schemaid) {\n         return storage.getArtifactVersions(schemaid)\n                       .stream()\n-                      .map(l -> {\n-                          SchemaVersion sv = new SchemaVersion();\n-                          sv.setId(l.intValue());\n-                          sv.setEnabled(true);\n-                          return sv;\n-                      }).collect(Collectors.toList());\n+                      .map(versionid -> getSchemaVersion(schemaid, versionid))\n+                      .filter(schemaVersion -> schemaVersion != null)\n+                      .collect(Collectors.toList());\n+    }\n+\n+    private SchemaVersion getLatestSchemaVersion(String schemaid) {\n+        return getSchemaVersion(schemaid, storage.getArtifact(schemaid).getVersion());\n+    }\n+\n+    private SchemaVersion getSchemaVersion(String schemaid, Long versionid) {\n+        SchemaVersion schemaVersion = new SchemaVersion();\n+        try {\n+            ArtifactVersionMetaDataDto artifactMetaData = storage.getArtifactVersionMetaData(schemaid, versionid);\n+            schemaVersion.setId(versionid.intValue()); // TODO not safe!\n+            schemaVersion.setDate(new Date(artifactMetaData.getCreatedOn()));\n+            schemaVersion.setName(artifactMetaData.getName());\n+            schemaVersion.setEnabled(!ArtifactState.DISABLED.equals(artifactMetaData.getState()));\n+            SchemaState versionState = new SchemaState();\n+            if(ArtifactState.DEPRECATED.equals(artifactMetaData.getState())) {\n+                versionState.setState(SchemaState.StateEnum.DEPRECATED);\n+            } else {\n+                versionState.setState(SchemaState.StateEnum.ACTIVE);\n+            }\n+            schemaVersion.setState(versionState);\n+        } catch (ArtifactNotFoundException e) {\n+            return null;\n+        }\n+        return schemaVersion;\n+    }\n+\n+    private void populateSchemaSummary(String schemaid, SchemaSummary schemaSummary) {\n+        List<ArtifactState> versionStates = storage.getArtifactVersions(schemaid).stream()\n+            .map(version -> storage.getArtifactVersionMetaData(schemaid, version).getState())\n+            .collect(Collectors.toList());\n+\n+        schemaSummary.setId(schemaid);\n+        schemaSummary.setName(schemaid); // TODO - add mechanism to store an artifact-level name\n+\n+        // The schema is disabled if all versions are disabled\n+        boolean isSchemaDisabled = versionStates.stream().allMatch(versionState -> ArtifactState.DISABLED.equals(versionState));\n+        schemaSummary.setEnabled(!isSchemaDisabled);\n+\n+        // The schema is deprecated if all versions are deprecated\n+        boolean isSchemaDeprecated = versionStates.stream().allMatch(versionState -> ArtifactState.DEPRECATED.equals(versionState));\n+        SchemaState schemaState = new SchemaState();\n+        if(isSchemaDeprecated) {\n+            schemaState.setState(SchemaState.StateEnum.DEPRECATED);\n+        } else {\n+            schemaState.setState(SchemaState.StateEnum.ACTIVE);\n+        }\n+        schemaSummary.setState(schemaState);\n+    }\n+\n+    private void handleArtifactCreation(AsyncResponse response, String artifactId, String versionName, Throwable t) {\n+        if (t != null) {\n+            response.resume(t);\n+            return;\n+        }\n+\n+        if (!doesArtifactExist(artifactId)) {\n+            // Some storage (such as asyncmem) needs a wait before the artifact is available for updating\n+            try {\n+                waitForArtifactCreation(artifactId);\n+            } catch (ArtifactNotFoundException e) {\n+                response.resume(e);\n+                return;\n+            }\n+        }\n+\n+        try {\n+            // Set the artifact name from the version name\n+            EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n+            dto.setName(versionName);\n+            //\n+            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n+            // The consumer thread appears to be blocked. Help needed here.\n+            //\n+            // storage.updateArtifactMetaData(artifactId, dto);\n+\n+            // Prepare the response\n+            SchemaInfo info = new SchemaInfo();\n+            populateSchemaSummary(artifactId, info);\n+            info.setVersions(getSchemaVersions(artifactId));\n+\n+            // updateArtifactMetaData call may be async, so also set the version name in the response\n+            List<SchemaVersion> versions = info.getVersions();\n+            versions.get(versions.size() - 1).setName(versionName);\n+\n+            response.resume(Response.status(Response.Status.CREATED).entity(info).build());\n+        } catch (Throwable throwable) {\n+            response.resume(throwable);\n+        }\n+    }\n+\n+    private void waitForArtifactCreation(String artifactId) throws ArtifactNotFoundException {\n+        for (int i = 0; i < 5 && !doesArtifactExist(artifactId); i++) {\n+            try {\n+                Thread.sleep(200L);\n+            } catch (InterruptedException e) {}\n+        }", "originalCommit": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM5NDc4Mg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r464394782", "bodyText": "Uh ... only acceptable for tests, and even then try to avoid it as much as possible ...", "author": "alesj", "createdAt": "2020-08-03T12:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NjUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "chunk": "diff --git a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\nindex bca978a0..9f8a11d1 100644\n--- a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n+++ b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n\n@@ -150,10 +145,7 @@ public class ApiServiceImpl implements ApiService {\n             // Set the artifact name from the version name\n             EditableArtifactMetaDataDto dto = new EditableArtifactMetaDataDto();\n             dto.setName(versionName);\n-            //\n-            // TODO: On Kafka topic storage, this call to updateArtifactMetaData never returns.\n-            // The consumer thread appears to be blocked. Help needed here.\n-            //\n+            // TODO: On Kafka topic storage, updateArtifactMetaData does not return. Help needed here.\n             // storage.updateArtifactMetaData(artifactId, dto);\n \n             // Prepare the response\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4ODIyOQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463688229", "bodyText": "Good change in approach - but I would perhaps add back in a comment explaining what's happening.  i.e. that a race condition could cause the artifact to be not found, so we'll return null here and filter out nulls later.", "author": "EricWittmann", "createdAt": "2020-07-31T15:46:04Z", "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -70,46 +230,34 @@\n                   .map(id -> {\n                       SchemaListItem item = new SchemaListItem();\n                       try {\n-                          StoredArtifact artifact = storage.getArtifact(id);\n-                          item.setId(id);\n-                          item.setEnabled(true);\n-                          SchemaVersion version = new SchemaVersion();\n-                          version.setId(artifact.getVersion().intValue()); // TODO not safe!\n-                          item.setLatest(version);\n+                          populateSchemaSummary(id, item);\n+                          item.setLatest(getLatestSchemaVersion(id));\n                       } catch (ArtifactNotFoundException e) {\n-                          // we can have deleted artifact ...\n+                          return null;", "originalCommit": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "844bc3b54650a56a998449bdc21cfad1538f1d67", "chunk": "diff --git a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\nindex bca978a0..104c6127 100644\n--- a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n+++ b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n\n@@ -233,6 +237,8 @@ public class ApiServiceImpl implements ApiService {\n                           populateSchemaSummary(id, item);\n                           item.setLatest(getLatestSchemaVersion(id));\n                       } catch (ArtifactNotFoundException e) {\n+                          // If artifact does not exist (which may occur due to race conditions), swallow\n+                          // the exception here and filter the null result out below.\n                           return null;\n                       }\n                       return item;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MDM2Mw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/708#discussion_r463690363", "bodyText": "Curious as to why.  Anti-capital letter bias?? ;)", "author": "EricWittmann", "createdAt": "2020-07-31T15:50:07Z", "path": "app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java", "diffHunk": "@@ -70,46 +230,34 @@\n                   .map(id -> {\n                       SchemaListItem item = new SchemaListItem();\n                       try {\n-                          StoredArtifact artifact = storage.getArtifact(id);\n-                          item.setId(id);\n-                          item.setEnabled(true);\n-                          SchemaVersion version = new SchemaVersion();\n-                          version.setId(artifact.getVersion().intValue()); // TODO not safe!\n-                          item.setLatest(version);\n+                          populateSchemaSummary(id, item);\n+                          item.setLatest(getLatestSchemaVersion(id));\n                       } catch (ArtifactNotFoundException e) {\n-                          // we can have deleted artifact ...\n+                          return null;\n                       }\n                       return item;\n                   })\n-                  .filter(SchemaListItem::isEnabled)\n+                  .filter(item -> item != null)\n                   .collect(Collectors.toList());\n     }\n \n     public void apiSchemasPost(AsyncResponse response, NewSchema schema, boolean verify)\n-    throws ArtifactNotFoundException {\n-        String artifactId = schema.getName();\n-        if (artifactId == null) {\n+    throws ArtifactNotFoundException, ArtifactAlreadyExistsException {\n+        String schemaName = schema.getName();\n+        final String artifactId;\n+        if (schemaName == null) {\n             artifactId = idGenerator.generate();\n+        } else {\n+            artifactId = schemaName.toLowerCase();", "originalCommit": "9aa2c005c1a7c0ed5b003c83e36fe6bbfb059ec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "844bc3b54650a56a998449bdc21cfad1538f1d67", "chunk": "diff --git a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\nindex bca978a0..104c6127 100644\n--- a/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n+++ b/app/src/main/java/io/apicurio/registry/ibmcompat/api/impl/ApiServiceImpl.java\n\n@@ -233,6 +237,8 @@ public class ApiServiceImpl implements ApiService {\n                           populateSchemaSummary(id, item);\n                           item.setLatest(getLatestSchemaVersion(id));\n                       } catch (ArtifactNotFoundException e) {\n+                          // If artifact does not exist (which may occur due to race conditions), swallow\n+                          // the exception here and filter the null result out below.\n                           return null;\n                       }\n                       return item;\n"}}, {"oid": "d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "url": "https://github.com/Apicurio/apicurio-registry/commit/d99a179ca9de6a6c082a68c205fd698d3ed2eab2", "message": "Enhance ibmcompat API GET and POST methods\n\n- This commit improves the data returned by the ibmcompat API GET\nendpoints to include metadata already stored with the artifact.\n- It also improves the ibmcompat API POST endpoints by returning\nmetadata stored with the artifact.\n- It also adds a set of initial tests for the functionality that follow\nthe ccompat API and artifact API tests.\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-08-11T07:24:20Z", "type": "commit"}, {"oid": "7c7a219aa5fa88f5fecadb50a7df2e732d68e000", "url": "https://github.com/Apicurio/apicurio-registry/commit/7c7a219aa5fa88f5fecadb50a7df2e732d68e000", "message": "Enhance ibmcompat API PATCH methods\n\n - This commit adds implementations and tests for the two lifecycle\nmanagement methods of the ibmcompat API:\n    - `PATCH ibmcompat/schemas/{schema-id}`\n    - `PATCH ibmcompat/schemas/{schema-id}/versions/{version-id}`\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-08-11T07:24:20Z", "type": "commit"}, {"oid": "844bc3b54650a56a998449bdc21cfad1538f1d67", "url": "https://github.com/Apicurio/apicurio-registry/commit/844bc3b54650a56a998449bdc21cfad1538f1d67", "message": "Fix test by ensuring ConcurrentException cause is returned\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-08-11T07:24:20Z", "type": "commit"}, {"oid": "844bc3b54650a56a998449bdc21cfad1538f1d67", "url": "https://github.com/Apicurio/apicurio-registry/commit/844bc3b54650a56a998449bdc21cfad1538f1d67", "message": "Fix test by ensuring ConcurrentException cause is returned\n\nSigned-off-by: Andrew Borley <borley@uk.ibm.com>", "committedDate": "2020-08-11T07:24:20Z", "type": "forcePushed"}]}